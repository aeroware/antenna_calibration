/* nec4d.f -- translated by f2c (version 20090411).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

/* Common Block Declarations */

struct {
    doublereal x[1210], y[1210], z__[1210], si[1210], bi[1210], alp[1210], 
	    bet[1210], salp[1210], t2x[1210], t2y[1210], t2z[1210];
    integer icon1[1210], icon2[1210], itag[1210], iconx[1210], ipsym, ld, n1, 
	    n2, n, np, m1, m2, m, mp;
} data_;

#define data_1 data_

struct {
    integer ifrq, nfrq;
    doublereal fmhzs, delfrq, fmhz;
} frqdat_;

#define frqdat_1 frqdat_

struct {
    integer iplot, lunplt;
    char plfnam[60];
} outfil_;

#define outfil_1 outfil_

struct {
    doublecomplex cm[1464100];
    integer ip[2420], ib11, ic11, id11, neqmat, neq, neq2;
} cmb_;

#define cmb_1 cmb_

struct {
    integer icase, nbloks, npblk, nlast, nblsym, npsym, nlsym, imat, icasx, 
	    nbbx, npbx, nlbx, nbbl, npbl, nlbl;
} matpar_;

#define matpar_1 matpar_

struct {
    doublecomplex aix[1210], bix[1210], cix[1210], cur[3630], xks[1210];
} crnt_;

#define crnt_1 crnt_

struct {
    doublecomplex xku, xkl, etau, etal, cepsu, cepsl, etal2, frati;
    doublereal omegag, clifl, clifh, epsr2, sig2, scnrad, scnwrd, gscal;
    integer iclift, nradl, ifar, iperf, ksymp;
} gnd_;

#define gnd_1 gnd_

struct {
    doublecomplex zarray[1210];
    integer nload, nlodf, ldtyp[30], ldtag[30], ldtagf[30], ldtagt[30];
    doublereal zlr[30], zli[30], zlc[30];
} zload_;

#define zload_1 zload_

struct {
    doublecomplex ceins[1210];
    doublereal brins[1210];
    integer nins, ninsf, intag[30], intagf[30], intagt[30];
    doublereal epsin[30], sigin[30], radin[30];
} inscom_;

#define inscom_1 inscom_

struct {
    doublecomplex zpeda[200];
    doublereal frmhza[200], zpnorm;
    integer nzsave, nzlimt, iszsav;
} zpsav_;

#define zpsav_1 zpsav_

struct {
    doublecomplex ax[30], bx[30], cx[30];
    integer jco[30], jsno, iscon[50], nscon, ipcon[10], npcon;
} segj_;

#define segj_1 segj_

struct {
    doublereal psor1[30], psor2[30], psor3[30], psor4[30], psor5[30], psor6[
	    30], dthinc, dphinc;
    integer nthinc, nphinc, nscinc, nsorc, isortp[30];
} sorces_;

#define sorces_1 sorces_

struct {
    doublecomplex tlyt1[30], tlyt2[30], yn11[30], yn12[30], yn22[30], svolts[
	    30];
    doublereal tlzch[30], tllen[30];
    integer nvsor, nvsora[30], iseg1[30], iseg2[30], nonet, netyp[30];
} netdef_;

#define netdef_1 netdef_

struct {
    doublecomplex zped;
    doublereal pin, pnls;
    integer izsave, npeq, ntsol, nprint;
} netcx_;

#define netcx_1 netcx_

struct {
    doublecomplex enintg, hnintg;
    doublereal xnr, ynr, znr, dxnr, dynr, dznr;
    integer near__, nfeh, nrx, nry, nrz;
} nfdat_;

#define nfdat_1 nfdat_

struct {
    integer iptflg, iptag, iptagf, iptagt, iptflq, iptaq, iptaqf, iptaqt;
} ptcont_;

#define ptcont_1 ptcont_

struct {
    integer icpt1, icps1, icpt2, icps2;
} cppram_;

#define cppram_1 cppram_

struct {
    doublereal pi, tp, dtorad, cvel, epsrz, rmuz, etaz;
} constn_;

#define constn_1 constn_

struct {
    doublereal geps, gsig, ueps, usig;
} setgn_;

#define setgn_1 setgn_

struct {
    doublecomplex xla[441]	/* was [21][21] */, gck1, gck1sq, gck2, 
	    gck2sq;
    doublereal zrat, rhon;
} gparm_;

#define gparm_1 gparm_

struct {
    doublecomplex ck1, ck1sq, ck2, ck2sq, cks12, con1, con2, con3, con4, 
	    epsc1, xjk;
    doublereal rho, zs, zo, zz, zzp, azp;
    integer icase;
} gnrzz_;

#define gnrzz_1 gnrzz_

struct {
    integer ivcap;
} vlcapc_;

#define vlcapc_1 vlcapc_

struct {
    integer isetjn;
} setjn_;

#define setjn_1 setjn_

struct {
    integer iglock;
} glock_;

#define glock_1 glock_

struct {
    integer kcom;
    char comin[390], infile__[80], outfile[80];
} ninfo_;

#define ninfo_1 ninfo_

struct {
    doublereal thets, dth, phis, dph, rfld, gnor;
    integer nth, nph, ipd, iavp, inor, iax;
} rpdat_;

#define rpdat_1 rpdat_

struct gndfil_1_ {
    integer nsfile;
    char somfil[40];
};

#define gndfil_1 (*(struct gndfil_1_ *) &gndfil_)

struct {
    doublecomplex xkseg;
    doublereal segl, xsj, ysj, zsj, dirx, diry, dirz, sn, xsn, ysn, xo, yo, 
	    zo;
    integer isnor, ireg, idirx;
} incom_;

#define incom_1 incom_

struct {
    doublecomplex xksj, exk, eyk, ezk, exs, eys, ezs, exc, eyc, ezc, zpeds;
    doublereal slenj, aradj, xj, yj, zj, dxj, dyj, dzj;
    integer ind1, ind2;
} dataj_;

#define dataj_1 dataj_

struct {
    doublecomplex qsege1[1210], qsege2[1210];
    integer ipqend[1210];
} jnqcom_;

#define jnqcom_1 jnqcom_

struct {
    doublecomplex cmn[900]	/* was [30][30] */, rhnx[30], rhnt[30], 
	    vltnet[30];
    integer ipnt[30], nteq, nteqa[30], ntveq, ntveqa[30];
} netwrk_;

#define netwrk_1 netwrk_

struct {
    doublereal thetrc[200], phirc[200], etarc, aratrc, patrc[200];
    integer npatrc, maxrcx, isegrp;
    char poltyp[6];
} recpat_;

#define recpat_1 recpat_

struct {
    doublecomplex h1x, h1y, h1z, h2x, h2y, h2z;
    doublereal spatj, xpatj, ypatj, zpatj, t1xj, t1yj, t1zj, t2xj, t2yj, t2zj;
    integer ipgnd;
} datap_;

#define datap_1 datap_

struct {
    integer nrprx[21], lrec[21], lrecl[21];
} rstruc_;

#define rstruc_1 rstruc_

union {
    struct {
	doublecomplex d__[2420];
    } _1;
    struct {
	doublecomplex y[2420];
    } _2;
    struct {
	doublereal gain[4840];
    } _3;
} scratm_;

#define scratm_1 (scratm_._1)
#define scratm_2 (scratm_._2)
#define scratm_3 (scratm_._3)

struct {
    doublecomplex ssx[400]	/* was [20][20] */;
} smat_;

#define smat_1 smat_

struct gregon_1_ {
    doublereal rhoa[3], rhob[3], zza[3], zzb[3], zpa[3], zpb[3], elm, elmx, 
	    scfac, rhmx1, zzmx1, zpmx1, rhmx2, zzmx2, zpmx2, zpmxx;
};

#define gregon_1 (*(struct gregon_1_ *) &gregon_)

struct {
    doublecomplex fac1[96]	/* was [32][3] */, fac2[96]	/* was [32][3]
	     */, fac3[96]	/* was [32][3] */, fac4[96]	/* was [32][3]
	     */, fac5[96]	/* was [32][3] */;
    doublereal rkfac;
    integer mfunf[3], mfunc[3];
} cofit_;

#define cofit_1 cofit_

struct {
    doublecomplex cff1, cff2, cff3, cff4, cff5, cff6, cff7, cff8;
    doublereal ff1, ff2, ff3, ff4, ff5, ff6, ff7, ff8, ff9, ff10, ff11, ff12, 
	    ff13, ff14, ff15, ff16, ff17, ff18, ff19, ff20, ff21, ff22, ff23, 
	    ff24;
    integer nfunf, nfunc;
} fparm_;

#define fparm_1 fparm_

struct {
    doublecomplex cd, aa, xlp, pg1, pg2, gg0, gg2, gx0, gx2, fa2, fb2, fa4, 
	    fb4;
} gasav_;

#define gasav_1 gasav_

struct {
    doublecomplex xkj;
    doublereal zp, rh2;
} tmh_;

#define tmh_1 tmh_

struct gridy_1_ {
    doublecomplex a1[1200], a2[1200], a3[1200], a4[1200], a5[1200];
    doublereal rh1[3], zz1[3], zp1[3], drh[3], dzz[3], dzp[3], drzzp[3], zpm1,
	     zpm2, zpmm1, zpmm2, zpd1, zpd2;
    integer nrh[3], nzz[3], nzp[3], npt[3], indi[3];
};

#define gridy_1 (*(struct gridy_1_ *) &gridy_)

struct gndcom_1_ {
    doublecomplex epscx;
    doublereal xrh1, dxrh, xzz1, dxzz, xzp1, dxzp, srh1, dsrh, szz1, dszz, 
	    szp1, dszp, res1, res2, res3, res4, res5, rex1, rex2, rex3, rex4, 
	    rex5;
    integer nreg, nxrh, nxzz, nxzp, nsrh, nszz, nszp;
};

#define gndcom_1 (*(struct gndcom_1_ *) &gndcom_)

struct {
    doublecomplex xkj, xksj;
    doublereal zz, rh2;
    integer ij;
} tmi_;

#define tmi_1 tmi_

union {
    struct {
	doublecomplex cksm, cck1, cck1s, cck2, cck2s, con1, con2, con3;
	doublereal tkmag, tsmag, ckar, ckai, ckbr, ckbi, zz, zp, rho;
	integer jh, iqaz;
    } _1;
    struct {
	doublecomplex cksm, ck1, ck1sq, ck2, ck2sq, con1, con2, con3;
	doublereal tkmag, tsmag, ckar, ckai, ckbr, ckbi, zz, zp, rho;
	integer jh, iqaz;
    } _2;
} evlcom_;

#define evlcom_1 (evlcom_._1)
#define evlcom_2 (evlcom_._2)

struct {
    integer ismprt;
} prntcm_;

#define prntcm_1 prntcm_

struct {
    doublecomplex a, b;
    doublereal bael;
} cntour_;

#define cntour_1 cntour_

struct {
    doublecomplex a1, a2, a3, a4, a5, b1, b2, b3, b4, b5, c1, c2, c3, c4, c5;
} srgam_;

#define srgam_1 srgam_

struct {
    doublereal rh1, drh, zz1, dzz, zp1, dzp, srh1, dsrh, szz1, dszz, szp1, 
	    dszp, res1, res2, res3, res4, res5, rex1, rex2, rex3, rex4, rex5;
    integer nrh, nzz, nzp, nsrh, nszz, nszp, iqax;
} ptfit_;

#define ptfit_1 ptfit_

/* Initialized data */

struct {
    integer e_1;
    integer fill_2[10];
    } gndfil_ = { 0 };

struct {
    doublereal e_1[18];
    doublereal fill_2[10];
    } gregon_ = { 0., .2, .6, .6, .6, 2., .2, 0., 0., 2., .2, 2., 0., 0., 0., 
	    .25, .25, .25 };

struct {
    doublereal fill_1[12000];
    doublereal e_2[9];
    doublereal fill_3[18];
    integer e_4[9];
    integer fill_5[6];
    } gridy_ = { {0}, 0., 0., 0., 0., 0., 0., 0., 0., 0., {0}, 11, 11, 5, 8, 
	    5, 4, 5, 5, 5 };

struct {
    doublecomplex e_1;
    integer fill_2[51];
    } gndcom_ = { 0., 0. };


/* Table of constant values */

static integer c_b5 = 1464100;
static integer c__2 = 2;
static integer c__1 = 1;
static integer c__11 = 11;
static integer c__12 = 12;
static integer c__21 = 21;
static doublereal c_b332 = 0.;
static doublecomplex c_b336 = {1.,0.};
static integer c__0 = 0;
static integer c__30 = 30;
static integer c__10 = 10;
static integer c__50 = 50;
static integer c__15 = 15;
static integer c__13 = 13;
static integer c__14 = 14;
static doublecomplex c_b1298 = {.5,0.};
static integer c__20 = 20;
static doublecomplex c_b1407 = {2.,0.};
static integer c__5 = 5;
static integer c__3 = 3;
static doublecomplex c_b2175 = {0.,1.};
static integer c__4 = 4;
static integer c__7 = 7;
static integer c_n1 = -1;
static integer c__9 = 9;
static doublereal c_b2721 = 1e-4;
static doublereal c_b2744 = 1e-5;
static doublereal c_b2760 = 1.;
static integer c__90 = 90;
static integer c__6 = 6;
static doublereal c_b3178 = .5;
static integer c__100 = 100;
static integer c__110 = 110;

/*     Numerical Electromagnetics Code (NEC-4.1)  Developed at Lawrence */
/*     Livermore National Laboratory, Livermore, CA. */
/*     (Contact G. Burke at 510-422-8414) */

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*                        ***** WARNING ***** */

/*             INFORMATION SUBJECT TO EXPORT CONTROL LAWS */

/*     This document may contain information subject to the International */
/*     Traffic in Arms Regulation (ITAR) or the Export Administration */
/*     Act (EAA) of 1979, extended by Executive Order 12730.  This */
/*     material may not be exported, released or disclosed to foreign */
/*     nationals inside or outside the United States without first */
/*     obtaining an export license.  A Violation of the ITAR or EAA may */
/*     be subject to a penalty of up to 10 years imprisonment and a fine */
/*     of $100,000 under 22 U.S.C. 2778 or Section 2410 of the Export */
/*     Administration Act of 1979.  Include this notice with any */
/*     reproduced portion of this document. */

/*                ***********NOTICE********** */

/*     This computer code material was prepared as an account of work */
/*     sponsored by the United States Government.  Neither the United */
/*     States nor the United States Department of Energy, nor any of */
/*     their employees, nor any of their contractors, subcontractors, or */
/*     their employees, makes any warranty, express or implied, or */
/*     assumes any legal liability or responsibility for the accuracy, */
/*     completeness or usefulness of any information, apparatus, product */
/*     or process disclosed, or represents that its use would not */
/*     infringe privately-owned rights. */

/*     History: */
/*        Date      Change */
/*      -------     ---------------------------------------------- */
/*      8/11/95     Call to SETTL added before 2nd call to COUPLE in MAIN */
/*      7/12/94     Routines QSOLVE, QJRATV, QMFIL changed to avoid */
/*                     instability in charge solution for junctions */
/*                     with many wires. */
/*      7/12/94     SEGCHK: tolerance on DEN for parallel wires tightened */
/*      7/12/94     EFCAP: exact field of cap used when series is not */
/*                         accurate */
/*      7/12/94     EXRINT: approximation for large R used in place of */
/*                          3-point Gaussian integration. */
/*      7/26/94     Added LE and LH commands to compute near E and H */
/*                  along lines. */
/*      5/04/95     Matrix re-transposed in subroutine FACTR. */
/*                  FACTR and SOLVE changed for non-transposed matrix. */
/*      1/16/96     Added call to SETGND on reading GD command */
/*      4/26/96     Changed call to RECOT to 'write D in FACGF' to fix */
/*                  error in NGF with matrix D out of core. */
/*      8/16/01     Sommerfeld solution modified to include point charge */
/*                  on wire ends within a margin inside the region */
/*                  for integrating over the segment.  This was needed */
/*                  to avoid unbalanced charge when switching to the */
/*                  one-point integration for the segments. */
/*      8/16/01     Lock switching between l.s. approx. and asymptotic */
/*                  while evaluating H from diferences to avoid a glitch. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

/* Main program */ int MAIN__(void)
{
    /* Format strings */
    static char fmt_135[] = "(///)";
    static char fmt_137[] = "(\002 ***** INPUT LINE\002,i3,2x,a2,1x,i3,3i5,6"
	    "(1x,1pe12.5))";
    static char fmt_139[] = "(\002 ***** INPUT LINE\002,i3,2x,a2,1x,i3,3i5,6"
	    "(1x,1pe12.5),/43x,(1x,1pe12.5),2x,a)";
    static char fmt_145[] = "(/,\002 THE EK AND KH COMMANDS HAVE NO EFFECT I"
	    "N NEC-4\002,/)";
    static char fmt_201[] = "(/,\002 RUN TIME =\002,f10.3)";
    static char fmt_302[] = "(\002 MAIN: ERROR - N.G.F. IN USE.  CANNOT WRIT"
	    "E NEW N.G.F.\002)";
    static char fmt_138[] = "(///,10x,\002MAIN: FAULTY INPUT COMMAND LABEL A"
	    "FTER GEOMETRY\002,\002 SECTION\002)";
    static char fmt_146[] = "(///,31x,\002- - - STRUCTURE IMPEDANCE LOADING "
	    "- - -\002)";
    static char fmt_147[] = "(/,35x,\002THIS STRUCTURE IS NOT LOADED\002)";
    static char fmt_327[] = "(/,36x,\002LOADING ONLY IN N.G.F. SECTION\002)";
    static char fmt_153[] = "(///,32x,\002- - - MATRIX TIMING - - -\002,//,2"
	    "4x,\002FILL=\002,f9.3,\002 SEC.,  FACTOR=\002,f9.3,\002 SEC.\002)"
	    ;

    /* System generated locals */
    integer i__1, i__2;
    cllist cl__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), s_cmp(char *, char *, ftnlen, 
	    ftnlen), do_fio(integer *, char *, ftnlen), f_clos(cllist *);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__;
    static char ain[2];
    static integer inc, igo, ix11;
    static doublereal tim;
    static integer mhz;
    static doublereal tim1, tim2, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
    extern /* Subroutine */ int load_(doublereal *, doublecomplex *);
    static integer iped, itmp1, itmp2, itmp3, itmp4;
    extern /* Subroutine */ int facgf_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *),
	     fbngf_(integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *), cmngf_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, integer *, integer *, integer *);
    static doublereal extim;
    static integer mpcnt, iflow, irngf;
    extern /* Subroutine */ int gfout_(char *, ftnlen), inset_(doublereal *);
    static integer ixtyp;
    extern /* Subroutine */ int xkset_(void), cmset_(integer *, doublecomplex 
	    *, integer *), etmns_(doublecomplex *), netwk_(doublecomplex *);
    static doublereal ploss;
    extern /* Subroutine */ int nfpat_(void), rdpat_(doublereal *, doublereal 
	    *, doublereal *), datagn_(void), fblock_(integer *, integer *, 
	    integer *, integer *, integer *), cdeflt_(integer *, integer *, 
	    integer *, integer *, integer *);
    static char filnam[40];
    extern /* Subroutine */ int readmn_(integer *, char *, integer *, integer 
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *, doublereal *, char *, 
	    ftnlen, ftnlen), conset_(void), getiof_(void), second_(doublereal 
	    *), necttl_(void), rsetex_(integer *, integer *, integer *, 
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *, integer *, integer *, 
	    integer *, integer *, integer *, doublereal *), rsetnt_(char *, 
	    integer *, integer *, integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, integer *, integer *, integer *, ftnlen), rsetfr_(
	    integer *, integer *, doublereal *, doublereal *, integer *, 
	    integer *, integer *, integer *, doublereal *), rsetis_(integer *,
	     integer *, integer *, integer *, doublereal *, doublereal *, 
	    doublereal *, integer *, integer *), rsetld_(integer *, integer *,
	     integer *, integer *, doublereal *, doublereal *, doublereal *, 
	    integer *, integer *), rsetgn_(integer *, integer *, doublereal *,
	     doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, char *, integer *, integer *, integer *, ftnlen), 
	    rsetjn_(integer *, integer *, integer *), rsetpt_(integer *, 
	    integer *, integer *, integer *), rsetpq_(integer *, integer *, 
	    integer *, integer *), rsetpl_(integer *, integer *, char *, 
	    ftnlen), geoout_(void), rsetgd_(integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, integer *), setgnd_(
	    doublereal *), rsetum_(doublereal *, doublereal *, integer *, 
	    integer *, integer *), rsetvc_(integer *, integer *, integer *), 
	    rsetcp_(integer *, integer *, integer *, integer *, integer *), 
	    couple_(integer *, integer *, integer *, integer *), rsetnf_(char 
	    *, integer *, integer *, integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, integer *, ftnlen), rsetnl_(char *, integer *, 
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *, ftnlen), rsetrp_(integer *
	    , integer *, integer *, integer *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *)
	    , rsetxq_(integer *, integer *), ptslen_(void), jnqset_(void), 
	    factrs_(integer *, integer *, doublecomplex *, integer *, integer 
	    *, integer *), settlx_(void);
    static doublereal thsave, phsave;
    static integer ithinc, iphinc;
    extern /* Subroutine */ int ptexct_(integer *), ptnetw_(void), curout_(
	    void), zpsave_(integer *, doublereal *, doublecomplex *, integer *
	    ), ptwirc_(integer *, integer *, integer *, integer *), ptrecp_(
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, integer *, integer *, integer *), ptwirq_(integer *, 
	    integer *, integer *, integer *), ptpchc_(void), pwrbgt_(
	    doublereal *, doublereal *, doublereal *), nfline_(void), ptrecn_(
	    void), ptzped_(void);

    /* Fortran I/O blocks */
    static cilist io___6 = { 0, 3, 0, fmt_135, 0 };
    static cilist io___24 = { 0, 3, 0, fmt_137, 0 };
    static cilist io___25 = { 0, 3, 0, fmt_139, 0 };
    static cilist io___26 = { 0, 3, 0, fmt_145, 0 };
    static cilist io___27 = { 0, 3, 0, fmt_201, 0 };
    static cilist io___28 = { 0, 3, 0, fmt_302, 0 };
    static cilist io___29 = { 0, 3, 0, fmt_138, 0 };
    static cilist io___31 = { 0, 3, 0, fmt_146, 0 };
    static cilist io___32 = { 0, 3, 0, fmt_147, 0 };
    static cilist io___33 = { 0, 3, 0, fmt_327, 0 };
    static cilist io___37 = { 0, 3, 0, fmt_153, 0 };
    static cilist io___38 = { 0, 3, 0, fmt_153, 0 };
    static cilist io___45 = { 0, 3, 0, fmt_135, 0 };
    static cilist io___46 = { 0, 3, 0, fmt_135, 0 };
    static cilist io___47 = { 0, 3, 0, fmt_135, 0 };
    static cilist io___48 = { 0, 3, 0, fmt_135, 0 };
    static cilist io___49 = { 0, 3, 0, fmt_135, 0 };


/* *** */
/* *** */
    conset_();
    getiof_();
    second_(&extim);
    data_1.ld = 1210;
L1:
    necttl_();
    i__1 = data_1.ld;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__ - 1;
	inscom_1.ceins[i__2].r = 1.f, inscom_1.ceins[i__2].i = 0.f;
	inscom_1.brins[i__ - 1] = 0.f;
/* L2: */
	i__2 = i__ - 1;
	zload_1.zarray[i__2].r = 0.f, zload_1.zarray[i__2].i = 0.f;
    }
    mpcnt = 0;
    matpar_1.imat = 0;

/*     SET UP GEOMETRY DATA IN SUBROUTINE DATAGN */

    datagn_();
    iflow = 1;
    if (matpar_1.imat != 0) {

/*     CORE ALLOCATION FOR ARRAYS B, C, AND D FOR N.G.F. SOLUTION */

	cmb_1.neq = data_1.n1 + (data_1.m1 << 1);
	cmb_1.neq2 = data_1.n - data_1.n1 + (data_1.m - data_1.m1 << 1) + 
		segj_1.nscon + (segj_1.npcon << 1);
	fbngf_(&cmb_1.neq, &cmb_1.neq2, &c_b5, &cmb_1.ib11, &cmb_1.ic11, &
		cmb_1.id11, &ix11);
    } else {
	cmb_1.neq = data_1.n + (data_1.m << 1);
	cmb_1.neq2 = 0;
	cmb_1.ib11 = 1;
	cmb_1.ic11 = 1;
	cmb_1.id11 = 1;
	ix11 = 1;
	matpar_1.icasx = 0;
    }
    netcx_1.npeq = data_1.np + (data_1.mp << 1);
    cmb_1.neqmat = cmb_1.neq + cmb_1.neq2;
    s_wsfe(&io___6);
    e_wsfe();
    cdeflt_(&igo, &iped, &irngf, &matpar_1.icasx, &ixtyp);

/*     MAIN INPUT SECTION - STANDARD READ STATEMENT - JUMPS TO APPRO- */
/*     PRIATE SECTION FOR SPECIFIC PARAMETER SET UP */

L14:
    readmn_(&c__2, ain, &itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &
	    tmp4, &tmp5, &tmp6, &tmp7, filnam, (ftnlen)2, (ftnlen)40);
    ++mpcnt;
    if (abs(tmp7) < 1e-25f && s_cmp(filnam, " ", (ftnlen)40, (ftnlen)1) == 0) 
	    {
	s_wsfe(&io___24);
	do_fio(&c__1, (char *)&mpcnt, (ftnlen)sizeof(integer));
	do_fio(&c__1, ain, (ftnlen)2);
	do_fio(&c__1, (char *)&itmp1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp3, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp4, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp4, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp5, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp6, (ftnlen)sizeof(doublereal));
	e_wsfe();
    } else {
	s_wsfe(&io___25);
	do_fio(&c__1, (char *)&mpcnt, (ftnlen)sizeof(integer));
	do_fio(&c__1, ain, (ftnlen)2);
	do_fio(&c__1, (char *)&itmp1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp3, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itmp4, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp4, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp5, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp6, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp7, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, filnam, (ftnlen)40);
	e_wsfe();
    }

    if (s_cmp(ain, "EK", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(ain, "KH", (
	    ftnlen)2, (ftnlen)2) == 0) {
	s_wsfe(&io___26);
	e_wsfe();
	goto L14;

    } else if (s_cmp(ain, "EX", (ftnlen)2, (ftnlen)2) == 0) {
	rsetex_(&itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &tmp4, &
		tmp5, &tmp6, &tmp7, &iflow, &igo, &iped, &ixtyp, &
		netcx_1.ntsol, &zpsav_1.zpnorm);
	goto L14;

    } else if (s_cmp(ain, "NT", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(ain, 
	    "TL", (ftnlen)2, (ftnlen)2) == 0) {
	rsetnt_(ain, &itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &
		tmp4, &tmp5, &tmp6, &iflow, &igo, &netcx_1.ntsol, (ftnlen)2);
	goto L14;

    } else if (s_cmp(ain, "FR", (ftnlen)2, (ftnlen)2) == 0) {
	rsetfr_(&itmp1, &itmp2, &tmp1, &tmp2, &igo, &iflow, &matpar_1.icasx, &
		iped, &zpsav_1.zpnorm);
	goto L14;

    } else if (s_cmp(ain, "IS", (ftnlen)2, (ftnlen)2) == 0) {
	rsetis_(&itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &igo, &
		iflow);
	goto L14;

    } else if (s_cmp(ain, "PS", (ftnlen)2, (ftnlen)2) == 0) {
	iflow = 14;
	goto L41;

    } else if (s_cmp(ain, "LD", (ftnlen)2, (ftnlen)2) == 0) {
	rsetld_(&itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &igo, &
		iflow);
	goto L14;

    } else if (s_cmp(ain, "GN", (ftnlen)2, (ftnlen)2) == 0) {
	rsetgn_(&itmp1, &itmp2, &tmp1, &tmp2, &tmp3, &tmp4, &tmp5, &tmp6, 
		filnam, &igo, &iflow, &matpar_1.icasx, (ftnlen)40);
	goto L14;

    } else if (s_cmp(ain, "JN", (ftnlen)2, (ftnlen)2) == 0) {
	rsetjn_(&itmp1, &igo, &iflow);
	goto L14;

    } else if (s_cmp(ain, "PT", (ftnlen)2, (ftnlen)2) == 0) {
	rsetpt_(&itmp1, &itmp2, &itmp3, &itmp4);
	goto L14;

    } else if (s_cmp(ain, "PQ", (ftnlen)2, (ftnlen)2) == 0) {
	rsetpq_(&itmp1, &itmp2, &itmp3, &itmp4);
	goto L14;

    } else if (s_cmp(ain, "PL", (ftnlen)2, (ftnlen)2) == 0) {
	rsetpl_(&itmp1, &iflow, filnam, (ftnlen)40);
	if (outfil_1.iplot != 0) {
	    geoout_();
	}
	goto L14;

    } else if (s_cmp(ain, "GD", (ftnlen)2, (ftnlen)2) == 0) {
	rsetgd_(&itmp1, &tmp1, &tmp2, &tmp3, &tmp4, &iflow);
	if (igo > 2) {
	    setgnd_(&frqdat_1.fmhz);
	}
	goto L14;

    } else if (s_cmp(ain, "UM", (ftnlen)2, (ftnlen)2) == 0) {
	rsetum_(&tmp1, &tmp2, &igo, &iflow, &matpar_1.icasx);
	goto L14;

    } else if (s_cmp(ain, "VC", (ftnlen)2, (ftnlen)2) == 0) {
	rsetvc_(&itmp1, &igo, &iflow);
	goto L14;

    } else if (s_cmp(ain, "CP", (ftnlen)2, (ftnlen)2) == 0) {
	rsetcp_(&itmp1, &itmp2, &itmp3, &itmp4, &iflow);
	if (igo > 2) {
	    couple_(&cppram_1.icpt1, &cppram_1.icps1, &cppram_1.icpt2, &
		    cppram_1.icps2);
	    goto L14;
	}
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	}

    } else if (s_cmp(ain, "NE", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(ain, 
	    "NH", (ftnlen)2, (ftnlen)2) == 0) {
	rsetnf_(ain, &itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &
		tmp4, &tmp5, &tmp6, &iflow, (ftnlen)2);
	if (frqdat_1.nfrq != 1) {
	    goto L14;
	}
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	    case 3:  goto L53;
	    case 4:  goto L72;
	}

    } else if (s_cmp(ain, "LE", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(ain, 
	    "LH", (ftnlen)2, (ftnlen)2) == 0) {
	rsetnl_(ain, &itmp1, &itmp2, &tmp1, &tmp2, &tmp3, &tmp4, &tmp5, &tmp6,
		 &iflow, (ftnlen)2);
	if (frqdat_1.nfrq != 1) {
	    goto L14;
	}
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	    case 3:  goto L53;
	    case 4:  goto L72;
	}

    } else if (s_cmp(ain, "EN", (ftnlen)2, (ftnlen)2) == 0) {
	second_(&tmp1);
	tmp1 -= extim;
	s_wsfe(&io___27);
	do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
	e_wsfe();
	cl__1.cerr = 1;
	cl__1.cunit = 11;
	cl__1.csta = "DELETE";
	i__2 = f_clos(&cl__1);
	if (i__2 != 0) {
	    goto L3;
	}
L3:
	s_stop("", (ftnlen)0);

    } else if (s_cmp(ain, "WG", (ftnlen)2, (ftnlen)2) == 0) {
	iflow = 12;
	if (matpar_1.icasx != 0) {
	    s_wsfe(&io___28);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	irngf = 732050;
	if (igo > 2) {
	    gfout_(filnam, (ftnlen)40);
	    goto L14;
	}
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	}
    } else if (s_cmp(ain, "RP", (ftnlen)2, (ftnlen)2) == 0) {
	rsetrp_(&itmp1, &itmp2, &itmp3, &itmp4, &tmp1, &tmp2, &tmp3, &tmp4, &
		tmp5, &tmp6, &iflow);
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	    case 3:  goto L53;
	    case 4:  goto L78;
	}

    } else if (s_cmp(ain, "XQ", (ftnlen)2, (ftnlen)2) == 0) {
	if (iflow == 10 && itmp1 == 0) {
	    goto L14;
	}
	if (frqdat_1.nfrq == 1 && itmp1 == 0 && iflow > 7) {
	    goto L14;
	}
	rsetxq_(&itmp1, &iflow);
	switch (igo) {
	    case 1:  goto L41;
	    case 2:  goto L46;
	    case 3:  goto L53;
	    case 4:  goto L78;
	}

    } else if (s_cmp(ain, "NX", (ftnlen)2, (ftnlen)2) == 0) {
	cl__1.cerr = 1;
	cl__1.cunit = 11;
	cl__1.csta = "DELETE";
	i__2 = f_clos(&cl__1);
	if (i__2 != 0) {
	    goto L1;
	}
	goto L1;

    } else {
	s_wsfe(&io___29);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }

/*     END OF THE MAIN INPUT SECTION */

/*     BEGINNING OF THE FREQUENCY DO LOOP */

L41:
    mhz = 1;
    frqdat_1.fmhz = frqdat_1.fmhzs;
/*     CORE ALLOCATION FOR PRIMARY INTERACTON MATRIX.  (A) */
    if (matpar_1.imat == 0) {
	fblock_(&netcx_1.npeq, &cmb_1.neq, &c_b5, &irngf, &data_1.ipsym);
    }
L42:
    if (mhz > 1) {
	if (frqdat_1.ifrq == 1) {
	    frqdat_1.fmhz *= frqdat_1.delfrq;
	} else {
	    frqdat_1.fmhz += frqdat_1.delfrq;
	}
    }
    igo = 2;

/*     SET FREQUENCY DEPENDENT GROUND PARAMETERS */

L46:
    setgnd_(&frqdat_1.fmhz);

/*     INSET COMPUTES WIRE SHEATH PARAMETERS THAT DEPEND ON FREQUENCY */

    inset_(&gnd_1.omegag);
    xkset_();
    if (iflow == 14) {
	ptslen_();
	iflow = 4;
	goto L14;
    }

/*     SET FREQUENCY DEPENDENT LOADING PARAMETERS */

    s_wsfe(&io___31);
    e_wsfe();
    if (zload_1.nload != 0) {
	load_(&frqdat_1.fmhz, &gnd_1.xku);
    }
    if (zload_1.nload == 0 && zload_1.nlodf == 0) {
	s_wsfe(&io___32);
	e_wsfe();
    }
    if (zload_1.nload == 0 && zload_1.nlodf != 0) {
	s_wsfe(&io___33);
	e_wsfe();
    }
/* * * * */
/*     FILL AND FACTOR PRIMARY INTERACTION MATRIX */

    jnqset_();
    second_(&tim1);
    if (matpar_1.icasx == 0) {
	cmset_(&cmb_1.neq, cmb_1.cm, &c__11);
	second_(&tim2);
	tim = tim2 - tim1;
	factrs_(&netcx_1.npeq, &cmb_1.neq, cmb_1.cm, cmb_1.ip, &c__11, &c__12)
		;
	second_(&tim1);
	tim2 = tim1 - tim2;
	s_wsfe(&io___37);
	do_fio(&c__1, (char *)&tim, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tim2, (ftnlen)sizeof(doublereal));
	e_wsfe();

/*     N.G.F. - FILL B, C, AND D AND FACTOR D-C(INV(A)B) */

    } else if (cmb_1.neq2 != 0) {
	cmngf_(&cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
		cmb_1.cm[cmb_1.id11 - 1], &matpar_1.npbx, &cmb_1.neq, &
		cmb_1.neq2);
	second_(&tim2);
	tim = tim2 - tim1;
	facgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1],
		 &cmb_1.cm[cmb_1.id11 - 1], &cmb_1.cm[ix11 - 1], cmb_1.ip, &
		data_1.np, &data_1.n1, &data_1.mp, &data_1.m1, &cmb_1.neq, &
		cmb_1.neq2);
	second_(&tim1);
	tim2 = tim1 - tim2;
	s_wsfe(&io___38);
	do_fio(&c__1, (char *)&tim, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tim2, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    igo = 3;
    netcx_1.ntsol = 0;
    if (iflow == 12) {

/*        WRITE N.G.F. FILE AND RETURN TO READING INPUT */

	gfout_(filnam, (ftnlen)40);
	goto L14;
    }
    if (iflow == 13) {

/*        COMPUTE MAXIMUM COUPLING AND RETURN TO READING INPUT */

	if (netdef_1.nonet > 0) {
	    settlx_();
	}
	couple_(&cppram_1.icpt1, &cppram_1.icps1, &cppram_1.icpt2, &
		cppram_1.icps2);
	goto L14;
    }

/*     EXCITATION SET UP (RIGHT HAND SIDE, -E INC.) */

L53:
    inc = 0;
    netcx_1.nprint = 0;
    if (sorces_1.nscinc > 0) {
	thsave = sorces_1.psor1[sorces_1.nscinc - 1];
	phsave = sorces_1.psor2[sorces_1.nscinc - 1];
    }
    i__2 = sorces_1.nthinc;
    for (ithinc = 1; ithinc <= i__2; ++ithinc) {
	if (ithinc > 1) {
	    sorces_1.psor1[sorces_1.nscinc - 1] += sorces_1.dthinc;
	}
	i__1 = sorces_1.nphinc;
	for (iphinc = 1; iphinc <= i__1; ++iphinc) {
	    if (iphinc > 1) {
		sorces_1.psor2[sorces_1.nscinc - 1] += sorces_1.dphinc;
	    }
	    ++inc;
	    ptexct_(&ptcont_1.iptflg);
	    etmns_(crnt_1.cur);

/*     MATRIX SOLVING  (NETWK CALLS SOLVES) */

	    if (netdef_1.nonet > 0 && inc == 1) {

/*     SET PARAMETERS FOR TRANSMISSION LINES AND PRINT NETWORK AND */
/*     TRANSMISSION LINE INFORMATION. */

		ptnetw_();
		settlx_();
	    }
	    if (inc > 1 && ptcont_1.iptflg > 0) {
		netcx_1.nprint = 1;
	    }
	    netwk_(crnt_1.cur);
	    if (outfil_1.iplot != 0) {
		curout_();
	    }
	    netcx_1.ntsol = 1;
	    if (iped != 0) {
		zpsave_(&mhz, &frqdat_1.fmhz, &netcx_1.zped, &netcx_1.izsave);
	    }

/*     PRINTING STRUCTURE CURRENT AND CHARGE */

	    if (ptcont_1.iptflg <= 0) {
		ptwirc_(&ptcont_1.iptflg, &ptcont_1.iptag, &ptcont_1.iptagf, &
			ptcont_1.iptagt);
	    }
	    if (ptcont_1.iptflg > 0) {
		ptrecp_(&sorces_1.psor1[sorces_1.nscinc - 1], &sorces_1.psor2[
			sorces_1.nscinc - 1], &sorces_1.psor3[sorces_1.nscinc 
			- 1], &sorces_1.psor5[sorces_1.nscinc - 1], &
			ptcont_1.iptflg, &ptcont_1.iptag, &ptcont_1.iptagf, &
			ptcont_1.iptagt, &inc);
	    }
	    if (ptcont_1.iptflq != -1) {
		ptwirq_(&ptcont_1.iptflq, &ptcont_1.iptaq, &ptcont_1.iptaqf, &
			ptcont_1.iptaqt);
	    }
	    if (ptcont_1.iptflg == -2 || ptcont_1.iptflg == 0) {
		ptpchc_();
	    }
	    if (ixtyp == 0 || ixtyp == 5) {
		pwrbgt_(&netcx_1.pin, &netcx_1.pnls, &ploss);
	    }
	    igo = 4;
	    if (iflow == 7) {
		if (ixtyp > 0 && ixtyp < 4) {
		    goto L54;
		}
		sorces_1.psor1[sorces_1.nscinc - 1] = thsave;
		sorces_1.psor2[sorces_1.nscinc - 1] = phsave;
		if (frqdat_1.nfrq != 1) {
		    goto L120;
		}
		s_wsfe(&io___45);
		e_wsfe();
		goto L14;
	    }

/*     NEAR AND FAR FIELD CALCULATIONS */

	    if (nfdat_1.near__ == 0 || nfdat_1.near__ == 1) {
		nfpat_();
	    }
	    if (nfdat_1.near__ == 2) {
		nfline_();
	    }
	    if (gnd_1.ifar != -1) {
		rdpat_(&netcx_1.pin, &netcx_1.pnls, &ploss);
	    }
L54:
	    ;
	}
	if (sorces_1.nscinc > 0) {
	    sorces_1.psor2[sorces_1.nscinc - 1] = phsave;
	}
/* L55: */
    }
    if (sorces_1.nscinc > 0) {
	sorces_1.psor1[sorces_1.nscinc - 1] = thsave;
    }
    if (ptcont_1.iptflg >= 2) {
	ptrecn_();
    }
    if (mhz == frqdat_1.nfrq) {
	gnd_1.ifar = -1;
	nfdat_1.near__ = -1;
    }
    if (frqdat_1.nfrq == 1) {
	s_wsfe(&io___46);
	e_wsfe();
	goto L14;
    }
L120:
    ++mhz;
    if (mhz <= frqdat_1.nfrq) {
	goto L42;
    }
    if (iped != 0) {
	ptzped_();
    }
    frqdat_1.nfrq = 1;
    mhz = 1;
    frqdat_1.fmhzs = frqdat_1.fmhz;
    s_wsfe(&io___47);
    e_wsfe();
    goto L14;
L72:
    if (nfdat_1.near__ == 0 || nfdat_1.near__ == 1) {
	nfpat_();
    } else {
	nfline_();
    }
    nfdat_1.near__ = -1;
    s_wsfe(&io___48);
    e_wsfe();
    goto L14;
L78:
    if (gnd_1.ifar != -1) {
	rdpat_(&netcx_1.pin, &netcx_1.pnls, &ploss);
    }
    gnd_1.ifar = -1;
    s_wsfe(&io___49);
    e_wsfe();
    goto L14;

} /* MAIN__ */

/* Subroutine */ int curout_(void)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsue(cilist *), do_uio(integer *, char *, ftnlen), e_wsue(void);

    /* Local variables */
    static integer i__;
    static char text[20];

    /* Fortran I/O blocks */
    static cilist io___51 = { 0, 0, 0, 0, 0 };
    static cilist io___52 = { 0, 0, 0, 0, 0 };
    static cilist io___54 = { 0, 0, 0, 0, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CUROUT WRITES A,B,C COEFFICIENTS FOR CURRENT TO A FILE FOR */
/*     PLOTTING BY PROGRAM PLT2D3D */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    s_copy(text, "***NEC4 CURRENT", (ftnlen)20, (ftnlen)15);
    io___51.ciunit = outfil_1.lunplt;
    s_wsue(&io___51);
    do_uio(&c__1, text, (ftnlen)20);
    e_wsue();
    io___52.ciunit = outfil_1.lunplt;
    s_wsue(&io___52);
    do_uio(&c__1, (char *)&data_1.n, (ftnlen)sizeof(integer));
    e_wsue();
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	io___54.ciunit = outfil_1.lunplt;
	s_wsue(&io___54);
	do_uio(&c__2, (char *)&crnt_1.aix[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__2, (char *)&crnt_1.bix[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__2, (char *)&crnt_1.cix[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_uio(&c__2, (char *)&crnt_1.xks[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	e_wsue();
    }
    return 0;
} /* curout_ */

/* Subroutine */ int geoout_(void)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsue(cilist *), do_uio(integer *, char *, ftnlen), e_wsue(void);

    /* Local variables */
    static integer i__;
    static char text[20];

    /* Fortran I/O blocks */
    static cilist io___56 = { 0, 0, 0, 0, 0 };
    static cilist io___57 = { 0, 0, 0, 0, 0 };
    static cilist io___59 = { 0, 0, 0, 0, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GEOOUT WRITES SEGMENT DATA TO A FILE FOR PLOTTING BY PLOT2D3D */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    s_copy(text, "***NEC4 GEOM", (ftnlen)20, (ftnlen)12);
    io___56.ciunit = outfil_1.lunplt;
    s_wsue(&io___56);
    do_uio(&c__1, text, (ftnlen)20);
    e_wsue();
    io___57.ciunit = outfil_1.lunplt;
    s_wsue(&io___57);
    do_uio(&c__1, (char *)&data_1.n, (ftnlen)sizeof(integer));
    e_wsue();
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	io___59.ciunit = outfil_1.lunplt;
	s_wsue(&io___59);
	do_uio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_uio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_uio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_uio(&c__1, (char *)&data_1.salp[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&data_1.icon1[i__ - 1], (ftnlen)sizeof(integer))
		;
	do_uio(&c__1, (char *)&data_1.icon2[i__ - 1], (ftnlen)sizeof(integer))
		;
	do_uio(&c__1, (char *)&data_1.itag[i__ - 1], (ftnlen)sizeof(integer));
	e_wsue();
    }
    return 0;
} /* geoout_ */

/* Subroutine */ int rsetpl_(integer *itmp1, integer *iflow, char *filnam, 
	ftnlen filnam_len)
{
    /* System generated locals */
    olist o__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer f_open(olist *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */
    *iflow = 1;
    if (*itmp1 != 0) {
	outfil_1.iplot = 0;
	return 0;
    }
    outfil_1.iplot = 1;
    outfil_1.lunplt = 22;
    if (s_cmp(outfil_1.plfnam, " ", (ftnlen)60, (ftnlen)1) == 0 || s_cmp(
	    filnam, " ", filnam_len, (ftnlen)1) != 0) {
	s_copy(outfil_1.plfnam, filnam, (ftnlen)60, filnam_len);
	if (s_cmp(filnam, " ", filnam_len, (ftnlen)1) == 0) {
	    s_copy(outfil_1.plfnam, "PLFIL.NEC", (ftnlen)60, (ftnlen)9);
	}
	o__1.oerr = 0;
	o__1.ounit = outfil_1.lunplt;
	o__1.ofnmlen = 60;
	o__1.ofnm = outfil_1.plfnam;
	o__1.orl = 0;
	o__1.osta = "unknown";
	o__1.oacc = 0;
	o__1.ofm = "UNFORMATTED";
	o__1.oblnk = 0;
	f_open(&o__1);
    }
    return 0;
} /* rsetpl_ */

/* Subroutine */ int catnry_(doublereal *xw1, doublereal *yw1, doublereal *
	zw1, doublereal *xw2, doublereal *yw2, doublereal *zw2, doublereal *
	rad, integer *ict, doublereal *rhmp, doublereal *zmp, integer *ns, 
	integer *itg)
{
    /* Format strings */
    static char fmt_90[] = "(\002 CATNRY: ERROR - INCORRECT PARAMETERS RECEI"
	    "VED\002)";
    static char fmt_91[] = "(10x,\002Catenary length =\002,1pe12.5,4x,\002To"
	    "tal segment length =\002,e12.5)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double sqrt(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double log(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal c1;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static doublereal aa, rh, xd, yd, zd, ex2, rhd;
    static integer ist;
    static doublereal cfac, clen, slen, exrm, zhgt, exrp, exrs, csegl, clenx, 
	    xlenx;
    extern /* Subroutine */ int catsol_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *)
	    , catexp_(doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *);

    /* Fortran I/O blocks */
    static cilist io___68 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___84 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CATNRY generates segment geometry data for a wire with NS segments */
/*     in the shape of a catenary. */

/*     INPUT: */
/*     XW1,YW1,ZW1 = starting point of the catenary */
/*     XW2,YW2,ZW2 = final point of the catenary */
/*     RAD = wire radius */
/*     ICT = flag to set method of determining the catenary shape */
/*     RHMP = horizontal distance from (XW1,YW1,ZW1) to a point along */
/*            the catenary for ICT=1 or 2; catenary length for ICT=3. */
/*     ZMP = height of the catenary at the distance RHMP for ICT=1 or 2. */
/*     NS = number of segments along the catenary */
/*     ITG = tag number for segments */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ist = data_1.n + 1;
    data_1.n += *ns;
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    if (*ns < 1) {
	return 0;
    }
    data_1.x[ist - 1] = *xw1;
    data_1.y[ist - 1] = *yw1;
    data_1.z__[ist - 1] = *zw1;
    data_1.bi[ist - 1] = *rad;
    data_1.itag[ist - 1] = *itg;
    x2[data_1.n - 1] = *xw2;
    y2[data_1.n - 1] = *yw2;
    z2[data_1.n - 1] = *zw2;
    xd = *xw2 - *xw1;
    yd = *yw2 - *yw1;
    zd = *zw2 - *zw1;
/* Computing 2nd power */
    d__1 = xd;
/* Computing 2nd power */
    d__2 = yd;
    rhd = sqrt(d__1 * d__1 + d__2 * d__2);
    if (rhd < 1e-20f) {
	s_wsfe(&io___68);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    xd /= rhd;
    yd /= rhd;
    if (*ict == 1) {
	zhgt = *zmp - *zw1;
    } else if (*ict == 2) {
	zhgt = zd * *rhmp / rhd - *zmp;
    }
    i__1 = *ict - 2;
    catsol_(&rhd, &zd, rhmp, &zhgt, &c1, &rh, &i__1);
    catexp_(&rhd, &rh, &ex2, &exrp, &exrm, &exrs);
    clen = (exrp * c1 - exrm / c1) * .5f;
    csegl = clen / *ns;
    cfac = (c1 - 1.f / c1) * .5f;
    clenx = 0.f;
    xlenx = 0.f;
    slen = 0.f;
    ++ist;
    i__1 = data_1.n;
    for (i__ = ist; i__ <= i__1; ++i__) {
	if (rh > 1e-20f) {
	    clenx += csegl;
	    aa = rh * clenx + cfac;
/* Computing 2nd power */
	    d__1 = aa;
	    xlenx = log((aa + sqrt(d__1 * d__1 + 1.f)) / c1) / rh;
	} else {
	    xlenx += rhd / *ns;
	}
	catexp_(&xlenx, &rh, &ex2, &exrp, &exrm, &exrs);
	data_1.x[i__ - 1] = *xw1 + xlenx * xd;
	data_1.y[i__ - 1] = *yw1 + xlenx * yd;
	data_1.z__[i__ - 1] = *zw1 + (exrp * c1 + exrm / c1) * .5f;
	data_1.bi[i__ - 1] = *rad;
	data_1.itag[i__ - 1] = *itg;
	x2[i__ - 2] = data_1.x[i__ - 1];
	y2[i__ - 2] = data_1.y[i__ - 1];
	z2[i__ - 2] = data_1.z__[i__ - 1];
/* Computing 2nd power */
	d__1 = x2[i__ - 2] - data_1.x[i__ - 2];
/* Computing 2nd power */
	d__2 = y2[i__ - 2] - data_1.y[i__ - 2];
/* Computing 2nd power */
	d__3 = z2[i__ - 2] - data_1.z__[i__ - 2];
	slen += sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
/* L1: */
    }
/* Computing 2nd power */
    d__1 = x2[data_1.n - 1] - data_1.x[data_1.n - 1];
/* Computing 2nd power */
    d__2 = y2[data_1.n - 1] - data_1.y[data_1.n - 1];
/* Computing 2nd power */
    d__3 = z2[data_1.n - 1] - data_1.z__[data_1.n - 1];
    slen += sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    s_wsfe(&io___84);
    do_fio(&c__1, (char *)&clen, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&slen, (ftnlen)sizeof(doublereal));
    e_wsfe();
    return 0;

} /* catnry_ */

#undef z2
#undef y2
#undef x2


/* Subroutine */ int catexp_(doublereal *x, doublereal *rh, doublereal *exr, 
	doublereal *exrp, doublereal *exrm, doublereal *exrs)
{
    /* System generated locals */
    doublereal d__1, d__2;

    /* Builtin functions */
    double exp(doublereal);

    /* Local variables */
    static doublereal xr;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CATEXP evaluates exponential terms for a catenary */

    xr = *x * *rh;
    *exr = exp(xr);
    if (abs(xr) > .1f) {
	*exrp = (*exr - 1.f) / *rh;
	*exrm = (1.f / *exr - 1.f) / *rh;
	*exrs = (*exrm + *exrp) / *rh;
    } else {
	*exrp = *x * ((((xr * .008333333f + .04166667f) * xr + .1666667f) * 
		xr + .5f) * xr + 1.f);
	*exrm = *x * ((((xr * -.008333333f + .04166667f) * xr - .1666667f) * 
		xr + .5f) * xr - 1.f);
/* Computing 2nd power */
	d__1 = *x;
/* Computing 2nd power */
	d__2 = xr;
	*exrs = d__1 * d__1 * (d__2 * d__2 * .08333333f + 1.f);
    }
    return 0;
} /* catexp_ */

/* Subroutine */ int catsol_(doublereal *x2, doublereal *y2, doublereal *xmx, 
	doublereal *ymx, doublereal *c1, doublereal *rh, integer *icat)
{
    /* Initialized data */

    static integer maxitr = 51;

    /* Format strings */
    static char fmt_90[] = "(\002 CATSOL: SOLUTION DID NOT CONVERGE\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static integer i__;
    static doublereal cp, yf, xm, ym, dyf, exrm, exrp, exrs, exrx, rxrx, 
	    rhdif, sqfac;
    extern /* Subroutine */ int catexp_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *);

    /* Fortran I/O blocks */
    static cilist io___96 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CATSOL solves for the constants C1 and RH for a catenary */
/*     Y=((EXP(RH*X)-1.)*C1 + (EXP(-RH*X)-1.)/C1)/(2.*RH).  The catenary */
/*     passes through the points (0,0) and (X2,Y2).  For ICAT=0 the */
/*     the catenary passes through the point (XMX,YMX).  For ICAT=1 the */
/*     XMX is the total length of the catenary. */

/*     OUTPUT: C1, RH = constants for the catenary. */

    if (*icat == 1) {
	xm = *x2;
	ym = *xmx;
/* Computing 2nd power */
	d__1 = *x2;
/* Computing 2nd power */
	d__2 = *y2;
	if (ym <= sqrt(d__1 * d__1 + d__2 * d__2)) {
	    *rh = 0.f;
/* Computing 2nd power */
	    d__1 = *x2;
/* Computing 2nd power */
	    d__2 = *y2;
	    *c1 = (*y2 + sqrt(d__1 * d__1 + d__2 * d__2)) / *x2;
	    return 0;
	}
    } else {
	xm = *xmx;
	ym = *ymx;
    }
    *rh = 1.f / *x2;
    rhdif = 1.f;
    i__1 = maxitr;
    for (i__ = 1; i__ <= i__1; ++i__) {
	catexp_(x2, rh, &exrx, &exrp, &exrm, &exrs);
/* Computing 2nd power */
	d__1 = *y2;
	sqfac = sqrt(d__1 * d__1 + exrs);
	if (*x2 < 0.f) {
	    sqfac = -sqfac;
	}
	*c1 = (*y2 + sqfac) / exrp;

/*     EXIT IF ITERATION HAS CONVERGED OR LIMIT HAS BEEN REACHED. */

	if ((d__1 = rhdif / *rh, abs(d__1)) < 1e-5f) {
	    goto L2;
	}
	if (i__ >= maxitr) {
	    s_wsfe(&io___96);
	    e_wsfe();
	    goto L2;
	}

/* Computing 2nd power */
	d__1 = *y2;
/* Computing 2nd power */
	d__2 = exrp;
	cp = (*y2 + (*x2 * (exrp - exrm) + d__1 * d__1 * 2.f) * .5f / sqfac) /
		 exrp - *x2 * exrx * (*y2 + sqfac) / (d__2 * d__2);
	if (*icat == 1) {
	    exrm = -exrm;
	    rxrx = -1.f / exrx;
	} else {
	    catexp_(&xm, rh, &exrx, &exrp, &exrm, &exrs);
	    rxrx = 1.f / exrx;
	}
	yf = (exrp * *c1 + exrm / *c1) * .5f;
/* Computing 2nd power */
	d__1 = *c1;
	dyf = (-yf + (xm * (exrx * *c1 - rxrx / *c1) + cp * (exrp - exrm / (
		d__1 * d__1))) * .5f) / *rh;
	rhdif = (yf - ym) / dyf;
	*rh -= rhdif;
	if (*rh * *x2 > 50.f) {
	    *rh = 50.f / *x2;
	}
/* L1: */
    }
L2:
    return 0;

} /* catsol_ */

/* Subroutine */ int conset_(void)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CONSET sets the values of constants (pi, etc.) in COMMON/CONSTN/ */

    constn_1.pi = 3.141592654f;
    constn_1.tp = 6.2831853071796;
    constn_1.dtorad = .01745329252f;
    constn_1.cvel = 2.998e8f;
    constn_1.epsrz = 8.854e-12f;
    constn_1.rmuz = constn_1.pi * 4e-7f;
    constn_1.etaz = 376.73f;
    return 0;
} /* conset_ */

/* Subroutine */ int setgnd_(doublereal *fmhz)
{
    /* Format strings */
    static char fmt_900[] = "(////,33x,\002- - - - - - FREQUENCY - - - - - "
	    "-\002,//,36x,\002FREQUENCY=\002,1pe11.4,\002 MHZ\002,/,36x,\002W"
	    "AVELENGTH=\002,e11.4,\002 METERS\002)";
    static char fmt_901[] = "(36x,\002SKIN DEPTH=\002,1pe11.4,\002 METERS"
	    "\002)";
    static char fmt_902[] = "(///,34x,\002- - - ANTENNA ENVIRONMENT - - -"
	    "\002,/)";
    static char fmt_903[] = "(44x,\002FREE SPACE\002)";
    static char fmt_904[] = "(40x,\002INFINITE MEDIUM\002)";
    static char fmt_905[] = "(40x,\002RELATIVE DIELECTRIC CONST.=\002,f7.3,/"
	    ",40x,\002CONDUCTIVITY=\002,1pe10.3,\002 MHOS/METER\002,/,40x,"
	    "\002COMPLEX DIELECTRIC CONSTANT=\002,2e12.5)";
    static char fmt_906[] = "(42x,\002PERFECT GROUND\002)";
    static char fmt_907[] = "(40x,\002RADIAL WIRE GROUND SCREEN\002,/,40x,"
	    "i5,\002 WIRES\002,/,40x,\002WIRE LENGTH=\002,f8.2,\002 METERS"
	    "\002,/,40x,\002WIRE RADIUS=\002,1pe10.3,\002 METERS\002)";
    static char fmt_908[] = "(40x,\002MEDIUM UNDER SCREEN -\002)";
    static char fmt_909[] = "(40x,\002FINITE GROUND.  SOMMERFELD SOLUTION"
	    "\002)";
    static char fmt_910[] = "(40x,\002FINITE GROUND.  REFLECTION COEFFICIENT"
	    " APPROXIMATION\002)";
    static char fmt_912[] = "(40x,\002RELATIVE DIELECTRIC CONST.=\002,f7.3,/"
	    ",40x,\002CONDUCTIVITY=\002,1pe10.3,\002 MHOS/METER\002,/,40x,"
	    "\002COMPLEX DIELECTRIC CONSTANT=\002,2e12.5)";
    static char fmt_911[] = "(/,40x,\002UPPER MEDIUM:\002)";

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    double d_imag(doublecomplex *), z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex xk;
    static doublereal wlam;
    static doublecomplex epsc2;
    static doublereal delsk;
    extern /* Subroutine */ int gndino_(doublecomplex *, integer *);

    /* Fortran I/O blocks */
    static cilist io___103 = { 0, 3, 0, fmt_900, 0 };
    static cilist io___105 = { 0, 3, 0, fmt_901, 0 };
    static cilist io___106 = { 0, 3, 0, fmt_902, 0 };
    static cilist io___107 = { 0, 3, 0, fmt_903, 0 };
    static cilist io___108 = { 0, 3, 0, fmt_904, 0 };
    static cilist io___109 = { 0, 3, 0, fmt_905, 0 };
    static cilist io___110 = { 0, 3, 0, fmt_906, 0 };
    static cilist io___112 = { 0, 3, 0, fmt_907, 0 };
    static cilist io___113 = { 0, 3, 0, fmt_908, 0 };
    static cilist io___114 = { 0, 3, 0, fmt_909, 0 };
    static cilist io___115 = { 0, 3, 0, fmt_910, 0 };
    static cilist io___116 = { 0, 3, 0, fmt_912, 0 };
    static cilist io___117 = { 0, 3, 0, fmt_911, 0 };
    static cilist io___118 = { 0, 3, 0, fmt_912, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SETGND sets parameters for the upper (or infinite) medium and for */
/*     ground. Ground and upper medium parameters are printed in the */
/*     output file. For the Sommerfeld ground model, subroutine GNDINO is */
/*     called to read the tables generated by SOMNTX. */


/*     UPPER MEDIUM PARAMETERS */

    if (setgn_1.usig < 0.f) {
	setgn_1.usig = -setgn_1.usig * constn_1.tp * *fmhz * 1e6f * 
		constn_1.epsrz;
    }
    d__1 = -setgn_1.usig / (constn_1.tp * *fmhz * 1e6f * constn_1.epsrz);
    z__1.r = setgn_1.ueps, z__1.i = d__1;
    gnd_1.cepsu.r = z__1.r, gnd_1.cepsu.i = z__1.i;
    gnd_1.cepsl.r = gnd_1.cepsu.r, gnd_1.cepsl.i = gnd_1.cepsu.i;
    z_sqrt(&z__1, &gnd_1.cepsu);
    xk.r = z__1.r, xk.i = z__1.i;
    d__1 = constn_1.tp * *fmhz * 1e6f;
    z__2.r = d__1 * xk.r, z__2.i = d__1 * xk.i;
    z__1.r = z__2.r / constn_1.cvel, z__1.i = z__2.i / constn_1.cvel;
    gnd_1.xku.r = z__1.r, gnd_1.xku.i = z__1.i;
    z__1.r = constn_1.tp * xk.r, z__1.i = constn_1.tp * xk.i;
    gparm_1.gck2.r = z__1.r, gparm_1.gck2.i = z__1.i;
    z__1.r = gparm_1.gck2.r * gparm_1.gck2.r - gparm_1.gck2.i * 
	    gparm_1.gck2.i, z__1.i = gparm_1.gck2.r * gparm_1.gck2.i + 
	    gparm_1.gck2.i * gparm_1.gck2.r;
    gparm_1.gck2sq.r = z__1.r, gparm_1.gck2sq.i = z__1.i;
    gnrzz_1.ck2.r = gparm_1.gck2.r, gnrzz_1.ck2.i = gparm_1.gck2.i;
    z__2.r = constn_1.etaz, z__2.i = 0.;
    z_div(&z__1, &z__2, &xk);
    gnd_1.etau.r = z__1.r, gnd_1.etau.i = z__1.i;
    gnd_1.xkl.r = gnd_1.xku.r, gnd_1.xkl.i = gnd_1.xku.i;
    gnd_1.etal.r = gnd_1.etau.r, gnd_1.etal.i = gnd_1.etau.i;
    gnd_1.gscal = *fmhz * 1e6f / constn_1.cvel;
    gnd_1.omegag = constn_1.tp * *fmhz * 1e6f;
    wlam = constn_1.tp / gnd_1.xku.r;
    s_wsfe(&io___103);
    do_fio(&c__1, (char *)&(*fmhz), (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&wlam, (ftnlen)sizeof(doublereal));
    e_wsfe();
    delsk = (d__1 = d_imag(&gnd_1.xku), abs(d__1));
    if (delsk * wlam > 1e-20f) {
	delsk = 1.f / delsk;
	s_wsfe(&io___105);
	do_fio(&c__1, (char *)&delsk, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    s_wsfe(&io___106);
    e_wsfe();
    if (gnd_1.ksymp == 1) {
	z__1.r = gnd_1.cepsu.r - 1.f, z__1.i = gnd_1.cepsu.i;
	if (z_abs(&z__1) < 1e-6f) {
	    s_wsfe(&io___107);
	    e_wsfe();
	} else {
	    s_wsfe(&io___108);
	    e_wsfe();
	    s_wsfe(&io___109);
	    do_fio(&c__1, (char *)&setgn_1.ueps, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&setgn_1.usig, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&gnd_1.cepsu, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
	return 0;
    }

/*     SET FREQUENCY DEPENDENT GROUND PARAMETERS */

    gnd_1.frati.r = 1.f, gnd_1.frati.i = 0.f;
    if (gnd_1.iperf == 1) {
	s_wsfe(&io___110);
	e_wsfe();
    } else {
	if (setgn_1.gsig < 0.f) {
	    setgn_1.gsig = -setgn_1.gsig * constn_1.tp * *fmhz * 1e6f * 
		    constn_1.epsrz;
	}
	d__1 = -setgn_1.gsig / (constn_1.tp * *fmhz * 1e6f * constn_1.epsrz);
	z__1.r = setgn_1.geps, z__1.i = d__1;
	gnrzz_1.epsc1.r = z__1.r, gnrzz_1.epsc1.i = z__1.i;
	gnd_1.cepsl.r = gnrzz_1.epsc1.r, gnd_1.cepsl.i = gnrzz_1.epsc1.i;
	z_sqrt(&z__1, &gnrzz_1.epsc1);
	xk.r = z__1.r, xk.i = z__1.i;
	d__1 = constn_1.tp * *fmhz * 1e6f;
	z__2.r = d__1 * xk.r, z__2.i = d__1 * xk.i;
	z__1.r = z__2.r / constn_1.cvel, z__1.i = z__2.i / constn_1.cvel;
	gnd_1.xkl.r = z__1.r, gnd_1.xkl.i = z__1.i;
	z__1.r = constn_1.tp * xk.r, z__1.i = constn_1.tp * xk.i;
	gparm_1.gck1.r = z__1.r, gparm_1.gck1.i = z__1.i;
	z__1.r = gparm_1.gck1.r * gparm_1.gck1.r - gparm_1.gck1.i * 
		gparm_1.gck1.i, z__1.i = gparm_1.gck1.r * gparm_1.gck1.i + 
		gparm_1.gck1.i * gparm_1.gck1.r;
	gparm_1.gck1sq.r = z__1.r, gparm_1.gck1sq.i = z__1.i;
	gnrzz_1.ck1.r = gparm_1.gck1.r, gnrzz_1.ck1.i = gparm_1.gck1.i;
	z__2.r = constn_1.etaz, z__2.i = 0.;
	z_div(&z__1, &z__2, &xk);
	gnd_1.etal.r = z__1.r, gnd_1.etal.i = z__1.i;
    }
    if (gnd_1.iclift != 0) {
	if (gnd_1.sig2 < 0.f) {
	    gnd_1.sig2 = -gnd_1.sig2 * constn_1.tp * *fmhz * 1e6f * 
		    constn_1.epsrz;
	}
	d__1 = -gnd_1.sig2 / (constn_1.tp * *fmhz * 1e6f * constn_1.epsrz);
	z__1.r = gnd_1.epsr2, z__1.i = d__1;
	epsc2.r = z__1.r, epsc2.i = z__1.i;
	z_sqrt(&z__1, &epsc2);
	xk.r = z__1.r, xk.i = z__1.i;
	z__2.r = constn_1.etaz, z__2.i = 0.;
	z_div(&z__1, &z__2, &xk);
	gnd_1.etal2.r = z__1.r, gnd_1.etal2.i = z__1.i;
    }
    if (gnd_1.iperf != 1) {
	if (gnd_1.nradl > 0) {
	    s_wsfe(&io___112);
	    do_fio(&c__1, (char *)&gnd_1.nradl, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&gnd_1.scnrad, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gnd_1.scnwrd, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	    s_wsfe(&io___113);
	    e_wsfe();
	}
	if (gnd_1.iperf == 2) {
	    z__3.r = gnd_1.xkl.r * gnd_1.xkl.r - gnd_1.xkl.i * gnd_1.xkl.i, 
		    z__3.i = gnd_1.xkl.r * gnd_1.xkl.i + gnd_1.xkl.i * 
		    gnd_1.xkl.r;
	    z__4.r = gnd_1.xku.r * gnd_1.xku.r - gnd_1.xku.i * gnd_1.xku.i, 
		    z__4.i = gnd_1.xku.r * gnd_1.xku.i + gnd_1.xku.i * 
		    gnd_1.xku.r;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__6.r = gnd_1.xkl.r * gnd_1.xkl.r - gnd_1.xkl.i * gnd_1.xkl.i, 
		    z__6.i = gnd_1.xkl.r * gnd_1.xkl.i + gnd_1.xkl.i * 
		    gnd_1.xkl.r;
	    z__7.r = gnd_1.xku.r * gnd_1.xku.r - gnd_1.xku.i * gnd_1.xku.i, 
		    z__7.i = gnd_1.xku.r * gnd_1.xku.i + gnd_1.xku.i * 
		    gnd_1.xku.r;
	    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	    z_div(&z__1, &z__2, &z__5);
	    gnd_1.frati.r = z__1.r, gnd_1.frati.i = z__1.i;
	    gndino_(&gnrzz_1.epsc1, &c__21);
	    s_wsfe(&io___114);
	    e_wsfe();
	} else {
	    s_wsfe(&io___115);
	    e_wsfe();
	}
	s_wsfe(&io___116);
	do_fio(&c__1, (char *)&setgn_1.geps, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&setgn_1.gsig, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&gnrzz_1.epsc1, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    z__1.r = gnd_1.cepsu.r - 1.f, z__1.i = gnd_1.cepsu.i;
    if (z_abs(&z__1) > 1e-6f) {
	s_wsfe(&io___117);
	e_wsfe();
	s_wsfe(&io___118);
	do_fio(&c__1, (char *)&setgn_1.ueps, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&setgn_1.usig, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&gnd_1.cepsu, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

} /* setgnd_ */

/* Subroutine */ int settlx_(void)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1;

    /* Builtin functions */
    double tan(doublereal), sin(doublereal);

    /* Local variables */
    static integer inet;
    static doublereal xkzero;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SETTLX computes the short-circuit admittance parameters for */
/*     ideal transmission lines. */

/*     DESCRIPTION: */
/*     TWO-PORT ADMITTANCE PARAMETERS ARE COMPUTED FROM THE LENGTH AND */
/*     CHARACTERISTIC IMPEDANCE OF THE TRANSMISSION LINE AND FREQUENCY. */

/*     INPUT: */
/*     TLZCH = CHARACTERISTIC IMPEDANCE OF TRANSMISSION LINE (OHMS) */
/*     TLLEN = LENGTH OF TRANSMISSION LINE (M) */
/*     TLYT1 = LOAD ADMITTANCE ACROSS END ONE OF TRANSMISSION LINE (MHOS) */
/*     TLYT2 = LOAD ADMITTANCE ACROSS END TWO OF TRANSMISSION LINE (MHOS) */
/*     OMEGAG = 2.*PI*(FREQUENCY) */
/*     OTHER INPUT FROM COMMON /NETDEF/ */

/*     OUTPUT: */
/*     YN11 = ADMITTANCE AT END ONE OF THE TRANSMISSION LINE WITH END */
/*            TWO SHORT CIRCUITED (MHOS) */
/*     YN22 = ADMITTANCE AT END TWO OF THE TRANSMISSION LINE WITH END */
/*            ONE SHORT CIRCUITED (MHOS) */
/*     YN12 = CURRENT IN END TWO (SHORT CURCUITED) WITH ONE VOLT ON END */
/*            ONE OF THE TRANSMISSION LINE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    xkzero = gnd_1.omegag / constn_1.cvel;
    i__1 = netdef_1.nonet;
    for (inet = 1; inet <= i__1; ++inet) {
	if (netdef_1.netyp[inet - 1] == 1) {
	    goto L1;
	}
	i__2 = inet - 1;
	d__1 = netdef_1.tlzch[inet - 1] * tan(xkzero * netdef_1.tllen[inet - 
		1]);
	z__1.r = -0.f / d__1, z__1.i = -1.f / d__1;
	netdef_1.yn11[i__2].r = z__1.r, netdef_1.yn11[i__2].i = z__1.i;
	i__2 = inet - 1;
	i__3 = inet - 1;
	netdef_1.yn22[i__2].r = netdef_1.yn11[i__3].r, netdef_1.yn22[i__2].i =
		 netdef_1.yn11[i__3].i;
	i__2 = inet - 1;
	d__1 = netdef_1.tlzch[inet - 1] * sin(xkzero * netdef_1.tllen[inet - 
		1]);
	z__1.r = 0.f / d__1, z__1.i = 1.f / d__1;
	netdef_1.yn12[i__2].r = z__1.r, netdef_1.yn12[i__2].i = z__1.i;

/*     REVERSE SIGN OF YN12 IF THE LINE IS TWISTED (NETYP=3) */

	if (netdef_1.netyp[inet - 1] == 3) {
	    i__2 = inet - 1;
	    i__3 = inet - 1;
	    z__1.r = -netdef_1.yn12[i__3].r, z__1.i = -netdef_1.yn12[i__3].i;
	    netdef_1.yn12[i__2].r = z__1.r, netdef_1.yn12[i__2].i = z__1.i;
	}

/*     ADD ADMITTANCES OF TERMINATING LOADS */

	i__2 = inet - 1;
	i__3 = inet - 1;
	i__4 = inet - 1;
	z__1.r = netdef_1.yn11[i__3].r + netdef_1.tlyt1[i__4].r, z__1.i = 
		netdef_1.yn11[i__3].i + netdef_1.tlyt1[i__4].i;
	netdef_1.yn11[i__2].r = z__1.r, netdef_1.yn11[i__2].i = z__1.i;
	i__2 = inet - 1;
	i__3 = inet - 1;
	i__4 = inet - 1;
	z__1.r = netdef_1.yn22[i__3].r + netdef_1.tlyt2[i__4].r, z__1.i = 
		netdef_1.yn22[i__3].i + netdef_1.tlyt2[i__4].i;
	netdef_1.yn22[i__2].r = z__1.r, netdef_1.yn22[i__2].i = z__1.i;
L1:
	;
    }
    return 0;
} /* settlx_ */

/* Subroutine */ int cdeflt_(integer *igo, integer *iped, integer *irngf, 
	integer *icasx, integer *ixtyp)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CDEFLT sets default parameters including frequency, sources, */
/*     radiation patterns, loading, networks, transmission lines, near */
/*     field output, print control and coupling calculation. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    *igo = 1;
    frqdat_1.nfrq = 1;
    sorces_1.nsorc = 0;
    *ixtyp = 0;
    zload_1.nload = 0;
    netdef_1.nonet = 0;
    vlcapc_1.ivcap = 0;
    setjn_1.isetjn = 1;
    nfdat_1.near__ = -1;
    ptcont_1.iptflg = -2;
    ptcont_1.iptflq = -1;
    gnd_1.iclift = 0;
    gnd_1.ifar = -1;
    *iped = 0;
    *irngf = 0;
    inscom_1.nins = 0;
    outfil_1.iplot = 0;
    s_copy(outfil_1.plfnam, " ", (ftnlen)60, (ftnlen)1);
    if (*icasx > 0) {
	return 0;
    }
    frqdat_1.fmhzs = constn_1.cvel * 1e-6f;
    zload_1.nlodf = 0;
    gnd_1.ksymp = 1;
    gnd_1.nradl = 0;
    gnd_1.iperf = 0;
    setgn_1.ueps = 1.f;
    setgn_1.usig = 0.f;
    inscom_1.ninsf = 0;
    glock_1.iglock = 0;
    return 0;
} /* cdeflt_ */

/* Subroutine */ int getiof_(void)
{
    /* Format strings */
    static char fmt_90[] = "(\002 ENTER DATA INPUT FILENAME >\002,$)";
    static char fmt_91[] = "(a)";
    static char fmt_92[] = "(\002 ENTER DATA OUTPUT FILENAME >\002,$)";
    static char fmt_94[] = "(//,\002 NEC-4.1 RUN IN PROGRESS\002,//,\002  IN"
	    "PUT FILE: \002,a60)";
    static char fmt_96[] = "(\002  OUTPUT FILE: \002,a60)";
    static char fmt_95[] = "(//,22x,\002*** WARNING ***\002,//,\002 The NEC-"
	    "4.1 code is subject to export restrictions under the\002,/,\002 "
	    "Export Administration Act of 1979, extended by Executive\002,/"
	    ",\002 Order 12730.  All requests except foreign requests shall be"
	    "\002,/,\002 directed to Lawrence Livermore National Laboratory ("
	    "LLNL) at\002,/,\002 P.O. Box 808, L-156, Livermore, CA 94550.  F"
	    "oreign requests\002,/,\002 shall be submitted through embassy ch"
	    "annels and HQDA\002,/,\002 (DAMI-CIT) to Commander, USAISC, ATTN"
	    ": ASIS, Fort Huachuca,\002,/,\002 AZ 85613-5000.  Further distri"
	    "bution by authorized\002,/,\002 recipients is not permitted.\002"
	    ",////)";
    static char fmt_93[] = "(\002 GETIOF: ERROR - UNABLE TO OPEN FILE \002,a)"
	    ;

    /* System generated locals */
    integer i__1;
    olist o__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), s_rsfe(cilist *), do_fio(integer *
	    , char *, ftnlen), e_rsfe(void), s_cmp(char *, char *, ftnlen, 
	    ftnlen), f_open(olist *);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer ierr;
    extern /* Subroutine */ int error_(void);
    static integer maxerr;

    /* Fortran I/O blocks */
    static cilist io___123 = { 0, 6, 0, fmt_90, 0 };
    static cilist io___124 = { 1, 5, 0, fmt_91, 0 };
    static cilist io___125 = { 0, 6, 0, fmt_92, 0 };
    static cilist io___126 = { 1, 5, 0, fmt_91, 0 };
    static cilist io___127 = { 0, 6, 0, fmt_94, 0 };
    static cilist io___128 = { 0, 6, 0, fmt_96, 0 };
    static cilist io___129 = { 0, 6, 0, fmt_95, 0 };
    static cilist io___130 = { 0, 6, 0, fmt_93, 0 };
    static cilist io___131 = { 0, 6, 0, fmt_93, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GETIOF requests names for the input and output files and reads */
/*     the names entered from the terminal. */

    maxerr = 20;
    ierr = 0;
L1:
    s_wsfe(&io___123);
    e_wsfe();
    i__1 = s_rsfe(&io___124);
    if (i__1 != 0) {
	goto L3;
    }
    i__1 = do_fio(&c__1, ninfo_1.infile__, (ftnlen)80);
    if (i__1 != 0) {
	goto L3;
    }
    i__1 = e_rsfe();
    if (i__1 != 0) {
	goto L3;
    }

/* *** VAX: */
/*      IF (INFILE .NE. ' ')OPEN (UNIT=2,FILE=INFILE,STATUS='OLD', */
/*     &                    READONLY,ERR=3) */

/* *** MACINTOSH: */
/*      IF (INFILE .NE. ' ')OPEN (UNIT=2,FILE=INFILE,STATUS='OLD', */
/*     &                    ACTION='READ',ERR=3) */

/* *** UNIX: */
    if (s_cmp(ninfo_1.infile__, " ", (ftnlen)80, (ftnlen)1) != 0) {
	o__1.oerr = 1;
	o__1.ounit = 2;
	o__1.ofnmlen = 80;
	o__1.ofnm = ninfo_1.infile__;
	o__1.orl = 0;
	o__1.osta = "OLD";
	o__1.oacc = 0;
	o__1.ofm = 0;
	o__1.oblnk = 0;
	i__1 = f_open(&o__1);
	if (i__1 != 0) {
	    goto L3;
	}
    }

    ierr = 0;
L2:
    s_wsfe(&io___125);
    e_wsfe();
    i__1 = s_rsfe(&io___126);
    if (i__1 != 0) {
	goto L4;
    }
    i__1 = do_fio(&c__1, ninfo_1.outfile, (ftnlen)80);
    if (i__1 != 0) {
	goto L4;
    }
    i__1 = e_rsfe();
    if (i__1 != 0) {
	goto L4;
    }

/* *** VAX: */
/*      IF (OUTFILE .NE. ' ')OPEN (UNIT=3,FILE=OUTFILE,STATUS='NEW',ERR=4) */

/* *** UNIX: */
    if (s_cmp(ninfo_1.outfile, " ", (ftnlen)80, (ftnlen)1) != 0) {
	o__1.oerr = 1;
	o__1.ounit = 3;
	o__1.ofnmlen = 80;
	o__1.ofnm = ninfo_1.outfile;
	o__1.orl = 0;
	o__1.osta = "UNKNOWN";
	o__1.oacc = 0;
	o__1.ofm = 0;
	o__1.oblnk = 0;
	i__1 = f_open(&o__1);
	if (i__1 != 0) {
	    goto L4;
	}
    }
    s_wsfe(&io___127);
    do_fio(&c__1, ninfo_1.infile__, (ftnlen)80);
    e_wsfe();
    s_wsfe(&io___128);
    do_fio(&c__1, ninfo_1.outfile, (ftnlen)80);
    e_wsfe();
    s_wsfe(&io___129);
    e_wsfe();
    return 0;
L3:
    error_();
    ++ierr;
    if (ierr > maxerr) {
	s_wsfe(&io___130);
	do_fio(&c__1, ninfo_1.infile__, (ftnlen)80);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    goto L1;
L4:
    error_();
    ++ierr;
    if (ierr > maxerr) {
	s_wsfe(&io___131);
	do_fio(&c__1, ninfo_1.outfile, (ftnlen)80);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    goto L2;

} /* getiof_ */

/* Subroutine */ int necttl_(void)
{
    /* Format strings */
    static char fmt_91[] = "(\0021\002)";
    static char fmt_92[] = "(///,32x,\002***********************************"
	    "************\002,/,32x,\002*\002,45x,\002*\002,/,32x,\002*  NUME"
	    "RICAL ELECTROMAGNETICS CODE (NEC-4.1)  *\002,/,32x,\002*\002,45x,"
	    "\002*\002,/,32x,\002********************************************"
	    "***\002,//)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);

    /* Fortran I/O blocks */
    static cilist io___132 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___133 = { 0, 3, 0, fmt_92, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NECTTL inserts a page eject and then prints the NEC output */
/*     heading.  Also, the counter for comment data lines is initialized. */

    ninfo_1.kcom = 0;
    s_wsfe(&io___132);
    e_wsfe();
    s_wsfe(&io___133);
    e_wsfe();
    return 0;

} /* necttl_ */

/* Subroutine */ int comout_(char *recdat, integer *icmblk, ftnlen recdat_len)
{
    /* Format strings */
    static char fmt_90[] = "(/,22x,58(\002*\002),//)";
    static char fmt_91[] = "(//,22x,58(\002*\002),/)";
    static char fmt_92[] = "(25x,a)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer do_fio(integer *, char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___134 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___135 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___136 = { 0, 3, 0, fmt_92, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     COMOUT prints text lines from the input file for title and */
/*     information.  The first 4 lines and the last line are saved. */

/*     INPUT: */
/*     RECDAT = CHARACTER STRING TO BE PRINTED */
/*     ICMBLK = 0 TO START A TEXT BLOCK, 1 TO CONTINUE A TEXT BLOCK */
/*              OR 2 TO PRINT THE TERMINATING BORDER. */

    if (*icmblk == 2) {
	s_wsfe(&io___134);
	e_wsfe();
	*icmblk = 0;
	return 0;
    } else if (*icmblk == 0) {
	s_wsfe(&io___135);
	e_wsfe();
	*icmblk = 1;
    }
    ++ninfo_1.kcom;
    if (ninfo_1.kcom > 5) {
	ninfo_1.kcom = 5;
    }
    s_copy(ninfo_1.comin + (ninfo_1.kcom - 1) * 78, recdat, (ftnlen)78, (
	    ftnlen)78);
    s_wsfe(&io___136);
    do_fio(&c__1, recdat, (ftnlen)78);
    e_wsfe();
    return 0;

} /* comout_ */

/* Subroutine */ int rsetex_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4, doublereal *tmp1, doublereal *tmp2, doublereal *tmp3, 
	doublereal *tmp4, doublereal *tmp5, doublereal *tmp6, doublereal *
	tmp7, integer *iflow, integer *igo, integer *iped, integer *ixtyp, 
	integer *ntsol, doublereal *zpnorm)
{
    /* Format strings */
    static char fmt_90[] = "(///,10x,\002RSETEX: NUMBER OF EXCITATION COMMAN"
	    "DS EXCEEDS\002,\002 STORAGE ALLOTTED\002)";
    static char fmt_91[] = "(\002 RSETEX: ERROR IN EX COMMAND - EXCITATION T"
	    "YPE\002,i5,\002 IS\002,\002 INVALID\002)";

    /* System generated locals */
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    extern integer isegno_(integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___137 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___138 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETEX stores the input data for EX input commands in */
/*     COMMON/SORCES/. */

/*     INPUT DEPENDS ON THE VALUE OF ITMP1: */

/*     ITMP1 = 0 FOR APPLIED FIELD VOLTAGE SOURCE */
/*          ITMP2 = TAG NUMBER OF SOURCE SEGMENT */
/*          ITMP3 = SOURCE SEGMENT NUMBER, OR NUMBER WITHIN TAG SET */
/*          ITMP4 = FLAG TO REQUEST IMPEDANCE NORMALIZATION IN FREQ. LOOP */
/*          CMPLX(TMP1,TMP2) = SOURCE VOLTAGE */

/*     ITMP1 = 1 FOR INCIDENT PLANE WAVE, LINEAR POLARIZATION */
/*             2 FOR INCIDENT PLANE WAVE, RIGHT-HAND ELLIPTIC POL. */
/*             3 FOR INCIDENT PLANE WAVE, LEFT-HAND ELLIPTIC POL. */
/*          TMP1,TMP2,TMP3 = THETA, PHI AND ETA DEFINING DIRECTION AND */
/*                           POLARIZATION OF INCIDENT WAVE (DEGREES) */
/*          TMP4 = INCREMENT FOR THETA (DEGREES) */
/*          TMP5 = INCREMENT FOR PHI (DEGREES) */
/*          TMP6 = AXIAL RATIO FOR ELLIPTIC POLARIZATION */
/*          TMP7 = FIELD STRENGTH (V/M) (MAJOR AXIS FOR ELLIPTIC POL.) */
/*          ITMP2 = NUMBER OF INCREMENTS IN THETA */
/*          ITMP3 = NUMBER OF INCREMENTS IN PHI */

/*     ITMP1 = 4 FOR HERTZIAN DIPOLE SOURCE */
/*          TMP1,TMP2,TMP3 = X,Y,Z COORDINATES OF CENTER OF THE DIPOLE */
/*          TMP4,TMP5 = ELEVATION AND AZIMUTH ANGLES OF DIPOLE (DEG.) */
/*          TMP6 = CURRENT MOMENT (AMP-METERS) */

/*     ITMP1 = 5 FOR BICONE VOLTAGE SOURCE */
/*          ITMP2 = TAG NUMBER OF SOURCE SEGMENT */
/*          ITMP3 = SEGMENT NUMBER OR NUMBER WITHIN TAG SET */
/*          CMPLX(TMP1,TMP2) = SOURCE VOLTAGE */

/*     OUTPUT (IN ADDITION TO PARAMETERS STORED IN COMMON/SORCES/): */

/*     IFLOW = FLAG TO INDICATE PREVIOUS COMMAND (= 5 FOR "EX" COMMAND) */
/*     IGO = FLAG TO INDICATE POINT FROM WHICH SOLUTION MUST BE REPEATED */
/*     IPED = FLAG TO REQUEST NORMALIZATION OF IMPEDANCES FROM FREQ. LOOP */
/*     MASYM = FLAG TO REQUEST CALC. OF MAX. RELATIVE MATRIX ASYMMETRY */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


/*     INITIALIZE IF STARTING A NEW SET OF EX COMMANDS */

    if (*iflow != 5) {
	*iflow = 5;
	sorces_1.nsorc = 0;
	*iped = 0;
	if (*igo > 3) {
	    *igo = 3;
	}
    }

/*     STORE INPUT DATA */

    ++sorces_1.nsorc;
    if (sorces_1.nsorc > 30) {
	s_wsfe(&io___137);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    *ixtyp = *itmp1;
    *ntsol = 0;
    if (*itmp1 == 0 || *itmp1 == 5) {

/*     VOLTAGE SOURCE - APPLIED FIELD OR BICONE. */

	sorces_1.isortp[sorces_1.nsorc - 1] = 1;
	if (*itmp1 == 5) {
	    sorces_1.isortp[sorces_1.nsorc - 1] = 4;
	}
	sorces_1.psor1[sorces_1.nsorc - 1] = (doublereal) isegno_(itmp2, 
		itmp3);
	sorces_1.psor2[sorces_1.nsorc - 1] = *tmp1;
	sorces_1.psor3[sorces_1.nsorc - 1] = *tmp2;
/* Computing 2nd power */
	d__1 = *tmp1;
/* Computing 2nd power */
	d__2 = *tmp2;
	if (d__1 * d__1 + d__2 * d__2 < 1e-37f) {
	    sorces_1.psor2[sorces_1.nsorc - 1] = 1.f;
	}
	*iped = *itmp4 - *itmp4 / 10 * 10;
	*zpnorm = *tmp3;
	sorces_1.nthinc = 1;
	sorces_1.nphinc = 1;
	return 0;
    } else if (*itmp1 >= 1 && *itmp1 <= 3) {

/*     INCIDENT PLANE WAVE, LINEAR OR ELLIPTIC POLARIZATION */

	sorces_1.isortp[sorces_1.nsorc - 1] = 2;
	sorces_1.psor1[sorces_1.nsorc - 1] = *tmp1;
	sorces_1.psor2[sorces_1.nsorc - 1] = *tmp2;
	sorces_1.psor3[sorces_1.nsorc - 1] = *tmp3;
	sorces_1.psor4[sorces_1.nsorc - 1] = 1.f;
	if (abs(*tmp7) > 1e-25f) {
	    sorces_1.psor4[sorces_1.nsorc - 1] = *tmp7;
	}
	sorces_1.psor5[sorces_1.nsorc - 1] = 0.f;
	if (*itmp1 == 2) {
	    sorces_1.psor5[sorces_1.nsorc - 1] = *tmp6;
	}
	if (*itmp1 == 3) {
	    sorces_1.psor5[sorces_1.nsorc - 1] = -(*tmp6);
	}
	sorces_1.nthinc = *itmp2;
	sorces_1.nphinc = *itmp3;
	sorces_1.dthinc = *tmp4;
	sorces_1.dphinc = *tmp5;
	sorces_1.nscinc = sorces_1.nsorc;
	return 0;
    } else if (*itmp1 == 4) {

/*     HERTZIAN DIPOLE SOURCE */

	sorces_1.isortp[sorces_1.nsorc - 1] = 3;
	sorces_1.psor1[sorces_1.nsorc - 1] = *tmp1;
	sorces_1.psor2[sorces_1.nsorc - 1] = *tmp2;
	sorces_1.psor3[sorces_1.nsorc - 1] = *tmp3;
	sorces_1.psor4[sorces_1.nsorc - 1] = *tmp4;
	sorces_1.psor5[sorces_1.nsorc - 1] = *tmp5;
	sorces_1.psor6[sorces_1.nsorc - 1] = *tmp6;
	sorces_1.nthinc = 1;
	sorces_1.nphinc = 1;
	return 0;
    }

/*     INVALID EXCITATION TYPE */

    s_wsfe(&io___138);
    do_fio(&c__1, (char *)&(*itmp1), (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);

    return 0;
} /* rsetex_ */

/* Subroutine */ int rsetxq_(integer *itmp1, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETXQ stores data from XQ commands from the input file. */

    if (*itmp1 == 0) {
	if (*iflow <= 7) {
	    *iflow = 7;
	} else {
	    *iflow = 11;
	}
	return 0;
    }
    gnd_1.ifar = 0;
    rpdat_1.rfld = 0.f;
    rpdat_1.ipd = 0;
    rpdat_1.iavp = 0;
    rpdat_1.inor = 0;
    rpdat_1.iax = 0;
    rpdat_1.nth = 91;
    rpdat_1.nph = 1;
    rpdat_1.thets = 0.f;
    rpdat_1.phis = 0.f;
    rpdat_1.dth = 1.f;
    rpdat_1.dph = 0.f;
    if (*itmp1 == 2) {
	rpdat_1.phis = 90.f;
    }
    if (*itmp1 != 3) {
	return 0;
    }
    rpdat_1.nph = 2;
    rpdat_1.dph = 90.f;
    return 0;
} /* rsetxq_ */

/* Subroutine */ int rsetrp_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4, doublereal *tmp1, doublereal *tmp2, doublereal *tmp3, 
	doublereal *tmp4, doublereal *tmp5, doublereal *tmp6, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETRP stores data from RP commands */

    gnd_1.ifar = *itmp1;
    rpdat_1.nth = *itmp2;
    rpdat_1.nph = *itmp3;
    if (rpdat_1.nth == 0) {
	rpdat_1.nth = 1;
    }
    if (rpdat_1.nph == 0) {
	rpdat_1.nph = 1;
    }
    rpdat_1.ipd = *itmp4 / 10;
    rpdat_1.iavp = *itmp4 - rpdat_1.ipd * 10;
    rpdat_1.inor = rpdat_1.ipd / 10;
    rpdat_1.ipd -= rpdat_1.inor * 10;
    rpdat_1.iax = rpdat_1.inor / 10;
    rpdat_1.inor -= rpdat_1.iax * 10;
    if (rpdat_1.iax != 0) {
	rpdat_1.iax = 1;
    }
    if (rpdat_1.ipd != 0) {
	rpdat_1.ipd = 1;
    }
    if (rpdat_1.nth < 2 || rpdat_1.nph < 2) {
	rpdat_1.iavp = 0;
    }
    if (gnd_1.ifar == 1) {
	rpdat_1.iavp = 0;
    }
    rpdat_1.thets = *tmp1;
    rpdat_1.phis = *tmp2;
    rpdat_1.dth = *tmp3;
    rpdat_1.dph = *tmp4;
    rpdat_1.rfld = *tmp5;
    rpdat_1.gnor = *tmp6;
    *iflow = 10;
    return 0;
} /* rsetrp_ */

/* Subroutine */ int rsetnf_(char *ain, integer *itmp1, integer *itmp2, 
	integer *itmp3, integer *itmp4, doublereal *tmp1, doublereal *tmp2, 
	doublereal *tmp3, doublereal *tmp4, doublereal *tmp5, doublereal *
	tmp6, integer *iflow, ftnlen ain_len)
{
    /* Format strings */
    static char fmt_90[] = "(///,\002 WHEN MULTIPLE FREQUENCIES ARE REQUESTE"
	    "D, ONLY ONE\002,\002 NEAR FIELD REQUEST CAN BE USED -\002,/,\002"
	    " LAST REQUEST READ IS\002,\002 USED\002)";

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void);

    /* Fortran I/O blocks */
    static cilist io___139 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETNF stores data from NE or NH commands requesting near field */
/*     output. */

    if (s_cmp(ain, "NE", (ftnlen)2, (ftnlen)2) == 0) {
	nfdat_1.nfeh = 0;
    }
    if (s_cmp(ain, "NH", (ftnlen)2, (ftnlen)2) == 0) {
	nfdat_1.nfeh = 1;
    }
    if ((*iflow == 8 || *iflow == 9) && frqdat_1.nfrq != 1) {
	s_wsfe(&io___139);
	e_wsfe();
    }
    nfdat_1.near__ = *itmp1;
    nfdat_1.nrx = *itmp2;
    nfdat_1.nry = *itmp3;
    nfdat_1.nrz = *itmp4;
    nfdat_1.xnr = *tmp1;
    nfdat_1.ynr = *tmp2;
    nfdat_1.znr = *tmp3;
    nfdat_1.dxnr = *tmp4;
    nfdat_1.dynr = *tmp5;
    nfdat_1.dznr = *tmp6;
    *iflow = 8;
    return 0;

} /* rsetnf_ */

/* Subroutine */ int rsetnl_(char *ain, integer *itmp1, integer *itmp2, 
	doublereal *tmp1, doublereal *tmp2, doublereal *tmp3, doublereal *
	tmp4, doublereal *tmp5, doublereal *tmp6, integer *iflow, ftnlen 
	ain_len)
{
    /* Format strings */
    static char fmt_90[] = "(///,\002 WHEN MULTIPLE FREQUENCIES ARE REQUESTE"
	    "D, ONLY ONE\002,\002 NEAR FIELD REQUEST CAN BE USED -\002,/,\002"
	    " LAST REQUEST READ IS\002,\002 USED\002)";

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void);

    /* Fortran I/O blocks */
    static cilist io___140 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETNL stores data from LE or LH commands requesting computation */
/*     of near E or H fields along a line. */

    if (s_cmp(ain, "LE", (ftnlen)2, (ftnlen)2) == 0) {
	nfdat_1.nfeh = 0;
    }
    if (s_cmp(ain, "LH", (ftnlen)2, (ftnlen)2) == 0) {
	nfdat_1.nfeh = 1;
    }
    if (*iflow != 9 || *itmp1 == -1) {
	nfdat_1.enintg.r = 0.f, nfdat_1.enintg.i = 0.f;
	nfdat_1.hnintg.r = 0.f, nfdat_1.hnintg.i = 0.f;
    }
    if ((*iflow == 8 || *iflow == 9) && frqdat_1.nfrq != 1) {
	s_wsfe(&io___140);
	e_wsfe();
    }
    nfdat_1.near__ = 2;
    nfdat_1.nrx = *itmp2;
    nfdat_1.xnr = *tmp1;
    nfdat_1.ynr = *tmp2;
    nfdat_1.znr = *tmp3;
    nfdat_1.dxnr = *tmp4;
    nfdat_1.dynr = *tmp5;
    nfdat_1.dznr = *tmp6;
    *iflow = 9;
    return 0;

} /* rsetnl_ */

/* Subroutine */ int rsetcp_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETCP stores data from a CP command to request calculation of */
/*     maximum coupling */

    *iflow = 13;
    cppram_1.icpt1 = *itmp1;
    cppram_1.icps1 = *itmp2;
    cppram_1.icpt2 = *itmp3;
    cppram_1.icps2 = *itmp4;
    return 0;
} /* rsetcp_ */

/* Subroutine */ int rsetvc_(integer *itmp1, integer *igo, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */
    if (*igo > 2) {
	*igo = 2;
    }
    *iflow = 1;
    vlcapc_1.ivcap = 1;
    if (*itmp1 == 1) {
	vlcapc_1.ivcap = 0;
    }
    return 0;
} /* rsetvc_ */

/* Subroutine */ int rsetum_(doublereal *tmp1, doublereal *tmp2, integer *igo,
	 integer *iflow, integer *icasx)
{
    /* Format strings */
    static char fmt_90[] = "(/,\002 RSETUM: ERROR - UM COMMAND IS NOT ALLOWE"
	    "D WITH N.G.F.\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___141 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETUM stores upper medium parameters from a UM command. */

    if (*icasx != 0) {
	s_wsfe(&io___141);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    setgn_1.ueps = *tmp1;
    setgn_1.usig = *tmp2;
    if (setgn_1.ueps == 0.f) {
	setgn_1.ueps = 1.f;
	setgn_1.usig = 0.f;
    }
    if (*igo > 2) {
	*igo = 2;
    }
    *iflow = 1;
    return 0;

} /* rsetum_ */

/* Subroutine */ int rsetjn_(integer *itmp1, integer *igo, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETJN selects the method for determining the charge at a junction */

/*     ISETJN = 1 for MM solution for charge */
/*              2 for charge proportional to log of wire radius (Wu-King) */

    if (*itmp1 == 0) {
	setjn_1.isetjn = 2;
    } else {
	setjn_1.isetjn = 1;
    }
    if (*igo > 2) {
	*igo = 2;
    }
    *iflow = 1;
    return 0;

} /* rsetjn_ */

/* Subroutine */ int rsetgd_(integer *itmp1, doublereal *tmp1, doublereal *
	tmp2, doublereal *tmp3, doublereal *tmp4, integer *iflow)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETGD stores parameters from a GD command defining second ground */
/*     medium or cliff. */

    gnd_1.iclift = *itmp1;
    gnd_1.epsr2 = *tmp1;
    gnd_1.sig2 = *tmp2;
    gnd_1.clifl = *tmp3;
    gnd_1.clifh = *tmp4;
    *iflow = 4;
    return 0;
} /* rsetgd_ */

/* Subroutine */ int rsetpt_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETPT stores parameters from a PT command limiting printing of */
/*     currents. */

    ptcont_1.iptflg = *itmp1;
    ptcont_1.iptag = *itmp2;
    ptcont_1.iptagf = *itmp3;
    ptcont_1.iptagt = *itmp4;
    if (*itmp3 == 0 && ptcont_1.iptflg != -1) {
	ptcont_1.iptflg = -2;
    }
    if (*itmp4 == 0) {
	ptcont_1.iptagt = ptcont_1.iptagf;
    }
    return 0;
} /* rsetpt_ */

/* Subroutine */ int rsetpq_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETPQ stores parameters from a PQ command requesting printing of */
/*     charge on wires. */

    ptcont_1.iptflq = *itmp1;
    ptcont_1.iptaq = *itmp2;
    ptcont_1.iptaqf = *itmp3;
    ptcont_1.iptaqt = *itmp4;
    if (*itmp3 == 0 && ptcont_1.iptflq != -1) {
	ptcont_1.iptflq = -2;
    }
    if (*itmp4 == 0) {
	ptcont_1.iptaqt = ptcont_1.iptaqf;
    }
    return 0;
} /* rsetpq_ */

/* Subroutine */ int rsetgn_(integer *itmp1, integer *itmp2, doublereal *tmp1,
	 doublereal *tmp2, doublereal *tmp3, doublereal *tmp4, doublereal *
	tmp5, doublereal *tmp6, char *filnam, integer *igo, integer *iflow, 
	integer *icasx, ftnlen filnam_len)
{
    /* Format strings */
    static char fmt_90[] = "(/,\002 RSETGN: ERROR - GN COMMAND IS NOT ALLOWE"
	    "D WITH N.G.F.\002)";
    static char fmt_91[] = "(\002 RSETGN: RADIAL WIRE G. S. APPROXIMATION MA"
	    "Y NOT BE USED\002,\002 WITH SOMMERFELD GROUND OPTION\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___142 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___143 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETGN stores parameters from a GN command defining ground */
/*     parameters in COMMON/GND/. */

    *iflow = 4;
    if (*icasx != 0) {
	s_wsfe(&io___142);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (*igo > 2) {
	*igo = 2;
    }
    if (*itmp1 == -1) {
	gnd_1.ksymp = 1;
	gnd_1.nradl = 0;
	gnd_1.iperf = 0;
	return 0;
    }
    gnd_1.iperf = *itmp1;
    gnd_1.nradl = *itmp2;
    gnd_1.ksymp = 2;
    setgn_1.geps = *tmp1;
    setgn_1.gsig = *tmp2;
    if (gnd_1.nradl > 0) {
	if (gnd_1.iperf == 2) {
	    s_wsfe(&io___143);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	gnd_1.scnrad = *tmp3;
	gnd_1.scnwrd = *tmp4;
	return 0;
    }
    if (*tmp3 > 1e-20f) {
	gnd_1.iclift = 1;
	gnd_1.epsr2 = *tmp3;
	gnd_1.sig2 = *tmp4;
	gnd_1.clifl = *tmp5;
	gnd_1.clifh = *tmp6;
    }
    if (s_cmp(filnam, " ", (ftnlen)40, (ftnlen)1) == 0) {
	s_copy(filnam, "SOMD.NEC", (ftnlen)40, (ftnlen)8);
    } else {
	gndfil_1.nsfile = 0;
    }
    s_copy(gndfil_1.somfil, filnam, (ftnlen)40, (ftnlen)40);
    return 0;

} /* rsetgn_ */

/* Subroutine */ int rsetis_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4, doublereal *tmp1, doublereal *tmp2, doublereal *tmp3, 
	integer *igo, integer *iflow)
{
    /* Format strings */
    static char fmt_90[] = "(///,10x,\002RSETIS: NUMBER OF IS COMMANDS EXCEE"
	    "DS STORAGE\002,\002 ALLOTTED\002)";
    static char fmt_91[] = "(///,10x,\002RSETIS: DATA FAULT ON IS COMMAND "
	    "NO.\002,i5,5x,\002ITAG STEP1=\002,i5,\002  IS GREATER THAN ITAG "
	    "STEP2=\002,i5)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer do_fio(integer *, char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___144 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___145 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETIS stores parameters for an insulating sheath from an IS */
/*     command.  Parameters are stored in COMMON/INSPAR/. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (*iflow != 2) {
	*iflow = 2;
	inscom_1.nins = 0;
	if (*igo > 2) {
	    *igo = 2;
	}
	if (*itmp1 == -1) {
	    return 0;
	}
    }
    ++inscom_1.nins;
    if (inscom_1.nins > 30) {
	s_wsfe(&io___144);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    inscom_1.intag[inscom_1.nins - 1] = *itmp2;
    if (*itmp4 == 0) {
	*itmp4 = *itmp3;
    }
    inscom_1.intagf[inscom_1.nins - 1] = *itmp3;
    inscom_1.intagt[inscom_1.nins - 1] = *itmp4;
    if (*itmp4 < *itmp3) {
	s_wsfe(&io___145);
	do_fio(&c__1, (char *)&inscom_1.nins, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*itmp3), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*itmp4), (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    inscom_1.epsin[inscom_1.nins - 1] = *tmp1;
    inscom_1.sigin[inscom_1.nins - 1] = *tmp2;
    inscom_1.radin[inscom_1.nins - 1] = *tmp3;
    return 0;

} /* rsetis_ */

/* Subroutine */ int rsetld_(integer *itmp1, integer *itmp2, integer *itmp3, 
	integer *itmp4, doublereal *tmp1, doublereal *tmp2, doublereal *tmp3, 
	integer *igo, integer *iflow)
{
    /* Format strings */
    static char fmt_90[] = "(///,10x,\002RSETLD: NUMBER OF LD COMMANDS EXCEE"
	    "DS STORAGE\002,\002 ALLOTTED\002)";
    static char fmt_91[] = "(///,10x,\002RSETLD: DATA FAULT ON LD COMMAND "
	    "NO.\002,i5,5x,\002ITAG STEP1=\002,i5,\002  IS GREATER THAN ITAG "
	    "STEP2=\002,i5)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer do_fio(integer *, char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___146 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___147 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETLD stores loading parameters from a LD command into */
/*     COMMON/ZLOAD/. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (*iflow != 3) {
	*iflow = 3;
	zload_1.nload = 0;
	if (*igo > 2) {
	    *igo = 2;
	}
	if (*itmp1 == -1) {
	    return 0;
	}
    }
    ++zload_1.nload;
    if (zload_1.nload > 30) {
	s_wsfe(&io___146);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    zload_1.ldtyp[zload_1.nload - 1] = *itmp1;
    zload_1.ldtag[zload_1.nload - 1] = *itmp2;
    if (*itmp4 == 0) {
	*itmp4 = *itmp3;
    }
    zload_1.ldtagf[zload_1.nload - 1] = *itmp3;
    zload_1.ldtagt[zload_1.nload - 1] = *itmp4;
    if (*itmp4 < *itmp3) {
	s_wsfe(&io___147);
	do_fio(&c__1, (char *)&zload_1.nload, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*itmp3), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*itmp4), (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    zload_1.zlr[zload_1.nload - 1] = *tmp1;
    zload_1.zli[zload_1.nload - 1] = *tmp2;
    zload_1.zlc[zload_1.nload - 1] = *tmp3;
    return 0;

} /* rsetld_ */

/* Subroutine */ int rsetfr_(integer *itmp1, integer *itmp2, doublereal *tmp1,
	 doublereal *tmp2, integer *igo, integer *iflow, integer *icasx, 
	integer *iped, doublereal *zpnorm)
{
    /* Format strings */
    static char fmt_90[] = "(/,\002 RSETFR: ERROR - FR COMMAND IS NOT ALLOWE"
	    "D WITH N.G.F.\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___148 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETFR stores frequency and looping parameters from the FR command */
/*     into COMMON/FRQDAT/. */

/*     INPUT: */
/*     ITMP1 = 0 FOR LINEAR INCREMENTING, 1 FOR MULTIPLICATIVE INCREMENT */
/*     ITMP2 = NUMBER OF FREQUENCY STEPS */
/*     TMP1 = INITIAL FREQUENCY (MHZ) */
/*     TMP2 = FREQUENCY INCREMENT (MHZ FOR LINEAR INC., FACTOR FOR MULT.) */

    if (*icasx != 0) {
	s_wsfe(&io___148);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    frqdat_1.ifrq = *itmp1;
    frqdat_1.nfrq = *itmp2;
    if (frqdat_1.nfrq == 0) {
	frqdat_1.nfrq = 1;
    }
    frqdat_1.fmhzs = *tmp1;
    frqdat_1.delfrq = *tmp2;
    if (*iped == 1) {
	*zpnorm = 0.f;
    }
    *igo = 1;
    *iflow = 1;
    return 0;

} /* rsetfr_ */

/* Subroutine */ int rsetnt_(char *ain, integer *itmp1, integer *itmp2, 
	integer *itmp3, integer *itmp4, doublereal *tmp1, doublereal *tmp2, 
	doublereal *tmp3, doublereal *tmp4, doublereal *tmp5, doublereal *
	tmp6, integer *iflow, integer *igo, integer *ntsol, ftnlen ain_len)
{
    /* Format strings */
    static char fmt_90[] = "(///,10x,\002RSETNT: NUMBER OF NETWORK COMMANDS "
	    "EXCEEDS\002,\002 STORAGE ALLOTTED\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;
    doublecomplex z__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    double sqrt(doublereal);

    /* Local variables */
    static integer isg1, isg2;
    extern integer isegno_(integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___149 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RSETNT stores parameters from NT or TL commands into */
/*     COMMON/NETDEF/. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (*iflow != 6) {
	*iflow = 6;
	netdef_1.nonet = 0;
	*ntsol = 0;
	if (*igo > 3) {
	    *igo = 3;
	}
	if (*itmp2 == -1) {
	    return 0;
	}
    }
    ++netdef_1.nonet;
    if (netdef_1.nonet > 30) {
	s_wsfe(&io___149);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    netdef_1.iseg1[netdef_1.nonet - 1] = isegno_(itmp1, itmp2);
    netdef_1.iseg2[netdef_1.nonet - 1] = isegno_(itmp3, itmp4);
    if (s_cmp(ain, "NT", (ftnlen)2, (ftnlen)2) == 0) {
	netdef_1.netyp[netdef_1.nonet - 1] = 1;
	i__1 = netdef_1.nonet - 1;
	z__1.r = *tmp1, z__1.i = *tmp2;
	netdef_1.yn11[i__1].r = z__1.r, netdef_1.yn11[i__1].i = z__1.i;
	i__1 = netdef_1.nonet - 1;
	z__1.r = *tmp3, z__1.i = *tmp4;
	netdef_1.yn12[i__1].r = z__1.r, netdef_1.yn12[i__1].i = z__1.i;
	i__1 = netdef_1.nonet - 1;
	z__1.r = *tmp5, z__1.i = *tmp6;
	netdef_1.yn22[i__1].r = z__1.r, netdef_1.yn22[i__1].i = z__1.i;
	return 0;
    } else {
	if (*tmp1 >= 0.f) {
	    netdef_1.netyp[netdef_1.nonet - 1] = 2;
	}
	if (*tmp1 < 0.f) {
	    netdef_1.netyp[netdef_1.nonet - 1] = 3;
	}
	netdef_1.tlzch[netdef_1.nonet - 1] = abs(*tmp1);
	if (abs(*tmp2) < 1e-20f) {

/*     TRANSMISSION LINE LENGTH IS ZERO SO SET IT TO THE DISTANCE BETWEEN */
/*     CONNECTION POINTS */

	    isg1 = netdef_1.iseg1[netdef_1.nonet - 1];
	    isg2 = netdef_1.iseg2[netdef_1.nonet - 1];
/* Computing 2nd power */
	    d__1 = data_1.x[isg2 - 1] - data_1.x[isg1 - 1];
/* Computing 2nd power */
	    d__2 = data_1.y[isg2 - 1] - data_1.y[isg1 - 1];
/* Computing 2nd power */
	    d__3 = data_1.z__[isg2 - 1] - data_1.z__[isg1 - 1];
	    *tmp2 = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
	}
	netdef_1.tllen[netdef_1.nonet - 1] = *tmp2;
	i__1 = netdef_1.nonet - 1;
	z__1.r = *tmp3, z__1.i = *tmp4;
	netdef_1.tlyt1[i__1].r = z__1.r, netdef_1.tlyt1[i__1].i = z__1.i;
	i__1 = netdef_1.nonet - 1;
	z__1.r = *tmp5, z__1.i = *tmp6;
	netdef_1.tlyt2[i__1].r = z__1.r, netdef_1.tlyt2[i__1].i = z__1.i;
    }
    return 0;

} /* rsetnt_ */

/* Subroutine */ int etmns_(doublecomplex *e)
{
    /* Initialized data */

    static doublereal ta = .01745329252;

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3;
    doublecomplex z__1;

    /* Local variables */
    static integer isor;
    extern /* Subroutine */ int sorvt1_(integer *, doublecomplex *, 
	    doublecomplex *);
    extern integer iround_(doublereal *);
    extern /* Subroutine */ int sorini_(doublecomplex *), sorpwa_(doublereal *
	    , doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublecomplex *), sorvqd_(integer *, doublecomplex *, 
	    doublecomplex *), sorhtz_(doublereal *, doublereal *, doublereal *
	    , doublereal *, doublereal *, doublereal *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ETMNS is the master routine for filling the excitation array E. */
/*     E is the right hand side of the matrix equation for current. */

/*     DESCRIPTION: */
/*     ETMNS FILLS THE ARRAY E FOR THE EXCITATION DESCRIBED IN COMMON */
/*     BLOCK /SORCES/. */

/*     INPUT: FROM COMMON/SORCES/. */

/*     OUTPUT: */
/*     E(I) FOR I= 1 THROUGH N CONTAINS THE NEGATIVE OF THE INCIDENT */
/*          ELECTRIC FIELD ON THE N WIRE SEGMENTS. */
/*     E(I) FOR I=N+1 THROUGH N+2*M CONTAINS THE TANGENTIAL COMPONENTS OF */
/*          MAGNETIC FIELD ON THE M PATCHES. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */

/*     INITIALIZE ARRAY E */

    sorini_(&e[1]);
    i__1 = sorces_1.nsorc;
    for (isor = 1; isor <= i__1; ++isor) {
	switch (sorces_1.isortp[isor - 1]) {
	    case 1:  goto L1;
	    case 2:  goto L2;
	    case 3:  goto L3;
	    case 4:  goto L4;
	}

/*     APPLIED FIELD VOLTAGE SOURCE */

L1:
	i__2 = iround_(&sorces_1.psor1[isor - 1]);
	i__3 = isor - 1;
	i__4 = isor - 1;
	z__1.r = sorces_1.psor2[i__3], z__1.i = sorces_1.psor3[i__4];
	sorvt1_(&i__2, &z__1, &e[1]);
	goto L10;

/*     INCIDENT PLANE WAVE SOURCE */

L2:
	d__1 = sorces_1.psor1[isor - 1] * ta;
	d__2 = sorces_1.psor2[isor - 1] * ta;
	d__3 = sorces_1.psor3[isor - 1] * ta;
	sorpwa_(&d__1, &d__2, &d__3, &sorces_1.psor4[isor - 1], &
		sorces_1.psor5[isor - 1], &e[1]);
	goto L10;

/*     HERTZIAN DIPOLE SOURCE */

L3:
	d__1 = sorces_1.psor4[isor - 1] * ta;
	d__2 = sorces_1.psor5[isor - 1] * ta;
	sorhtz_(&sorces_1.psor1[isor - 1], &sorces_1.psor2[isor - 1], &
		sorces_1.psor3[isor - 1], &d__1, &d__2, &sorces_1.psor6[isor 
		- 1], &e[1]);
	goto L10;

/*     CHARGE DISCONTINUITY (BICONE) VOLTAGE SOURCE */

L4:
	i__2 = iround_(&sorces_1.psor1[isor - 1]);
	i__3 = isor - 1;
	i__4 = isor - 1;
	z__1.r = sorces_1.psor2[i__3], z__1.i = sorces_1.psor3[i__4];
	sorvqd_(&i__2, &z__1, &e[1]);
L10:
	;
    }
    return 0;
} /* etmns_ */

/* Subroutine */ int sorini_(doublecomplex *e)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SORINI initializes the excitation array E to zero. */

/*     DESCRIPTION: */
/*     INPUT: NEQMAT = LENGTH OF EXCITATION ARRAY TO BE INITIALIZED */
/*                    (NEQMAT = NO. SEGMENTS + 2* NO. OF PATCHES) */

/*     OUTPUT: ARRAY E SET TO ZERO */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    i__1 = cmb_1.neqmat;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	i__2 = i__;
	e[i__2].r = 0.f, e[i__2].i = 0.f;
    }
    return 0;
} /* sorini_ */

/* Subroutine */ int sorvt1_(integer *iseg, doublecomplex *volts, 
	doublecomplex *e)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublecomplex z__1, z__2;

    /* Local variables */
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    extern /* Subroutine */ int vltcap_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SORVT1 increments the excitation array E by the field of an */
/*     applied-field voltage source.  The field due to end caps on the */
/*     source segment is included if IVCAP=1. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     ISEG = NUMBER OF THE SEGMENT ON WHICH THE VOLTAGE SOURCE IS */
/*            LOCATED */
/*     VOLTS = SOURCE VOLTAGE (VOLTS) */
/*     SI(ISEG) = LENGTH OF SEGMENT ISEG (FROM COMMON/DATA/) */

/*     OUTPUT: */
/*     E = EXCITATION ARRAY INCREMENTED BY FIELD OF VOLTAGE SOURCE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    i__1 = *iseg;
    i__2 = *iseg;
    i__3 = *iseg - 1;
    z__2.r = volts->r / data_1.si[i__3], z__2.i = volts->i / data_1.si[i__3];
    z__1.r = e[i__2].r - z__2.r, z__1.i = e[i__2].i - z__2.i;
    e[i__1].r = z__1.r, e[i__1].i = z__1.i;
    if (vlcapc_1.ivcap == 1) {
	vltcap_(&data_1.x[*iseg - 1], &data_1.y[*iseg - 1], &data_1.z__[*iseg 
		- 1], &cab[*iseg - 1], &sab[*iseg - 1], &data_1.salp[*iseg - 
		1], &data_1.si[*iseg - 1], &data_1.bi[*iseg - 1], volts, &e[1]
		);
    }
    return 0;
} /* sorvt1_ */

#undef sab
#undef cab


/* Subroutine */ int sorpwa_(doublereal *thet, doublereal *phi, doublereal *
	et, doublereal *emax, doublereal *axrat, doublecomplex *e)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    double cos(doublereal), sin(doublereal), d_imag(doublecomplex *);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, i1, i2;
    static doublecomplex cx, cy, cz;
    static integer is;
    static doublecomplex xk;
    static doublereal px, py;
    static doublecomplex rx, ry, rz, tx, ty, tz;
    static doublereal pz, wx, wy, wz, qx, qy, qz;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex eta, arg;
    static doublereal cph, cth, cet;
    static doublecomplex ckx, cky, ckz;
    static doublereal sph, set;
    static doublecomplex rcx, rcy, rcz;
    static doublereal sth;
    static doublecomplex thx, thy, thz, xkx;
    static doublereal xsp, ysp, zsp, side;
    static doublecomplex ckzx, romu, yste, zstm;
    extern /* Subroutine */ int refpt1_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *), refcof_(doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, integer *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    static integer iperfg;
    extern /* Subroutine */ int trxcof_(doublereal *, doublereal *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *), trxkno_(
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *), 
	    zysurf_(doublereal *, doublereal *, doublereal *, doublereal *, 
	    integer *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SORPWA increments the excitation array E by the field of a plane */
/*     wave with linear or elliptic polarization. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     THET,PHI = ANGLES (RADIANS) IN SPHERICAL COORDINATES OF THE VECTOR */
/*                TOWARD THE SOURCE OF THE PLANE WAVE. */
/*     ET = POLARIZATION ANGLE OF E FIELD.  FOR ET=0, E FIELD IS ALONG */
/*          THE THETA UNIT VECTOR.  POSITIVE ET ROTATES POLARIZATION */
/*          COUNTER CLOCKWISE WHEN VIEWED IN THE DIRECTION OF PROPAGATION */
/*     EMAX = MAGNITUDE OF E FIELD (ALONG MAJOR AXIS OF POLARIZATION */
/*            ELLIPSE) */
/*     AXRAT = RATIO OF MINOR AXIS TO MAJOR AXIS FIELD (POSITIVE FOR */
/*             RIGHT HAND POLARIZATION. */

/*     OUTPUT: */
/*     E = EXCITATION ARRAY INCREMENTED BY FIELD OF PLANE WAVE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    cth = cos(*thet);
    sth = sin(*thet);
    cph = cos(*phi);
    sph = sin(*phi);
    cet = cos(*et);
    set = sin(*et);

/*     WX,WY,WZ = UNIT VECTOR IN DIRECTION OF PROPAGATION */
/*     PX,PY,PZ = UNIT VECTOR IN DIRECTION OF MAJOR AXIS OF POLARIZATION */
/*     QX,QY,QZ = UNIT VECTOR IN DIRECTION OF MINOR AXIS OF POLARIZATION */
/*     CX,CY,CZ = COMPLEX VECTOR FOR INCIDENT E FIELD */
/*     CKX,CKY,CKZ = COMPLEX PROPAGATION VECTOR (K) */

    px = cth * cph * cet - sph * set;
    py = cth * sph * cet + cph * set;
    pz = -sth * cet;
    wx = -sth * cph;
    wy = -sth * sph;
    wz = -cth;
    qx = wy * pz - wz * py;
    qy = wz * px - wx * pz;
    qz = wx * py - wy * px;
    z__4.r = *axrat * fj.r, z__4.i = *axrat * fj.i;
    z__3.r = qx * z__4.r, z__3.i = qx * z__4.i;
    z__2.r = px - z__3.r, z__2.i = -z__3.i;
    z__1.r = *emax * z__2.r, z__1.i = *emax * z__2.i;
    cx.r = z__1.r, cx.i = z__1.i;
    z__4.r = *axrat * fj.r, z__4.i = *axrat * fj.i;
    z__3.r = qy * z__4.r, z__3.i = qy * z__4.i;
    z__2.r = py - z__3.r, z__2.i = -z__3.i;
    z__1.r = *emax * z__2.r, z__1.i = *emax * z__2.i;
    cy.r = z__1.r, cy.i = z__1.i;
    z__4.r = *axrat * fj.r, z__4.i = *axrat * fj.i;
    z__3.r = qz * z__4.r, z__3.i = qz * z__4.i;
    z__2.r = pz - z__3.r, z__2.i = -z__3.i;
    z__1.r = *emax * z__2.r, z__1.i = *emax * z__2.i;
    cz.r = z__1.r, cz.i = z__1.i;
    if (cth > -1e-7f) {

/*     RAY IS INCIDENT ON THE INTERFACE FROM ABOVE */

	side = 1.f;
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	xkx.r = gnd_1.xkl.r, xkx.i = gnd_1.xkl.i;
	eta.r = gnd_1.etau.r, eta.i = gnd_1.etau.i;
    } else {

/*     RAY IS INCIDENT ON THE INTERFACE FROM BELOW */

	side = -1.f;
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	xkx.r = gnd_1.xku.r, xkx.i = gnd_1.xku.i;
	eta.r = gnd_1.etal.r, eta.i = gnd_1.etal.i;
    }
    if (gnd_1.ksymp == 1) {
	side = 0.f;
    }
    z__1.r = wx * xk.r, z__1.i = wx * xk.i;
    ckx.r = z__1.r, ckx.i = z__1.i;
    z__1.r = wy * xk.r, z__1.i = wy * xk.i;
    cky.r = z__1.r, cky.i = z__1.i;
    z__1.r = wz * xk.r, z__1.i = wz * xk.i;
    ckz.r = z__1.r, ckz.i = z__1.i;
    if (gnd_1.ksymp > 1) {

/*     IF SOURCE IS IN A CONDUCTING HALF SPACE, THEN THE FIELD IS ZERO. */

	if (d_imag(&xk) < 0.f) {
	    return 0;
	}
	if (gnd_1.iperf == 1 && side < 0.f) {
	    return 0;
	}

/*     FINITELY CONDUCTING GROUND.  COMPUTE REF. AND TRANS. FIELD. */

	zysurf_(&cth, &c_b332, &c_b332, &side, &iperfg, &yste, &zstm);
	d__1 = -sph;
	refcof_(&cth, &d__1, &cph, &eta, &iperfg, &yste, &zstm, &cx, &cy, &cz,
		 &rx, &ry, &rz);
	if (gnd_1.iperf != 1) {
	    trxkno_(&cth, &xk, &xkx, &ckzx);
	    d__1 = -sph;
	    trxcof_(&d__1, &cph, &ckz, &ckzx, &xk, &xkx, &cx, &cy, &cz, &tx, &
		    ty, &tz);
	}
    }
    if (data_1.n == 0) {
	goto L17;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (side * data_1.z__[i__ - 1] >= 0.f) {

/*     DIRECT FIELD */

	    i__2 = i__ - 1;
	    z__3.r = data_1.x[i__2] * ckx.r, z__3.i = data_1.x[i__2] * ckx.i;
	    i__3 = i__ - 1;
	    z__4.r = data_1.y[i__3] * cky.r, z__4.i = data_1.y[i__3] * cky.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    i__4 = i__ - 1;
	    z__5.r = data_1.z__[i__4] * ckz.r, z__5.i = data_1.z__[i__4] * 
		    ckz.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    arg.r = z__1.r, arg.i = z__1.i;
	    i__2 = i__;
	    i__3 = i__;
	    i__4 = i__ - 1;
	    z__5.r = cab[i__4] * cx.r, z__5.i = cab[i__4] * cx.i;
	    i__5 = i__ - 1;
	    z__6.r = sab[i__5] * cy.r, z__6.i = sab[i__5] * cy.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = data_1.salp[i__6] * cz.r, z__7.i = data_1.salp[i__6] * 
		    cz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__10.r = -fj.r, z__10.i = -fj.i;
	    z__9.r = z__10.r * arg.r - z__10.i * arg.i, z__9.i = z__10.r * 
		    arg.i + z__10.i * arg.r;
	    z_exp(&z__8, &z__9);
	    z__2.r = z__3.r * z__8.r - z__3.i * z__8.i, z__2.i = z__3.r * 
		    z__8.i + z__3.i * z__8.r;
	    z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    if (gnd_1.ksymp == 1) {
		goto L16;
	    }
	    if (gnd_1.iclift == 0 && gnd_1.nradl == 0) {

/*     REFLECTED FIELD FOR UNIFORM GROUND */

		i__2 = i__ - 1;
		z__3.r = data_1.x[i__2] * ckx.r, z__3.i = data_1.x[i__2] * 
			ckx.i;
		i__3 = i__ - 1;
		z__4.r = data_1.y[i__3] * cky.r, z__4.i = data_1.y[i__3] * 
			cky.i;
		z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
		i__4 = i__ - 1;
		z__5.r = data_1.z__[i__4] * ckz.r, z__5.i = data_1.z__[i__4] *
			 ckz.i;
		z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
		arg.r = z__1.r, arg.i = z__1.i;
		i__2 = i__;
		i__3 = i__;
		i__4 = i__ - 1;
		z__5.r = cab[i__4] * rx.r, z__5.i = cab[i__4] * rx.i;
		i__5 = i__ - 1;
		z__6.r = sab[i__5] * ry.r, z__6.i = sab[i__5] * ry.i;
		z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
		i__6 = i__ - 1;
		z__7.r = data_1.salp[i__6] * rz.r, z__7.i = data_1.salp[i__6] 
			* rz.i;
		z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
		z__10.r = -fj.r, z__10.i = -fj.i;
		z__9.r = z__10.r * arg.r - z__10.i * arg.i, z__9.i = z__10.r *
			 arg.i + z__10.i * arg.r;
		z_exp(&z__8, &z__9);
		z__2.r = z__3.r * z__8.r - z__3.i * z__8.i, z__2.i = z__3.r * 
			z__8.i + z__3.i * z__8.r;
		z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
		e[i__2].r = z__1.r, e[i__2].i = z__1.i;

/*     REFLECTED FIELD FOR VARYING GROUND */

	    } else {
		refpt1_(&wx, &wy, &wz, &data_1.x[i__ - 1], &data_1.y[i__ - 1],
			 &data_1.z__[i__ - 1], &xsp, &ysp, &zsp);
		zysurf_(&cth, &xsp, &ysp, &side, &iperfg, &yste, &zstm);
		d__1 = -sph;
		refcof_(&cth, &d__1, &cph, &eta, &iperfg, &yste, &zstm, &cx, &
			cy, &cz, &rcx, &rcy, &rcz);
		i__2 = i__ - 1;
		z__3.r = data_1.x[i__2] * ckx.r, z__3.i = data_1.x[i__2] * 
			ckx.i;
		i__3 = i__ - 1;
		z__4.r = data_1.y[i__3] * cky.r, z__4.i = data_1.y[i__3] * 
			cky.i;
		z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
		d__1 = data_1.z__[i__ - 1] - zsp * 2.f;
		z__5.r = d__1 * ckz.r, z__5.i = d__1 * ckz.i;
		z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
		arg.r = z__1.r, arg.i = z__1.i;
		i__2 = i__;
		i__3 = i__;
		i__4 = i__ - 1;
		z__5.r = cab[i__4] * rcx.r, z__5.i = cab[i__4] * rcx.i;
		i__5 = i__ - 1;
		z__6.r = sab[i__5] * rcy.r, z__6.i = sab[i__5] * rcy.i;
		z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
		i__6 = i__ - 1;
		z__7.r = data_1.salp[i__6] * rcz.r, z__7.i = data_1.salp[i__6]
			 * rcz.i;
		z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
		z__10.r = -fj.r, z__10.i = -fj.i;
		z__9.r = z__10.r * arg.r - z__10.i * arg.i, z__9.i = z__10.r *
			 arg.i + z__10.i * arg.r;
		z_exp(&z__8, &z__9);
		z__2.r = z__3.r * z__8.r - z__3.i * z__8.i, z__2.i = z__3.r * 
			z__8.i + z__3.i * z__8.r;
		z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
		e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    }
	} else {

/*     FIELD TRANSMITTED ACROSS INTERFACE */

	    i__2 = i__ - 1;
	    z__3.r = data_1.x[i__2] * ckx.r, z__3.i = data_1.x[i__2] * ckx.i;
	    i__3 = i__ - 1;
	    z__4.r = data_1.y[i__3] * cky.r, z__4.i = data_1.y[i__3] * cky.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    i__4 = i__ - 1;
	    z__5.r = data_1.z__[i__4] * ckzx.r, z__5.i = data_1.z__[i__4] * 
		    ckzx.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    arg.r = z__1.r, arg.i = z__1.i;
	    i__2 = i__;
	    i__3 = i__;
	    i__4 = i__ - 1;
	    z__5.r = cab[i__4] * tx.r, z__5.i = cab[i__4] * tx.i;
	    i__5 = i__ - 1;
	    z__6.r = sab[i__5] * ty.r, z__6.i = sab[i__5] * ty.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = data_1.salp[i__6] * tz.r, z__7.i = data_1.salp[i__6] * 
		    tz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__10.r = -fj.r, z__10.i = -fj.i;
	    z__9.r = z__10.r * arg.r - z__10.i * arg.i, z__9.i = z__10.r * 
		    arg.i + z__10.i * arg.r;
	    z_exp(&z__8, &z__9);
	    z__2.r = z__3.r * z__8.r - z__3.i * z__8.i, z__2.i = z__3.r * 
		    z__8.i + z__3.i * z__8.r;
	    z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	}
L16:
	;
    }
L17:
    if (data_1.m == 0) {
	return 0;
    }

/*     MAGNETIC FIELD FOR PATCHES */
/*     MAGNETIC FIELD COMPONENTS ARE COMPUTED FROM (K VECTOR) X (E) */

    z__2.r = gnd_1.xku.r * gnd_1.etau.r - gnd_1.xku.i * gnd_1.etau.i, z__2.i =
	     gnd_1.xku.r * gnd_1.etau.i + gnd_1.xku.i * gnd_1.etau.r;
    z_div(&z__1, &c_b336, &z__2);
    romu.r = z__1.r, romu.i = z__1.i;
    thx.r = cx.r, thx.i = cx.i;
    thy.r = cy.r, thy.i = cy.i;
    thz.r = cz.r, thz.i = cz.i;
    z__3.r = cky.r * thz.r - cky.i * thz.i, z__3.i = cky.r * thz.i + cky.i * 
	    thz.r;
    z__4.r = ckz.r * thy.r - ckz.i * thy.i, z__4.i = ckz.r * thy.i + ckz.i * 
	    thy.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i + 
	    z__2.i * romu.r;
    cx.r = z__1.r, cx.i = z__1.i;
    z__3.r = ckz.r * thx.r - ckz.i * thx.i, z__3.i = ckz.r * thx.i + ckz.i * 
	    thx.r;
    z__4.r = ckx.r * thz.r - ckx.i * thz.i, z__4.i = ckx.r * thz.i + ckx.i * 
	    thz.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i + 
	    z__2.i * romu.r;
    cy.r = z__1.r, cy.i = z__1.i;
    z__3.r = ckx.r * thy.r - ckx.i * thy.i, z__3.i = ckx.r * thy.i + ckx.i * 
	    thy.r;
    z__4.r = cky.r * thx.r - cky.i * thx.i, z__4.i = cky.r * thx.i + cky.i * 
	    thx.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i + 
	    z__2.i * romu.r;
    cz.r = z__1.r, cz.i = z__1.i;
    if (gnd_1.ksymp > 1) {

/*     SET UP FOR REFLECTED FIELD */

	thx.r = rx.r, thx.i = rx.i;
	thy.r = ry.r, thy.i = ry.i;
	thz.r = rz.r, thz.i = rz.i;
	z__3.r = cky.r * thz.r - cky.i * thz.i, z__3.i = cky.r * thz.i + 
		cky.i * thz.r;
	z__4.r = ckz.r * thy.r - ckz.i * thy.i, z__4.i = ckz.r * thy.i + 
		ckz.i * thy.r;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i 
		+ z__2.i * romu.r;
	rx.r = z__1.r, rx.i = z__1.i;
	z__4.r = -ckz.r, z__4.i = -ckz.i;
	z__3.r = z__4.r * thx.r - z__4.i * thx.i, z__3.i = z__4.r * thx.i + 
		z__4.i * thx.r;
	z__5.r = ckx.r * thz.r - ckx.i * thz.i, z__5.i = ckx.r * thz.i + 
		ckx.i * thz.r;
	z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
	z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i 
		+ z__2.i * romu.r;
	ry.r = z__1.r, ry.i = z__1.i;
	z__3.r = ckx.r * thy.r - ckx.i * thy.i, z__3.i = ckx.r * thy.i + 
		ckx.i * thy.r;
	z__4.r = cky.r * thx.r - cky.i * thx.i, z__4.i = cky.r * thx.i + 
		cky.i * thx.r;
	z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * romu.i 
		+ z__2.i * romu.r;
	rz.r = z__1.r, rz.i = z__1.i;
	if (gnd_1.iperf != 1) {
	    z__3.r = cky.r * tz.r - cky.i * tz.i, z__3.i = cky.r * tz.i + 
		    cky.i * tz.r;
	    z__4.r = ckzx.r * ty.r - ckzx.i * ty.i, z__4.i = ckzx.r * ty.i + 
		    ckzx.i * ty.r;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * 
		    romu.i + z__2.i * romu.r;
	    thx.r = z__1.r, thx.i = z__1.i;
	    z__3.r = ckzx.r * tx.r - ckzx.i * tx.i, z__3.i = ckzx.r * tx.i + 
		    ckzx.i * tx.r;
	    z__4.r = ckx.r * tz.r - ckx.i * tz.i, z__4.i = ckx.r * tz.i + 
		    ckx.i * tz.r;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * 
		    romu.i + z__2.i * romu.r;
	    thy.r = z__1.r, thy.i = z__1.i;
	    z__3.r = ckx.r * ty.r - ckx.i * ty.i, z__3.i = ckx.r * ty.i + 
		    ckx.i * ty.r;
	    z__4.r = cky.r * tx.r - cky.i * tx.i, z__4.i = cky.r * tx.i + 
		    cky.i * tx.r;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__1.r = z__2.r * romu.r - z__2.i * romu.i, z__1.i = z__2.r * 
		    romu.i + z__2.i * romu.r;
	    thz.r = z__1.r, thz.i = z__1.i;
	}
    }
    i__ = data_1.ld + 1;
    i1 = data_1.n - 1;
    i__1 = data_1.m;
    for (is = 1; is <= i__1; ++is) {
	--i__;
	i1 += 2;
	i2 = i1 + 1;
	if (gnd_1.ksymp == 1 || gnd_1.iperf == 1 || cth * data_1.z__[i__ - 1] 
		>= 0.f) {

/*     DIRECT MAGNETIC FIELD */

	    z__4.r = -fj.r, z__4.i = -fj.i;
	    i__2 = i__ - 1;
	    z__7.r = data_1.x[i__2] * ckx.r, z__7.i = data_1.x[i__2] * ckx.i;
	    i__3 = i__ - 1;
	    z__8.r = data_1.y[i__3] * cky.r, z__8.i = data_1.y[i__3] * cky.i;
	    z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
	    i__4 = i__ - 1;
	    z__9.r = data_1.z__[i__4] * ckz.r, z__9.i = data_1.z__[i__4] * 
		    ckz.i;
	    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
	    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * 
		    z__5.i + z__4.i * z__5.r;
	    z_exp(&z__2, &z__3);
	    i__5 = i__ - 1;
	    z__1.r = data_1.salp[i__5] * z__2.r, z__1.i = data_1.salp[i__5] * 
		    z__2.i;
	    arg.r = z__1.r, arg.i = z__1.i;
	    i__2 = i2;
	    i__3 = i2;
	    i__4 = i__ - 1;
	    z__5.r = t1x[i__4] * cx.r, z__5.i = t1x[i__4] * cx.i;
	    i__5 = i__ - 1;
	    z__6.r = t1y[i__5] * cy.r, z__6.i = t1y[i__5] * cy.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = t1z[i__6] * cz.r, z__7.i = t1z[i__6] * cz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * arg.i 
		    + z__3.i * arg.r;
	    z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    i__2 = i1;
	    i__3 = i1;
	    i__4 = i__ - 1;
	    z__5.r = data_1.t2x[i__4] * cx.r, z__5.i = data_1.t2x[i__4] * 
		    cx.i;
	    i__5 = i__ - 1;
	    z__6.r = data_1.t2y[i__5] * cy.r, z__6.i = data_1.t2y[i__5] * 
		    cy.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = data_1.t2z[i__6] * cz.r, z__7.i = data_1.t2z[i__6] * 
		    cz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * arg.i 
		    + z__3.i * arg.r;
	    z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    if (gnd_1.ksymp > 1) {

/*     REFLECTED MAGNETIC FIELD */

		z__4.r = -fj.r, z__4.i = -fj.i;
		i__2 = i__ - 1;
		z__7.r = data_1.x[i__2] * ckx.r, z__7.i = data_1.x[i__2] * 
			ckx.i;
		i__3 = i__ - 1;
		z__8.r = data_1.y[i__3] * cky.r, z__8.i = data_1.y[i__3] * 
			cky.i;
		z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
		i__4 = i__ - 1;
		z__9.r = data_1.z__[i__4] * ckz.r, z__9.i = data_1.z__[i__4] *
			 ckz.i;
		z__5.r = z__6.r - z__9.r, z__5.i = z__6.i - z__9.i;
		z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * 
			z__5.i + z__4.i * z__5.r;
		z_exp(&z__2, &z__3);
		i__5 = i__ - 1;
		z__1.r = data_1.salp[i__5] * z__2.r, z__1.i = data_1.salp[
			i__5] * z__2.i;
		arg.r = z__1.r, arg.i = z__1.i;
		i__2 = i2;
		i__3 = i2;
		i__4 = i__ - 1;
		z__5.r = t1x[i__4] * rx.r, z__5.i = t1x[i__4] * rx.i;
		i__5 = i__ - 1;
		z__6.r = t1y[i__5] * ry.r, z__6.i = t1y[i__5] * ry.i;
		z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
		i__6 = i__ - 1;
		z__7.r = t1z[i__6] * rz.r, z__7.i = t1z[i__6] * rz.i;
		z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
		z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * 
			arg.i + z__3.i * arg.r;
		z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
		e[i__2].r = z__1.r, e[i__2].i = z__1.i;
		i__2 = i1;
		i__3 = i1;
		i__4 = i__ - 1;
		z__5.r = data_1.t2x[i__4] * rx.r, z__5.i = data_1.t2x[i__4] * 
			rx.i;
		i__5 = i__ - 1;
		z__6.r = data_1.t2y[i__5] * ry.r, z__6.i = data_1.t2y[i__5] * 
			ry.i;
		z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
		i__6 = i__ - 1;
		z__7.r = data_1.t2z[i__6] * rz.r, z__7.i = data_1.t2z[i__6] * 
			rz.i;
		z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
		z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * 
			arg.i + z__3.i * arg.r;
		z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
		e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    }
	} else {

/*     MAGNETIC FIELD TRANSMITTED ACROSS INTERFACE */

	    z__4.r = -fj.r, z__4.i = -fj.i;
	    i__2 = i__ - 1;
	    z__7.r = data_1.x[i__2] * ckx.r, z__7.i = data_1.x[i__2] * ckx.i;
	    i__3 = i__ - 1;
	    z__8.r = data_1.y[i__3] * cky.r, z__8.i = data_1.y[i__3] * cky.i;
	    z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
	    i__4 = i__ - 1;
	    z__9.r = data_1.z__[i__4] * ckzx.r, z__9.i = data_1.z__[i__4] * 
		    ckzx.i;
	    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
	    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * 
		    z__5.i + z__4.i * z__5.r;
	    z_exp(&z__2, &z__3);
	    i__5 = i__ - 1;
	    z__1.r = data_1.salp[i__5] * z__2.r, z__1.i = data_1.salp[i__5] * 
		    z__2.i;
	    arg.r = z__1.r, arg.i = z__1.i;
	    i__2 = i2;
	    i__3 = i2;
	    i__4 = i__ - 1;
	    z__5.r = t1x[i__4] * thx.r, z__5.i = t1x[i__4] * thx.i;
	    i__5 = i__ - 1;
	    z__6.r = t1y[i__5] * thy.r, z__6.i = t1y[i__5] * thy.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = t1z[i__6] * thz.r, z__7.i = t1z[i__6] * thz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * arg.i 
		    + z__3.i * arg.r;
	    z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    i__2 = i1;
	    i__3 = i1;
	    i__4 = i__ - 1;
	    z__5.r = data_1.t2x[i__4] * thx.r, z__5.i = data_1.t2x[i__4] * 
		    thx.i;
	    i__5 = i__ - 1;
	    z__6.r = data_1.t2y[i__5] * thy.r, z__6.i = data_1.t2y[i__5] * 
		    thy.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = data_1.t2z[i__6] * thz.r, z__7.i = data_1.t2z[i__6] * 
		    thz.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * arg.r - z__3.i * arg.i, z__2.i = z__3.r * arg.i 
		    + z__3.i * arg.r;
	    z__1.r = e[i__3].r + z__2.r, z__1.i = e[i__3].i + z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	}
/* L21: */
    }
    return 0;
} /* sorpwa_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int sorhtz_(doublereal *xs, doublereal *ys, doublereal *zs, 
	doublereal *dalp, doublereal *dbet, doublereal *dipmom, doublecomplex 
	*e)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    double cos(doublereal), sin(doublereal), sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublereal r__;
    static integer i1, i2, ii;
    static doublecomplex ds, er, et, cx, cy, cz;
    static integer is;
    static doublereal rs, rx, ry, rz;
    static doublecomplex tt1;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex arg, erh;
    static doublereal ddx, ddy, ddz, dsh, cth;
    static doublecomplex ezh;
    static integer npm;
    static doublereal sth, rhx, rhy, rhz;
    static doublecomplex egnd[9];
    extern /* Subroutine */ int sflds_(doublereal *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SORHTZ increments the excitation array E by the field of a */
/*     hertzian dipole source. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     XS,YS,ZS = COORDINATES OF THE HERTZIAN DIPOLE SOURCE */
/*     DALP = ELEVATION ANGLE (RADIANS) OF THE HERTZIAN DIPOLE ABOVE THE */
/*            X-Y PLANE */
/*     DBET = ANGLE (RADIANS) BETWEEN X AXIS AND THE PROJECTION OF THE */
/*            HERTZIAN DIPOLE ONTO THE X-Y PLANE */
/*     DIPMOM = DIPOLE MOMENT OF HERTZIAN DIPOLE */

/*     OUTPUT: */
/*     E = EXCITATION ARRAY INCREMENTED BY THE FIELD OF THE HERTZIAN */
/*         DIPOLE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    ddz = cos(*dalp);
    ddx = ddz * cos(*dbet);
    ddy = ddz * sin(*dbet);
    ddz = sin(*dalp);
    if (gnd_1.iperf == 2) {
	goto L28;
    }
    z__2.r = *dipmom * gnd_1.etau.r, z__2.i = *dipmom * gnd_1.etau.i;
    z__1.r = z__2.r / constn_1.tp, z__1.i = z__2.i / constn_1.tp;
    ds.r = z__1.r, ds.i = z__1.i;
    dsh = *dipmom / (constn_1.tp * 2.f);
    npm = data_1.n + data_1.m;
    is = data_1.ld + 1;
    i1 = data_1.n - 1;
    i__1 = npm;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ii = i__;
	if (i__ > data_1.n) {
	    --is;
	    ii = is;
	    i1 += 2;
	    i2 = i1 + 1;
	}

/*     RX,RY,RZ = UNIT VECTOR FROM SEGMENT OR PATCH TOWARD THE DIPOLE */
/*     DDX,DDY,DDZ = UNIT VECTOR IN THE DIRECTION OF THE DIPOLE SOURCE */
/*     RHX,RHY,RHZ = UNIT VECTOR NORMAL TO THE DIPOLE SOURCE IN THE PLANE */
/*                   CONTAINING THE SEGMENT OR PATCH CENTER */

	rx = data_1.x[ii - 1] - *xs;
	ry = data_1.y[ii - 1] - *ys;
	rz = data_1.z__[ii - 1] - *zs;
	rs = rx * rx + ry * ry + rz * rz;
	if (rs < 1e-30f) {
	    goto L27;
	}
	r__ = sqrt(rs);
	rx /= r__;
	ry /= r__;
	rz /= r__;
	cth = rx * ddx + ry * ddy + rz * ddz;
	sth = sqrt(1.f - cth * cth);
	rhx = rx - ddx * cth;
	rhy = ry - ddy * cth;
	rhz = rz - ddz * cth;
	incom_1.sn = sqrt(rhx * rhx + rhy * rhy + rhz * rhz);
	if (incom_1.sn > 1e-30f) {
	    rhx /= incom_1.sn;
	    rhy /= incom_1.sn;
	    rhz /= incom_1.sn;
	} else {
	    rhx = 1.f;
	    rhy = 0.f;
	    rhz = 0.f;
	}
	z__4.r = -fj.r, z__4.i = -fj.i;
	z__3.r = z__4.r * gnd_1.xku.r - z__4.i * gnd_1.xku.i, z__3.i = z__4.r 
		* gnd_1.xku.i + z__4.i * gnd_1.xku.r;
	z__2.r = r__ * z__3.r, z__2.i = r__ * z__3.i;
	z_exp(&z__1, &z__2);
	arg.r = z__1.r, arg.i = z__1.i;
	if (i__ <= data_1.n) {

/*     E FIELD ON SEGMENTS */

	    z__4.r = r__ * gnd_1.xku.r, z__4.i = r__ * gnd_1.xku.i;
	    z_div(&z__3, &fj, &z__4);
	    z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
	    z__1.r = z__2.r / rs, z__1.i = z__2.i / rs;
	    tt1.r = z__1.r, tt1.i = z__1.i;
	    z__3.r = ds.r * arg.r - ds.i * arg.i, z__3.i = ds.r * arg.i + 
		    ds.i * arg.r;
	    z__2.r = z__3.r * tt1.r - z__3.i * tt1.i, z__2.i = z__3.r * tt1.i 
		    + z__3.i * tt1.r;
	    z__1.r = cth * z__2.r, z__1.i = cth * z__2.i;
	    er.r = z__1.r, er.i = z__1.i;
	    z__4.r = ds.r * .5f, z__4.i = ds.i * .5f;
	    z__3.r = z__4.r * arg.r - z__4.i * arg.i, z__3.i = z__4.r * arg.i 
		    + z__4.i * arg.r;
	    z__7.r = fj.r * gnd_1.xku.r - fj.i * gnd_1.xku.i, z__7.i = fj.r * 
		    gnd_1.xku.i + fj.i * gnd_1.xku.r;
	    z__6.r = z__7.r / r__, z__6.i = z__7.i / r__;
	    z__5.r = z__6.r + tt1.r, z__5.i = z__6.i + tt1.i;
	    z__2.r = z__3.r * z__5.r - z__3.i * z__5.i, z__2.i = z__3.r * 
		    z__5.i + z__3.i * z__5.r;
	    z__1.r = sth * z__2.r, z__1.i = sth * z__2.i;
	    et.r = z__1.r, et.i = z__1.i;
	    z__2.r = cth * er.r, z__2.i = cth * er.i;
	    z__3.r = sth * et.r, z__3.i = sth * et.i;
	    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	    ezh.r = z__1.r, ezh.i = z__1.i;
	    z__2.r = sth * er.r, z__2.i = sth * er.i;
	    z__3.r = cth * et.r, z__3.i = cth * et.i;
	    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	    erh.r = z__1.r, erh.i = z__1.i;
	    z__2.r = ddx * ezh.r, z__2.i = ddx * ezh.i;
	    z__3.r = rhx * erh.r, z__3.i = rhx * erh.i;
	    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	    cx.r = z__1.r, cx.i = z__1.i;
	    z__2.r = ddy * ezh.r, z__2.i = ddy * ezh.i;
	    z__3.r = rhy * erh.r, z__3.i = rhy * erh.i;
	    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	    cy.r = z__1.r, cy.i = z__1.i;
	    z__2.r = ddz * ezh.r, z__2.i = ddz * ezh.i;
	    z__3.r = rhz * erh.r, z__3.i = rhz * erh.i;
	    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	    cz.r = z__1.r, cz.i = z__1.i;
	    i__2 = i__;
	    i__3 = i__;
	    i__4 = i__ - 1;
	    z__4.r = cab[i__4] * cx.r, z__4.i = cab[i__4] * cx.i;
	    i__5 = i__ - 1;
	    z__5.r = sab[i__5] * cy.r, z__5.i = sab[i__5] * cy.i;
	    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	    i__6 = i__ - 1;
	    z__6.r = data_1.salp[i__6] * cz.r, z__6.i = data_1.salp[i__6] * 
		    cz.i;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	} else {

/*     H FIELD ON PATCHES */

	    rx = ddy * rhz - ddz * rhy;
	    ry = ddz * rhx - ddx * rhz;
	    rz = ddx * rhy - ddy * rhx;
	    z__4.r = dsh * arg.r, z__4.i = dsh * arg.i;
	    d__1 = 1.f / rs;
	    z__7.r = fj.r * gnd_1.xku.r - fj.i * gnd_1.xku.i, z__7.i = fj.r * 
		    gnd_1.xku.i + fj.i * gnd_1.xku.r;
	    z__6.r = z__7.r / r__, z__6.i = z__7.i / r__;
	    z__5.r = d__1 + z__6.r, z__5.i = z__6.i;
	    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * 
		    z__5.i + z__4.i * z__5.r;
	    z__2.r = sth * z__3.r, z__2.i = sth * z__3.i;
	    i__2 = ii - 1;
	    z__1.r = data_1.salp[i__2] * z__2.r, z__1.i = data_1.salp[i__2] * 
		    z__2.i;
	    tt1.r = z__1.r, tt1.i = z__1.i;
	    z__1.r = rx * tt1.r, z__1.i = rx * tt1.i;
	    cx.r = z__1.r, cx.i = z__1.i;
	    z__1.r = ry * tt1.r, z__1.i = ry * tt1.i;
	    cy.r = z__1.r, cy.i = z__1.i;
	    z__1.r = rz * tt1.r, z__1.i = rz * tt1.i;
	    cz.r = z__1.r, cz.i = z__1.i;
	    i__2 = i2;
	    i__3 = i2;
	    i__4 = ii - 1;
	    z__4.r = t1x[i__4] * cx.r, z__4.i = t1x[i__4] * cx.i;
	    z__3.r = e[i__3].r + z__4.r, z__3.i = e[i__3].i + z__4.i;
	    i__5 = ii - 1;
	    z__5.r = t1y[i__5] * cy.r, z__5.i = t1y[i__5] * cy.i;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__6 = ii - 1;
	    z__6.r = t1z[i__6] * cz.r, z__6.i = t1z[i__6] * cz.i;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    i__2 = i1;
	    i__3 = i1;
	    i__4 = ii - 1;
	    z__4.r = data_1.t2x[i__4] * cx.r, z__4.i = data_1.t2x[i__4] * 
		    cx.i;
	    z__3.r = e[i__3].r + z__4.r, z__3.i = e[i__3].i + z__4.i;
	    i__5 = ii - 1;
	    z__5.r = data_1.t2y[i__5] * cy.r, z__5.i = data_1.t2y[i__5] * 
		    cy.i;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__6 = ii - 1;
	    z__6.r = data_1.t2z[i__6] * cz.r, z__6.i = data_1.t2z[i__6] * 
		    cz.i;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	}
L27:
	;
    }
    return 0;

/*     E FIELD OF A POINT SOURCE NEAR AN INTERFACE (SOMMERFELD) */

/*     ****** NOTE: MAGNETIC FIELD FOR PATCHES IS NOT IMPLEMENTED. ****** */
/*     DO NOT USE HERTZIAN DIPOLE SOURCE WITH PATCHES AND GROUND */

L28:
    incom_1.segl = 1.f;
    incom_1.xsj = *xs;
    incom_1.ysj = *ys;
    incom_1.zsj = *zs;
    incom_1.dirx = ddx;
    incom_1.diry = ddy;
    incom_1.dirz = ddz;
    incom_1.sn = sqrt(incom_1.dirx * incom_1.dirx + incom_1.diry * 
	    incom_1.diry);
    if (incom_1.sn > 1e-5f) {
	incom_1.xsn = incom_1.dirx / incom_1.sn;
	incom_1.ysn = incom_1.diry / incom_1.sn;
    } else {
	incom_1.sn = 0.f;
	incom_1.xsn = 0.f;
	incom_1.ysn = 0.f;
    }
    incom_1.xkseg.r = gnd_1.xku.r, incom_1.xkseg.i = gnd_1.xku.i;
    incom_1.isnor = 2;
    incom_1.ireg = 0;
    incom_1.idirx = 0;
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	incom_1.xo = data_1.x[i__ - 1];
	incom_1.yo = data_1.y[i__ - 1];
	incom_1.zo = data_1.z__[i__ - 1];
	sflds_(&c_b332, egnd);
/* L31: */
	i__2 = i__;
	i__3 = i__;
	i__4 = i__ - 1;
	z__5.r = cab[i__4] * egnd[0].r, z__5.i = cab[i__4] * egnd[0].i;
	i__5 = i__ - 1;
	z__6.r = sab[i__5] * egnd[1].r, z__6.i = sab[i__5] * egnd[1].i;
	z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	i__6 = i__ - 1;
	z__7.r = data_1.salp[i__6] * egnd[2].r, z__7.i = data_1.salp[i__6] * 
		egnd[2].i;
	z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	z__2.r = *dipmom * z__3.r, z__2.i = *dipmom * z__3.i;
	z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	e[i__2].r = z__1.r, e[i__2].i = z__1.i;
    }
    return 0;
} /* sorhtz_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int sorvqd_(integer *iseg, doublecomplex *volts, 
	doublecomplex *e)
{
    /* Initialized data */

    static doublecomplex ccj = {0.,-.01666666667};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    double log(doublereal);
    void z_cos(doublecomplex *, doublecomplex *), z_sin(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static integer i__, j, i1, ij;
    static doublereal xi;
    static integer jx;
    static doublereal yi, zi, tx, ty, tz;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex etc;
    extern /* Subroutine */ int tbf_(integer *, integer *);
    static doublecomplex etk, ets;
    static doublereal cabi;
    extern /* Subroutine */ int efld_(doublereal *, doublereal *, doublereal *
	    );
    static doublereal sabi;
    static doublecomplex curd, cfcon;
    extern /* Subroutine */ int hsfld_(doublereal *, doublereal *, doublereal 
	    *);
    static doublereal salpi;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SORVQD increments the excitation array E by the field of a charge */
/*     discontinuity (bicone) source. */

/*     DISCRIPTION: */
/*     THE BICONE SOURCE IS LOCATED ON END ONE OF SEGMENT ISEG.  A BASIS */
/*     FUNCTION FOR SEGMENT ISEG IS COMPUTED AS IF END ONE OF SEGMENT */
/*     ISEG WERE A FREE END.  ICON1(ISEG) IS TEMPORARILY SET TO ZERO FOR */
/*     THIS PURPOSE.  THE AMPLITUDE OF THIS BASIS FUNCTION TO PRODUCE THE */
/*     REQUIRED CHARGE DISCONTINUITY IS COMPUTED IN CURD.  SUBROUTINE */
/*     EFLD IS THEN CALLED TO COMPUTE THE E FIELD THAT THIS BASIS */
/*     FUNCTION PRODUCES ON EACH SEGMENT AND HSFLD TO COMPUTE THE H FIELD */
/*     ON PATCHES */

/*     INPUT: */
/*     ISEG = SOURCE SEGMENT NUMBER.  SOURCE IS ON END ONE OF SEGMENT */
/*            NUMBER ISEG. */
/*     VOLTS = SOURCE VOLTAGE (VOLTS) */

/*     OUTPUT: */
/*     E = EXCITATION ARRAY INCREMENTED BY THE SOURCE FIELD */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    i__ = data_1.icon1[(106480 + (0 + (*iseg - 1 << 2)) - 106480) / 4];
    data_1.icon1[*iseg - 1] = 0;
    tbf_(iseg, &c__0);
    data_1.icon1[*iseg - 1] = i__;
    dataj_1.slenj = data_1.si[*iseg - 1] * .5f;
    i__1 = *iseg - 1;
    dataj_1.xksj.r = crnt_1.xks[i__1].r, dataj_1.xksj.i = crnt_1.xks[i__1].i;
    z__2.r = ccj.r * volts->r - ccj.i * volts->i, z__2.i = ccj.r * volts->i + 
	    ccj.i * volts->r;
    d__1 = log(dataj_1.slenj * 2.f / data_1.bi[*iseg - 1]) - 1.f;
    i__1 = segj_1.jsno - 1;
    z__7.r = dataj_1.slenj * dataj_1.xksj.r, z__7.i = dataj_1.slenj * 
	    dataj_1.xksj.i;
    z_cos(&z__6, &z__7);
    z__5.r = segj_1.bx[i__1].r * z__6.r - segj_1.bx[i__1].i * z__6.i, z__5.i =
	     segj_1.bx[i__1].r * z__6.i + segj_1.bx[i__1].i * z__6.r;
    i__2 = segj_1.jsno - 1;
    z__10.r = dataj_1.slenj * dataj_1.xksj.r, z__10.i = dataj_1.slenj * 
	    dataj_1.xksj.i;
    z_sin(&z__9, &z__10);
    z__8.r = segj_1.cx[i__2].r * z__9.r - segj_1.cx[i__2].i * z__9.i, z__8.i =
	     segj_1.cx[i__2].r * z__9.i + segj_1.cx[i__2].i * z__9.r;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
    z_div(&z__1, &z__2, &z__3);
    curd.r = z__1.r, curd.i = z__1.i;

/*     LOOP OVER SEGMENTS ONTO WHICH THE BASIS FUNCTION EXTENDS */

    i__1 = segj_1.jsno;
    for (jx = 1; jx <= i__1; ++jx) {
	j = segj_1.jco[jx - 1];
	dataj_1.slenj = data_1.si[j - 1];
	dataj_1.aradj = data_1.bi[j - 1];
	dataj_1.xj = data_1.x[j - 1];
	dataj_1.yj = data_1.y[j - 1];
	dataj_1.zj = data_1.z__[j - 1];
	dataj_1.dxj = cab[j - 1];
	dataj_1.dyj = sab[j - 1];
	dataj_1.dzj = data_1.salp[j - 1];
	i__2 = j - 1;
	dataj_1.xksj.r = crnt_1.xks[i__2].r, dataj_1.xksj.i = crnt_1.xks[i__2]
		.i;
	i__2 = j - 1;
	dataj_1.zpeds.r = zload_1.zarray[i__2].r, dataj_1.zpeds.i = 
		zload_1.zarray[i__2].i;

/*     COMPUTE E FIELD ON SEGMENTS DUE TO THE MODIFIED BASIS FUNCTION */

	dataj_1.ind1 = data_1.icon1[j - 1];
	dataj_1.ind2 = data_1.icon2[j - 1];
	if (jnqcom_1.ipqend[j - 1] == 1 || jnqcom_1.ipqend[j - 1] == 3) {
	    dataj_1.ind1 = 60000;
	}
	if (jnqcom_1.ipqend[j - 1] > 1) {
	    dataj_1.ind2 = 60000;
	}
	i__2 = data_1.n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    xi = data_1.x[i__ - 1];
	    yi = data_1.y[i__ - 1];
	    zi = data_1.z__[i__ - 1];
	    efld_(&xi, &yi, &zi);
	    cabi = cab[i__ - 1];
	    sabi = sab[i__ - 1];
	    salpi = data_1.salp[i__ - 1];
	    z__3.r = cabi * dataj_1.exk.r, z__3.i = cabi * dataj_1.exk.i;
	    z__4.r = sabi * dataj_1.eyk.r, z__4.i = sabi * dataj_1.eyk.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = salpi * dataj_1.ezk.r, z__5.i = salpi * dataj_1.ezk.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etk.r = z__1.r, etk.i = z__1.i;
	    z__3.r = cabi * dataj_1.exs.r, z__3.i = cabi * dataj_1.exs.i;
	    z__4.r = sabi * dataj_1.eys.r, z__4.i = sabi * dataj_1.eys.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = salpi * dataj_1.ezs.r, z__5.i = salpi * dataj_1.ezs.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    ets.r = z__1.r, ets.i = z__1.i;
	    z__3.r = cabi * dataj_1.exc.r, z__3.i = cabi * dataj_1.exc.i;
	    z__4.r = sabi * dataj_1.eyc.r, z__4.i = sabi * dataj_1.eyc.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = salpi * dataj_1.ezc.r, z__5.i = salpi * dataj_1.ezc.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etc.r = z__1.r, etc.i = z__1.i;
/* L17: */
	    i__3 = i__;
	    i__4 = i__;
	    i__5 = jx - 1;
	    z__5.r = etk.r * segj_1.ax[i__5].r - etk.i * segj_1.ax[i__5].i, 
		    z__5.i = etk.r * segj_1.ax[i__5].i + etk.i * segj_1.ax[
		    i__5].r;
	    i__6 = jx - 1;
	    z__6.r = ets.r * segj_1.bx[i__6].r - ets.i * segj_1.bx[i__6].i, 
		    z__6.i = ets.r * segj_1.bx[i__6].i + ets.i * segj_1.bx[
		    i__6].r;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__7 = jx - 1;
	    z__7.r = etc.r * segj_1.cx[i__7].r - etc.i * segj_1.cx[i__7].i, 
		    z__7.i = etc.r * segj_1.cx[i__7].i + etc.i * segj_1.cx[
		    i__7].r;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * curd.r - z__3.i * curd.i, z__2.i = z__3.r * 
		    curd.i + z__3.i * curd.r;
	    z__1.r = e[i__4].r - z__2.r, z__1.i = e[i__4].i - z__2.i;
	    e[i__3].r = z__1.r, e[i__3].i = z__1.i;
	}
	if (data_1.m == 0) {
	    goto L19;
	}
	ij = data_1.ld + 1;
	i1 = data_1.n;

/*     COMPUTE H FIELD ON PATCHES DUE TO THE MODIFIED BASIS FUNCTION */

	i__3 = data_1.m;
	for (i__ = 1; i__ <= i__3; ++i__) {
	    --ij;
	    xi = data_1.x[ij - 1];
	    yi = data_1.y[ij - 1];
	    zi = data_1.z__[ij - 1];
	    hsfld_(&xi, &yi, &zi);
	    ++i1;
	    tx = data_1.t2x[ij - 1];
	    ty = data_1.t2y[ij - 1];
	    tz = data_1.t2z[ij - 1];
	    z__3.r = tx * dataj_1.exk.r, z__3.i = tx * dataj_1.exk.i;
	    z__4.r = ty * dataj_1.eyk.r, z__4.i = ty * dataj_1.eyk.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezk.r, z__5.i = tz * dataj_1.ezk.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etk.r = z__1.r, etk.i = z__1.i;
	    z__3.r = tx * dataj_1.exs.r, z__3.i = tx * dataj_1.exs.i;
	    z__4.r = ty * dataj_1.eys.r, z__4.i = ty * dataj_1.eys.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezs.r, z__5.i = tz * dataj_1.ezs.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    ets.r = z__1.r, ets.i = z__1.i;
	    z__3.r = tx * dataj_1.exc.r, z__3.i = tx * dataj_1.exc.i;
	    z__4.r = ty * dataj_1.eyc.r, z__4.i = ty * dataj_1.eyc.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezc.r, z__5.i = tz * dataj_1.ezc.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etc.r = z__1.r, etc.i = z__1.i;
	    i__4 = i1;
	    i__5 = i1;
	    i__6 = jx - 1;
	    z__6.r = etk.r * segj_1.ax[i__6].r - etk.i * segj_1.ax[i__6].i, 
		    z__6.i = etk.r * segj_1.ax[i__6].i + etk.i * segj_1.ax[
		    i__6].r;
	    i__7 = jx - 1;
	    z__7.r = ets.r * segj_1.bx[i__7].r - ets.i * segj_1.bx[i__7].i, 
		    z__7.i = ets.r * segj_1.bx[i__7].i + ets.i * segj_1.bx[
		    i__7].r;
	    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	    i__2 = jx - 1;
	    z__8.r = etc.r * segj_1.cx[i__2].r - etc.i * segj_1.cx[i__2].i, 
		    z__8.i = etc.r * segj_1.cx[i__2].i + etc.i * segj_1.cx[
		    i__2].r;
	    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	    z__3.r = z__4.r * curd.r - z__4.i * curd.i, z__3.i = z__4.r * 
		    curd.i + z__4.i * curd.r;
	    i__8 = ij - 1;
	    z__2.r = data_1.salp[i__8] * z__3.r, z__2.i = data_1.salp[i__8] * 
		    z__3.i;
	    z__1.r = e[i__5].r + z__2.r, z__1.i = e[i__5].i + z__2.i;
	    e[i__4].r = z__1.r, e[i__4].i = z__1.i;
	    ++i1;
	    tx = t1x[ij - 1];
	    ty = t1y[ij - 1];
	    tz = t1z[ij - 1];
	    z__3.r = tx * dataj_1.exk.r, z__3.i = tx * dataj_1.exk.i;
	    z__4.r = ty * dataj_1.eyk.r, z__4.i = ty * dataj_1.eyk.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezk.r, z__5.i = tz * dataj_1.ezk.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etk.r = z__1.r, etk.i = z__1.i;
	    z__3.r = tx * dataj_1.exs.r, z__3.i = tx * dataj_1.exs.i;
	    z__4.r = ty * dataj_1.eys.r, z__4.i = ty * dataj_1.eys.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezs.r, z__5.i = tz * dataj_1.ezs.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    ets.r = z__1.r, ets.i = z__1.i;
	    z__3.r = tx * dataj_1.exc.r, z__3.i = tx * dataj_1.exc.i;
	    z__4.r = ty * dataj_1.eyc.r, z__4.i = ty * dataj_1.eyc.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = tz * dataj_1.ezc.r, z__5.i = tz * dataj_1.ezc.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    etc.r = z__1.r, etc.i = z__1.i;
/* L18: */
	    i__4 = i1;
	    i__5 = i1;
	    i__6 = jx - 1;
	    z__6.r = etk.r * segj_1.ax[i__6].r - etk.i * segj_1.ax[i__6].i, 
		    z__6.i = etk.r * segj_1.ax[i__6].i + etk.i * segj_1.ax[
		    i__6].r;
	    i__7 = jx - 1;
	    z__7.r = ets.r * segj_1.bx[i__7].r - ets.i * segj_1.bx[i__7].i, 
		    z__7.i = ets.r * segj_1.bx[i__7].i + ets.i * segj_1.bx[
		    i__7].r;
	    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	    i__2 = jx - 1;
	    z__8.r = etc.r * segj_1.cx[i__2].r - etc.i * segj_1.cx[i__2].i, 
		    z__8.i = etc.r * segj_1.cx[i__2].i + etc.i * segj_1.cx[
		    i__2].r;
	    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	    z__3.r = z__4.r * curd.r - z__4.i * curd.i, z__3.i = z__4.r * 
		    curd.i + z__4.i * curd.r;
	    i__8 = ij - 1;
	    z__2.r = data_1.salp[i__8] * z__3.r, z__2.i = data_1.salp[i__8] * 
		    z__3.i;
	    z__1.r = e[i__5].r + z__2.r, z__1.i = e[i__5].i + z__2.i;
	    e[i__4].r = z__1.r, e[i__4].i = z__1.i;
	}

/*     ADD E FIELD DUE TO LOADING (Z*I VOLTAGE) */

L19:
	if (zload_1.nload > 0 || zload_1.nlodf > 0) {
	    i__4 = j;
	    i__5 = j;
	    i__6 = j - 1;
	    z__4.r = zload_1.zarray[i__6].r * curd.r - zload_1.zarray[i__6].i 
		    * curd.i, z__4.i = zload_1.zarray[i__6].r * curd.i + 
		    zload_1.zarray[i__6].i * curd.r;
	    i__7 = jx - 1;
	    z__3.r = z__4.r * segj_1.ax[i__7].r - z__4.i * segj_1.ax[i__7].i, 
		    z__3.i = z__4.r * segj_1.ax[i__7].i + z__4.i * segj_1.ax[
		    i__7].r;
	    z__2.r = z__3.r * gnd_1.xku.r - z__3.i * gnd_1.xku.i, z__2.i = 
		    z__3.r * gnd_1.xku.i + z__3.i * gnd_1.xku.r;
	    z__1.r = e[i__5].r + z__2.r, z__1.i = e[i__5].i + z__2.i;
	    e[i__4].r = z__1.r, e[i__4].i = z__1.i;
	}
	if (inscom_1.nins != 0 || inscom_1.ninsf != 0) {
	    if (inscom_1.brins[j - 1] > 0.f) {
		if (data_1.z__[j - 1] >= 0.f) {
		    i__4 = j - 1;
		    z__3.r = inscom_1.ceins[i__4].r - gnd_1.cepsu.r, z__3.i = 
			    inscom_1.ceins[i__4].i - gnd_1.cepsu.i;
		    z__2.r = gnd_1.etau.r * z__3.r - gnd_1.etau.i * z__3.i, 
			    z__2.i = gnd_1.etau.r * z__3.i + gnd_1.etau.i * 
			    z__3.r;
		    z_div(&z__1, &z__2, &gnd_1.xku);
		    cfcon.r = z__1.r, cfcon.i = z__1.i;
		}
		if (data_1.z__[j - 1] < 0.f) {
		    i__4 = j - 1;
		    z__3.r = inscom_1.ceins[i__4].r - gnd_1.cepsl.r, z__3.i = 
			    inscom_1.ceins[i__4].i - gnd_1.cepsl.i;
		    z__2.r = gnd_1.etal.r * z__3.r - gnd_1.etal.i * z__3.i, 
			    z__2.i = gnd_1.etal.r * z__3.i + gnd_1.etal.i * 
			    z__3.r;
		    z_div(&z__1, &z__2, &gnd_1.xkl);
		    cfcon.r = z__1.r, cfcon.i = z__1.i;
		}
		z__3.r = cfcon.r * 0.f - cfcon.i * 1.f, z__3.i = cfcon.r * 
			1.f + cfcon.i * 0.f;
		d__1 = log(inscom_1.brins[j - 1] / data_1.bi[j - 1]);
		z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
		i__4 = j - 1;
		z__4.r = constn_1.tp * inscom_1.ceins[i__4].r, z__4.i = 
			constn_1.tp * inscom_1.ceins[i__4].i;
		z_div(&z__1, &z__2, &z__4);
		cfcon.r = z__1.r, cfcon.i = z__1.i;
		i__4 = j;
		i__5 = j;
		i__6 = jx - 1;
		z__2.r = cfcon.r * segj_1.cx[i__6].r - cfcon.i * segj_1.cx[
			i__6].i, z__2.i = cfcon.r * segj_1.cx[i__6].i + 
			cfcon.i * segj_1.cx[i__6].r;
		z__1.r = e[i__5].r + z__2.r, z__1.i = e[i__5].i + z__2.i;
		e[i__4].r = z__1.r, e[i__4].i = z__1.i;
	    }
	}
/* L20: */
    }
    return 0;
} /* sorvqd_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int zysurf_(doublereal *cth, doublereal *xs, doublereal *ys, 
	doublereal *side, integer *iperfg, doublecomplex *yste, doublecomplex 
	*zstm)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), pow_zi(
	    doublecomplex *, doublecomplex *, integer *), z_sqrt(
	    doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *), sqrt(doublereal), log(doublereal), z_abs(
	    doublecomplex *);

    /* Local variables */
    static doublecomplex eta, cthm, etax, yscrn, zscrn;
    static doublereal rhoscn;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ZYSURF computes the surface admittance and impedance of the */
/*     ground plane at coordinates XS,YS. */

/*     DESCRIPTION: */
/*     THE SURFACE ADMITTANCE AND IMPEDANCE ARE COMPUTED FOR THE GIVEN */
/*     INCIDENCE ANGLE OF THE RAY AND THE INTRINSIC IMPEDANCE OF THE */
/*     UPPER AND LOWER MEDIA.  IF THE CLIFF OPTION IS IN USE AND THE */
/*     REFLECTION POINT IS BEYOND THE EDGE OF THE CLIFF THEN THE */
/*     INTRINSIC IMPEDANCE OF THE OUTER MEDIUM (ETAL2) IS USED.  IF THE */
/*     RADIAL WIRE GROUND SCREEN OPTION IS IN USE THEN THE SURFACE */
/*     ADMITTANCE OF THE SCREEN (TM ONLY AT THIS TIME) IS ADDED IN */
/*     PARALLEL WITH THAT OF THE GROUND. */

/*     INPUT: */
/*     CTH = COSINE OF THE ANGLE BETWEEN THE INCIDENT RAY AND THE NORMAL */
/*     XS,YS = X AND Y COORDINATES OF THE REFLECTION POINT ON THE X-Y */
/*             PLANE */
/*     SIDE = 1 IF THE RAY IS INCIDENT FROM ABOVE THE INTERFACE */
/*            -1 IF THE RAY IS INCIDENT FROM BELOW THE INTERFACE */
/*            0 IF THERE IS NO INTERFACE */
/*     OTHER INPUT FROM COMMON/GND/ */

/*     OUTPUT: */
/*     IPERFG = 1 IF REFLECTION POINT IS ON A PERFECTLY CONDUCING */
/*              GROUND, = 0 OTHERWISE. */
/*     YSTE = SURFACE ADMITTANCE FOR A TE POLARIZED FIELD */
/*     ZSTM = SURFACE IMPEDANCE FOR A TM POLARIZED FIELD */

    *iperfg = gnd_1.iperf;
    if (gnd_1.iperf == 1) {

/*     PERFECTLY CONDUCTING GROUND UNLESS (XS,YS) IS ON SECOND MEDIUM. */

	if (*side < 0.f) {
	    return 0;
	}
	if (gnd_1.iclift == 1 && *xs > gnd_1.clifl) {
	    *iperfg = 0;
	}
/* Computing 2nd power */
	d__1 = gnd_1.clifl;
	if (gnd_1.iclift == 2 && *xs * *xs + *ys * *ys > d__1 * d__1) {
	    *iperfg = 0;
	}
	if (*iperfg == 1) {
	    return 0;
	}
    }

/*     ETA = INTRINSIC IMPEDANCE OF MEDIUM IN WHICH RAY IS PROPAGATING */
/*     ETAX = INTRINSIC IMPEDANCE ON OTHER SIDE OF INTERFACE (GROUND) */

    if (*side <= 0.f) {
	eta.r = gnd_1.etal.r, eta.i = gnd_1.etal.i;
	etax.r = gnd_1.etau.r, etax.i = gnd_1.etau.i;
    } else {
	eta.r = gnd_1.etau.r, eta.i = gnd_1.etau.i;
	etax.r = gnd_1.etal.r, etax.i = gnd_1.etal.i;
	if (gnd_1.iclift != 0) {

/*     RESET ETAX IF REFLECTION POINT IS ON OUTER MEDIUM BEYOND CLIFF. */

	    if (gnd_1.iclift == 1 && *xs > gnd_1.clifl) {
		etax.r = gnd_1.etal2.r, etax.i = gnd_1.etal2.i;
	    }
/* Computing 2nd power */
	    d__1 = gnd_1.clifl;
	    if (gnd_1.iclift == 2 && *xs * *xs + *ys * *ys > d__1 * d__1) {
		etax.r = gnd_1.etal2.r, etax.i = gnd_1.etal2.i;
	    }
	}
    }

/*     COMPUTE SURFACE IMPEDANCE AND ADMITTANCE OF GROUND */

    z_div(&z__5, &etax, &eta);
    pow_zi(&z__4, &z__5, &c__2);
    d__1 = 1.f - *cth * *cth;
    z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
    z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
    z_sqrt(&z__1, &z__2);
    cthm.r = z__1.r, cthm.i = z__1.i;
    if (*cth < 0.f) {
	z__1.r = -cthm.r, z__1.i = -cthm.i;
	cthm.r = z__1.r, cthm.i = z__1.i;
    }
    if ((d__2 = cthm.r, abs(d__2)) < (d__1 = d_imag(&cthm), abs(d__1)) * 
	    1e-6f) {
	if (*cth * d_imag(&cthm) >= 0.f) {
	    z__1.r = -cthm.r, z__1.i = -cthm.i;
	    cthm.r = z__1.r, cthm.i = z__1.i;
	}
    }
    z_div(&z__1, &cthm, &etax);
    yste->r = z__1.r, yste->i = z__1.i;
    z__1.r = cthm.r * etax.r - cthm.i * etax.i, z__1.i = cthm.r * etax.i + 
	    cthm.i * etax.r;
    zstm->r = z__1.r, zstm->i = z__1.i;
    if (*side < 0.f || gnd_1.nradl == 0) {
	return 0;
    }

/*     ADD SURFACE IMPEDANCE OF RADIAL-WIRE GROUND SCREEN IN PARALLEL */
/*     WITH THAT OF THE GROUND */

/* Computing 2nd power */
    d__1 = gnd_1.scnwrd * gnd_1.nradl;
    rhoscn = sqrt(*xs * *xs + *ys * *ys + d__1 * d__1);
    if (rhoscn > gnd_1.scnrad) {
	return 0;
    }
    z__5.r = constn_1.rmuz * 0.f, z__5.i = constn_1.rmuz * 1.f;
    z__4.r = gnd_1.omegag * z__5.r, z__4.i = gnd_1.omegag * z__5.i;
    z__3.r = rhoscn * z__4.r, z__3.i = rhoscn * z__4.i;
    d__1 = (doublereal) gnd_1.nradl;
    z__2.r = z__3.r / d__1, z__2.i = z__3.i / d__1;
    d__2 = log(rhoscn / (gnd_1.scnwrd * gnd_1.nradl));
    z__1.r = d__2 * z__2.r, z__1.i = d__2 * z__2.i;
    zscrn.r = z__1.r, zscrn.i = z__1.i;
    if (z_abs(&zscrn) > 0.f) {
	z_div(&z__1, &c_b336, &zscrn);
	yscrn.r = z__1.r, yscrn.i = z__1.i;
    } else {
	yscrn.r = 1e15f, yscrn.i = 0.f;
    }
    z__2.r = zstm->r * zscrn.r - zstm->i * zscrn.i, z__2.i = zstm->r * 
	    zscrn.i + zstm->i * zscrn.r;
    z__3.r = zstm->r + zscrn.r, z__3.i = zstm->i + zscrn.i;
    z_div(&z__1, &z__2, &z__3);
    zstm->r = z__1.r, zstm->i = z__1.i;
    z__1.r = yste->r + yscrn.r, z__1.i = yste->i + yscrn.i;
    yste->r = z__1.r, yste->i = z__1.i;
    return 0;
} /* zysurf_ */

/* Subroutine */ int refcof_(doublereal *cth, doublereal *vnorx, doublereal *
	vnory, doublecomplex *eta, integer *iperfg, doublecomplex *yste, 
	doublecomplex *zstm, doublecomplex *ex, doublecomplex *ey, 
	doublecomplex *ez, doublecomplex *rx, doublecomplex *ry, 
	doublecomplex *rz)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex enor, yzte, zztm, refte, reftm;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     REFCOF computes the reflected electric field at the interface for */
/*     a given incident electric field. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     CTH = COSINE OF THE ANGLE BETWEEN THE INCIDENT RAY AND THE NORMAL */
/*     VNORX,VNORY = X AND Y COMPONENTS OF THE UNIT VECTOR NORMAL TO THE */
/*                   PLANE OF INCIDENCE OF THE INCIDENT RAY */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM IN WHICH THE RAY IS */
/*           PROPAGATING */
/*     IPERFG = 1 IF GROUND IS PERFECTLY CONDUCTING, 0 OTHERWISE */
/*     YSTE = SURFACE ADMITTANCE FOR TE POLARIZED FIELD */
/*     ZSTM = SUMFACE IMPEDANCE FOR TM POLARIZED FIELD */
/*     EX,EY,EZ = VECTOR COMPONENTS OF THE INCIDENT E FIELD */

/*     OUTPUT: */
/*     RX,RY,RZ = VECTOR COMPONENTS OF THE REFLECTED E FIELD */

    if (*iperfg == 1) {

/*     PERFECTLY CONDUCTING GROUND */

	z__1.r = -ex->r, z__1.i = -ex->i;
	rx->r = z__1.r, rx->i = z__1.i;
	z__1.r = -ey->r, z__1.i = -ey->i;
	ry->r = z__1.r, ry->i = z__1.i;
	rz->r = ez->r, rz->i = ez->i;
	return 0;
    }

/*     FINITELY CONDUCTING GROUND */

    z__2.r = *cth, z__2.i = 0.;
    z_div(&z__1, &z__2, eta);
    yzte.r = z__1.r, yzte.i = z__1.i;
    z__1.r = *cth * eta->r, z__1.i = *cth * eta->i;
    zztm.r = z__1.r, zztm.i = z__1.i;
    z__2.r = yzte.r - yste->r, z__2.i = yzte.i - yste->i;
    z__3.r = yzte.r + yste->r, z__3.i = yzte.i + yste->i;
    z_div(&z__1, &z__2, &z__3);
    refte.r = z__1.r, refte.i = z__1.i;
    z__3.r = zztm.r - zstm->r, z__3.i = zztm.i - zstm->i;
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__4.r = zztm.r + zstm->r, z__4.i = zztm.i + zstm->i;
    z_div(&z__1, &z__2, &z__4);
    reftm.r = z__1.r, reftm.i = z__1.i;
    z__3.r = *vnorx * ex->r, z__3.i = *vnorx * ex->i;
    z__4.r = *vnory * ey->r, z__4.i = *vnory * ey->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__5.r = refte.r - reftm.r, z__5.i = refte.i - reftm.i;
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    enor.r = z__1.r, enor.i = z__1.i;
    z__2.r = reftm.r * ex->r - reftm.i * ex->i, z__2.i = reftm.r * ex->i + 
	    reftm.i * ex->r;
    z__3.r = *vnorx * enor.r, z__3.i = *vnorx * enor.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    rx->r = z__1.r, rx->i = z__1.i;
    z__2.r = reftm.r * ey->r - reftm.i * ey->i, z__2.i = reftm.r * ey->i + 
	    reftm.i * ey->r;
    z__3.r = *vnory * enor.r, z__3.i = *vnory * enor.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ry->r = z__1.r, ry->i = z__1.i;
    z__2.r = -reftm.r, z__2.i = -reftm.i;
    z__1.r = z__2.r * ez->r - z__2.i * ez->i, z__1.i = z__2.r * ez->i + 
	    z__2.i * ez->r;
    rz->r = z__1.r, rz->i = z__1.i;
    return 0;
} /* refcof_ */

/* Subroutine */ int trxkno_(doublereal *cth, doublecomplex *xk, 
	doublecomplex *xkx, doublecomplex *ckzx)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TRXKNO computes the Z component of the wave propagation vector k */
/*     on the opposite side of the interface from an incident plane wave. */

/*     DESCRIPTION: */
/*     THE Z COMPONENT OF THE WAVE PRORAGATION VECTOR ON THE OPPOSITE */
/*     SIDE OF THE INTERFACE IS DETERMINED BY SNELL'S LAW.  THE SIGN OF */
/*     THE SQUARE ROOT IS CHOSEN FOR A WAVE PROPAGATING AWAY FROM THE */
/*     INTERFACE AND ATTENUATING. */

/*     INPUT: */
/*     CTH = COSINE OF THE ANGLE BETWEEN THE INCIDENT RAY AND THE NORMAL */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE INCIDENT RAY */
/*     XKX = WAVE NUMBER ON OPPOSITE SIDE OF THE INTERFACE */

/*     OUTPUT: */
/*     CKZX = Z COMPONENT OF WAVE PROPAGATION VECTOR K ON THE OPPOSITE */
/*            SIDE OF THE INTERFACE FROM THE INCIDENT RAY. */

    z__3.r = xkx->r * xkx->r - xkx->i * xkx->i, z__3.i = xkx->r * xkx->i + 
	    xkx->i * xkx->r;
    d__1 = 1.f - *cth * *cth;
    z__5.r = d__1 * xk->r, z__5.i = d__1 * xk->i;
    z__4.r = z__5.r * xk->r - z__5.i * xk->i, z__4.i = z__5.r * xk->i + 
	    z__5.i * xk->r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z_sqrt(&z__1, &z__2);
    ckzx->r = z__1.r, ckzx->i = z__1.i;
    if (*cth > 0.f) {
	z__1.r = -ckzx->r, z__1.i = -ckzx->i;
	ckzx->r = z__1.r, ckzx->i = z__1.i;
    }
    if (ckzx->r == 0.f && *cth * d_imag(ckzx) < 0.f) {
	z__1.r = -ckzx->r, z__1.i = -ckzx->i;
	ckzx->r = z__1.r, ckzx->i = z__1.i;
    }
    return 0;
} /* trxkno_ */

/* Subroutine */ int trxcof_(doublereal *vnorx, doublereal *vnory, 
	doublecomplex *ckz, doublecomplex *ckzx, doublecomplex *xk, 
	doublecomplex *xkx, doublecomplex *ex, doublecomplex *ey, 
	doublecomplex *ez, doublecomplex *tx, doublecomplex *ty, 
	doublecomplex *tz)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Builtin functions */
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex tpp, trr, tzz, ephi, erho;
    static doublereal vrhox, vrhoy;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TRXCOF computes the E field transmitted across an interface given */
/*     an incident plane-wave field at the interface. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     VNORX,VNORY = X AND Y COMPONENTS OF THE UNIT VECTOR NORMAL TO THE */
/*                   PLANE OF INCIDENCE OF THE INCIDENT RAY */
/*     CKZ = Z COMPONENT OF THE WAVE PROPAGATION VECTOR K OF THE INCIDENT */
/*           RAY */
/*     CKZX = Z COMPONENT OF THE PROPAGATION VECTOR K OF RAY AFTER */
/*            CROSSING THE INTERFACE */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE INCIDENT RAY */
/*     XKX = WAVE NUMBER ON OPPOSITE SIDE OF THE INTERFACE */
/*     EX,EY,EZ = VECTOR COMPONENTS OF THE INCIDENT E FIELD */

/*     OUTPUT: */
/*     TX,TY,TZ = VECTOR COMPONENTS OF THE E FIELD TRANSMITTED ACROSS THE */
/*                INTERFACE */

    if (d_imag(xk) != 0.f) {

/*     WAVE INCIDENT FROM LOSSY MEDIUM IS ZERO */

	tx->r = 0.f, tx->i = 0.f;
	ty->r = 0.f, ty->i = 0.f;
	tz->r = 0.f, tz->i = 0.f;
	return 0;
    }
    z__3.r = xk->r * 2.f, z__3.i = xk->i * 2.f;
    z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
	    z__3.i * xk->r;
    z__6.r = xkx->r * xkx->r - xkx->i * xkx->i, z__6.i = xkx->r * xkx->i + 
	    xkx->i * xkx->r;
    z__5.r = z__6.r * ckz->r - z__6.i * ckz->i, z__5.i = z__6.r * ckz->i + 
	    z__6.i * ckz->r;
    z__8.r = xk->r * xk->r - xk->i * xk->i, z__8.i = xk->r * xk->i + xk->i * 
	    xk->r;
    z__7.r = z__8.r * ckzx->r - z__8.i * ckzx->i, z__7.i = z__8.r * ckzx->i + 
	    z__8.i * ckzx->r;
    z__4.r = z__5.r + z__7.r, z__4.i = z__5.i + z__7.i;
    z_div(&z__1, &z__2, &z__4);
    tzz.r = z__1.r, tzz.i = z__1.i;
    z__1.r = tzz.r * ckzx->r - tzz.i * ckzx->i, z__1.i = tzz.r * ckzx->i + 
	    tzz.i * ckzx->r;
    trr.r = z__1.r, trr.i = z__1.i;
    z__2.r = ckz->r * 2.f, z__2.i = ckz->i * 2.f;
    z__3.r = ckz->r + ckzx->r, z__3.i = ckz->i + ckzx->i;
    z_div(&z__1, &z__2, &z__3);
    tpp.r = z__1.r, tpp.i = z__1.i;
    z__1.r = tzz.r * ckz->r - tzz.i * ckz->i, z__1.i = tzz.r * ckz->i + tzz.i 
	    * ckz->r;
    tzz.r = z__1.r, tzz.i = z__1.i;
    vrhox = *vnory;
    vrhoy = -(*vnorx);
    z__3.r = vrhox * ex->r, z__3.i = vrhox * ex->i;
    z__4.r = vrhoy * ey->r, z__4.i = vrhoy * ey->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * trr.r - z__2.i * trr.i, z__1.i = z__2.r * trr.i + 
	    z__2.i * trr.r;
    erho.r = z__1.r, erho.i = z__1.i;
    z__3.r = *vnorx * ex->r, z__3.i = *vnorx * ex->i;
    z__4.r = *vnory * ey->r, z__4.i = *vnory * ey->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * tpp.r - z__2.i * tpp.i, z__1.i = z__2.r * tpp.i + 
	    z__2.i * tpp.r;
    ephi.r = z__1.r, ephi.i = z__1.i;
    z__2.r = vrhox * erho.r, z__2.i = vrhox * erho.i;
    z__3.r = *vnorx * ephi.r, z__3.i = *vnorx * ephi.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    tx->r = z__1.r, tx->i = z__1.i;
    z__2.r = vrhoy * erho.r, z__2.i = vrhoy * erho.i;
    z__3.r = *vnory * ephi.r, z__3.i = *vnory * ephi.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ty->r = z__1.r, ty->i = z__1.i;
    z__1.r = tzz.r * ez->r - tzz.i * ez->i, z__1.i = tzz.r * ez->i + tzz.i * 
	    ez->r;
    tz->r = z__1.r, tz->i = z__1.i;
    return 0;
} /* trxcof_ */

/* Subroutine */ int refpt1_(doublereal *dx, doublereal *dy, doublereal *dz, 
	doublereal *xp, doublereal *yp, doublereal *zp, doublereal *xs, 
	doublereal *ys, doublereal *zs)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    extern /* Subroutine */ int refpt_(doublereal *, doublereal *, doublereal 
	    *, doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     REFPT1 computes the specular reflection point (XS,YS,ZS) for a ray */
/*     with direction (DX,DY,DZ) incident on the two-level ground plane */
/*     defined in COMMON/GND/ and passing through the point (XP,YP,ZP). */

/*     DESCRIPTION: */
/*     SUBROUTINE REFPT IS CALLED TO GET THE SPECULAR REFLECTION POINT */
/*     ON A GIVEN HORIZONTAL PLANE.  IF THE TWO-MEDIUM GROUND OPTION IS */
/*     IN USE, THE CLIFF LOCATION AND HEIGHT IS CHECKED TO DETERMINE */
/*     WHICH MEDIUM THE RAY REFLECTS FROM. */

/*     INPUT: */
/*     DX,DY,DZ = X, Y AND Z COMPONENTS OF THE UNIT VECTOR IN THE */
/*                DIRECTION OF PROPAGATION OF THE RADIATED FIELD (RAY */
/*                FROM (XP,YP,ZP) AFTER REFLECTION) */
/*     XP,YP,ZP = X, Y AND Z COORDINATES OF THE POINT REPRESENTING THE */
/*                SOURCE OF THE RAY */

/*     OUTPUT: */
/*     XS,YS,ZS = X, Y AND Z COORDINATES OF THE REFLECTION POINT ON THE */
/*                INTERFACE.  ZS WILL BE ZERO UNLESS THE RAY REFLECTS ON */
/*                THE SECOND MEDIUM, BEYOND A "CLIFF". */

    refpt_(&c_b332, dx, dy, dz, xp, yp, zp, xs, ys, zs);
    if (gnd_1.iclift == 0) {
	goto L1;
    }
    if (gnd_1.iclift == 1 && *xs < gnd_1.clifl) {
	goto L1;
    }
/* Computing 2nd power */
    d__1 = gnd_1.clifl;
    if (gnd_1.iclift == 2 && *xs * *xs + *ys * *ys < d__1 * d__1) {
	goto L1;
    }
    d__1 = -gnd_1.clifh;
    refpt_(&d__1, dx, dy, dz, xp, yp, zp, xs, ys, zs);
L1:
    return 0;
} /* refpt1_ */

/* Subroutine */ int refpt_(doublereal *zgnd, doublereal *dx, doublereal *dy, 
	doublereal *dz, doublereal *xp, doublereal *yp, doublereal *zp, 
	doublereal *xs, doublereal *ys, doublereal *zs)
{
    static doublereal aa;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     REFPT computes the specular reflection point (XS,YS,ZS) for a ray */
/*     with direction (DX,DY,DZ) incident on a horizontal plane at height */
/*     ZGND and passing through the point (XP,YP,ZP). */

/*     DESCRIPTION: */


/*     INPUT: */
/*     ZGND = HEIGHT OF THE HORIZONTAL GROUND PLANE */
/*     DX,DY,DZ = X, Y AND Z COMPONENTS OF THE UNIT VECTOR IN THE */
/*                DIRECTION OF PROPAGATION OF THE RADIATED FIELD (RAY */
/*                FROM (XP,YP,ZP) AFTER REFLECTION) */
/*     XP,YP,ZP = X, Y AND Z COORDINATES OF THE POINT REPRESENTING THE */
/*                SOURCE OF THE RAY */

/*     OUTPUT: */
/*     XS,YS,ZS = X, Y AND Z COORDINATES OF THE REFLECTION POINT ON THE */
/*                INTERFACE.  ZS IS ALWAYS SET EQUAL TO ZGND. */

    aa = 1e10f;
    if (abs(*dz) > 1e-10f) {
	aa = (*zp - *zgnd) / *dz;
    }
    *xs = *xp + aa * *dx;
    *ys = *yp + aa * *dy;
    *zs = *zgnd;
    return 0;
} /* refpt_ */

integer iround_(doublereal *r__)
{
    /* System generated locals */
    integer ret_val;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     IROUND rounds the real number R to an integer, IROUND */

    ret_val = (integer) (*r__ + .5f);
    return ret_val;
} /* iround_ */

/* Subroutine */ int netwk_(doublecomplex *einc)
{
    /* Format strings */
    static char fmt_63[] = "(///,27x,\002- - - STRUCTURE EXCITATION DATA AT "
	    "NETWORK CONNECTION POINTS - - -\002)";
    static char fmt_62[] = "(/,3x,\002TAG\002,3x,\002SEG.\002,4x,\002VOLTAGE"
	    " (VOLTS)\002,9x,\002CURRENT (AMPS)\002,9x,\002IMPEDANCE (OHMS"
	    ")\002,8x,\002ADMITTANCE (MHOS)\002,6x,\002POWER\002,/,3x,\002NO"
	    ".\002,3x,\002NO.\002,4x,\002REAL\002,8x,\002IMAG.\002,3(7x,\002R"
	    "EAL\002,8x,\002IMAG.\002),5x,\002(WATTS)\002)";
    static char fmt_64[] = "(2(1x,i5),1p9e12.5)";
    static char fmt_65[] = "(///,42x,\002- - - ANTENNA INPUT PARAMETERS - "
	    "- -\002)";
    static char fmt_66[] = "(1x,i5,\002 *\002,i4,1p9e12.5)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), d_cnjg(
	    doublecomplex *, doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, j;
    static doublecomplex cux, vlt;
    static doublereal pwr;
    static integer isc1;
    extern /* Subroutine */ int cabc_(doublecomplex *);
    static doublecomplex ymit;
    static integer neqz2, irow1, irow2, lablv;
    extern /* Subroutine */ int solgf_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, integer *), yamit1_(integer *, 
	    doublecomplex *, doublecomplex *, doublecomplex *), yamit2_(
	    integer *, doublecomplex *, doublecomplex *, doublecomplex *);
    extern integer iround_(doublereal *);
    extern /* Subroutine */ int netsol_(doublecomplex *, integer *);
    static integer netmxp;

    /* Fortran I/O blocks */
    static cilist io___296 = { 0, 3, 0, fmt_63, 0 };
    static cilist io___297 = { 0, 3, 0, fmt_62, 0 };
    static cilist io___304 = { 0, 3, 0, fmt_64, 0 };
    static cilist io___305 = { 0, 3, 0, fmt_64, 0 };
    static cilist io___308 = { 0, 3, 0, fmt_65, 0 };
    static cilist io___309 = { 0, 3, 0, fmt_62, 0 };
    static cilist io___312 = { 0, 3, 0, fmt_64, 0 };
    static cilist io___313 = { 0, 3, 0, fmt_65, 0 };
    static cilist io___314 = { 0, 3, 0, fmt_62, 0 };
    static cilist io___315 = { 0, 3, 0, fmt_66, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NETWK controls the solution for currents on a structure for a */
/*     given excitation and prints "ANTENNA INPUT PARAMETERS". */

/*     DISCRIPTION: */
/*     THIS SUBROUTINE IS THE REMNANT OF THE OLD SUBROUTINE NETWK WITH */
/*     THE NETWORK-SOLUTION CODING REMOVED TO SUBROUTINES NETSOL AND */
/*     NTSORT.  WHEN NETWORKS OR TRANSMISSION LINES ARE IN USE, */
/*     SUBROUTINE NETSOL IS CALLED TO SOLVE THE NETWORK EQUATIONS */
/*     TOGETHER WITH THE STRUCTURE INTERACTION EQUATIONS. */

/*     INPUT: */
/*     EINC = EXCITATION ARRAY, FILLED BY SUBROUTINE ETMNS FROM USER- */
/*            DEFINED SOURCES */
/*     OTHER INPUT FROM COMMON BLOCKS /DATA/, /CMB/, /SORCES/, /NETDEF/, */
/*     AND /NETCX/ */

/*     OUTPUT: */
/*     EINC = ARRAY OF CURRENTS ON SEGMENTS AND PATCHES */
/*     PARAMETERS IN COMMON/NETCX/ */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --einc;

    /* Function Body */
    netmxp = 31;
    netcx_1.pin = 0.f;
    netcx_1.pnls = 0.f;
    if (netdef_1.nonet == 0) {
	goto L48;
    }

/*     SOLUTION WHEN NETWORKS ARE PRESENT */

    netdef_1.nvsor = 0;

/*     FILL ARRAYS FOR VOLTAGE SOURCES IN PARALLEL WITH NETWORK PORTS. */
/*     THE FIELDS DUE TO THESE VOLTAGES MUST ALSO BE INCLUDED IN THE */
/*     EXCITATION VECTOR EINC.  THE VOLTAGE ENTERED IN ARRAY SVOLTS IS */
/*     TREATED AS BEING ACROSS THE NETWORK PORT, WHILE ANY REMAINDER IN */
/*     THE FIELD (V/DELTA) IN ARRAY EINC IS OUTBOARD OF THE PORT. */

    if (sorces_1.nsorc > 0) {
	i__1 = sorces_1.nsorc;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (sorces_1.isortp[i__ - 1] == 1) {
		++netdef_1.nvsor;
		netdef_1.nvsora[netdef_1.nvsor - 1] = iround_(&sorces_1.psor1[
			i__ - 1]);
		i__2 = netdef_1.nvsor - 1;
		i__3 = i__ - 1;
		i__4 = i__ - 1;
		z__1.r = sorces_1.psor2[i__3], z__1.i = sorces_1.psor3[i__4];
		netdef_1.svolts[i__2].r = z__1.r, netdef_1.svolts[i__2].i = 
			z__1.i;
	    }
/* L1: */
	}
    }

/*     CALL NETSOL TO SOLVE NETWORK EQUATIONS */

    netsol_(&einc[1], &netcx_1.ntsol);

/*     PRINT "STRUCTURE EXCITATION DATA AT NETWORK CONNECTION POINTS." */
/*     POWER DISSAPATED IN NETWORKS IS ALSO COMPUTED AS PNLS. */

    if (netcx_1.nprint == 0) {
	s_wsfe(&io___296);
	e_wsfe();
    }
    if (netcx_1.nprint == 0) {
	s_wsfe(&io___297);
	e_wsfe();
    }

/*     FOR NETWORK PORTS WITHOUT VOLTAGE SOURCES */

    i__1 = netwrk_1.nteq;
    for (i__ = 1; i__ <= i__1; ++i__) {
	irow1 = netwrk_1.nteqa[i__ - 1];
	i__2 = i__ - 1;
	vlt.r = netwrk_1.rhnt[i__2].r, vlt.i = netwrk_1.rhnt[i__2].i;
	yamit1_(&irow1, &vlt, &cux, &ymit);
	z_div(&z__1, &c_b336, &ymit);
	netcx_1.zped.r = z__1.r, netcx_1.zped.i = z__1.i;
	irow2 = data_1.itag[irow1 - 1];
	z__3.r = vlt.r * ymit.r - vlt.i * ymit.i, z__3.i = vlt.r * ymit.i + 
		vlt.i * ymit.r;
	d_cnjg(&z__2, &z__3);
	z__1.r = vlt.r * z__2.r - vlt.i * z__2.i, z__1.i = vlt.r * z__2.i + 
		vlt.i * z__2.r;
	pwr = z__1.r * .5f;
	netcx_1.pnls -= pwr;
	if (netcx_1.nprint == 0) {
	    s_wsfe(&io___304);
	    do_fio(&c__1, (char *)&irow2, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&irow1, (ftnlen)sizeof(integer));
	    do_fio(&c__2, (char *)&vlt, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&cux, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&netcx_1.zped, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&ymit, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&pwr, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
/* L46: */
    }
    if (netwrk_1.ntveq == 0) {
	goto L49;
    }

/*     FOR NETWORK PORTS WITH VOLTAGE SOURCES */

    i__1 = netwrk_1.ntveq;
    for (i__ = 1; i__ <= i__1; ++i__) {
	irow1 = netwrk_1.ntveqa[i__ - 1];
	i__2 = i__ - 1;
	vlt.r = netwrk_1.vltnet[i__2].r, vlt.i = netwrk_1.vltnet[i__2].i;
	yamit1_(&irow1, &vlt, &cux, &ymit);
	z_div(&z__1, &c_b336, &ymit);
	netcx_1.zped.r = z__1.r, netcx_1.zped.i = z__1.i;
	irow2 = data_1.itag[irow1 - 1];
	z__3.r = vlt.r * ymit.r - vlt.i * ymit.i, z__3.i = vlt.r * ymit.i + 
		vlt.i * ymit.r;
	d_cnjg(&z__2, &z__3);
	z__1.r = vlt.r * z__2.r - vlt.i * z__2.i, z__1.i = vlt.r * z__2.i + 
		vlt.i * z__2.r;
	pwr = z__1.r * .5f;
	netcx_1.pnls -= pwr;
/* L47: */
	if (netcx_1.nprint == 0) {
	    s_wsfe(&io___305);
	    do_fio(&c__1, (char *)&irow2, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&irow1, (ftnlen)sizeof(integer));
	    do_fio(&c__2, (char *)&vlt, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&cux, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&netcx_1.zped, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&ymit, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&pwr, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
    }
    goto L49;

/*     SOLVE FOR CURRENTS WHEN NO NETWORKS ARE PRESENT */

L48:
    neqz2 = cmb_1.neq2;
    if (neqz2 == 0) {
	neqz2 = 1;
    }
    solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
	    cmb_1.cm[cmb_1.id11 - 1], &einc[1], cmb_1.ip, &data_1.np, &
	    data_1.n1, &data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &
	    cmb_1.neq, &cmb_1.neq2, &neqz2);
    cabc_(&einc[1]);
    netwrk_1.ntveq = 0;
L49:
    lablv = 0;

/*     PRINT "ANTENNA INPUT PARAMETERS".  TOTAL INPUT POWER FROM SOURCES */
/*     IS ALSO COMPUTED AS PIN. */

    i__1 = sorces_1.nsorc;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*     FIRST FOR APPLIED FIELD (GAP) VOLTAGE SOURCES */

	if (sorces_1.isortp[i__ - 1] != 1) {
	    goto L3;
	}
	if (lablv == 0) {
	    lablv = 1;
	    s_wsfe(&io___308);
	    e_wsfe();
	    s_wsfe(&io___309);
	    e_wsfe();
	}
	isc1 = iround_(&sorces_1.psor1[i__ - 1]);
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__1.r = sorces_1.psor2[i__2], z__1.i = sorces_1.psor3[i__3];
	vlt.r = z__1.r, vlt.i = z__1.i;
	yamit1_(&isc1, &vlt, &cux, &ymit);
	irow1 = 0;

/*     IF THE VOLTAGE SOURCE IS IN PARALLEL WITH ONE OR MORE NETWORK */
/*     PORTS, ADD THE CURRENTS INTO THE NETWORK PORTS TO THE SEGMENT */
/*     CURRENT TO GET TOTAL CURRENT THROUGH THE SOURCE. */

	if (netwrk_1.ntveq > 0) {
	    i__2 = netwrk_1.ntveq;
	    for (j = 1; j <= i__2; ++j) {
		if (netwrk_1.ntveqa[j - 1] == isc1) {
		    irow1 = netmxp - j;
		    i__3 = irow1 - 1;
		    z__1.r = cux.r + netwrk_1.rhnt[i__3].r, z__1.i = cux.i + 
			    netwrk_1.rhnt[i__3].i;
		    cux.r = z__1.r, cux.i = z__1.i;
		    z_div(&z__2, &netwrk_1.rhnt[irow1 - 1], &vlt);
		    z__1.r = ymit.r + z__2.r, z__1.i = ymit.i + z__2.i;
		    ymit.r = z__1.r, ymit.i = z__1.i;
		    goto L51;
		}
/* L50: */
	    }
	}
L51:
	z_div(&z__1, &c_b336, &ymit);
	netcx_1.zped.r = z__1.r, netcx_1.zped.i = z__1.i;
	netcx_1.izsave = isc1;
	z__3.r = vlt.r * ymit.r - vlt.i * ymit.i, z__3.i = vlt.r * ymit.i + 
		vlt.i * ymit.r;
	d_cnjg(&z__2, &z__3);
	z__1.r = vlt.r * z__2.r - vlt.i * z__2.i, z__1.i = vlt.r * z__2.i + 
		vlt.i * z__2.r;
	pwr = z__1.r * .5f;
	netcx_1.pin += pwr;
	if (irow1 != 0) {
	    netcx_1.pnls += pwr;
	}
	irow2 = data_1.itag[isc1 - 1];
	s_wsfe(&io___312);
	do_fio(&c__1, (char *)&irow2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&isc1, (ftnlen)sizeof(integer));
	do_fio(&c__2, (char *)&vlt, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&cux, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&netcx_1.zped, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&ymit, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&pwr, (ftnlen)sizeof(doublereal));
	e_wsfe();
L3:
	;
    }

/*     NOW DO CHARGE DISCONTINUITY (BICONE) VOLTAGE SOURCES.  NOTE THAT */
/*     THESE ARE NEVER IN PARALLEL WITH NETWORK PORTS. */

    i__1 = sorces_1.nsorc;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (sorces_1.isortp[i__ - 1] != 4) {
	    goto L5;
	}
	if (lablv == 0) {
	    lablv = 1;
	    s_wsfe(&io___313);
	    e_wsfe();
	    s_wsfe(&io___314);
	    e_wsfe();
	}
	isc1 = iround_(&sorces_1.psor1[i__ - 1]);
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__1.r = sorces_1.psor2[i__2], z__1.i = sorces_1.psor3[i__3];
	vlt.r = z__1.r, vlt.i = z__1.i;
	yamit2_(&isc1, &vlt, &cux, &ymit);
	z_div(&z__1, &c_b336, &ymit);
	netcx_1.zped.r = z__1.r, netcx_1.zped.i = z__1.i;
	netcx_1.izsave = isc1;
	z__3.r = vlt.r * ymit.r - vlt.i * ymit.i, z__3.i = vlt.r * ymit.i + 
		vlt.i * ymit.r;
	d_cnjg(&z__2, &z__3);
	z__1.r = vlt.r * z__2.r - vlt.i * z__2.i, z__1.i = vlt.r * z__2.i + 
		vlt.i * z__2.r;
	pwr = z__1.r * .5f;
	netcx_1.pin += pwr;
	irow2 = data_1.itag[isc1 - 1];
	s_wsfe(&io___315);
	do_fio(&c__1, (char *)&irow2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&isc1, (ftnlen)sizeof(integer));
	do_fio(&c__2, (char *)&vlt, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&cux, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&netcx_1.zped, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&ymit, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&pwr, (ftnlen)sizeof(doublereal));
	e_wsfe();
L5:
	;
    }
    return 0;

} /* netwk_ */

/* Subroutine */ int netsol_(doublecomplex *einc, integer *ntsol)
{
    /* Format strings */
    static char fmt_61[] = "(\002 NETSOL: ERROR - NETWORK ARRAY DIMENSIONS T"
	    "OO SMALL\002)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, j;
    static doublecomplex rhs[3630];
    extern /* Subroutine */ int cabc_(doublecomplex *);
    static doublecomplex curx;
    static integer nseg1, nseg2, ivsc1, ivsc2, neqz2, irow1, irow2;
    extern /* Subroutine */ int factr_(integer *, doublecomplex *, integer *, 
	    integer *), solgf_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, integer *), solve_(integer *, doublecomplex 
	    *, integer *, doublecomplex *, integer *), sorini_(doublecomplex *
	    );
    static integer netmxp;
    extern /* Subroutine */ int ntsort_(integer *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___326 = { 0, 3, 0, fmt_61, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NETSOL solves for structure currents and network-port voltages and */
/*     currents for structures with non-radiating networks. */

/*     DESCRIPTION: */
/*     AN ADMITTANCE MATRIX IS DERIVED FOR THE ELECTROMAGNETIC */
/*     INTERACTION OF THE SEGMENTS TO WHICH NETWORK PORTS CONNECT.  THIS */
/*     MATRIX IS COMBINED WITH THE ADMITTANCE MATRIX FOR THE NETWORKS */
/*     AND SOLVED FOR THE VOLTAGES AND CURRENTS AT NETWORK PORTS. */

/*     INPUT: */
/*     EINC = EXCITATION ARRAY, FILLED BY SUBROUTINE ETMNS FROM USER- */
/*            DEFINED SOURCES */
/*     NTSOL = FLAG TO INDICATE (WHEN .NE. 0) THAT NETWORK EQUATIONS DO */
/*             NOT NEED TO BE RECOMPUTED.  THIS SITUATION OCCURS WHEN */
/*             NETSOL IS CALLED REPEATEDLY WITH ONLY THE STRUCTURE */
/*             EXCITATION, EXCLUDING VOLTAGE SOURCES IN PARALLEL WITH */
/*             NETWORK PORTS, CHANGING.  IF VOLTAGE SOURCES IN PARALLEL */
/*             WITH NETWORK PORTS ARE CHANGED, NETSOL MUST BE CALLED WITH */
/*             NTSOL EQUAL TO ZERO. */
/*     NVSOR = NUMBER OF VOLTAGE SOURCES IN THE STRUCTURE */
/*     NVSORA(I) = SEGMENT NUMBER FOR VOLTAGE SOURCE I */
/*     SVOLTS(I) = VOLTAGE ON SOURCE I.  THE FIELD DUE TO THIS VOLTAGE */
/*                 MUST ALSO BE INCLUDED IN THE EXCITATION VECTOR EINC. */
/*                 THE COMPONENT DUE TO SVOLTS IS TREATED AS BEING ACROSS */
/*                 THE NETWORK PORT, WHILE ANY REMAINDER IN EINC IS */
/*                 OUTBOARD OF THE PORT. */
/*     OTHER INPUT FROM COMMON BLOCKS /DATA/, /CMB/ AND /NETDEF/ */

/*     OUTPUT: */
/*     EINC = ARRAY OF CURRENTS ON SEGMENTS AND PATCHES */
/*     NTEQ = NUMBER OF SEGMENTS THAT CONNECT TO NETWORK PORTS WITHOUT */
/*            VOLTAGE SOURCES */
/*     NTEQA(I) = SEGMENT NUMBER OF THE I th SEGMENT THAT CONNECTS TO A */
/*                NETWORK PORT WITHOUT A VOLTAGE SOURCE */
/*     NTVEQ = NUMBER OF SEGMENTS THAT CONNECT TO NETWORK PORTS WITH */
/*             VOLTAGE SOURCES */
/*     NTVEQA(I) = SEGMENT NUMBER OF THE I th SEGMENT THAT CONNECTS TO A */
/*                NETWORK PORT WITH A VOLTAGE SOURCE */
/*     RHNT(I) = PORT VOLTAGE (VOLTS) ON SEGMENT NUMBER NTEQA(I) FOR I */
/*               FROM 1 THROUGH NTEQ */
/*     RHNT(NETMXP - I) = NETWORK COMPONENT OF SOURCE CURRENT (AMPS) FOR */
/*                        THE SOURCE IN PARALLEL WITH THE NETWORK PORT ON */
/*                        SEGMENT NTVEQA(I) FOR I FROM 1 THROUGH NTVEQ. */
/*                        THE TOTAL SOURCE CURRENT IS THE SUM OF THIS */
/*                        QUANTITY AND THE CURRENT IN THE SEGMENT. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --einc;

    /* Function Body */
    netmxp = 31;
    neqz2 = cmb_1.neq2;
    if (neqz2 == 0) {
	neqz2 = 1;
    }
    if (*ntsol != 0) {
	goto L42;
    }

/*     INITIALIZE ARRAYS FOR NETWORK EQUTIONS */

    for (i__ = 1; i__ <= 30; ++i__) {
	i__1 = i__ - 1;
	netwrk_1.rhnx[i__1].r = 0.f, netwrk_1.rhnx[i__1].i = 0.f;
	for (j = 1; j <= 30; ++j) {
/* L15: */
	    i__1 = i__ + j * 30 - 31;
	    netwrk_1.cmn[i__1].r = 0.f, netwrk_1.cmn[i__1].i = 0.f;
	}
    }
    netwrk_1.nteq = 0;
    netwrk_1.ntveq = 0;

/*     SORT NETWORK AND SOURCE DATA AND ASSIGN EQUATION NUMBERS TO */
/*     SEGMENTS.  EQUATIONS FOR PORTS WITHOUT VOLTAGE SOURCES ARE */
/*     STORED DOWNWARD FROM THE TOP ROW OF CMN.  EQUATIONS FOR PORTS */
/*     WITH VOLTAGE SOURCES ARE STORED UPWARD FROM THE BOTTOM OF CMN AND */
/*     USED LATER TO COMPUTE THE INPUT ADMITTANCES SEEN BY THE SOURCES. */

    i__1 = netdef_1.nonet;
    for (j = 1; j <= i__1; ++j) {
	nseg1 = netdef_1.iseg1[j - 1];
	nseg2 = netdef_1.iseg2[j - 1];
	ntsort_(&nseg1, &irow1, &ivsc1);
	ntsort_(&nseg2, &irow2, &ivsc2);
	if (ivsc1 != 0) {
	    irow1 = netmxp - irow1;
	}
	if (ivsc2 != 0) {
	    irow2 = netmxp - irow2;
	}
	if (netwrk_1.nteq + netwrk_1.ntveq > 30) {
	    s_wsfe(&io___326);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}

/*     FILL NETWORK EQUATION MATRIX AND RIGHT HAND SIDE VECTOR WITH */
/*     NETWORK SHORT-CIRCUIT ADMITTANCE MATRIX COEFFICIENTS.  THE */
/*     (Y sub i,j) COMPONENTS OF THE MATRIX IN EQ. 202 OF PART I OF THE */
/*     NEC-2 MANUAL ARE STORED IN CMN.  THE NEGATIVE OF (C sub i) IN EQ. */
/*     202 IS STORED IN RHNX.  CMN IS STORRED TRANSPOSED. */

	if (ivsc1 == 0) {
	    i__2 = irow1 + irow1 * 30 - 31;
	    i__3 = irow1 + irow1 * 30 - 31;
	    i__4 = j - 1;
	    i__5 = nseg1 - 1;
	    z__2.r = data_1.si[i__5] * netdef_1.yn11[i__4].r, z__2.i = 
		    data_1.si[i__5] * netdef_1.yn11[i__4].i;
	    z__1.r = netwrk_1.cmn[i__3].r - z__2.r, z__1.i = netwrk_1.cmn[
		    i__3].i - z__2.i;
	    netwrk_1.cmn[i__2].r = z__1.r, netwrk_1.cmn[i__2].i = z__1.i;
	    i__2 = irow1 + irow2 * 30 - 31;
	    i__3 = irow1 + irow2 * 30 - 31;
	    i__4 = j - 1;
	    i__5 = nseg1 - 1;
	    z__2.r = data_1.si[i__5] * netdef_1.yn12[i__4].r, z__2.i = 
		    data_1.si[i__5] * netdef_1.yn12[i__4].i;
	    z__1.r = netwrk_1.cmn[i__3].r - z__2.r, z__1.i = netwrk_1.cmn[
		    i__3].i - z__2.i;
	    netwrk_1.cmn[i__2].r = z__1.r, netwrk_1.cmn[i__2].i = z__1.i;
	} else {
	    i__2 = irow1 - 1;
	    i__3 = irow1 - 1;
	    i__4 = j - 1;
	    i__5 = ivsc1 - 1;
	    z__2.r = netdef_1.yn11[i__4].r * netdef_1.svolts[i__5].r - 
		    netdef_1.yn11[i__4].i * netdef_1.svolts[i__5].i, z__2.i = 
		    netdef_1.yn11[i__4].r * netdef_1.svolts[i__5].i + 
		    netdef_1.yn11[i__4].i * netdef_1.svolts[i__5].r;
	    z__1.r = netwrk_1.rhnx[i__3].r + z__2.r, z__1.i = netwrk_1.rhnx[
		    i__3].i + z__2.i;
	    netwrk_1.rhnx[i__2].r = z__1.r, netwrk_1.rhnx[i__2].i = z__1.i;
	    i__2 = irow2 - 1;
	    i__3 = irow2 - 1;
	    i__4 = j - 1;
	    i__5 = ivsc1 - 1;
	    z__2.r = netdef_1.yn12[i__4].r * netdef_1.svolts[i__5].r - 
		    netdef_1.yn12[i__4].i * netdef_1.svolts[i__5].i, z__2.i = 
		    netdef_1.yn12[i__4].r * netdef_1.svolts[i__5].i + 
		    netdef_1.yn12[i__4].i * netdef_1.svolts[i__5].r;
	    z__1.r = netwrk_1.rhnx[i__3].r + z__2.r, z__1.i = netwrk_1.rhnx[
		    i__3].i + z__2.i;
	    netwrk_1.rhnx[i__2].r = z__1.r, netwrk_1.rhnx[i__2].i = z__1.i;
	}
	if (ivsc2 == 0) {
	    i__2 = irow2 + irow2 * 30 - 31;
	    i__3 = irow2 + irow2 * 30 - 31;
	    i__4 = j - 1;
	    i__5 = nseg2 - 1;
	    z__2.r = data_1.si[i__5] * netdef_1.yn22[i__4].r, z__2.i = 
		    data_1.si[i__5] * netdef_1.yn22[i__4].i;
	    z__1.r = netwrk_1.cmn[i__3].r - z__2.r, z__1.i = netwrk_1.cmn[
		    i__3].i - z__2.i;
	    netwrk_1.cmn[i__2].r = z__1.r, netwrk_1.cmn[i__2].i = z__1.i;
	    i__2 = irow2 + irow1 * 30 - 31;
	    i__3 = irow2 + irow1 * 30 - 31;
	    i__4 = j - 1;
	    i__5 = nseg2 - 1;
	    z__2.r = data_1.si[i__5] * netdef_1.yn12[i__4].r, z__2.i = 
		    data_1.si[i__5] * netdef_1.yn12[i__4].i;
	    z__1.r = netwrk_1.cmn[i__3].r - z__2.r, z__1.i = netwrk_1.cmn[
		    i__3].i - z__2.i;
	    netwrk_1.cmn[i__2].r = z__1.r, netwrk_1.cmn[i__2].i = z__1.i;
	} else {
	    i__2 = irow1 - 1;
	    i__3 = irow1 - 1;
	    i__4 = j - 1;
	    i__5 = ivsc2 - 1;
	    z__2.r = netdef_1.yn12[i__4].r * netdef_1.svolts[i__5].r - 
		    netdef_1.yn12[i__4].i * netdef_1.svolts[i__5].i, z__2.i = 
		    netdef_1.yn12[i__4].r * netdef_1.svolts[i__5].i + 
		    netdef_1.yn12[i__4].i * netdef_1.svolts[i__5].r;
	    z__1.r = netwrk_1.rhnx[i__3].r + z__2.r, z__1.i = netwrk_1.rhnx[
		    i__3].i + z__2.i;
	    netwrk_1.rhnx[i__2].r = z__1.r, netwrk_1.rhnx[i__2].i = z__1.i;
	    i__2 = irow2 - 1;
	    i__3 = irow2 - 1;
	    i__4 = j - 1;
	    i__5 = ivsc2 - 1;
	    z__2.r = netdef_1.yn22[i__4].r * netdef_1.svolts[i__5].r - 
		    netdef_1.yn22[i__4].i * netdef_1.svolts[i__5].i, z__2.i = 
		    netdef_1.yn22[i__4].r * netdef_1.svolts[i__5].i + 
		    netdef_1.yn22[i__4].i * netdef_1.svolts[i__5].r;
	    z__1.r = netwrk_1.rhnx[i__3].r + z__2.r, z__1.i = netwrk_1.rhnx[
		    i__3].i + z__2.i;
	    netwrk_1.rhnx[i__2].r = z__1.r, netwrk_1.rhnx[i__2].i = z__1.i;
	}
/* L38: */
    }

/*     ADD INTERACTION-MATRIX ADMITTANCE ELEMENTS TO NETWORK EQUATION */
/*     MATRIX.  THESE ARE THE INVERSE(G sub i,j) COMPONENTS OF THE */
/*     NETWORK MATRIX IN EQ. 202 OF PART I OF THE NEC-2 MANUAL. */

    i__1 = netwrk_1.nteq;
    for (j = 1; j <= i__1; ++j) {
	sorini_(rhs);
	irow1 = netwrk_1.nteqa[j - 1];
	i__2 = irow1 - 1;
	rhs[i__2].r = 1.f, rhs[i__2].i = 0.f;
	solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1],
		 &cmb_1.cm[cmb_1.id11 - 1], rhs, cmb_1.ip, &data_1.np, &
		data_1.n1, &data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &
		cmb_1.neq, &cmb_1.neq2, &neqz2);
	cabc_(rhs);
	i__2 = netwrk_1.nteq;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    irow1 = netwrk_1.nteqa[i__ - 1];
/* L40: */
	    i__3 = j + i__ * 30 - 31;
	    i__4 = j + i__ * 30 - 31;
	    i__5 = irow1 - 1;
	    z__1.r = netwrk_1.cmn[i__4].r + rhs[i__5].r, z__1.i = 
		    netwrk_1.cmn[i__4].i + rhs[i__5].i;
	    netwrk_1.cmn[i__3].r = z__1.r, netwrk_1.cmn[i__3].i = z__1.i;
	}
/* L41: */
    }

/*     FACTOR NETWORK EQUATION MATRIX */

    factr_(&netwrk_1.nteq, netwrk_1.cmn, netwrk_1.ipnt, &c__30);

/*     ADD TO NETWORK EQUATION RIGHT HAND SIDE THE TERMS DUE TO ELEMENT */
/*     INTERACTIONS.  THESE ARE THE (B sub i) TERMS IN EQ. 202. */

L42:
    i__1 = cmb_1.neqmat;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L43: */
	i__3 = i__ - 1;
	i__4 = i__;
	rhs[i__3].r = einc[i__4].r, rhs[i__3].i = einc[i__4].i;
    }
    solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
	    cmb_1.cm[cmb_1.id11 - 1], rhs, cmb_1.ip, &data_1.np, &data_1.n1, &
	    data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &cmb_1.neq, &
	    cmb_1.neq2, &neqz2);
    cabc_(rhs);
    i__3 = netwrk_1.nteq;
    for (i__ = 1; i__ <= i__3; ++i__) {
	irow1 = netwrk_1.nteqa[i__ - 1];
/* L44: */
	i__4 = i__ - 1;
	i__1 = i__ - 1;
	i__5 = irow1 - 1;
	z__1.r = netwrk_1.rhnx[i__1].r + rhs[i__5].r, z__1.i = netwrk_1.rhnx[
		i__1].i + rhs[i__5].i;
	netwrk_1.rhnt[i__4].r = z__1.r, netwrk_1.rhnt[i__4].i = z__1.i;
    }

/*     SOLVE NETWORK EQUATIONS */

    solve_(&netwrk_1.nteq, netwrk_1.cmn, netwrk_1.ipnt, netwrk_1.rhnt, &c__30)
	    ;

/*     ADD FIELDS DUE TO NETWORK VOLTAGES TO ELECTRIC FIELDS APPLIED TO */
/*     STRUCTURE AND SOLVE FOR INDUCED CURRENT */

    i__4 = netwrk_1.nteq;
    for (i__ = 1; i__ <= i__4; ++i__) {
	irow1 = netwrk_1.nteqa[i__ - 1];
/* L45: */
	i__1 = irow1;
	i__5 = irow1;
	i__3 = i__ - 1;
	z__1.r = einc[i__5].r - netwrk_1.rhnt[i__3].r, z__1.i = einc[i__5].i 
		- netwrk_1.rhnt[i__3].i;
	einc[i__1].r = z__1.r, einc[i__1].i = z__1.i;
    }
    solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
	    cmb_1.cm[cmb_1.id11 - 1], &einc[1], cmb_1.ip, &data_1.np, &
	    data_1.n1, &data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &
	    cmb_1.neq, &cmb_1.neq2, &neqz2);
    cabc_(&einc[1]);

/*     FOR PORTS WITH VOLTAGE SOURCES, EVALUATE THE TOTAL CURRENT INTO */
/*     NETWORK PORTS AT EACH SEGMENT AND STORE IN THE BOTTOM OF RHNT. */
/*     THE SOURCE CURRENT IN EQ. 203 OF PART I OF NEC-2 MANUAL IS THE SUM */
/*     OF THIS QUANTITY AND THE CURRENT IN THE SEGMENT. */

    i__1 = netwrk_1.ntveq;
    for (i__ = 1; i__ <= i__1; ++i__) {
	irow1 = netmxp - i__;
	i__5 = irow1 - 1;
	curx.r = netwrk_1.rhnx[i__5].r, curx.i = netwrk_1.rhnx[i__5].i;
	i__5 = netwrk_1.nteq;
	for (j = 1; j <= i__5; ++j) {
/* L51: */
	    i__3 = j + irow1 * 30 - 31;
	    i__4 = j - 1;
	    z__2.r = netwrk_1.cmn[i__3].r * netwrk_1.rhnt[i__4].r - 
		    netwrk_1.cmn[i__3].i * netwrk_1.rhnt[i__4].i, z__2.i = 
		    netwrk_1.cmn[i__3].r * netwrk_1.rhnt[i__4].i + 
		    netwrk_1.cmn[i__3].i * netwrk_1.rhnt[i__4].r;
	    z__1.r = curx.r - z__2.r, z__1.i = curx.i - z__2.i;
	    curx.r = z__1.r, curx.i = z__1.i;
	}
/* L50: */
	i__3 = irow1 - 1;
	netwrk_1.rhnt[i__3].r = curx.r, netwrk_1.rhnt[i__3].i = curx.i;
    }

/*     CONVERT FIELD VALUES FOR PORTS WITHOUT VOLTAGE SOURCES TO PORT */
/*     VOLTAGES AND STORE IN TOP PART OF RHNT. */

    i__3 = netwrk_1.nteq;
    for (i__ = 1; i__ <= i__3; ++i__) {
	irow1 = netwrk_1.nteqa[i__ - 1];
/* L46: */
	i__1 = i__ - 1;
	i__4 = i__ - 1;
	i__5 = irow1 - 1;
	z__1.r = data_1.si[i__5] * netwrk_1.rhnt[i__4].r, z__1.i = data_1.si[
		i__5] * netwrk_1.rhnt[i__4].i;
	netwrk_1.rhnt[i__1].r = z__1.r, netwrk_1.rhnt[i__1].i = z__1.i;
    }
    return 0;

} /* netsol_ */

/* Subroutine */ int ntsort_(integer *netseg, integer *neteqn, integer *ivsrc)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NTSORT determines the network equation for segment NETSEG. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     NETSEG = SEGMENT NUMBER FOR WHICH NETWORK EQUATION NUMBER IS TO BE */
/*              DETERMINED */
/*     NTEQA = ARRAY OF SEGMENTS WITHOUT VOLTAGE SOURCES FOR WHICH */
/*             NETWORK EQUATION NUMBERS HAVE BEEN ESTABLISHED (COMMON */
/*             /NETWRK/) */
/*     NTVEQA = ARRAY OF SEGMENTS WITH VOLTAGE SOURCES FOR WHICH NETWORK */
/*             EQUATION NUMBERS HAVE BEEN ESTABLISHED (COMMON/NETWRK/) */
/*     OTHER INPUT FROM COMMON BLOCKS /NETDEF/ AND /NETWRK/ */

/*     OUTPUT: */
/*     NETEQN = NETWORK EQUATION NUMBER FOR PORTS WITHOUT VOLTAGE SOURCES */
/*              IF IVSRC .EQ. 0; NETWORK EQUATION NUMBER FOR PORTS WITH */
/*              VOLTAGE SOURCES IF IVSRC .NE. 0. */
/*     IVSRC = INDEX OF SEGMENT NETSEG IN ARRAY NVSORA IF SEGMENT NETSEG */
/*             WAS FOUND TO HAVE A VOLTAGE SOURCE.  IF SEGMENT NETSEG */
/*             WAS NOT FOUND IN ARRAY NVSORA THEN IVSRC = 0. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


/*     CHECK IF NETWORK PORT ALSO HAS A VOLTAGE SOURCE */

    if (netdef_1.nvsor > 0) {
	i__1 = netdef_1.nvsor;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (*netseg == netdef_1.nvsora[i__ - 1]) {
		*ivsrc = i__;
		goto L3;
	    }
/* L1: */
	}
    }

/*     NETWORK PORT WITHOUT VOLTAGE SOURCE.  GET EQUATION NUMBER. */

    *ivsrc = 0;
    if (netwrk_1.nteq > 0) {
	i__1 = netwrk_1.nteq;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (*netseg == netwrk_1.nteqa[i__ - 1]) {
		*neteqn = i__;
		return 0;
	    }
/* L2: */
	}
    }

/*     NEW NETWORK EQUATION.  ENTER SEGMENT NUMBER IN ARRAY NTEQA. */

    ++netwrk_1.nteq;
    netwrk_1.nteqa[netwrk_1.nteq - 1] = *netseg;
    *neteqn = netwrk_1.nteq;
    return 0;

/*     NETWORK PORT WITH VOLTAGE SOURCE.  GET EQUATION NUMBER. */

L3:
    if (netwrk_1.ntveq > 0) {
	i__1 = netwrk_1.ntveq;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (*netseg == netwrk_1.ntveqa[i__ - 1]) {
		*neteqn = i__;
		return 0;
	    }
/* L4: */
	}
    }

/*     NEW NETWORK-VOLTAGE SOURCE EQUATION.  ENTER SEGMENT NUMBER IN */
/*     ARRAY NTVEQA */

    ++netwrk_1.ntveq;
    netwrk_1.ntveqa[netwrk_1.ntveq - 1] = *netseg;
    *neteqn = netwrk_1.ntveq;
    i__1 = netwrk_1.ntveq - 1;
    i__2 = *ivsrc - 1;
    netwrk_1.vltnet[i__1].r = netdef_1.svolts[i__2].r, netwrk_1.vltnet[i__1]
	    .i = netdef_1.svolts[i__2].i;
    return 0;
} /* ntsort_ */

/* Subroutine */ int yamit1_(integer *iseg, doublecomplex *volts, 
	doublecomplex *crnt, doublecomplex *ymit)
{
    /* System generated locals */
    integer i__1;
    doublecomplex z__1;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     YAMIT1 computes the input admittance and source current for a */
/*     segment with an applied-field voltage source. */

/*     DESCRIPTION: */
/*     INPUT ADMITTANCE IS COMPUTED AS THE RATIO OF THE CURRENT AT THE */
/*     CENTER OF THE SEGMENT TO THE SPECIFIED VOLTAGE.  NOTE THAT THIS */
/*     IS THE INPUT ADMITTANCE FOR THE STRUCTURE.  IT DOES NOT INCLUDE */
/*     CURRENT INTO ANY NETWORKS OR TRANSMISSION LINES ON THIS SEGMENT. */
/*     INPUT: */
/*     ISEG = NUMBER OF THE SEGMENT ON WHICH THE SOURCE IS LOCATED */
/*     VOLTS = SOURCE VOLTAGE (VOLTS) */

/*     OUTPUT: */
/*     CRNT = SOURCE CURRENT (AMPS) */
/*     YMIT = INPUT ADMITTANCE (MHOS) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    i__1 = *iseg - 1;
    crnt->r = crnt_1.cur[i__1].r, crnt->i = crnt_1.cur[i__1].i;
    z_div(&z__1, crnt, volts);
    ymit->r = z__1.r, ymit->i = z__1.i;
    return 0;
} /* yamit1_ */

/* Subroutine */ int yamit2_(integer *iseg, doublecomplex *volts, 
	doublecomplex *crnt, doublecomplex *ymit)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_sin(doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     YAMIT2 computes the input admittance and source current for a */
/*     segment with a charge discontinuity voltage source. */

/*     DESCRIPTION: */
/*     INPUT ADMITTANCE IS COMPUTED AS THE RATIO OF THE CURRENT AT END */
/*     ONE OF THE SEGMENT TO THE SPECIFIED VOLTAGE.  NOTE THAT THIS */
/*     IS THE INPUT ADMITTANCE FOR THE STRUCTURE.  IT DOES NOT INCLUDE */
/*     CURRENT INTO ANY NETWORKS OR TRANSMISSION LINES ON THIS SEGMENT. */
/*     INPUT: */
/*     ISEG = NUMBER OF THE SEGMENT ON WHICH THE SOURCE IS LOCATED */
/*     VOLTS = SOURCE VOLTAGE (VOLTS) */

/*     OUTPUT: */
/*     CRNT = SOURCE CURRENT (AMPS) */
/*     YMIT = INPUT ADMITTANCE (MHOS) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    d__1 = data_1.si[*iseg - 1] * .5f;
    i__1 = *iseg - 1;
    z__1.r = d__1 * crnt_1.xks[i__1].r, z__1.i = d__1 * crnt_1.xks[i__1].i;
    crnt->r = z__1.r, crnt->i = z__1.i;
    i__1 = *iseg - 1;
    i__2 = *iseg - 1;
    z_sin(&z__4, crnt);
    z__3.r = crnt_1.bix[i__2].r * z__4.r - crnt_1.bix[i__2].i * z__4.i, 
	    z__3.i = crnt_1.bix[i__2].r * z__4.i + crnt_1.bix[i__2].i * 
	    z__4.r;
    z__2.r = crnt_1.aix[i__1].r - z__3.r, z__2.i = crnt_1.aix[i__1].i - 
	    z__3.i;
    i__3 = *iseg - 1;
    z_cos(&z__7, crnt);
    z__6.r = z__7.r - 1.f, z__6.i = z__7.i;
    z__5.r = crnt_1.cix[i__3].r * z__6.r - crnt_1.cix[i__3].i * z__6.i, 
	    z__5.i = crnt_1.cix[i__3].r * z__6.i + crnt_1.cix[i__3].i * 
	    z__6.r;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    crnt->r = z__1.r, crnt->i = z__1.i;
    z_div(&z__1, crnt, volts);
    ymit->r = z__1.r, ymit->i = z__1.i;
    return 0;
} /* yamit2_ */

/* Subroutine */ int zpsave_(integer *mhz, doublereal *fmhz, doublecomplex *
	zped, integer *izsave)
{
    /* Initialized data */

    static integer nzsmax = 200;

    /* Format strings */
    static char fmt_185[] = "(///,4x,\002ZPSAVE: STORAGE FOR IMPEDANCE NORMA"
	    "LIZATION TOO\002,\002 SMALL; ARRAY TRUNCATED\002)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);

    /* Fortran I/O blocks */
    static cilist io___331 = { 0, 3, 0, fmt_185, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ZPSAVE stores values in COMMON/ZPSAV/ for printing a table of */
/*     input impedances. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     MHZ = ARRAY INDEX AT WHICH THE PRESENT VALUES WILL BE STORED */
/*     FMHZ = FREQUENCY (MHZ) */
/*     ZPED = VALUE OF INPUT IMPEDANCE (VOLTS, COMPLEX) */
/*     IZSAVE = NUMBER OF THE SEGMENT ON WHICH THE INPUT IMPEDANCE WAS */
/*              COMPUTED (OHMS) */

/*     OUTPUT: TO COMMON /ZPSAV/ */

    if (*mhz == 1) {
	zpsav_1.nzlimt = 0;
    }
    if (*mhz > nzsmax) {
	if (zpsav_1.nzlimt == 0) {
	    s_wsfe(&io___331);
	    e_wsfe();
	}
	zpsav_1.nzlimt = 1;
	return 0;
    }
    zpsav_1.nzsave = *mhz;
    zpsav_1.iszsav = *izsave;
    zpsav_1.frmhza[*mhz - 1] = *fmhz;
    i__1 = *mhz - 1;
    zpsav_1.zpeda[i__1].r = zped->r, zpsav_1.zpeda[i__1].i = zped->i;
    return 0;

} /* zpsave_ */

/* Subroutine */ int ptzped_(void)
{
    /* Format strings */
    static char fmt_184[] = "(///,36x,\002- - - INPUT IMPEDANCE DATA - - "
	    "-\002,/,45x,\002SOURCE SEGMENT NO.\002,i4,/,45x,\002NORMALIZATIO"
	    "N FACTOR=\002,1pe12.5,//,7x,\002FREQ.\002,13x,\002-  -  UNNORMAL"
	    "IZED IMPEDANCE  -  -\002,21x,\002-  -  NORMALIZED IMPEDANCE  -  -"
	    "\002,/,19x,\002RESISTANCE\002,4x,\002REACTANCE\002,6x,\002MAGNIT"
	    "UDE\002,4x,\002PHASE\002,7x,\002RESISTANCE\002,4x,\002REACTANC"
	    "E\002,6x,\002MAGNITUDE\002,4x,\002PHASE\002,/,8x,\002MHZ\002,11x,"
	    "\002OHMS\002,10x,\002OHMS\002,11x,\002OHMS\002,5x,\002DEGREES"
	    "\002,47x,\002DEGREES\002,/)";
    static char fmt_186[] = "(3x,f9.3,2x,2(2x,1pe12.5),3x,e12.5,2x,0pf7.2,2x"
	    ",2(2x,1pe12.5),3x,e12.5,2x,0pf7.2)";
    static char fmt_187[] = "(//)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    double d_imag(doublecomplex *);

    /* Local variables */
    static integer i__;
    extern doublereal cang_(doublecomplex *);
    static doublereal zpedm, zpedp, zpmnor, zprnor, zpxnor;

    /* Fortran I/O blocks */
    static cilist io___334 = { 0, 3, 0, fmt_184, 0 };
    static cilist io___339 = { 0, 3, 0, fmt_186, 0 };
    static cilist io___340 = { 0, 3, 0, fmt_187, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTZPED prints a table of input impedances and normalized input */
/*     impedances versus frequency. */

/*     DESCRIPTION: */
/*     IMPEDANCE IS TAKEN FROM ARRAY ZPEDA AND FREQUENCY FROM FRMHZA. */
/*     IMPEDANCE IS NORMALIZED BY THE VALUE OF ZPNORM.  IF THIS VALUE IS */
/*     ZERO, THE MAXIMUM MAGNITUDE IN ZPEDA IS DETERMINED AND USED FOR */
/*     NORMALIZATION. */

/*     INPUT: FROM COMMON/ZPSAV/ */
/*     OUTPUT: */
/*     FRMHZA = FREQUENCY (MHZ) */
/*     ZPEDA = IMPEDANCE (OHMS, COMPLEX) */
/*     ZPEDM = MAGNITUDE OF ZPEDA */
/*     ZPEDP = PHASE OF ZPEDA */
/*     ZPRNOR = REAL PART OF ZPEDA NORMALIZED */
/*     ZPXNOR = IMAGINARY PART OF ZPEDA NORMALIZED */
/*     ZPMNOR = MAGNITUDE OF ZPEDA NORMALIZED */

    if (zpsav_1.zpnorm == 0.f) {

/*     DETERMINE MAXIMUM MAGNITUDE OF IMPEDANCE FOR USE IN NORMALIZATION */

	i__1 = zpsav_1.nzsave;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    zpedm = z_abs(&zpsav_1.zpeda[i__ - 1]);
	    if (zpedm > zpsav_1.zpnorm) {
		zpsav_1.zpnorm = zpedm;
	    }
/* L1: */
	}
    }

/*     PRINT TABLE OF IMPEDANCE AND NORMALIZED IMPEDANCE */

    s_wsfe(&io___334);
    do_fio(&c__1, (char *)&zpsav_1.iszsav, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&zpsav_1.zpnorm, (ftnlen)sizeof(doublereal));
    e_wsfe();
    i__1 = zpsav_1.nzsave;
    for (i__ = 1; i__ <= i__1; ++i__) {
	zpedm = z_abs(&zpsav_1.zpeda[i__ - 1]);
	zpedp = cang_(&zpsav_1.zpeda[i__ - 1]);
	i__2 = i__ - 1;
	zprnor = zpsav_1.zpeda[i__2].r / zpsav_1.zpnorm;
	zpxnor = d_imag(&zpsav_1.zpeda[i__ - 1]) / zpsav_1.zpnorm;
	zpmnor = zpedm / zpsav_1.zpnorm;
/* L2: */
	s_wsfe(&io___339);
	do_fio(&c__1, (char *)&zpsav_1.frmhza[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__2, (char *)&zpsav_1.zpeda[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__1, (char *)&zpedm, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zpedp, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zprnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zpxnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zpmnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zpedp, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    s_wsfe(&io___340);
    e_wsfe();
    return 0;

} /* ptzped_ */

/* Subroutine */ int ptnetw_(void)
{
    /* Format strings */
    static char fmt_158[] = "(///,44x,\002- - - NETWORK DATA - - -\002)";
    static char fmt_159[] = "(/,6x,\002- FROM -    - TO -\002,11x,\002TRANSM"
	    "ISSION LINE\002,15x,\002-  -  SHUNT ADMITTANCES (MHOS)  -  -\002"
	    ",14x,\002LINE\002,/,6x,\002TAG  SEG.   TAG  SEG.\002,6x,\002IMPE"
	    "DANCE\002,6x,\002LENGTH\002,12x,\002- END ONE -\002,17x,\002- EN"
	    "D TWO -\002,12x,\002TYPE\002,/,6x,\002NO.   NO.   NO.   NO.\002,"
	    "9x,\002OHMS\002,8x,\002METERS\002,9x,\002REAL\002,10x,\002IMAG"
	    ".\002,9x,\002REAL\002,10x,\002IMAG.\002)";
    static char fmt_90[] = "(4x,4(i5,1x),6(3x,1pe11.4),3x,\002STRAIGHT\002)";
    static char fmt_91[] = "(4x,4(i5,1x),6(3x,1pe11.4),3x,\002CROSSED\002)";
    static char fmt_160[] = "(/,6x,\002- FROM -\002,4x,\002- TO -\002,26x"
	    ",\002-  -  ADMITTANCE MATRIX ELEMENTS (MHOS)  -  -\002,/,6x,\002"
	    "HTAG  SEG.   TAG  SEG.\002,13x,\002(ONE,ONE)\002,19x,\002(ONE,TW"
	    "O)\002,19x,\002(TWO,TWO)\002,/,6x,\002NO.   NO.   NO.   NO.\002,"
	    "8x,\002REAL\002,10x,\002IMAG.\002,9x,\002REAL\002,10x,\002IMAG"
	    ".\002,9x,\002REAL\002,10x,\002IMAG.\002)";
    static char fmt_92[] = "(4x,4(i5,1x),6(3x,1pe11.4))";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, is1, is2, ihead;

    /* Fortran I/O blocks */
    static cilist io___341 = { 0, 3, 0, fmt_158, 0 };
    static cilist io___344 = { 0, 3, 0, fmt_159, 0 };
    static cilist io___347 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___348 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___349 = { 0, 3, 0, fmt_160, 0 };
    static cilist io___350 = { 0, 3, 0, fmt_92, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTNETW prints a description of transmission lines and two port */
/*     networks that have been defined. */

/*     DESCRIPTION: */
/*     INPUT: FROM COMMON BLOCKS /NETDEF/ AND /DATA/ */
/*     OUTPUT: FROM COMMON BLOCKS /NETDEF/ AND /DATA/ */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    s_wsfe(&io___341);
    e_wsfe();
    ihead = 0;
    i__1 = netdef_1.nonet;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (netdef_1.netyp[i__ - 1] != 2 && netdef_1.netyp[i__ - 1] != 3) {
	    goto L1;
	}
	if (ihead == 0) {
	    s_wsfe(&io___344);
	    e_wsfe();
	    ihead = 1;
	}
	is1 = netdef_1.iseg1[i__ - 1];
	is2 = netdef_1.iseg2[i__ - 1];
	if (netdef_1.netyp[i__ - 1] == 2) {
	    s_wsfe(&io___347);
	    do_fio(&c__1, (char *)&data_1.itag[is1 - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&is1, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&data_1.itag[is2 - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&is2, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&netdef_1.tlzch[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&netdef_1.tllen[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__2, (char *)&netdef_1.tlyt1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__2, (char *)&netdef_1.tlyt2[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    e_wsfe();
	}
	if (netdef_1.netyp[i__ - 1] == 3) {
	    s_wsfe(&io___348);
	    do_fio(&c__1, (char *)&data_1.itag[is1 - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&is1, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&data_1.itag[is2 - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&is2, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&netdef_1.tlzch[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&netdef_1.tllen[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__2, (char *)&netdef_1.tlyt1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__2, (char *)&netdef_1.tlyt2[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    e_wsfe();
	}
L1:
	;
    }
    ihead = 0;
    i__1 = netdef_1.nonet;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (netdef_1.netyp[i__ - 1] != 1) {
	    goto L2;
	}
	if (ihead == 0) {
	    s_wsfe(&io___349);
	    e_wsfe();
	    ihead = 1;
	}
	is1 = netdef_1.iseg1[i__ - 1];
	is2 = netdef_1.iseg2[i__ - 1];
	s_wsfe(&io___350);
	do_fio(&c__1, (char *)&data_1.itag[is1 - 1], (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&is1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.itag[is2 - 1], (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&is2, (ftnlen)sizeof(integer));
	do_fio(&c__2, (char *)&netdef_1.yn11[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__2, (char *)&netdef_1.yn12[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__2, (char *)&netdef_1.yn22[i__ - 1], (ftnlen)sizeof(
		doublereal));
	e_wsfe();
L2:
	;
    }
    return 0;

} /* ptnetw_ */

/* Subroutine */ int ptpchc_(void)
{
    /* Format strings */
    static char fmt_197[] = "(////,41x,\002- - - - SURFACE PATCH CURRENTS - "
	    "- - -\002,//,50x,\002DISTANCES IN WAVELENGTHS (2.*PI/CABS(K))"
	    "\002,/,50x,\002CURRENT IN AMPS/METER\002,//,28x,\002- - SURFACE "
	    "COMPONENTS - -\002,19x,\002- - - RECTANGULAR COMPONENTS - - -"
	    "\002,/,6x,\002PATCH CENTER\002,6x,\002TANGENT VECTOR 1\002,3x"
	    ",\002TANGENT VECTOR 2\002,11x,\002X\002,19x,\002Y\002,19x,\002"
	    "Z\002,/,5x,\002X\002,6x,\002Y\002,6x,\002Z\002,5x,\002MAG.\002,7"
	    "x,\002PHASE\002,3x,\002MAG.\002,7x,\002PHASE\002,3(4x,\002REA"
	    "L\002,6x,\002IMAG. \002))";
    static char fmt_198[] = "(1x,i4,/,1x,3f7.3,2(1pe11.4,0pf8.2),1p6e10.2)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublecomplex xk;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    extern doublereal cang_(doublecomplex *);
    static integer ipat;
    static doublereal wlam;
    static integer icur;
    static doublecomplex curx, cury, curz;
    static doublereal xnor, ynor, znor;
    static integer ixyz;
    static doublecomplex curt1, curt2;
    static doublereal curt1a, curt2a, curt1m, curt2m;

    /* Fortran I/O blocks */
    static cilist io___354 = { 0, 3, 0, fmt_197, 0 };
    static cilist io___372 = { 0, 3, 0, fmt_198, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTPCHC prints a table of surface patch currents. */

/*     DESCRIPTION: */
/*     INPUT: FROM COMMON BLOCKS /DATA/, /CRNT/ AND /GND/ */

/*     OUTPUT: */
/*     IPAT = NUMBER OF THE PATCH */
/*     XNOR,YNOR,ZNOR = X, Y AND Z COORDINATES OF THE CENTER OF THE PATCH */
/*                      NORMALIZED TO WAVELENGTH */
/*     CURT1M,CURT1A = MAGNITUDE AND PHASE OF THE COMPONENT OF CURRENT */
/*                     ALONG UNIT VECTOR T1 ON THE SURFACE OF THE PATCH */
/*     CURT2M,CURT2A = MAGNITUDE AND PHASE OF THE COMPONENT OF CURRENT */
/*                     ALONG UNIT VECTOR T2 ON THE SURFACE OF THE PATCH */
/*     CURX,CURY,CURZ = X, Y AND Z COMPONENTS OF THE CURRENT ON THE PATCH */
/*                      (AMPS) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (data_1.m == 0) {
	return 0;
    }
    s_wsfe(&io___354);
    e_wsfe();
    icur = data_1.n - 2;
    ixyz = data_1.ld + 1;
    i__1 = data_1.m;
    for (ipat = 1; ipat <= i__1; ++ipat) {
	icur += 3;
	--ixyz;
	i__2 = icur - 1;
	curx.r = crnt_1.cur[i__2].r, curx.i = crnt_1.cur[i__2].i;
	i__2 = icur;
	cury.r = crnt_1.cur[i__2].r, cury.i = crnt_1.cur[i__2].i;
	i__2 = icur + 1;
	curz.r = crnt_1.cur[i__2].r, curz.i = crnt_1.cur[i__2].i;

/*     COMPUTE COMPONENTS OF CURRENT ALONG THE UNIT VECTORS T1 AND T2 */

	i__2 = ixyz - 1;
	z__3.r = t1x[i__2] * curx.r, z__3.i = t1x[i__2] * curx.i;
	i__3 = ixyz - 1;
	z__4.r = t1y[i__3] * cury.r, z__4.i = t1y[i__3] * cury.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = ixyz - 1;
	z__5.r = t1z[i__4] * curz.r, z__5.i = t1z[i__4] * curz.i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	curt1.r = z__1.r, curt1.i = z__1.i;
	i__2 = ixyz - 1;
	z__3.r = data_1.t2x[i__2] * curx.r, z__3.i = data_1.t2x[i__2] * 
		curx.i;
	i__3 = ixyz - 1;
	z__4.r = data_1.t2y[i__3] * cury.r, z__4.i = data_1.t2y[i__3] * 
		cury.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = ixyz - 1;
	z__5.r = data_1.t2z[i__4] * curz.r, z__5.i = data_1.t2z[i__4] * 
		curz.i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	curt2.r = z__1.r, curt2.i = z__1.i;
	curt1m = z_abs(&curt1);
	curt1a = cang_(&curt1);
	curt2m = z_abs(&curt2);
	curt2a = cang_(&curt2);

/*     COMPUTE PATCH COORDINATES NORMALIZED TO WAVELENGTH */

	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	if (data_1.z__[ixyz - 1] < 0.f) {
	    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	}
	wlam = 6.2831853071796 / z_abs(&xk);
	xnor = data_1.x[ixyz - 1] / wlam;
	ynor = data_1.y[ixyz - 1] / wlam;
	znor = data_1.z__[ixyz - 1] / wlam;
	s_wsfe(&io___372);
	do_fio(&c__1, (char *)&ipat, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&xnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ynor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&znor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&curt1m, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&curt1a, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&curt2m, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&curt2a, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&curx, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&cury, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&curz, (ftnlen)sizeof(doublereal));
	e_wsfe();
/* L1: */
    }
    return 0;

} /* ptpchc_ */

#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int ptrecn_(void)
{
    /* Format strings */
    static char fmt_181[] = "(///,4x,\002PTRECN: RECEIVING PATTERN STORAGE T"
	    "OO SMALL;\002,\002 ARRAY TRUNCATED\002)";
    static char fmt_182[] = "(///,32x,\002- - - NORMALIZED RECEIVING PATTERN"
	    " - - -\002,/,41x,\002NORMALIZATION FACTOR=\002,1pe11.4,/,41x,"
	    "\002ETA=\002,0pf7.2,\002 DEGREES\002,/,41x,\002TYPE -\002,a6,/,4"
	    "1x,\002AXIAL RATIO=\002,f6.3,/,41x,\002SEGMENT NO.=\002,i5,//,21"
	    "x,\002THETA\002,6x,\002PHI\002,9x,\002-  PATTERN  -\002,/,21x"
	    ",\002(DEG)\002,5x,\002(DEG)\002,8x,\002DB\002,8x,\002MAGNITUD"
	    "E\002,/)";
    static char fmt_183[] = "(20x,2(f7.2,3x),1x,f7.2,4x,1pe11.4)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    extern doublereal db20_(doublereal *);
    static doublereal pmax, patdb, patrcn;

    /* Fortran I/O blocks */
    static cilist io___373 = { 0, 3, 0, fmt_181, 0 };
    static cilist io___376 = { 0, 3, 0, fmt_182, 0 };
    static cilist io___379 = { 0, 3, 0, fmt_183, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTRECN prints a normalized receiving pattern table. */

/*     DESCRIPTION: */
/*     INPUT: FROM COMMON /RECPAT/ */

/*     OUTPUT: */
/*     THETRC = SPHERICAL COORDINATE ANGLE THETA (DEGREES) OF THE INCIDENT */
/*              PLANE WAVE */
/*     PHIRC = SPHERICAL COORDINATE ANGLE PHI (DEGREES) OF THE INCIDENT */
/*             PLANE WAVE */
/*     PATDB = NORMALIZED PATTERN VALUE IN DB */
/*     PATRCN = NORMALIZED PATTERN VALUE */

    if (recpat_1.maxrcx == 1) {
	s_wsfe(&io___373);
	e_wsfe();
    }
    pmax = recpat_1.patrc[0];
    i__1 = recpat_1.npatrc;
    for (i__ = 2; i__ <= i__1; ++i__) {
	if (recpat_1.patrc[i__ - 1] > pmax) {
	    pmax = recpat_1.patrc[i__ - 1];
	}
/* L1: */
    }
    s_wsfe(&io___376);
    do_fio(&c__1, (char *)&pmax, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&recpat_1.etarc, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, recpat_1.poltyp, (ftnlen)6);
    do_fio(&c__1, (char *)&recpat_1.aratrc, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&recpat_1.isegrp, (ftnlen)sizeof(integer));
    e_wsfe();
    i__1 = recpat_1.npatrc;
    for (i__ = 1; i__ <= i__1; ++i__) {
	patrcn = recpat_1.patrc[i__ - 1] / pmax;
	patdb = db20_(&patrcn);
/* L2: */
	s_wsfe(&io___379);
	do_fio(&c__1, (char *)&recpat_1.thetrc[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__1, (char *)&recpat_1.phirc[i__ - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__1, (char *)&patdb, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&patrcn, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

} /* ptrecn_ */

/* Subroutine */ int wcharg_(doublereal *dseg, integer *iseg, doublecomplex *
	qseg, doublereal *xsnor, doublereal *ysnor, doublereal *zsnor, 
	doublereal *sinor)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14;

    /* Builtin functions */
    void z_cos(doublecomplex *, doublecomplex *), z_sin(doublecomplex *, 
	    doublecomplex *), pow_zi(doublecomplex *, doublecomplex *, 
	    integer *), z_div(doublecomplex *, doublecomplex *, doublecomplex 
	    *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex xk;
    static doublereal wlam;
    static doublecomplex xkss;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     WCHARG computes the linear charge density at a point on a wire */
/*     using the previously computed current. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     DSEG = DISTANCE FROM THE CENTER OF SEGMENT ISEG TO THE POINT AT */
/*            WHICH THE CHARGE IS TO BE COMPUTED (M) */
/*     ISEG = NUMBER OF THE SEGMENT ON WHICH CHARGE IS TO BE COMPUTED */

/*     OUTPUT: */
/*     QSEG = LINEAR CHARGE DENSITY AT THE SPECIFIED POINT (COULOMBS/M) */
/*     XSNOR = X COORDINATE OF THE POINT NORMALIZED BY WAVELENGTH */
/*     YSNOR = Y COORDINATE OF THE POINT NORMALIZED BY WAVELENGTH */
/*     ZSNOR = Z COORDINATE OF THE POINT NORMALIZED BY WAVELENGTH */
/*     SINOR = LENGTH OF SEGMENT ISEG NORMALIZED BY WAVELENGTH */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
    if (data_1.z__[*iseg - 1] < 0.f) {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
    }
    i__1 = *iseg - 1;
    xkss.r = crnt_1.xks[i__1].r, xkss.i = crnt_1.xks[i__1].i;
    z__5.r = xk.r * xk.r - xk.i * xk.i, z__5.i = xk.r * xk.i + xk.i * xk.r;
    d__1 = z__5.r;
    z__4.r = d__1 * 0.f, z__4.i = d__1 * 1.f;
    z__3.r = z__4.r * xkss.r - z__4.i * xkss.i, z__3.i = z__4.r * xkss.i + 
	    z__4.i * xkss.r;
    pow_zi(&z__7, &xk, &c__2);
    z__6.r = gnd_1.omegag * z__7.r, z__6.i = gnd_1.omegag * z__7.i;
    z_div(&z__2, &z__3, &z__6);
    i__1 = *iseg - 1;
    z__11.r = *dseg * xkss.r, z__11.i = *dseg * xkss.i;
    z_cos(&z__10, &z__11);
    z__9.r = crnt_1.bix[i__1].r * z__10.r - crnt_1.bix[i__1].i * z__10.i, 
	    z__9.i = crnt_1.bix[i__1].r * z__10.i + crnt_1.bix[i__1].i * 
	    z__10.r;
    i__2 = *iseg - 1;
    z__14.r = *dseg * xkss.r, z__14.i = *dseg * xkss.i;
    z_sin(&z__13, &z__14);
    z__12.r = crnt_1.cix[i__2].r * z__13.r - crnt_1.cix[i__2].i * z__13.i, 
	    z__12.i = crnt_1.cix[i__2].r * z__13.i + crnt_1.cix[i__2].i * 
	    z__13.r;
    z__8.r = z__9.r - z__12.r, z__8.i = z__9.i - z__12.i;
    z__1.r = z__2.r * z__8.r - z__2.i * z__8.i, z__1.i = z__2.r * z__8.i + 
	    z__2.i * z__8.r;
    qseg->r = z__1.r, qseg->i = z__1.i;
    wlam = 6.2831853071796 / z_abs(&xk);
    *xsnor = (data_1.x[*iseg - 1] + data_1.alp[*iseg - 1] * *dseg) / wlam;
    *ysnor = (data_1.y[*iseg - 1] + data_1.bet[*iseg - 1] * *dseg) / wlam;
    *zsnor = (data_1.z__[*iseg - 1] + data_1.salp[*iseg - 1] * *dseg) / wlam;
    *sinor = data_1.si[*iseg - 1] / wlam;
    return 0;
} /* wcharg_ */

/* Subroutine */ int ptwirq_(integer *iptflq, integer *iptaq, integer *iptaqf,
	 integer *iptaqt)
{
    /* Format strings */
    static char fmt_315[] = "(///,34x,\002- - - CHARGE DENSITIES - - -\002,/"
	    "/,23x,\002LENGTHS NORMALIZED TO WAVELENGTH (OR 2.*PI/CABS(K))"
	    "\002,///,2x,\002SEG.\002,2x,\002TAG\002,4x,\002COORD. OF SEG. CE"
	    "NTER\002,5x,\002SEG.\002,10x,\002CHARGE DENSITY (COULOMBS/METER"
	    ")\002,/,2x,\002NO.\002,3x,\002NO.\002,5x,\002X\002,8x,\002Y\002,"
	    "8x,\002Z\002,6x,\002LENGTH\002,5x,\002REAL\002,8x,\002IMAG.\002,"
	    "7x,\002MAG.\002,8x,\002PHASE\002)";
    static char fmt_166[] = "(1x,i5,\002E\002,i4,3f9.4,f9.5,1x,1p3e12.4,0pf9"
	    ".3)";
    static char fmt_165[] = "(1x,2i5,3f9.4,f9.5,1x,1p3e12.4,0pf9.3)";

    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal ph;
    extern doublereal cang_(doublecomplex *);
    static doublereal qmag;
    static integer iseg;
    static doublecomplex qseg;
    static doublereal sinor, xsnor, ysnor, zsnor;
    extern /* Subroutine */ int wcharg_(doublereal *, integer *, 
	    doublecomplex *, doublereal *, doublereal *, doublereal *, 
	    doublereal *);
    static integer icount;

    /* Fortran I/O blocks */
    static cilist io___383 = { 0, 3, 0, fmt_315, 0 };
    static cilist io___393 = { 0, 3, 0, fmt_166, 0 };
    static cilist io___394 = { 0, 3, 0, fmt_165, 0 };
    static cilist io___395 = { 0, 3, 0, fmt_166, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTWIRQ prints the linear charge density on wire segments. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     IPTFLQ = PRINT CONTROL FLAG FOR CHARGE (FIRST INTEGER FROM PQ */
/*              COMMAND) */
/*     IPTAQ = SEGMENT TAG FOR PRINTING A LIMITED RANGE OF SEGMENTS */
/*     IPTAQF,IPTAQT = SEGMENT NUMBERS FOR PRINTING A LIMITED RANGE OF */
/*                     SEGMENTS.  CHARGE IS PRINTED FOR SEGMENTS HAVING */
/*                     TAGS EQUAL TO IPTAQ FROM SEGMENT IPTAQF THROUGH */
/*                     SEGMENT IPTAQT. */

/*     OUTPUT: */
/*     ISEG = SEGMENT NUMBER */
/*     ITAG = SEGMENT TAG */
/*     XSNOR,YSNOR,ZSNOR = X, Y AND Z COORDINATES OF THE SEGMENT CENTER */
/*                         NORMALIZED TO WAVELENGTH */
/*     SINOR = SEGMENT LENGTH NORMALIZED TO WAVELENGTH */
/*     QSEG = LINEAR CHARGE DENSITY (COULOMBS/M) */
/*     QMAG = MAGNITUDE OF QSEG */
/*     PH = PHASE OF QSEG */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (data_1.n == 0) {
	return 0;
    }
    s_wsfe(&io___383);
    e_wsfe();
    icount = 0;
    i__1 = data_1.n;
    for (iseg = 1; iseg <= i__1; ++iseg) {
	if (*iptflq == 0) {

/*     CHECK WHETHER SEGMENT ISEG IS IN THE LIMITED PRINTING RANGE */

	    if (*iptaq != 0 && *iptaq != data_1.itag[iseg - 1]) {
		goto L69;
	    }
	    ++icount;
	    if (icount < *iptaqf || icount > *iptaqt) {
		goto L69;
	    }
	}
	if (data_1.icon1[iseg - 1] == 0) {

/*     END ONE OF SEGMENT ISEG IS A FREE END.  PRINT CHARGE. */

	    d__1 = data_1.si[iseg - 1] * -.5f;
	    wcharg_(&d__1, &iseg, &qseg, &xsnor, &ysnor, &zsnor, &sinor);
	    qmag = z_abs(&qseg);
	    ph = cang_(&qseg);
	    s_wsfe(&io___393);
	    do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&data_1.itag[iseg - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&xsnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ysnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&zsnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&sinor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&qseg, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&qmag, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ph, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}

/*     PRINT CHARGE AT THE CENTER OF SEGMENT ISEG. */

	wcharg_(&c_b332, &iseg, &qseg, &xsnor, &ysnor, &zsnor, &sinor);
	qmag = z_abs(&qseg);
	ph = cang_(&qseg);
	s_wsfe(&io___394);
	do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.itag[iseg - 1], (ftnlen)sizeof(integer))
		;
	do_fio(&c__1, (char *)&xsnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ysnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zsnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&sinor, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&qseg, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&qmag, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ph, (ftnlen)sizeof(doublereal));
	e_wsfe();
	if (data_1.icon2[iseg - 1] == 0) {

/*     END TWO OF SEGMENT ISEG IS A FREE END.  PRINT CHARGE. */

	    d__1 = data_1.si[iseg - 1] * .5f;
	    wcharg_(&d__1, &iseg, &qseg, &xsnor, &ysnor, &zsnor, &sinor);
	    qmag = z_abs(&qseg);
	    ph = cang_(&qseg);
	    s_wsfe(&io___395);
	    do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&data_1.itag[iseg - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&xsnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ysnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&zsnor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&sinor, (ftnlen)sizeof(doublereal));
	    do_fio(&c__2, (char *)&qseg, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&qmag, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ph, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
L69:
	;
    }
    return 0;

} /* ptwirq_ */

/* Subroutine */ int ptrecp_(doublereal *thet, doublereal *phi, doublereal *
	eta, doublereal *axrat, integer *iptflg, integer *iptag, integer *
	iptagf, integer *iptagt, integer *inc)
{
    /* Initialized data */

    static char hpol[6*3] = "LINEAR" "RIGHT " "LEFT  ";
    static integer maxrcp = 200;

    /* Format strings */
    static char fmt_163[] = "(///,33x,\002- - - RECEIVING PATTERN PARAMETERS"
	    " - - -\002,/,43x,\002ETA=\002,f7.2,\002 DEGREES\002,/,43x,\002TY"
	    "PE -\002,a6,/,43x,\002AXIAL RATIO=\002,f6.3,//,11x,\002THETA\002"
	    ",6x,\002PHI\002,10x,\002-  CURRENT  -\002,9x,\002SEG\002,/,11x"
	    ",\002(DEG)\002,5x,\002(DEG)\002,7x,\002MAGNITUDE\002,4x,\002PHASE"
	    "\002,6x,\002NO.\002,/)";
    static char fmt_164[] = "(10x,2(f7.2,3x),1x,1pe11.4,3x,0pf7.2,4x,i5)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublereal ph, cmag;
    extern doublereal cang_(doublecomplex *);
    static integer iseg;
    static doublecomplex curi;
    static integer icount;

    /* Fortran I/O blocks */
    static cilist io___398 = { 0, 3, 0, fmt_163, 0 };
    static cilist io___404 = { 0, 3, 0, fmt_164, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTRECP prints structure currents in a format for receiving */
/*     patterns. */

/*     DESCRIPTION: */
/*     EACH TIME THAT PTRECP IS CALLED IT PRINTS THE CURRENTS ON SEGMENTS */
/*     WITHIN THE SPECIFIED RANGE IN A FORMAT FOR RECEIVING PATTERNS. */
/*     WHEN IT IS CALLED WITH INC=1 IT PRINTS A HEADING FOR THE TABLE. */
/*     PTRECP ALSO STORES THE VALUES IN COMMON/RECPAT/ FOR SUBSEQUENT */
/*     PRINTING OF NORMALIZED RECEIVING PATTERN. */

/*     INPUT: */
/*     THET,PHI = ANGLES (DEGREES) IN SPHERICAL COORDINATES OF THE VECTOR */
/*                TOWARD THE SOURCE OF THE PLANE WAVE. */
/*     ETA = POLARIZATION ANGLE OF E FIELD.  FOR ETA=0, E FIELD IS ALONG */
/*           THE THETA UNIT VECTOR.  POSITIVE ETA ROTATES POLARIZATION */
/*           COUNTER CLOCKWISE WHEN VIEWED IN THE DIRECTION OF PROPAGATION */
/*     AXRAT = RATIO OF MINOR AXIS TO MAJOR AXIS FIELD OF AN ELLIPTICALLY */
/*             POLARIZED INCIDENT WAVE */
/*     IPTFLG = PRINT CONTROL FLAG FOR CURRENT (FIRST INTEGER FROM PT */
/*              COMMAND) */
/*     IPTAG = SEGMENT TAG FOR PRINTING A LIMITED RANGE OF SEGMENTS */
/*     IPTAGF,IPTAGT = SEGMENT NUMBERS FOR PRINTING A LIMITED RANGE OF */
/*                     SEGMENTS.  CURRENT IS PRINTED FOR SEGMENTS HAVING */
/*                     TAGS EQUAL TO IPTAG FROM SEGMENT IPTAGF THROUGH */
/*                     SEGMENT IPTAGT. */
/*     INC = ARRAY INDEX FOR STORING VALUES IN COMMON/RECPAT/ */

/*     OUTPUT: */
/*     ETARC = ETA FROM INPUT */
/*     POLTYP = DESCRIPTION OF ELLIPTIC POLARIZATION (CHARACTER) */
/*     ARATRC = AXRAT FROM INPUT */
/*     THET,PHI = SAME AS INPUT */
/*     CMAG = MAGNITUDE OF CURRENT (AMPS) */
/*     PH = PHASE OF CURRENT (DEGREES) */
/*     ISEG = SEGMENT NUMBER */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (data_1.n == 0) {
	return 0;
    }
    if (*inc == 1) {

/*     PRINT HEADING */

	if (*axrat > 1e-5f) {
	    s_copy(recpat_1.poltyp, hpol + 6, (ftnlen)6, (ftnlen)6);
	} else if (*axrat < -1e-5f) {
	    s_copy(recpat_1.poltyp, hpol + 12, (ftnlen)6, (ftnlen)6);
	} else {
	    s_copy(recpat_1.poltyp, hpol, (ftnlen)6, (ftnlen)6);
	}
	recpat_1.aratrc = abs(*axrat);
	recpat_1.etarc = *eta;
	recpat_1.maxrcx = 0;
	if (*iptflg != 3) {
	    s_wsfe(&io___398);
	    do_fio(&c__1, (char *)&recpat_1.etarc, (ftnlen)sizeof(doublereal))
		    ;
	    do_fio(&c__1, recpat_1.poltyp, (ftnlen)6);
	    do_fio(&c__1, (char *)&recpat_1.aratrc, (ftnlen)sizeof(doublereal)
		    );
	    e_wsfe();
	}
    }
    icount = 0;

/*     LOOP TO PRINT CURRENTS */

    i__1 = data_1.n;
    for (iseg = 1; iseg <= i__1; ++iseg) {
	if (*iptag != 0 && *iptag != data_1.itag[iseg - 1]) {
	    goto L69;
	}
	++icount;
	if (icount < *iptagf || icount > *iptagt) {
	    goto L69;
	}
	i__2 = iseg - 1;
	curi.r = crnt_1.cur[i__2].r, curi.i = crnt_1.cur[i__2].i;
	cmag = z_abs(&curi);
	ph = cang_(&curi);
	if (*iptflg != 3) {
	    s_wsfe(&io___404);
	    do_fio(&c__1, (char *)&(*thet), (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&(*phi), (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&cmag, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ph, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	    e_wsfe();
	}
	if (*iptflg < 2) {
	    goto L69;
	}
	if (*inc > maxrcp) {

/*     ARRAY IS FULL SO CAN'T STORE ANY MORE CURRENTS FOR NORM. RAD. PAT. */

	    recpat_1.maxrcx = 1;
	    goto L69;
	}

/*     STORE ANGLES AND CURRENT FOR NORMALIZED RADIATION PATTERN TABLE */

	recpat_1.thetrc[*inc - 1] = *thet;
	recpat_1.phirc[*inc - 1] = *phi;
	recpat_1.patrc[*inc - 1] = cmag;
	recpat_1.npatrc = *inc;
	recpat_1.isegrp = iseg;
L69:
	;
    }
    return 0;

} /* ptrecp_ */

/* Subroutine */ int ptwirc_(integer *iptflg, integer *iptag, integer *iptagf,
	 integer *iptagt)
{
    /* Format strings */
    static char fmt_161[] = "(///,29x,\002- - - CURRENTS AND LOCATION - - "
	    "-\002,//,21x,\002LENGTHS NORMALIZED BY WAVELENGTH (OR 2.*PI/CABS"
	    "(K))\002,//,2x,\002SEG.\002,2x,\002TAG\002,4x,\002COORD. OF SEG."
	    " CENTER\002,5x,\002SEG.\002,12x,\002- - - CURRENT (AMPS) - - "
	    "-\002,/,2x,\002NO.\002,3x,\002NO.\002,5x,\002X\002,8x,\002Y\002,"
	    "8x,\002Z\002,6x,\002LENGTH\002,5x,\002REAL\002,8x,\002IMAG.\002,"
	    "7x,\002MAG.\002,8x,\002PHASE\002)";
    static char fmt_165[] = "(1x,2i5,3f9.4,f9.5,1x,1p3e12.4,0pf9.3)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal ph;
    static doublecomplex xk;
    static doublereal cmag;
    extern doublereal cang_(doublecomplex *);
    static integer iseg;
    static doublereal wlam;
    static doublecomplex curi;
    static doublereal snorm, xnorm, ynorm, znorm;
    static integer icount;

    /* Fortran I/O blocks */
    static cilist io___405 = { 0, 3, 0, fmt_161, 0 };
    static cilist io___417 = { 0, 3, 0, fmt_165, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTWIRC prints a table of currents on wire segments. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     IPTFLG = PRINT CONTROL FLAG FOR CURRENT (FIRST INTEGER FROM PT */
/*              COMMAND) */
/*     IPTAG = SEGMENT TAG FOR PRINTING A LIMITED RANGE OF SEGMENTS */
/*     IPTAGF,IPTAGT = SEGMENT NUMBERS FOR PRINTING A LIMITED RANGE OF */
/*                     SEGMENTS.  CURRENT IS PRINTED FOR SEGMENTS HAVING */
/*                     TAGS EQUAL TO IPTAG FROM SEGMENT IPTAGF THROUGH */
/*                     SEGMENT IPTAGT. */
/*     OTHER INPUT FROM COMMON BLOCKS /DATA/, /GND/ AND /CRNT/ */

/*     OUTPUT: */
/*     ISEG = SEGMENT NUMBER */
/*     ITAG = TAG NUMBER OF SEGMENT */
/*     XNORM,YNORM,ZNORM = X, Y AND Z COORDINATES OF THE CENTER OF THE */
/*                         SEGMENT, NORMALIZED TO WAVELENTGH */
/*     SNORM = SEGMENT LENGTH NORMALIZED TO WAVELENGTH */
/*     CURI = SEGMENT CURRENT (AMPS, COMPLEX) */
/*     CMAG = MAGNITUDE OF CURI (AMPS) */
/*     PH = PHASE OF CURI (DEGREES) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (*iptflg == -1) {
	return 0;
    }
    if (data_1.n == 0) {
	return 0;
    }
    s_wsfe(&io___405);
    e_wsfe();
    icount = 0;
    i__1 = data_1.n;
    for (iseg = 1; iseg <= i__1; ++iseg) {
	if (*iptflg == 0) {

/*     CURRENTS PRINTED FOR LIMITED RANGE OF SEGMENTS.  CHECK TAGS. */

	    if (*iptag != 0 && *iptag != data_1.itag[iseg - 1]) {
		goto L69;
	    }
	    ++icount;
	    if (icount < *iptagf || icount > *iptagt) {
		goto L69;
	    }
	}

/*     PRINT SEGMENT COORDINATES AND CURRENT */

	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	if (data_1.z__[iseg - 1] < 0.f) {
	    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	}
	wlam = 6.2831853071796 / z_abs(&xk);
	xnorm = data_1.x[iseg - 1] / wlam;
	ynorm = data_1.y[iseg - 1] / wlam;
	znorm = data_1.z__[iseg - 1] / wlam;
	snorm = data_1.si[iseg - 1] / wlam;
	i__2 = iseg - 1;
	curi.r = crnt_1.cur[i__2].r, curi.i = crnt_1.cur[i__2].i;
	cmag = z_abs(&curi);
	ph = cang_(&curi);
	s_wsfe(&io___417);
	do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.itag[iseg - 1], (ftnlen)sizeof(integer))
		;
	do_fio(&c__1, (char *)&xnorm, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ynorm, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&znorm, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&snorm, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&curi, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&cmag, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ph, (ftnlen)sizeof(doublereal));
	e_wsfe();
L69:
	;
    }
    return 0;

} /* ptwirc_ */

/* Subroutine */ int pwrbgt_(doublereal *pin, doublereal *pnls, doublereal *
	ploss)
{
    /* Format strings */
    static char fmt_90[] = "(///,40x,\002- - - POWER BUDGET - - -\002,//,4"
	    "3x,\002INPUT POWER   =\002,1pe11.4,\002 WATTS\002,/,43x,\002RADI"
	    "ATED POWER=\002,e11.4,\002 WATTS\002,/,43x,\002WIRE LOSS     "
	    "=\002,e11.4,\002 WATTS\002)";
    static char fmt_91[] = "(43x,\002SHEATH LOSS   =\002,1pe11.4,\002 WATT"
	    "S\002)";
    static char fmt_92[] = "(43x,\002NETWORK LOSS  =\002,1pe11.4,\002 WATT"
	    "S\002)";
    static char fmt_93[] = "(43x,\002EFFICIENCY    =\002,f7.2,\002 PERCEN"
	    "T\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static doublereal effncy, pwrrad;
    extern /* Subroutine */ int wirlos_(doublereal *, doublereal *);
    static doublereal psloss, pwloss;

    /* Fortran I/O blocks */
    static cilist io___422 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___423 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___424 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___425 = { 0, 3, 0, fmt_93, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PWRBGT prints a power budget of input power, radiated power and */
/*     dissipated power. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     PIN = TOTAL INPUT POWER FROM VOLTAGE SOURCES (WATTS) */
/*     PNLS = TOTAL POWER DISSIPATED IN NETWORKS AND TRANSMISSION LINES */
/*            (WATTS) */
/*     OTHER INPUT FROM COMMON BLOCKS */

/*     OUTPUT: */
/*     PLOSS = TOTAL POWER DISSIPATED IN WIRES AND SHEATH */

    wirlos_(&pwloss, &psloss);
    *ploss = pwloss + psloss;
    pwrrad = *pin - *pnls - *ploss;
    effncy = pwrrad * 100.f / *pin;
    s_wsfe(&io___422);
    do_fio(&c__1, (char *)&(*pin), (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&pwrrad, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&pwloss, (ftnlen)sizeof(doublereal));
    e_wsfe();
    if (psloss > 0.f) {
	s_wsfe(&io___423);
	do_fio(&c__1, (char *)&psloss, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    if (*pnls > 0.f) {
	s_wsfe(&io___424);
	do_fio(&c__1, (char *)&(*pnls), (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    s_wsfe(&io___425);
    do_fio(&c__1, (char *)&effncy, (ftnlen)sizeof(doublereal));
    e_wsfe();
    return 0;

} /* pwrbgt_ */

/* Subroutine */ int wirlos_(doublereal *pwloss, doublereal *psloss)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *), sin(doublereal), sinh(doublereal), log(
	    doublereal);

    /* Local variables */
    static integer i__;
    static doublecomplex xk;
    static doublereal sf1, sf2, arg, cint, zarr, bmags, cmags, epcon, xmags;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     WIRLOS computes the power dissipated by ohmic loss in wires and */
/*     in lossy sheaths. */

/*     INPUT: FROM COMMON BLOCKS */

/*     OUTPUT: */
/*     PWLOSS = POWER DISSIPATED IN FINITELY CONDUCTING WIRES */
/*     PSLOSS = POWER DISSIPATED IN A LOSSY SHEATH ON THE WIRE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    *pwloss = 0.f;
    *psloss = 0.f;

/*     COMPUTE OHMIC LOSS ON WIRE SEGMENTS */

    if (zload_1.nload != 0 || zload_1.nlodf != 0) {
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    i__2 = i__ - 1;
	    z__1.r = zload_1.zarray[i__2].r * gnd_1.xku.r - zload_1.zarray[
		    i__2].i * gnd_1.xku.i, z__1.i = zload_1.zarray[i__2].r * 
		    gnd_1.xku.i + zload_1.zarray[i__2].i * gnd_1.xku.r;
	    zarr = z__1.r;
	    if (abs(zarr) < 1e-20f) {
		goto L1;
	    }
	    i__2 = i__ - 1;
	    d_cnjg(&z__2, &crnt_1.cur[i__ - 1]);
	    z__1.r = crnt_1.cur[i__2].r * z__2.r - crnt_1.cur[i__2].i * 
		    z__2.i, z__1.i = crnt_1.cur[i__2].r * z__2.i + crnt_1.cur[
		    i__2].i * z__2.r;
	    *pwloss += z__1.r * zarr * data_1.si[i__ - 1];
L1:
	    ;
	}
	*pwloss *= .5f;
    }

/*     LOSS IN WIRE SHEATH */

    if (inscom_1.nins != 0 || inscom_1.ninsf != 0) {
/*        EPCON=-1./(4.*PI*OMEGA*EPSRZ) */
	epcon = -1.f / (gnd_1.omegag * 1.1126e-10f);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (inscom_1.brins[i__ - 1] == 0.f) {
		goto L3;
	    }
	    i__2 = i__ - 1;
	    xk.r = crnt_1.xks[i__2].r, xk.i = crnt_1.xks[i__2].i;
	    i__2 = i__ - 1;
/* Computing 2nd power */
	    d__1 = crnt_1.bix[i__2].r;
/* Computing 2nd power */
	    d__2 = d_imag(&crnt_1.bix[i__ - 1]);
	    bmags = d__1 * d__1 + d__2 * d__2;
/* Computing 2nd power */
	    d__1 = xk.r;
/* Computing 2nd power */
	    d__2 = d_imag(&xk);
	    xmags = d__1 * d__1 + d__2 * d__2;
	    arg = xk.r * data_1.si[i__ - 1];
	    if (abs(arg) < .01f) {
		cint = data_1.si[i__ - 1] * xmags * bmags;
	    } else {
		sf1 = sin(arg) / arg;
		arg = d_imag(&xk) * data_1.si[i__ - 1];
		sf2 = 1.f;
		if (abs(arg) > .001f) {
		    sf2 = sinh(arg) / arg;
		}
		i__2 = i__ - 1;
/* Computing 2nd power */
		d__1 = crnt_1.cix[i__2].r;
/* Computing 2nd power */
		d__2 = d_imag(&crnt_1.cix[i__ - 1]);
		cmags = d__1 * d__1 + d__2 * d__2;
		cint = data_1.si[i__ - 1] * .5f * xmags * ((sf1 + sf2) * 
			bmags + (sf2 - sf1) * cmags);
	    }
	    i__2 = i__ - 1;
/* Computing 2nd power */
	    d__1 = inscom_1.ceins[i__2].r;
/* Computing 2nd power */
	    d__2 = d_imag(&inscom_1.ceins[i__ - 1]);
	    xmags = log(inscom_1.brins[i__ - 1] / data_1.bi[i__ - 1]) / (d__1 
		    * d__1 + d__2 * d__2);
	    *psloss += epcon * d_imag(&inscom_1.ceins[i__ - 1]) * xmags * 
		    cint;
L3:
	    ;
	}
    }
    return 0;
} /* wirlos_ */

/* Subroutine */ int ptexct_(integer *iptflg)
{
    /* Initialized data */

    static char hpol[6*3] = "LINEAR" "RIGHT " "LEFT  ";

    /* Format strings */
    static char fmt_154[] = "(///,40x,\002- - - EXCITATION - - -\002)";
    static char fmt_155[] = "(/,4x,\002PLANE WAVE\002,4x,\002THETA=\002,f7"
	    ".2,\002 DEG,  PHI=\002,f7.2,\002 DEG,  ETA=\002,f7.2,\002 DEG,  "
	    "TYPE -\002,a6,\002=  AXIAL RATIO=\002,f6.3)";
    static char fmt_156[] = "(/,31x,\002POSITION (METERS)\002,14x,\002ORIENT"
	    "ATION (DEG)=\002,/,28x,\002X\002,12x,\002Y\002,12x,\002Z\002,10x,"
	    "\002ALPHA\002,5x,\002BETA\002,4x,\002DIPOLE MOMENT\002,//,4x,"
	    "\002CURRENT SOURCE\002,1x,3(3x,f10.5),1x,2(3x,f7.2),4x,f8.3)";

    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, isp, ipol;
    static doublereal axrat;
    static integer iphead;

    /* Fortran I/O blocks */
    static cilist io___441 = { 0, 3, 0, fmt_154, 0 };
    static cilist io___444 = { 0, 3, 0, fmt_155, 0 };
    static cilist io___445 = { 0, 3, 0, fmt_156, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PTEXCT prints a description of the excitation for an incident */
/*     plane wave or hertzian dipole source. */

/*     DESCRIPTION: */
/*     INPUT: */
/*     IPTFLG = PRINT CONTROL FLAG FOR CURRENTS.  IF CURRENTS ARE TO BE */
/*              PRINTED IN THE RECEIVING PATTERN FORMAT THEN THE PLANE */
/*              WAVE DISCRIPTION IS NOT PRINTED AT THIS POINT. */
/*     OTHER INPUT FROM COMMON /SORCES/ */

/*     OUTPUT: */
/*     FROM COMMON /SORCES/ */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    iphead = 0;

/*     SEARCH SOURCE ARRAY FOR PLANE WAVE OR HERTZIAN DIPOLE SOURCES. */
/*     NOTHING IS DONE FOR VOLTAGE SOURCES. */
    i__1 = sorces_1.nsorc;
    for (i__ = 1; i__ <= i__1; ++i__) {
	isp = sorces_1.isortp[i__ - 1];
	if (isp == 1 || isp == 4) {
	    goto L1;
	}
	if ((*iptflg <= 0 || isp == 3) && iphead == 0) {

/*     PRINT HEADING FOR PLANE WAVE OR HERTZIAN DIPOLE SOURCE */

	    s_wsfe(&io___441);
	    e_wsfe();
	    iphead = 1;
	}
	if (isp == 2 && *iptflg <= 0) {

/*     PRINT DESCRIPTION OF INCIDENT PLANE WAVE */

	    if (sorces_1.psor5[i__ - 1] == 0.f) {
		ipol = 1;
	    }
	    if (sorces_1.psor5[i__ - 1] > 0.f) {
		ipol = 2;
	    }
	    if (sorces_1.psor5[i__ - 1] < 0.f) {
		ipol = 3;
	    }
	    axrat = (d__1 = sorces_1.psor5[i__ - 1], abs(d__1));
	    s_wsfe(&io___444);
	    do_fio(&c__1, (char *)&sorces_1.psor1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor2[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor3[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, hpol + (ipol - 1) * 6, (ftnlen)6);
	    do_fio(&c__1, (char *)&axrat, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}

/*     PRINT DESCRIPTION OF HERTZIAN DIPOLE SOURCE */

	if (isp == 3) {
	    s_wsfe(&io___445);
	    do_fio(&c__1, (char *)&sorces_1.psor1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor2[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor3[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor4[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor5[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&sorces_1.psor6[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    e_wsfe();
	}
L1:
	;
    }
    return 0;

} /* ptexct_ */

/* Subroutine */ int ffld_(doublereal *thet, doublereal *phi, doublecomplex *
	eth, doublecomplex *eph)
{
    /* Initialized data */

    static doublecomplex cons = {0.,.07957747151};

    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    double sin(doublereal), cos(doublereal), d_imag(doublecomplex *);

    /* Local variables */
#define s ((doublereal *)&data_1 + 4840)
    static doublecomplex ex, ey, ez, xk;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex eta;
    static doublereal cph, cth;
    static doublecomplex cex, cey, cez, ckx, cky, ckz;
    static doublereal sph;
    static doublecomplex rex, rey, rez;
    static doublereal sth, phx, phy, thx, thy, thz, rox;
    static doublecomplex xkx;
    static doublereal roy, roz, side;
    static doublecomplex ckzx, yste, zstm, const__;
    extern /* Subroutine */ int refcof_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, integer *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *), fflref_(
	    doublecomplex *, doublecomplex *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublecomplex *, doublecomplex *, doublecomplex *), ffldir_(
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublereal *, doublecomplex *, doublecomplex *, doublecomplex *)
	    ;
    static integer iperfg;
    extern /* Subroutine */ int trxcof_(doublereal *, doublereal *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *), trxkno_(
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *), 
	    zysurf_(doublereal *, doublereal *, doublereal *, doublereal *, 
	    integer *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FFLD calculates the far zone radiated electric fields. */

/*     DESCRIPTION: */
/*     FFLD CALLS SUBROUTINES TO COMPUTE THE RADIATED ELECTRIC FIELD OF */
/*     A STRUCTURE.  IF A GROUND PLANE IS PRESENT, FFLD COMPUTES THE */
/*     TOTAL FIELD INCLUDING DIRECT AND REFLECTED FIELD AND FIELD */
/*     TRANSMITTED ACROSS THE INTERFACE.  SURFACE WAVE IS NOT INCLUDED. */
/*     THE FACTOR EXP(-J*K*R)/R IS OMITTED FROM THE RESULT. */

/*     INPUT: */
/*     THET,PHI = SPHERICAL COORDINATE ANGLES (RADIANS) OF THE VECTOR */
/*                IN THE DIRECTION IN WHICH THE RADIATED FIELD IS TO BE */
/*                COMPUTED */
/*     OTHER INPUT FROM COMMON BLOCKS /DATA/ AND /GND/ */

/*     OUTPUT: */
/*     ETH,EPH = COMPONENT OF (E FIELD)*R*EXP(-J*K*R) ALONG THE UNIT */
/*               VECTORS THETA AND PHI, RESPECTIVELY */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    z__3.r = -gnd_1.xku.r, z__3.i = -gnd_1.xku.i;
    z__2.r = z__3.r * gnd_1.etau.r - z__3.i * gnd_1.etau.i, z__2.i = z__3.r * 
	    gnd_1.etau.i + z__3.i * gnd_1.etau.r;
    z__1.r = z__2.r * cons.r - z__2.i * cons.i, z__1.i = z__2.r * cons.i + 
	    z__2.i * cons.r;
    const__.r = z__1.r, const__.i = z__1.i;
    sph = sin(*phi);
    cph = cos(*phi);
    sth = sin(*thet);
    cth = cos(*thet);
    phx = -sph;
    phy = cph;
    thx = cth * cph;
    thy = cth * sph;
    thz = -sth;
    rox = sth * cph;
    roy = sth * sph;
    roz = cth;

/*     SET FIELD TO ZERO BELOW PERFECTLY CONDUCTING GROUND */

    if (gnd_1.iperf != 1 || roz > -1e-7f) {
	goto L4;
    }
    eth->r = 0.f, eth->i = 0.f;
    eph->r = 0.f, eph->i = 0.f;
    return 0;

/*     SET PARAMETERS FOR FIELD ABOVE OR BELOW INTERFACE */

L4:
    if (gnd_1.iperf != 1 && roz < -1e-7f) {
	goto L1;
    }
    xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
    xkx.r = gnd_1.xkl.r, xkx.i = gnd_1.xkl.i;
    eta.r = gnd_1.etau.r, eta.i = gnd_1.etau.i;
    side = 1.f;
    goto L2;
L1:
    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
    xkx.r = gnd_1.xku.r, xkx.i = gnd_1.xku.i;
    eta.r = gnd_1.etal.r, eta.i = gnd_1.etal.i;
    side = -1.f;
L2:
    if (gnd_1.ksymp == 1) {
	side = 0.f;
    }

/*     SET FIELD TO ZERO BELOW INTERFACE OF CONDUCTING GROUND */

    if (gnd_1.ksymp == 1) {
	goto L3;
    }
    if ((d__2 = d_imag(&xk), abs(d__2)) < (d__1 = xk.r, abs(d__1)) * 1e-6f) {
	goto L3;
    }
    eth->r = 0.f, eth->i = 0.f;
    eph->r = 0.f, eph->i = 0.f;
    return 0;

/*     CALCULATE DIRECT FIELD FROM SEGMENTS ON NEAR SIDE OF INTERFACE */

L3:
    d__1 = -rox;
    z__1.r = d__1 * xk.r, z__1.i = d__1 * xk.i;
    ckx.r = z__1.r, ckx.i = z__1.i;
    d__1 = -roy;
    z__1.r = d__1 * xk.r, z__1.i = d__1 * xk.i;
    cky.r = z__1.r, cky.i = z__1.i;
    d__1 = -roz;
    z__1.r = d__1 * xk.r, z__1.i = d__1 * xk.i;
    ckz.r = z__1.r, ckz.i = z__1.i;
    ffldir_(&xk, &ckx, &cky, &ckz, &side, &ex, &ey, &ez);
    if (gnd_1.ksymp == 1) {
	goto L29;
    }

/*     ADD REFLECTED FIELD FOR UNIFORM GROUND */

    if (gnd_1.iclift != 0 || gnd_1.nradl != 0) {
	goto L5;
    }
    z__1.r = -ckz.r, z__1.i = -ckz.i;
    ffldir_(&xk, &ckx, &cky, &z__1, &side, &cex, &cey, &cez);
    zysurf_(&cth, &c_b332, &c_b332, &side, &iperfg, &yste, &zstm);
    refcof_(&cth, &phx, &phy, &eta, &gnd_1.iperf, &yste, &zstm, &cex, &cey, &
	    cez, &rex, &rey, &rez);
    goto L6;

/*     ADD REFLECTED FIELD FOR VARYING GROUND */

L5:
    fflref_(&xk, &eta, &phx, &phy, &rox, &roy, &roz, &side, &rex, &rey, &rez);
L6:
    z__1.r = ex.r + rex.r, z__1.i = ex.i + rex.i;
    ex.r = z__1.r, ex.i = z__1.i;
    z__1.r = ey.r + rey.r, z__1.i = ey.i + rey.i;
    ey.r = z__1.r, ey.i = z__1.i;
    z__1.r = ez.r + rez.r, z__1.i = ez.i + rez.i;
    ez.r = z__1.r, ez.i = z__1.i;

/*     ADD FIELD TRANSMITED ACROSS THE INTERFACE */

    if (gnd_1.iperf == 1) {
	goto L29;
    }
    trxkno_(&cth, &xk, &xkx, &ckzx);
    d__1 = -side;
    ffldir_(&xkx, &ckx, &cky, &ckzx, &d__1, &cex, &cey, &cez);
    trxcof_(&phx, &phy, &ckz, &ckzx, &xk, &xkx, &cex, &cey, &cez, &rex, &rey, 
	    &rez);
    z__1.r = ex.r + rex.r, z__1.i = ex.i + rex.i;
    ex.r = z__1.r, ex.i = z__1.i;
    z__1.r = ey.r + rey.r, z__1.i = ey.i + rey.i;
    ey.r = z__1.r, ey.i = z__1.i;
    z__1.r = ez.r + rez.r, z__1.i = ez.i + rez.i;
    ez.r = z__1.r, ez.i = z__1.i;

/*     CONVERT TO THETA AND PHI COMPONENTS OF RADIATED FIELD */

L29:
    z__4.r = thx * ex.r, z__4.i = thx * ex.i;
    z__5.r = thy * ey.r, z__5.i = thy * ey.i;
    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
    z__6.r = thz * ez.r, z__6.i = thz * ez.i;
    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
    z__1.r = z__2.r * const__.r - z__2.i * const__.i, z__1.i = z__2.r * 
	    const__.i + z__2.i * const__.r;
    eth->r = z__1.r, eth->i = z__1.i;
    z__3.r = phx * ex.r, z__3.i = phx * ex.i;
    z__4.r = phy * ey.r, z__4.i = phy * ey.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * const__.r - z__2.i * const__.i, z__1.i = z__2.r * 
	    const__.i + z__2.i * const__.r;
    eph->r = z__1.r, eph->i = z__1.i;
    return 0;
} /* ffld_ */

#undef sab
#undef cab
#undef s


/* Subroutine */ int ffldir_(doublecomplex *xk, doublecomplex *ckx, 
	doublecomplex *cky, doublecomplex *ckz, doublereal *side, 
	doublecomplex *ex, doublecomplex *ey, doublecomplex *ez)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    void z_sin(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static doublecomplex a;
    static integer i__;
#define s ((doublereal *)&data_1 + 4840)
    static integer ic;
    static doublereal el;
    static integer ip;
    static doublecomplex qi;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex arg, exa, bot, xkk, top, sill, curx, cury, curz, 
	    omega;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FFLDIR calculates the far zone radiated electric fields in an */
/*     infinite medium. */

/*     DESCRIPTION: */
/*     THE E FIELD IS COMPUTED IN RECTANGULAR COMPONENTS, WITH A */
/*     MEANINGLESS RADIAL COMPONENT INCLUDED.  ALSO, THE FACTOR */
/*     -J*W*MU/(4.*PI)*EXP(-J*K*R)/R IS OMITTED AT THIS POINT.  TO OBTAIN */
/*     RADIATED ELECTRIC FIELD, THE COMPONENTS TRANSVERSE TO THE */
/*     DIRECTION OF PROPAGATION SHOULD BE MULTIPLIED BY THE ABOVE FACTOR. */

/*     INPUT: */
/*     XK = WAVE NUMBER IN THE MEDIUM */
/*     CKX,CKY,CKZ = WAVE PROPAGATION VECTOR K FOR A WAVE ARRIVING FROM */
/*                   A POINT AT INFINITY IN THE DIRECTION IN WHICH THE */
/*                   RADIATED FIELD IS BEING COMPUTED. */
/*     SIDE = +1 TO COMPUTE FIELD DUE TO CURRENTS AT + Z COORD. ONLY */
/*            -1 TO COMPUTE FIELD DUE TO CURRENTS AT - Z COORD. ONLY */
/*             0 TO COMPUTE FIELD DUE TO ALL CURRENTS. */
/*             SIDE IS USED TO COMPUTE THE "DIRECT" REFLECTED AND */
/*             TRANSMITTED FIELDS WHICH ARE THEN TRANSFORMED BY THE */
/*             APPROPRIATE REFLECTION OR TRANSMISSION COEFFICIENTS. */

/*     OUTPUT: */
/*     EX,EY,EZ = RECTANGULAR COMPONENTS OF A VECTOR FROM WHICH THE */
/*                RADIATED FIELD CAN BE DERIVED. SEE "DISCRIPTION" ABOVE. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ex->r = 0.f, ex->i = 0.f;
    ey->r = 0.f, ey->i = 0.f;
    ez->r = 0.f, ez->i = 0.f;
    if (data_1.n == 0) {
	goto L25;
    }

/*     LOOP OVER STRUCTURE SEGMENTS */

    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (data_1.z__[i__ - 1] * *side < 0.f) {
	    goto L23;
	}
	i__2 = i__ - 1;
	z__3.r = cab[i__2] * ckx->r, z__3.i = cab[i__2] * ckx->i;
	i__3 = i__ - 1;
	z__4.r = sab[i__3] * cky->r, z__4.i = sab[i__3] * cky->i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = i__ - 1;
	z__5.r = data_1.salp[i__4] * ckz->r, z__5.i = data_1.salp[i__4] * 
		ckz->i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	omega.r = z__1.r, omega.i = z__1.i;
	el = data_1.si[i__ - 1] * .5f;
	i__2 = i__ - 1;
	xkk.r = crnt_1.xks[i__2].r, xkk.i = crnt_1.xks[i__2].i;
	z__1.r = el * xk->r, z__1.i = el * xk->i;
	if (z_abs(&z__1) < .05f) {
	    z__4.r = omega.r * omega.r - omega.i * omega.i, z__4.i = omega.r *
		     omega.i + omega.i * omega.r;
	    i__2 = i__ - 1;
	    z__3.r = z__4.r * crnt_1.aix[i__2].r - z__4.i * crnt_1.aix[i__2]
		    .i, z__3.i = z__4.r * crnt_1.aix[i__2].i + z__4.i * 
		    crnt_1.aix[i__2].r;
	    z__7.r = xkk.r * 0.f - xkk.i * 2.f, z__7.i = xkk.r * 2.f + xkk.i *
		     0.f;
	    z__6.r = z__7.r * omega.r - z__7.i * omega.i, z__6.i = z__7.r * 
		    omega.i + z__7.i * omega.r;
	    i__3 = i__ - 1;
	    z__5.r = z__6.r * crnt_1.bix[i__3].r - z__6.i * crnt_1.bix[i__3]
		    .i, z__5.i = z__6.r * crnt_1.bix[i__3].i + z__6.i * 
		    crnt_1.bix[i__3].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    z__9.r = xkk.r * xkk.r - xkk.i * xkk.i, z__9.i = xkk.r * xkk.i + 
		    xkk.i * xkk.r;
	    i__4 = i__ - 1;
	    z__8.r = z__9.r * crnt_1.cix[i__4].r - z__9.i * crnt_1.cix[i__4]
		    .i, z__8.i = z__9.r * crnt_1.cix[i__4].i + z__9.i * 
		    crnt_1.cix[i__4].r;
	    z__1.r = z__2.r + z__8.r, z__1.i = z__2.i + z__8.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	    i__2 = i__ - 1;
	    i__3 = i__ - 1;
	    z__2.r = data_1.si[i__2] * crnt_1.aix[i__3].r, z__2.i = data_1.si[
		    i__2] * crnt_1.aix[i__3].i;
	    d__1 = el * el * el;
	    z__4.r = d__1 * qi.r, z__4.i = d__1 * qi.i;
	    z__3.r = z__4.r / 3.f, z__3.i = z__4.i / 3.f;
	    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	} else {
	    z__1.r = el * omega.r, z__1.i = el * omega.i;
	    sill.r = z__1.r, sill.i = z__1.i;
	    z__2.r = xkk.r + omega.r, z__2.i = xkk.i + omega.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    top.r = z__1.r, top.i = z__1.i;
	    z__2.r = xkk.r - omega.r, z__2.i = xkk.i - omega.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    bot.r = z__1.r, bot.i = z__1.i;
	    if (z_abs(&sill) > .001f) {
		z_sin(&z__3, &sill);
		z__2.r = z__3.r * 2.f, z__2.i = z__3.i * 2.f;
		z_div(&z__1, &z__2, &sill);
		a.r = z__1.r, a.i = z__1.i;
	    } else {
		z__3.r = sill.r * sill.r - sill.i * sill.i, z__3.i = sill.r * 
			sill.i + sill.i * sill.r;
		z__2.r = z__3.r / 3.f, z__2.i = z__3.i / 3.f;
		z__1.r = 2.f - z__2.r, z__1.i = -z__2.i;
		a.r = z__1.r, a.i = z__1.i;
	    }
	    if (z_abs(&top) > .001f) {
		z_sin(&z__2, &top);
		z_div(&z__1, &z__2, &top);
		top.r = z__1.r, top.i = z__1.i;
	    } else {
		z__3.r = top.r * top.r - top.i * top.i, z__3.i = top.r * 
			top.i + top.i * top.r;
		z__2.r = z__3.r / 6.f, z__2.i = z__3.i / 6.f;
		z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
		top.r = z__1.r, top.i = z__1.i;
	    }
	    if (z_abs(&bot) > .001f) {
		z_sin(&z__2, &bot);
		z_div(&z__1, &z__2, &bot);
		bot.r = z__1.r, bot.i = z__1.i;
	    } else {
		z__3.r = bot.r * bot.r - bot.i * bot.i, z__3.i = bot.r * 
			bot.i + bot.i * bot.r;
		z__2.r = z__3.r / 6.f, z__2.i = z__3.i / 6.f;
		z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
		bot.r = z__1.r, bot.i = z__1.i;
	    }
	    i__2 = i__ - 1;
	    z__4.r = a.r * crnt_1.aix[i__2].r - a.i * crnt_1.aix[i__2].i, 
		    z__4.i = a.r * crnt_1.aix[i__2].i + a.i * crnt_1.aix[i__2]
		    .r;
	    z__7.r = bot.r - top.r, z__7.i = bot.i - top.i;
	    z__6.r = fj.r * z__7.r - fj.i * z__7.i, z__6.i = fj.r * z__7.i + 
		    fj.i * z__7.r;
	    i__3 = i__ - 1;
	    z__5.r = z__6.r * crnt_1.bix[i__3].r - z__6.i * crnt_1.bix[i__3]
		    .i, z__5.i = z__6.r * crnt_1.bix[i__3].i + z__6.i * 
		    crnt_1.bix[i__3].r;
	    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
	    z__10.r = bot.r + top.r, z__10.i = bot.i + top.i;
	    z__9.r = z__10.r - a.r, z__9.i = z__10.i - a.i;
	    i__4 = i__ - 1;
	    z__8.r = z__9.r * crnt_1.cix[i__4].r - z__9.i * crnt_1.cix[i__4]
		    .i, z__8.i = z__9.r * crnt_1.cix[i__4].i + z__9.i * 
		    crnt_1.cix[i__4].r;
	    z__2.r = z__3.r + z__8.r, z__2.i = z__3.i + z__8.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	}
	i__2 = i__ - 1;
	z__3.r = data_1.x[i__2] * ckx->r, z__3.i = data_1.x[i__2] * ckx->i;
	i__3 = i__ - 1;
	z__4.r = data_1.y[i__3] * cky->r, z__4.i = data_1.y[i__3] * cky->i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = i__ - 1;
	z__5.r = data_1.z__[i__4] * ckz->r, z__5.i = data_1.z__[i__4] * 
		ckz->i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	arg.r = z__1.r, arg.i = z__1.i;
	z__4.r = -fj.r, z__4.i = -fj.i;
	z__3.r = z__4.r * arg.r - z__4.i * arg.i, z__3.i = z__4.r * arg.i + 
		z__4.i * arg.r;
	z_exp(&z__2, &z__3);
	z__1.r = z__2.r * qi.r - z__2.i * qi.i, z__1.i = z__2.r * qi.i + 
		z__2.i * qi.r;
	exa.r = z__1.r, exa.i = z__1.i;

/*     SUMMATION FOR FAR FIELD INTEGRAL */

	i__2 = i__ - 1;
	z__2.r = cab[i__2] * exa.r, z__2.i = cab[i__2] * exa.i;
	z__1.r = ex->r + z__2.r, z__1.i = ex->i + z__2.i;
	ex->r = z__1.r, ex->i = z__1.i;
	i__2 = i__ - 1;
	z__2.r = sab[i__2] * exa.r, z__2.i = sab[i__2] * exa.i;
	z__1.r = ey->r + z__2.r, z__1.i = ey->i + z__2.i;
	ey->r = z__1.r, ey->i = z__1.i;
	i__2 = i__ - 1;
	z__2.r = data_1.salp[i__2] * exa.r, z__2.i = data_1.salp[i__2] * 
		exa.i;
	z__1.r = ez->r + z__2.r, z__1.i = ez->i + z__2.i;
	ez->r = z__1.r, ez->i = z__1.i;
L23:
	;
    }
L25:
    if (data_1.m == 0) {
	return 0;
    }

/*     CONTRIBUTION FROM SURFACE PATCHES */

    ic = data_1.n - 3;
    ip = data_1.ld + 1;
    i__1 = data_1.m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ic += 3;
	--ip;
	if (data_1.z__[ip - 1] * *side < 0.f) {
	    goto L28;
	}
	i__2 = ic;
	curx.r = crnt_1.cur[i__2].r, curx.i = crnt_1.cur[i__2].i;
	i__2 = ic + 1;
	cury.r = crnt_1.cur[i__2].r, cury.i = crnt_1.cur[i__2].i;
	i__2 = ic + 2;
	curz.r = crnt_1.cur[i__2].r, curz.i = crnt_1.cur[i__2].i;
	z__4.r = -fj.r, z__4.i = -fj.i;
	i__2 = ip - 1;
	z__7.r = data_1.x[i__2] * ckx->r, z__7.i = data_1.x[i__2] * ckx->i;
	i__3 = ip - 1;
	z__8.r = data_1.y[i__3] * cky->r, z__8.i = data_1.y[i__3] * cky->i;
	z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
	i__4 = ip - 1;
	z__9.r = data_1.z__[i__4] * ckz->r, z__9.i = data_1.z__[i__4] * 
		ckz->i;
	z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z_exp(&z__2, &z__3);
	i__5 = ip - 1;
	z__1.r = s[i__5] * z__2.r, z__1.i = s[i__5] * z__2.i;
	exa.r = z__1.r, exa.i = z__1.i;
	z__2.r = curx.r * exa.r - curx.i * exa.i, z__2.i = curx.r * exa.i + 
		curx.i * exa.r;
	z__1.r = ex->r + z__2.r, z__1.i = ex->i + z__2.i;
	ex->r = z__1.r, ex->i = z__1.i;
	z__2.r = cury.r * exa.r - cury.i * exa.i, z__2.i = cury.r * exa.i + 
		cury.i * exa.r;
	z__1.r = ey->r + z__2.r, z__1.i = ey->i + z__2.i;
	ey->r = z__1.r, ey->i = z__1.i;
	z__2.r = curz.r * exa.r - curz.i * exa.i, z__2.i = curz.r * exa.i + 
		curz.i * exa.r;
	z__1.r = ez->r + z__2.r, z__1.i = ez->i + z__2.i;
	ez->r = z__1.r, ez->i = z__1.i;
L28:
	;
    }
    return 0;
} /* ffldir_ */

#undef sab
#undef cab
#undef s


/* Subroutine */ int fflref_(doublecomplex *xk, doublecomplex *eta, 
	doublereal *vnorx, doublereal *vnory, doublereal *dx, doublereal *dy, 
	doublereal *dz, doublereal *side, doublecomplex *ex, doublecomplex *
	ey, doublecomplex *ez)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    void z_sin(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static doublecomplex a;
    static integer i__;
#define s ((doublereal *)&data_1 + 4840)
    static integer ic;
    static doublereal el;
    static integer ip;
    static doublecomplex qi, rx, ry, rz;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex arg, exa, cex, cey, bot, ckx, cky, ckz, cez, xkk, 
	    top;
    static doublereal xsp, ysp, zsp;
    static doublecomplex sill, curx, cury, curz, yste, zstm, omega;
    extern /* Subroutine */ int refpt1_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *), refcof_(doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, integer *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    static integer iperfg;
    extern /* Subroutine */ int zysurf_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *, doublecomplex *, 
	    doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FFLREF calculates the far zone radiated electric fields reflected */
/*     from a ground plane.  The height and the electrical parameters of */
/*     the ground plane may vary with position. */

/*     DESCRIPTION: */
/*     THE FIELD OF THE IMAGE OF EACH SEGMENT OR PATCH IS COMPUTED AND */
/*     MULTIPLIED BY THE REFLECTION COEFFICIENTS COMPUTED FOR THE POINT */
/*     WHERE THE RAY REFLECTS FROM THE INTERFACE.  RECTANGULAR COMPONENTS */
/*     OF FIELD WITH A MEANINGLESS RADIAL COMPONENT ARE USED HERE.  ALSO, */
/*     THE FACTOR -J*W*MU/(4.*PI)*EXP(-J*K*R)/R IS OMITTED. */

/*     INPUT: */
/*     XK = WAVE NUMBER IN THE MEDIUM */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */
/*     VNORX,VNORY = X AND Y COMPONENTS OF THE UNIT VECTOR NORMAL TO THE */
/*                   VERTICAL PLANE CONTAINING THE RAY */
/*     DX,DY,DZ = X, Y AND Z COMPONENTS OF THE UNIT VECTOR IN THE */
/*                DIRECTION OF PROPAGATION OF THE RADIATED FIELD */
/*                (REFLECTED RAY) */
/*     SIDE = +1 TO COMPUTE FIELD DUE TO CURRENTS AT + Z COORD. ONLY */
/*            -1 TO COMPUTE FIELD DUE TO CURRENTS AT - Z COORD. ONLY */
/*             0 TO COMPUTE FIELD DUE TO ALL CURRENTS. */
/*             SIDE IS USED TO COMPUTE THE "DIRECT" REFLECTED AND */
/*             TRANSMITTED FIELDS WHICH ARE THEN TRANSFORMED BY THE */
/*             APPROPRIATE REFLECTION OR TRANSMISSION COEFFICIENTS. */

/*     OUTPUT: */
/*     EX,EY,EZ = RECTANGULAR COMPONENTS OF A VECTOR FROM WHICH THE */
/*                RADIATED FIELD CAN BE DERIVED. SEE "DISCRIPTION" ABOVE. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    z__2.r = -xk->r, z__2.i = -xk->i;
    z__1.r = *dx * z__2.r, z__1.i = *dx * z__2.i;
    ckx.r = z__1.r, ckx.i = z__1.i;
    z__2.r = -xk->r, z__2.i = -xk->i;
    z__1.r = *dy * z__2.r, z__1.i = *dy * z__2.i;
    cky.r = z__1.r, cky.i = z__1.i;
    z__2.r = -xk->r, z__2.i = -xk->i;
    z__1.r = *dz * z__2.r, z__1.i = *dz * z__2.i;
    ckz.r = z__1.r, ckz.i = z__1.i;
    ex->r = 0.f, ex->i = 0.f;
    ey->r = 0.f, ey->i = 0.f;
    ez->r = 0.f, ez->i = 0.f;
    if (data_1.n == 0) {
	goto L25;
    }

/*     LOOP OVER STRUCTURE SEGMENTS */

    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (data_1.z__[i__ - 1] * *side < 0.f) {
	    goto L23;
	}
	i__2 = i__ - 1;
	z__3.r = cab[i__2] * ckx.r, z__3.i = cab[i__2] * ckx.i;
	i__3 = i__ - 1;
	z__4.r = sab[i__3] * cky.r, z__4.i = sab[i__3] * cky.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = i__ - 1;
	z__5.r = data_1.salp[i__4] * ckz.r, z__5.i = data_1.salp[i__4] * 
		ckz.i;
	z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
	omega.r = z__1.r, omega.i = z__1.i;
	el = data_1.si[i__ - 1] * .5f;
	i__2 = i__ - 1;
	xkk.r = crnt_1.xks[i__2].r, xkk.i = crnt_1.xks[i__2].i;
	z__1.r = el * xk->r, z__1.i = el * xk->i;
	if (z_abs(&z__1) < .05f) {
	    z__4.r = omega.r * omega.r - omega.i * omega.i, z__4.i = omega.r *
		     omega.i + omega.i * omega.r;
	    i__2 = i__ - 1;
	    z__3.r = z__4.r * crnt_1.aix[i__2].r - z__4.i * crnt_1.aix[i__2]
		    .i, z__3.i = z__4.r * crnt_1.aix[i__2].i + z__4.i * 
		    crnt_1.aix[i__2].r;
	    z__7.r = xkk.r * 0.f - xkk.i * 2.f, z__7.i = xkk.r * 2.f + xkk.i *
		     0.f;
	    z__6.r = z__7.r * omega.r - z__7.i * omega.i, z__6.i = z__7.r * 
		    omega.i + z__7.i * omega.r;
	    i__3 = i__ - 1;
	    z__5.r = z__6.r * crnt_1.bix[i__3].r - z__6.i * crnt_1.bix[i__3]
		    .i, z__5.i = z__6.r * crnt_1.bix[i__3].i + z__6.i * 
		    crnt_1.bix[i__3].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    z__9.r = xkk.r * xkk.r - xkk.i * xkk.i, z__9.i = xkk.r * xkk.i + 
		    xkk.i * xkk.r;
	    i__4 = i__ - 1;
	    z__8.r = z__9.r * crnt_1.cix[i__4].r - z__9.i * crnt_1.cix[i__4]
		    .i, z__8.i = z__9.r * crnt_1.cix[i__4].i + z__9.i * 
		    crnt_1.cix[i__4].r;
	    z__1.r = z__2.r + z__8.r, z__1.i = z__2.i + z__8.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	    i__2 = i__ - 1;
	    i__3 = i__ - 1;
	    z__2.r = data_1.si[i__2] * crnt_1.aix[i__3].r, z__2.i = data_1.si[
		    i__2] * crnt_1.aix[i__3].i;
	    d__1 = el * el * el;
	    z__4.r = d__1 * qi.r, z__4.i = d__1 * qi.i;
	    z__3.r = z__4.r / 3.f, z__3.i = z__4.i / 3.f;
	    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	} else {
	    z__1.r = el * omega.r, z__1.i = el * omega.i;
	    sill.r = z__1.r, sill.i = z__1.i;
	    z__2.r = xkk.r + omega.r, z__2.i = xkk.i + omega.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    top.r = z__1.r, top.i = z__1.i;
	    z__2.r = xkk.r - omega.r, z__2.i = xkk.i - omega.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    bot.r = z__1.r, bot.i = z__1.i;
	    if (z_abs(&sill) > .001f) {
		z_sin(&z__3, &sill);
		z__2.r = z__3.r * 2.f, z__2.i = z__3.i * 2.f;
		z_div(&z__1, &z__2, &sill);
		a.r = z__1.r, a.i = z__1.i;
	    } else {
		z__3.r = sill.r * sill.r - sill.i * sill.i, z__3.i = sill.r * 
			sill.i + sill.i * sill.r;
		z__2.r = z__3.r / 3.f, z__2.i = z__3.i / 3.f;
		z__1.r = 2.f - z__2.r, z__1.i = -z__2.i;
		a.r = z__1.r, a.i = z__1.i;
	    }
	    if (z_abs(&top) > .001f) {
		z_sin(&z__2, &top);
		z_div(&z__1, &z__2, &top);
		top.r = z__1.r, top.i = z__1.i;
	    } else {
		z__3.r = top.r * top.r - top.i * top.i, z__3.i = top.r * 
			top.i + top.i * top.r;
		z__2.r = z__3.r / 6.f, z__2.i = z__3.i / 6.f;
		z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
		top.r = z__1.r, top.i = z__1.i;
	    }
	    if (z_abs(&bot) > .001f) {
		z_sin(&z__2, &bot);
		z_div(&z__1, &z__2, &bot);
		bot.r = z__1.r, bot.i = z__1.i;
	    } else {
		z__3.r = bot.r * bot.r - bot.i * bot.i, z__3.i = bot.r * 
			bot.i + bot.i * bot.r;
		z__2.r = z__3.r / 6.f, z__2.i = z__3.i / 6.f;
		z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
		bot.r = z__1.r, bot.i = z__1.i;
	    }
	    i__2 = i__ - 1;
	    z__4.r = a.r * crnt_1.aix[i__2].r - a.i * crnt_1.aix[i__2].i, 
		    z__4.i = a.r * crnt_1.aix[i__2].i + a.i * crnt_1.aix[i__2]
		    .r;
	    z__7.r = bot.r - top.r, z__7.i = bot.i - top.i;
	    z__6.r = fj.r * z__7.r - fj.i * z__7.i, z__6.i = fj.r * z__7.i + 
		    fj.i * z__7.r;
	    i__3 = i__ - 1;
	    z__5.r = z__6.r * crnt_1.bix[i__3].r - z__6.i * crnt_1.bix[i__3]
		    .i, z__5.i = z__6.r * crnt_1.bix[i__3].i + z__6.i * 
		    crnt_1.bix[i__3].r;
	    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
	    z__10.r = bot.r + top.r, z__10.i = bot.i + top.i;
	    z__9.r = z__10.r - a.r, z__9.i = z__10.i - a.i;
	    i__4 = i__ - 1;
	    z__8.r = z__9.r * crnt_1.cix[i__4].r - z__9.i * crnt_1.cix[i__4]
		    .i, z__8.i = z__9.r * crnt_1.cix[i__4].i + z__9.i * 
		    crnt_1.cix[i__4].r;
	    z__2.r = z__3.r + z__8.r, z__2.i = z__3.i + z__8.i;
	    z__1.r = el * z__2.r, z__1.i = el * z__2.i;
	    qi.r = z__1.r, qi.i = z__1.i;
	}
	refpt1_(dx, dy, dz, &data_1.x[i__ - 1], &data_1.y[i__ - 1], &
		data_1.z__[i__ - 1], &xsp, &ysp, &zsp);
	i__2 = i__ - 1;
	z__3.r = data_1.x[i__2] * ckx.r, z__3.i = data_1.x[i__2] * ckx.i;
	i__3 = i__ - 1;
	z__4.r = data_1.y[i__3] * cky.r, z__4.i = data_1.y[i__3] * cky.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	d__1 = data_1.z__[i__ - 1] - zsp * 2.f;
	z__5.r = d__1 * ckz.r, z__5.i = d__1 * ckz.i;
	z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
	arg.r = z__1.r, arg.i = z__1.i;
	z__4.r = -fj.r, z__4.i = -fj.i;
	z__3.r = z__4.r * arg.r - z__4.i * arg.i, z__3.i = z__4.r * arg.i + 
		z__4.i * arg.r;
	z_exp(&z__2, &z__3);
	z__1.r = z__2.r * qi.r - z__2.i * qi.i, z__1.i = z__2.r * qi.i + 
		z__2.i * qi.r;
	exa.r = z__1.r, exa.i = z__1.i;
	i__2 = i__ - 1;
	z__1.r = cab[i__2] * exa.r, z__1.i = cab[i__2] * exa.i;
	cex.r = z__1.r, cex.i = z__1.i;
	i__2 = i__ - 1;
	z__1.r = sab[i__2] * exa.r, z__1.i = sab[i__2] * exa.i;
	cey.r = z__1.r, cey.i = z__1.i;
	i__2 = i__ - 1;
	z__1.r = data_1.salp[i__2] * exa.r, z__1.i = data_1.salp[i__2] * 
		exa.i;
	cez.r = z__1.r, cez.i = z__1.i;
	zysurf_(dz, &xsp, &ysp, side, &iperfg, &yste, &zstm);
	refcof_(dz, vnorx, vnory, eta, &iperfg, &yste, &zstm, &cex, &cey, &
		cez, &rx, &ry, &rz);

/*     SUMMATION FOR FAR FIELD INTEGRAL */

	z__1.r = ex->r + rx.r, z__1.i = ex->i + rx.i;
	ex->r = z__1.r, ex->i = z__1.i;
	z__1.r = ey->r + ry.r, z__1.i = ey->i + ry.i;
	ey->r = z__1.r, ey->i = z__1.i;
	z__1.r = ez->r + rz.r, z__1.i = ez->i + rz.i;
	ez->r = z__1.r, ez->i = z__1.i;
L23:
	;
    }
L25:
    if (data_1.m == 0) {
	return 0;
    }

/*     CONTRIBUTION FROM SURFACE PATCHES */

    ic = data_1.n - 3;
    ip = data_1.ld + 1;
    i__1 = data_1.m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ic += 3;
	--ip;
	if (data_1.z__[ip - 1] * *side < 0.f) {
	    goto L28;
	}
	i__2 = ic;
	curx.r = crnt_1.cur[i__2].r, curx.i = crnt_1.cur[i__2].i;
	i__2 = ic + 1;
	cury.r = crnt_1.cur[i__2].r, cury.i = crnt_1.cur[i__2].i;
	i__2 = ic + 2;
	curz.r = crnt_1.cur[i__2].r, curz.i = crnt_1.cur[i__2].i;
	refpt1_(dx, dy, dz, &data_1.x[ip - 1], &data_1.y[ip - 1], &data_1.z__[
		ip - 1], &xsp, &ysp, &zsp);
	z__4.r = -fj.r, z__4.i = -fj.i;
	i__2 = ip - 1;
	z__7.r = data_1.x[i__2] * ckx.r, z__7.i = data_1.x[i__2] * ckx.i;
	i__3 = ip - 1;
	z__8.r = data_1.y[i__3] * cky.r, z__8.i = data_1.y[i__3] * cky.i;
	z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
	d__1 = data_1.z__[ip - 1] - zsp * 2.f;
	z__9.r = d__1 * ckz.r, z__9.i = d__1 * ckz.i;
	z__5.r = z__6.r - z__9.r, z__5.i = z__6.i - z__9.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z_exp(&z__2, &z__3);
	i__4 = ip - 1;
	z__1.r = s[i__4] * z__2.r, z__1.i = s[i__4] * z__2.i;
	exa.r = z__1.r, exa.i = z__1.i;
	z__1.r = curx.r * exa.r - curx.i * exa.i, z__1.i = curx.r * exa.i + 
		curx.i * exa.r;
	cex.r = z__1.r, cex.i = z__1.i;
	z__1.r = cury.r * exa.r - cury.i * exa.i, z__1.i = cury.r * exa.i + 
		cury.i * exa.r;
	cey.r = z__1.r, cey.i = z__1.i;
	z__1.r = curz.r * exa.r - curz.i * exa.i, z__1.i = curz.r * exa.i + 
		curz.i * exa.r;
	cez.r = z__1.r, cez.i = z__1.i;
	zysurf_(dz, &xsp, &ysp, side, &iperfg, &yste, &zstm);
	refcof_(dz, vnorx, vnory, eta, &iperfg, &yste, &zstm, &cex, &cey, &
		cez, &rx, &ry, &rz);
	z__1.r = ex->r + rx.r, z__1.i = ex->i + rx.i;
	ex->r = z__1.r, ex->i = z__1.i;
	z__1.r = ey->r + ry.r, z__1.i = ey->i + ry.i;
	ey->r = z__1.r, ey->i = z__1.i;
	z__1.r = ez->r + rz.r, z__1.i = ez->i + rz.i;
	ez->r = z__1.r, ez->i = z__1.i;
L28:
	;
    }
    return 0;
} /* fflref_ */

#undef sab
#undef cab
#undef s


/* Subroutine */ int arcnec_(integer *itg, integer *ns, doublereal *rada, 
	doublereal *ang1, doublereal *ang2, doublereal *rad)
{
    /* Initialized data */

    static doublereal ta = .01745329252;

    /* Format strings */
    static char fmt_3[] = "(\002 ARCNEC: ERROR - ARC ANGLE EXCEEDS 360. DEGR"
	    "EES\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double cos(doublereal), sin(doublereal);

    /* Local variables */
    static integer i__;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static doublereal xs1, xs2, zs1, zs2, ang;
    static integer ist;
    static doublereal dang;

    /* Fortran I/O blocks */
    static cilist io___543 = { 0, 3, 0, fmt_3, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     ARCNEC generates segment geometry data for an arc of NS segments. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ist = data_1.n + 1;
    data_1.n += *ns;
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    if (*ns < 1) {
	return 0;
    }
    if ((d__1 = *ang2 - *ang1, abs(d__1)) < 360.00001f) {
	goto L1;
    }
    s_wsfe(&io___543);
    e_wsfe();
    s_stop("", (ftnlen)0);
L1:
    ang = *ang1 * ta;
    dang = (*ang2 - *ang1) * ta / *ns;
    xs1 = *rada * cos(ang);
    zs1 = *rada * sin(ang);
    i__1 = data_1.n;
    for (i__ = ist; i__ <= i__1; ++i__) {
	ang += dang;
	xs2 = *rada * cos(ang);
	zs2 = *rada * sin(ang);
	data_1.x[i__ - 1] = xs1;
	data_1.y[i__ - 1] = 0.f;
	data_1.z__[i__ - 1] = zs1;
	x2[i__ - 1] = xs2;
	y2[i__ - 1] = 0.f;
	z2[i__ - 1] = zs2;
	xs1 = xs2;
	zs1 = zs2;
	data_1.bi[i__ - 1] = *rad;
/* L2: */
	data_1.itag[i__ - 1] = *itg;
    }
    return 0;

} /* arcnec_ */

#undef z2
#undef y2
#undef x2


doublereal atgn2_(doublereal *x, doublereal *y)
{
    /* System generated locals */
    doublereal ret_val;

    /* Builtin functions */
    double atan2(doublereal, doublereal);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     ATGN2 is arctangent function modified to return 0. when X=Y=0. */

    if (*x != 0.) {
	goto L3;
    } else {
	goto L1;
    }
L1:
    if (*y != 0.) {
	goto L3;
    } else {
	goto L2;
    }
L2:
    ret_val = 0.f;
    return ret_val;
L3:
    ret_val = atan2(*x, *y);
    return ret_val;
} /* atgn2_ */

doublereal cang_(doublecomplex *z__)
{
    /* System generated locals */
    doublereal ret_val, d__1, d__2;

    /* Builtin functions */
    double d_imag(doublecomplex *);

    /* Local variables */
    extern doublereal atgn2_(doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CANG returns the phase angle of a complex number in degrees. */

    d__1 = d_imag(z__);
    d__2 = z__->r;
    ret_val = atgn2_(&d__1, &d__2) * 57.29577951f;
    return ret_val;
} /* cang_ */

/* Subroutine */ int cmss_(integer *j1, integer *j2, integer *im1, integer *
	im2, doublecomplex *cm, integer *nrow, integer *itrp)
{
    /* System generated locals */
    integer cm_dim1, cm_offset, i__1, i__2, i__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Local variables */
    static integer i__, j, i1, i2;
    static doublecomplex g11, g12, g21, g22;
    static integer il, jl;
    static doublereal xi, yi, zi;
    static integer ii1, ii2, jj1, jj2;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    static integer ldp;
    static doublereal t1xi, t1yi, t1zi, t2xi, t2yi, t2zi;
    static integer icomp;
    extern /* Subroutine */ int hintg_(doublereal *, doublereal *, doublereal 
	    *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CMSS computes matrix elements for surface-surface interactions. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    cm_dim1 = *nrow;
    cm_offset = 1 + cm_dim1;
    cm -= cm_offset;

    /* Function Body */
    ldp = data_1.ld + 1;
    i1 = (*im1 + 1) / 2;
    i2 = (*im2 + 1) / 2;
    icomp = (i1 << 1) - 3;
    ii1 = -1;
    if (icomp + 2 < *im1) {
	ii1 = -2;
    }
/*     LOOP OVER OBSERVATION PATCHES */
    i__1 = i2;
    for (i__ = i1; i__ <= i__1; ++i__) {
	il = ldp - i__;
	icomp += 2;
	ii1 += 2;
	ii2 = ii1 + 1;
	t1xi = t1x[il - 1] * data_1.salp[il - 1];
	t1yi = t1y[il - 1] * data_1.salp[il - 1];
	t1zi = t1z[il - 1] * data_1.salp[il - 1];
	t2xi = data_1.t2x[il - 1] * data_1.salp[il - 1];
	t2yi = data_1.t2y[il - 1] * data_1.salp[il - 1];
	t2zi = data_1.t2z[il - 1] * data_1.salp[il - 1];
	xi = data_1.x[il - 1];
	yi = data_1.y[il - 1];
	zi = data_1.z__[il - 1];
	jj1 = -1;
/*     LOOP OVER SOURCE PATCHES */
	i__2 = *j2;
	for (j = *j1; j <= i__2; ++j) {
	    jl = ldp - j;
	    jj1 += 2;
	    jj2 = jj1 + 1;
	    datap_1.spatj = data_1.bi[jl - 1];
	    datap_1.xpatj = data_1.x[jl - 1];
	    datap_1.ypatj = data_1.y[jl - 1];
	    datap_1.zpatj = data_1.z__[jl - 1];
	    datap_1.t1xj = t1x[jl - 1];
	    datap_1.t1yj = t1y[jl - 1];
	    datap_1.t1zj = t1z[jl - 1];
	    datap_1.t2xj = data_1.t2x[jl - 1];
	    datap_1.t2yj = data_1.t2y[jl - 1];
	    datap_1.t2zj = data_1.t2z[jl - 1];
	    hintg_(&xi, &yi, &zi);
	    z__4.r = t2xi * datap_1.h1x.r, z__4.i = t2xi * datap_1.h1x.i;
	    z__5.r = t2yi * datap_1.h1y.r, z__5.i = t2yi * datap_1.h1y.i;
	    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	    z__6.r = t2zi * datap_1.h1z.r, z__6.i = t2zi * datap_1.h1z.i;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = -z__2.r, z__1.i = -z__2.i;
	    g11.r = z__1.r, g11.i = z__1.i;
	    z__4.r = t2xi * datap_1.h2x.r, z__4.i = t2xi * datap_1.h2x.i;
	    z__5.r = t2yi * datap_1.h2y.r, z__5.i = t2yi * datap_1.h2y.i;
	    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	    z__6.r = t2zi * datap_1.h2z.r, z__6.i = t2zi * datap_1.h2z.i;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = -z__2.r, z__1.i = -z__2.i;
	    g12.r = z__1.r, g12.i = z__1.i;
	    z__4.r = t1xi * datap_1.h1x.r, z__4.i = t1xi * datap_1.h1x.i;
	    z__5.r = t1yi * datap_1.h1y.r, z__5.i = t1yi * datap_1.h1y.i;
	    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	    z__6.r = t1zi * datap_1.h1z.r, z__6.i = t1zi * datap_1.h1z.i;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = -z__2.r, z__1.i = -z__2.i;
	    g21.r = z__1.r, g21.i = z__1.i;
	    z__4.r = t1xi * datap_1.h2x.r, z__4.i = t1xi * datap_1.h2x.i;
	    z__5.r = t1yi * datap_1.h2y.r, z__5.i = t1yi * datap_1.h2y.i;
	    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	    z__6.r = t1zi * datap_1.h2z.r, z__6.i = t1zi * datap_1.h2z.i;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = -z__2.r, z__1.i = -z__2.i;
	    g22.r = z__1.r, g22.i = z__1.i;
	    if (i__ != j) {
		goto L1;
	    }
	    z__1.r = g11.r - .5f, z__1.i = g11.i;
	    g11.r = z__1.r, g11.i = z__1.i;
	    z__1.r = g22.r + .5f, z__1.i = g22.i;
	    g22.r = z__1.r, g22.i = z__1.i;
L1:
	    if (*itrp != 0) {
		goto L3;
	    }
/*     NORMAL FILL */
	    if (icomp < *im1) {
		goto L2;
	    }
	    i__3 = ii1 + jj1 * cm_dim1;
	    cm[i__3].r = g11.r, cm[i__3].i = g11.i;
	    i__3 = ii1 + jj2 * cm_dim1;
	    cm[i__3].r = g12.r, cm[i__3].i = g12.i;
L2:
	    if (icomp >= *im2) {
		goto L5;
	    }
	    i__3 = ii2 + jj1 * cm_dim1;
	    cm[i__3].r = g21.r, cm[i__3].i = g21.i;
	    i__3 = ii2 + jj2 * cm_dim1;
	    cm[i__3].r = g22.r, cm[i__3].i = g22.i;
	    goto L5;
/*     TRANSPOSED FILL */
L3:
	    if (icomp < *im1) {
		goto L4;
	    }
	    i__3 = jj1 + ii1 * cm_dim1;
	    cm[i__3].r = g11.r, cm[i__3].i = g11.i;
	    i__3 = jj2 + ii1 * cm_dim1;
	    cm[i__3].r = g12.r, cm[i__3].i = g12.i;
L4:
	    if (icomp >= *im2) {
		goto L5;
	    }
	    i__3 = jj1 + ii2 * cm_dim1;
	    cm[i__3].r = g21.r, cm[i__3].i = g21.i;
	    i__3 = jj2 + ii2 * cm_dim1;
	    cm[i__3].r = g22.r, cm[i__3].i = g22.i;
L5:
	    ;
	}
    }
    return 0;
} /* cmss_ */

#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int cmws_(integer *j, integer *i1, integer *i2, 
	doublecomplex *cm, integer *nr, doublecomplex *cw, integer *nw, 
	integer *itrp)
{
    /* System generated locals */
    integer cm_dim1, cm_offset, cw_dim1, cw_offset, i__1, i__2, i__3, i__4, 
	    i__5, i__6, i__7;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, ij, ik, js;
    static doublereal xi, yi, zi;
    static integer jx;
    static doublereal tx, ty, tz;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex etc, etk, ets;
    static integer ldp, ipr;
    extern /* Subroutine */ int hsfld_(doublereal *, doublereal *, doublereal 
	    *);
    static integer ipatch;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CMWS computes matrix elements for H at surface patches due to */
/*     current on wire segments. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    cm_dim1 = *nr;
    cm_offset = 1 + cm_dim1;
    cm -= cm_offset;
    cw_dim1 = *nw;
    cw_offset = 1 + cw_dim1;
    cw -= cw_offset;

    /* Function Body */
    ldp = data_1.ld + 1;
    dataj_1.slenj = data_1.si[*j - 1];
    dataj_1.aradj = data_1.bi[*j - 1];
    dataj_1.xj = data_1.x[*j - 1];
    dataj_1.yj = data_1.y[*j - 1];
    dataj_1.zj = data_1.z__[*j - 1];
    dataj_1.dxj = cab[*j - 1];
    dataj_1.dyj = sab[*j - 1];
    dataj_1.dzj = data_1.salp[*j - 1];
    i__1 = *j - 1;
    dataj_1.xksj.r = crnt_1.xks[i__1].r, dataj_1.xksj.i = crnt_1.xks[i__1].i;

/*     OBSERVATION LOOP */

    ipr = 0;
    i__1 = *i2;
    for (i__ = *i1; i__ <= i__1; ++i__) {
	++ipr;
	ipatch = (i__ + 1) / 2;
	ik = i__ - (i__ / 2 << 1);
	if (ik == 0 && ipr != 1) {
	    goto L1;
	}
	js = ldp - ipatch;
	xi = data_1.x[js - 1];
	yi = data_1.y[js - 1];
	zi = data_1.z__[js - 1];
	hsfld_(&xi, &yi, &zi);
	if (ik == 0) {
	    goto L1;
	}
	tx = data_1.t2x[js - 1];
	ty = data_1.t2y[js - 1];
	tz = data_1.t2z[js - 1];
	goto L2;
L1:
	tx = t1x[js - 1];
	ty = t1y[js - 1];
	tz = t1z[js - 1];
L2:
	z__6.r = tx * dataj_1.exk.r, z__6.i = tx * dataj_1.exk.i;
	z__7.r = ty * dataj_1.eyk.r, z__7.i = ty * dataj_1.eyk.i;
	z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	z__8.r = tz * dataj_1.ezk.r, z__8.i = tz * dataj_1.ezk.i;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z__3.r = -z__4.r, z__3.i = -z__4.i;
	i__2 = js - 1;
	z__2.r = data_1.salp[i__2] * z__3.r, z__2.i = data_1.salp[i__2] * 
		z__3.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	etk.r = z__1.r, etk.i = z__1.i;
	z__6.r = tx * dataj_1.exs.r, z__6.i = tx * dataj_1.exs.i;
	z__7.r = ty * dataj_1.eys.r, z__7.i = ty * dataj_1.eys.i;
	z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	z__8.r = tz * dataj_1.ezs.r, z__8.i = tz * dataj_1.ezs.i;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z__3.r = -z__4.r, z__3.i = -z__4.i;
	i__2 = js - 1;
	z__2.r = data_1.salp[i__2] * z__3.r, z__2.i = data_1.salp[i__2] * 
		z__3.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	ets.r = z__1.r, ets.i = z__1.i;
	z__6.r = tx * dataj_1.exc.r, z__6.i = tx * dataj_1.exc.i;
	z__7.r = ty * dataj_1.eyc.r, z__7.i = ty * dataj_1.eyc.i;
	z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
	z__8.r = tz * dataj_1.ezc.r, z__8.i = tz * dataj_1.ezc.i;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z__3.r = -z__4.r, z__3.i = -z__4.i;
	i__2 = js - 1;
	z__2.r = data_1.salp[i__2] * z__3.r, z__2.i = data_1.salp[i__2] * 
		z__3.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	etc.r = z__1.r, etc.i = z__1.i;

/*     FILL MATRIX ELEMENTS.  ELEMENT LOCATIONS DETERMINED BY CONNECTION */
/*     DATA. */

	if (*itrp != 0) {
	    goto L4;
	}
/*     NORMAL FILL */
	i__2 = segj_1.jsno;
	for (ij = 1; ij <= i__2; ++ij) {
	    jx = segj_1.jco[ij - 1];
/* L3: */
	    i__3 = ipr + jx * cm_dim1;
	    i__4 = ipr + jx * cm_dim1;
	    i__5 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__5].r - etk.i * segj_1.ax[i__5].i, 
		    z__4.i = etk.r * segj_1.ax[i__5].i + etk.i * segj_1.ax[
		    i__5].r;
	    z__3.r = cm[i__4].r + z__4.r, z__3.i = cm[i__4].i + z__4.i;
	    i__6 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__6].r - ets.i * segj_1.bx[i__6].i, 
		    z__5.i = ets.r * segj_1.bx[i__6].i + ets.i * segj_1.bx[
		    i__6].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__7 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__7].r - etc.i * segj_1.cx[i__7].i, 
		    z__6.i = etc.r * segj_1.cx[i__7].i + etc.i * segj_1.cx[
		    i__7].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__3].r = z__1.r, cm[i__3].i = z__1.i;
	}
	goto L9;
L4:
	if (*itrp == 2) {
	    goto L6;
	}
/*     TRANSPOSED FILL */
	i__3 = segj_1.jsno;
	for (ij = 1; ij <= i__3; ++ij) {
	    jx = segj_1.jco[ij - 1];
/* L5: */
	    i__4 = jx + ipr * cm_dim1;
	    i__5 = jx + ipr * cm_dim1;
	    i__6 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__6].r - etk.i * segj_1.ax[i__6].i, 
		    z__4.i = etk.r * segj_1.ax[i__6].i + etk.i * segj_1.ax[
		    i__6].r;
	    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + z__4.i;
	    i__7 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__7].r - ets.i * segj_1.bx[i__7].i, 
		    z__5.i = ets.r * segj_1.bx[i__7].i + ets.i * segj_1.bx[
		    i__7].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__2 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__2].r - etc.i * segj_1.cx[i__2].i, 
		    z__6.i = etc.r * segj_1.cx[i__2].i + etc.i * segj_1.cx[
		    i__2].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
	}
	goto L9;
/*     TRANSPOSED FILL - C(WS) AND D(WS)PRIME (=CW) */
L6:
	i__4 = segj_1.jsno;
	for (ij = 1; ij <= i__4; ++ij) {
	    jx = segj_1.jco[ij - 1];
	    if (jx > *nr) {
		goto L7;
	    }
	    i__5 = jx + ipr * cm_dim1;
	    i__6 = jx + ipr * cm_dim1;
	    i__7 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__7].r - etk.i * segj_1.ax[i__7].i, 
		    z__4.i = etk.r * segj_1.ax[i__7].i + etk.i * segj_1.ax[
		    i__7].r;
	    z__3.r = cm[i__6].r + z__4.r, z__3.i = cm[i__6].i + z__4.i;
	    i__2 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__2].r - ets.i * segj_1.bx[i__2].i, 
		    z__5.i = ets.r * segj_1.bx[i__2].i + ets.i * segj_1.bx[
		    i__2].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__3 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__3].r - etc.i * segj_1.cx[i__3].i, 
		    z__6.i = etc.r * segj_1.cx[i__3].i + etc.i * segj_1.cx[
		    i__3].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__5].r = z__1.r, cm[i__5].i = z__1.i;
	    goto L8;
L7:
	    jx -= *nr;
	    i__5 = jx + ipr * cw_dim1;
	    i__6 = jx + ipr * cw_dim1;
	    i__7 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__7].r - etk.i * segj_1.ax[i__7].i, 
		    z__4.i = etk.r * segj_1.ax[i__7].i + etk.i * segj_1.ax[
		    i__7].r;
	    z__3.r = cw[i__6].r + z__4.r, z__3.i = cw[i__6].i + z__4.i;
	    i__2 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__2].r - ets.i * segj_1.bx[i__2].i, 
		    z__5.i = ets.r * segj_1.bx[i__2].i + ets.i * segj_1.bx[
		    i__2].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__3 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__3].r - etc.i * segj_1.cx[i__3].i, 
		    z__6.i = etc.r * segj_1.cx[i__3].i + etc.i * segj_1.cx[
		    i__3].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cw[i__5].r = z__1.r, cw[i__5].i = z__1.i;
L8:
	    ;
	}
L9:
	;
    }
    return 0;
} /* cmws_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int conect_(integer *ignd, integer *ichk)
{
    /* Initialized data */

    static doublereal smin = .001;

    /* Format strings */
    static char fmt_54[] = "(/,3x,\002GROUND PLANE SPECIFIED.\002)";
    static char fmt_55[] = "(/,3x,\002WHERE WIRE ENDS TOUCH GROUND, CURRENT "
	    "WILL BE INTERPOLATED TO IMAGE IN GROUND PLANE.\002,/)";
    static char fmt_56[] = "(\002 CONECT: ERROR - SEGMENT\002,i5,\002 EXTEND"
	    "S BELOW GROUND\002)";
    static char fmt_57[] = "(\002 CONECT: ERROR - SEGMENT\002,i5,\002 LIES I"
	    "N GROUND PLANE\002)";
    static char fmt_62[] = "(\002 CONECT: ERROR - NO. NGF PATCHES CONNECTING"
	    " TO NEW\002,\002 SEGMENTS EXCEEDS LIMIT OF\002,i5)";
    static char fmt_58[] = "(/,3x,\002TOTAL SEGMENTS USED=\002,i5,5x,\002NO."
	    " SEG. IN \002,\002A SYMMETRIC CELL=\002,i5,5x,\002SYMMETRY FLAG"
	    "=\002,i3)";
    static char fmt_61[] = "(3x,\002TOTAL PATCHES USED=\002,i5,6x,\002NO. PA"
	    "TCHES IN A SYMMETRIC CELL=\002,i5)";
    static char fmt_59[] = "(\002 STRUCTURE HAS\002,i4,\002 FOLD ROTATIONAL "
	    "SYMMETRY\002,/)";
    static char fmt_60[] = "(\002 STRUCTURE HAS\002,i2,\002 PLANES OF SYMMET"
	    "RY\002,/)";
    static char fmt_50[] = "(//,9x,\002- MULTIPLE WIRE JUNCTIONS -\002,/,1x"
	    ",\002JUNCTION\002,4x,\002SEGMENTS  (- FOR END 1, + FOR END 2)"
	    "\002)";
    static char fmt_63[] = "(\002 CONECT: ERROR - NO. NGF SEGMENTS CONNECTIN"
	    "G TO NEW\002,\002 SEGMENTS EXCEEDS LIMIT OF\002,i5)";
    static char fmt_51[] = "(1x,i5,5x,20i5,/,(11x,20i5))";
    static char fmt_52[] = "(2x,\002NONE\002)";
    static char fmt_53[] = "(\002 CONECT: SEGMENT CONNECTION ERROR FOR SEGME"
	    "NT\002,i5)";

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, j;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static integer ic;
    static doublereal xa, ya;
    static integer ix;
    static doublereal za, xs, ys, zs, xi1, yi1, zi1, xi2, yi2, zi2, sep;
    static integer iend, jend, iseg;
    static doublereal slen;
    static integer nsflg;
    extern /* Subroutine */ int subph_(integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *);
    static integer iwarn;
    extern /* Subroutine */ int segchk_(integer *, integer *);
    static integer ierror;

    /* Fortran I/O blocks */
    static cilist io___605 = { 0, 3, 0, fmt_54, 0 };
    static cilist io___606 = { 0, 3, 0, fmt_55, 0 };
    static cilist io___615 = { 0, 3, 0, fmt_56, 0 };
    static cilist io___619 = { 0, 3, 0, fmt_56, 0 };
    static cilist io___620 = { 0, 3, 0, fmt_57, 0 };
    static cilist io___629 = { 0, 3, 0, fmt_62, 0 };
    static cilist io___630 = { 0, 3, 0, fmt_58, 0 };
    static cilist io___631 = { 0, 3, 0, fmt_61, 0 };
    static cilist io___632 = { 0, 3, 0, fmt_59, 0 };
    static cilist io___633 = { 0, 3, 0, fmt_60, 0 };
    static cilist io___634 = { 0, 3, 0, fmt_50, 0 };
    static cilist io___638 = { 0, 3, 0, fmt_63, 0 };
    static cilist io___639 = { 0, 3, 0, fmt_51, 0 };
    static cilist io___640 = { 0, 3, 0, fmt_52, 0 };
    static cilist io___643 = { 0, 3, 0, fmt_53, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CONECT sets up segment connection data in arrays ICON1 and ICON2 */
/*     by searching for segment ends that are in contact. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    segj_1.nscon = 0;
    segj_1.npcon = 0;
    if (*ignd == 0) {
	goto L3;
    }
    s_wsfe(&io___605);
    e_wsfe();
    if (*ignd > 0) {
	s_wsfe(&io___606);
	e_wsfe();
    }
    if (data_1.ipsym != 2) {
	goto L1;
    }
    data_1.np <<= 1;
    data_1.mp <<= 1;
L1:
    if (abs(data_1.ipsym) <= 2) {
	goto L2;
    }
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
L2:
    if (data_1.np > data_1.n) {
	s_stop("", (ftnlen)0);
    }
    if (data_1.np == data_1.n && data_1.mp == data_1.m) {
	data_1.ipsym = 0;
    }
L3:
    if (data_1.n == 0) {
	goto L26;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	data_1.iconx[i__ - 1] = 0;
	xi1 = data_1.x[i__ - 1];
	yi1 = data_1.y[i__ - 1];
	zi1 = data_1.z__[i__ - 1];
	xi2 = x2[i__ - 1];
	yi2 = y2[i__ - 1];
	zi2 = z2[i__ - 1];
/* Computing 2nd power */
	d__1 = xi2 - xi1;
/* Computing 2nd power */
	d__2 = yi2 - yi1;
/* Computing 2nd power */
	d__3 = zi2 - zi1;
	slen = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3) * smin;

/*     DETERMINE CONNECTION DATA FOR END 1 OF SEGMENT. */

	if (*ignd < 1) {
	    goto L5;
	}
	if (zi1 > -slen) {
	    goto L4;
	}
	s_wsfe(&io___615);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L4:
	if (zi1 > slen) {
	    goto L5;
	}
	data_1.icon1[i__ - 1] = i__;
	data_1.z__[i__ - 1] = 0.f;
	goto L9;
L5:
	ic = i__;
	i__2 = data_1.n;
	for (j = 2; j <= i__2; ++j) {
	    ++ic;
	    if (ic > data_1.n) {
		ic = 1;
	    }
	    sep = (d__1 = xi1 - data_1.x[ic - 1], abs(d__1)) + (d__2 = yi1 - 
		    data_1.y[ic - 1], abs(d__2)) + (d__3 = zi1 - data_1.z__[
		    ic - 1], abs(d__3));
	    if (sep > slen) {
		goto L6;
	    }
	    data_1.icon1[i__ - 1] = -ic;
	    goto L8;
L6:
	    sep = (d__1 = xi1 - x2[ic - 1], abs(d__1)) + (d__2 = yi1 - y2[ic 
		    - 1], abs(d__2)) + (d__3 = zi1 - z2[ic - 1], abs(d__3));
	    if (sep > slen) {
		goto L7;
	    }
	    data_1.icon1[i__ - 1] = ic;
	    goto L8;
L7:
	    ;
	}
	if (i__ < data_1.n2 && data_1.icon1[i__ - 1] > 30000) {
	    goto L8;
	}
	data_1.icon1[i__ - 1] = 0;

/*     DETERMINE CONNECTION DATA FOR END 2 OF SEGMENT. */

L8:
	if (*ignd < 1) {
	    goto L12;
	}
L9:
	if (zi2 > -slen) {
	    goto L10;
	}
	s_wsfe(&io___619);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L10:
	if (zi2 > slen) {
	    goto L12;
	}
	if (data_1.icon1[i__ - 1] != i__) {
	    goto L11;
	}
	s_wsfe(&io___620);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L11:
	data_1.icon2[i__ - 1] = i__;
	z2[i__ - 1] = 0.f;
	goto L15;
L12:
	ic = i__;
	i__2 = data_1.n;
	for (j = 2; j <= i__2; ++j) {
	    ++ic;
	    if (ic > data_1.n) {
		ic = 1;
	    }
	    sep = (d__1 = xi2 - data_1.x[ic - 1], abs(d__1)) + (d__2 = yi2 - 
		    data_1.y[ic - 1], abs(d__2)) + (d__3 = zi2 - data_1.z__[
		    ic - 1], abs(d__3));
	    if (sep > slen) {
		goto L13;
	    }
	    data_1.icon2[i__ - 1] = ic;
	    goto L15;
L13:
	    sep = (d__1 = xi2 - x2[ic - 1], abs(d__1)) + (d__2 = yi2 - y2[ic 
		    - 1], abs(d__2)) + (d__3 = zi2 - z2[ic - 1], abs(d__3));
	    if (sep > slen) {
		goto L14;
	    }
	    data_1.icon2[i__ - 1] = -ic;
	    goto L15;
L14:
	    ;
	}
	if (i__ < data_1.n2 && data_1.icon2[i__ - 1] > 30000) {
	    goto L15;
	}
	data_1.icon2[i__ - 1] = 0;
L15:
	;
    }
    if (data_1.m == 0) {
	goto L26;
    }
/*     FIND WIRE-SURFACE CONNECTIONS FOR NEW PATCHES */
    ix = data_1.ld + 1 - data_1.m1;
    i__ = data_1.m2;
L16:
    if (i__ > data_1.m) {
	goto L20;
    }
    --ix;
    xs = data_1.x[ix - 1];
    ys = data_1.y[ix - 1];
    zs = data_1.z__[ix - 1];
    i__1 = data_1.n;
    for (iseg = 1; iseg <= i__1; ++iseg) {
	xi1 = data_1.x[iseg - 1];
	yi1 = data_1.y[iseg - 1];
	zi1 = data_1.z__[iseg - 1];
	xi2 = x2[iseg - 1];
	yi2 = y2[iseg - 1];
	zi2 = z2[iseg - 1];
	slen = ((d__1 = xi2 - xi1, abs(d__1)) + (d__2 = yi2 - yi1, abs(d__2)) 
		+ (d__3 = zi2 - zi1, abs(d__3))) * smin;
/*     FOR FIRST END OF SEGMENT */
	sep = (d__1 = xi1 - xs, abs(d__1)) + (d__2 = yi1 - ys, abs(d__2)) + (
		d__3 = zi1 - zs, abs(d__3));
	if (sep > slen) {
	    goto L17;
	}
/*     CONNECTION - DIVIDE PATCH INTO 4 PATCHES AT PRESENT ARRAY LOC. */
	data_1.icon1[iseg - 1] = i__ + 30000;
	ic = 0;
	subph_(&i__, &ic, &xi1, &yi1, &zi1, &xi2, &yi2, &zi2, &xa, &ya, &za, &
		xs, &ys, &zs);
	goto L19;
L17:
	sep = (d__1 = xi2 - xs, abs(d__1)) + (d__2 = yi2 - ys, abs(d__2)) + (
		d__3 = zi2 - zs, abs(d__3));
	if (sep > slen) {
	    goto L18;
	}
	data_1.icon2[iseg - 1] = i__ + 30000;
	ic = 0;
	subph_(&i__, &ic, &xi1, &yi1, &zi1, &xi2, &yi2, &zi2, &xa, &ya, &za, &
		xs, &ys, &zs);
	goto L19;
L18:
	;
    }
L19:
    ++i__;
    goto L16;
/*     REPEAT SEARCH FOR NEW SEGMENTS CONNECTED TO NGF PATCHES. */
L20:
    if (data_1.m1 == 0 || data_1.n2 > data_1.n) {
	goto L26;
    }
    ix = data_1.ld + 1;
    i__ = 1;
L21:
    if (i__ > data_1.m1) {
	goto L25;
    }
    --ix;
    xs = data_1.x[ix - 1];
    ys = data_1.y[ix - 1];
    zs = data_1.z__[ix - 1];
    i__1 = data_1.n;
    for (iseg = data_1.n2; iseg <= i__1; ++iseg) {
	xi1 = data_1.x[iseg - 1];
	yi1 = data_1.y[iseg - 1];
	zi1 = data_1.z__[iseg - 1];
	xi2 = x2[iseg - 1];
	yi2 = y2[iseg - 1];
	zi2 = z2[iseg - 1];
	slen = ((d__1 = xi2 - xi1, abs(d__1)) + (d__2 = yi2 - yi1, abs(d__2)) 
		+ (d__3 = zi2 - zi1, abs(d__3))) * smin;
	sep = (d__1 = xi1 - xs, abs(d__1)) + (d__2 = yi1 - ys, abs(d__2)) + (
		d__3 = zi1 - zs, abs(d__3));
	if (sep > slen) {
	    goto L22;
	}
	data_1.icon1[iseg - 1] = data_1.m + 30001;
	ic = 1;
	++segj_1.npcon;
	segj_1.ipcon[segj_1.npcon - 1] = i__;
	subph_(&i__, &ic, &xi1, &yi1, &zi1, &xi2, &yi2, &zi2, &xa, &ya, &za, &
		xs, &ys, &zs);
	goto L24;
L22:
	sep = (d__1 = xi2 - xs, abs(d__1)) + (d__2 = yi2 - ys, abs(d__2)) + (
		d__3 = zi2 - zs, abs(d__3));
	if (sep > slen) {
	    goto L23;
	}
	data_1.icon2[iseg - 1] = data_1.m + 30001;
	ic = 1;
	++segj_1.npcon;
	segj_1.ipcon[segj_1.npcon - 1] = i__;
	subph_(&i__, &ic, &xi1, &yi1, &zi1, &xi2, &yi2, &zi2, &xa, &ya, &za, &
		xs, &ys, &zs);
	goto L24;
L23:
	;
    }
L24:
    ++i__;
    goto L21;
L25:
    if (segj_1.npcon <= 10) {
	goto L26;
    }
    s_wsfe(&io___629);
    do_fio(&c__1, (char *)&c__10, (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);
L26:
    s_wsfe(&io___630);
    do_fio(&c__1, (char *)&data_1.n, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&data_1.np, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&data_1.ipsym, (ftnlen)sizeof(integer));
    e_wsfe();
    if (data_1.m > 0) {
	s_wsfe(&io___631);
	do_fio(&c__1, (char *)&data_1.m, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.mp, (ftnlen)sizeof(integer));
	e_wsfe();
    }
    iseg = (data_1.n + data_1.m) / (data_1.np + data_1.mp);
    if (iseg == 1) {
	goto L30;
    }
    if (data_1.ipsym < 0) {
	goto L28;
    } else if (data_1.ipsym == 0) {
	goto L27;
    } else {
	goto L29;
    }
L27:
    s_stop("", (ftnlen)0);
L28:
    s_wsfe(&io___632);
    do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
    e_wsfe();
    goto L30;
L29:
    ic = iseg / 2;
    if (iseg == 8) {
	ic = 3;
    }
    s_wsfe(&io___633);
    do_fio(&c__1, (char *)&ic, (ftnlen)sizeof(integer));
    e_wsfe();
L30:
    if (data_1.n == 0) {
	goto L48;
    }
    s_wsfe(&io___634);
    e_wsfe();
    iseg = 0;
/*     ADJUST CONNECTED SEG. ENDS TO EXACTLY COINCIDE.  PRINT JUNCTIONS */
/*     OF 3 OR MORE SEG.  ALSO FIND OLD SEG. CONNECTING TO NEW SEG. */
    i__1 = data_1.n;
    for (j = 1; j <= i__1; ++j) {
	iend = -1;
	jend = -1;
	ix = data_1.icon1[j - 1];
	ic = 1;
	segj_1.jco[0] = -j;
	xa = data_1.x[j - 1];
	ya = data_1.y[j - 1];
	za = data_1.z__[j - 1];
L31:
	if (ix == 0) {
	    goto L43;
	}
	if (ix == j) {
	    goto L43;
	}
	if (ix > 30000) {
	    goto L43;
	}
	nsflg = 0;
L32:
	if (ix < 0) {
	    goto L33;
	} else if (ix == 0) {
	    goto L49;
	} else {
	    goto L34;
	}
L33:
	ix = -ix;
	goto L35;
L34:
	jend = -jend;
L35:
	if (ix == j) {
	    goto L37;
	}
	if (ix < j) {
	    goto L43;
	}
	++ic;
	if (ic > 30) {
	    goto L49;
	}
	segj_1.jco[ic - 1] = ix * jend;
	if (ix > data_1.n1) {
	    nsflg = 1;
	}
	if (jend == 1) {
	    goto L36;
	}
	xa += data_1.x[ix - 1];
	ya += data_1.y[ix - 1];
	za += data_1.z__[ix - 1];
	ix = data_1.icon1[ix - 1];
	goto L32;
L36:
	xa += x2[ix - 1];
	ya += y2[ix - 1];
	za += z2[ix - 1];
	ix = data_1.icon2[ix - 1];
	goto L32;
L37:
	sep = (doublereal) ic;
	xa /= sep;
	ya /= sep;
	za /= sep;
	i__2 = ic;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    ix = segj_1.jco[i__ - 1];
	    if (ix > 0) {
		goto L38;
	    }
	    ix = -ix;
	    data_1.x[ix - 1] = xa;
	    data_1.y[ix - 1] = ya;
	    data_1.z__[ix - 1] = za;
	    goto L39;
L38:
	    x2[ix - 1] = xa;
	    y2[ix - 1] = ya;
	    z2[ix - 1] = za;
L39:
	    ;
	}
	if (data_1.n1 == 0) {
	    goto L42;
	}
	if (nsflg == 0) {
	    goto L42;
	}
	i__2 = ic;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    ix = (i__3 = segj_1.jco[i__ - 1], abs(i__3));
	    if (ix > data_1.n1) {
		goto L41;
	    }
	    if (data_1.iconx[ix - 1] != 0) {
		goto L41;
	    }
	    ++segj_1.nscon;
	    if (segj_1.nscon <= 50) {
		goto L40;
	    }
	    s_wsfe(&io___638);
	    do_fio(&c__1, (char *)&c__50, (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
L40:
	    segj_1.iscon[segj_1.nscon - 1] = ix;
	    data_1.iconx[ix - 1] = segj_1.nscon;
L41:
	    ;
	}
L42:
	if (ic < 3) {
	    goto L43;
	}
	++iseg;
	s_wsfe(&io___639);
	do_fio(&c__1, (char *)&iseg, (ftnlen)sizeof(integer));
	i__2 = ic;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_fio(&c__1, (char *)&segj_1.jco[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	e_wsfe();
L43:
	if (iend == 1) {
	    goto L44;
	}
	iend = 1;
	jend = 1;
	ix = data_1.icon2[j - 1];
	ic = 1;
	segj_1.jco[0] = j;
	xa = x2[j - 1];
	ya = y2[j - 1];
	za = z2[j - 1];
	goto L31;
L44:
	;
    }
    if (iseg == 0) {
	s_wsfe(&io___640);
	e_wsfe();
    }
    if (data_1.n1 == 0 || data_1.m1 == data_1.m) {
	goto L48;
    }
/*     FIND OLD SEGMENTS THAT CONNECT TO NEW PATCHES */
    i__1 = data_1.n1;
    for (j = 1; j <= i__1; ++j) {
	ix = data_1.icon1[j - 1];
	if (ix < 30000) {
	    goto L45;
	}
	ix += -30000;
	if (ix > data_1.m1) {
	    goto L46;
	}
L45:
	ix = data_1.icon2[j - 1];
	if (ix < 30000) {
	    goto L47;
	}
	ix += -30000;
	if (ix < data_1.m2) {
	    goto L47;
	}
L46:
	if (data_1.iconx[j - 1] != 0) {
	    goto L47;
	}
	++segj_1.nscon;
	segj_1.iscon[segj_1.nscon - 1] = j;
	data_1.iconx[j - 1] = segj_1.nscon;
L47:
	;
    }
L48:
    if (*ichk >= 0) {
	segchk_(&ierror, &iwarn);
	if (*ichk == 0 && ierror != 0) {
	    s_stop("", (ftnlen)0);
	}
	if (*ichk == 1 && (ierror != 0 || iwarn != 0)) {
	    s_stop("", (ftnlen)0);
	}
    }
    return 0;
L49:
    s_wsfe(&io___643);
    do_fio(&c__1, (char *)&ix, (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);

    return 0;
} /* conect_ */

#undef z2
#undef y2
#undef x2


/* Subroutine */ int segchk_(integer *ierror, integer *iwarn)
{
    /* Format strings */
    static char fmt_90[] = "(/,\002 SEGCHK: ERROR - SEGMENTS\002,i4,\002 AN"
	    "D\002,i4,\002 ARE PARALLEL\002,\002 AND OVERLAPPING\002)";
    static char fmt_91[] = "(/,\002 SEGCHK: WARNING - SEGMENTS\002,i4,\002 A"
	    "ND\002,i4,\002 ARE\002,\002 PARALLEL AND SEPARATED BY LESS THAN "
	    "THE SUM OF THEIR RADII\002)";
    static char fmt_92[] = "(/,\002 SEGCHK: ERROR - SEGMENTS\002,i4,\002 AN"
	    "D\002,i4,\002 INTERSECT\002,\002 AT A MIDPOINT\002)";
    static char fmt_93[] = "(/,\002 SEGCHK: WARNING - SEGMENTS\002,i4,\002 A"
	    "ND\002,i4,\002 CROSS AT A\002,\002 MIDPOINT WITH SEPARATION LESS"
	    " THAN THE SUM OF THEIR RADII\002)";
    static char fmt_94[] = "(/,\002 SEGCHK: WARNING - THE CENTER OF SEGMEN"
	    "T\002,i4,\002 IS\002,\002 WITHIN THE VOLUME OF SEGMENT\002,i4)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__, j;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static integer ip, nm, ichk, inrad1, inrad2;
    extern /* Subroutine */ int segxct_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___654 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___655 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___656 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___657 = { 0, 3, 0, fmt_93, 0 };
    static cilist io___658 = { 0, 3, 0, fmt_94, 0 };
    static cilist io___659 = { 0, 3, 0, fmt_94, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SEGCHK calls SEGXCT to check for illegally intersecting segments */
/*     or violations of the thin-wire approximation, and prints error and */
/*     warning messages. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    *ierror = 0;
    *iwarn = 0;
    nm = data_1.n - 1;
    i__1 = nm;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ip = i__ + 1;
	i__2 = data_1.n;
	for (j = ip; j <= i__2; ++j) {
	    segxct_(&data_1.x[i__ - 1], &data_1.y[i__ - 1], &data_1.z__[i__ - 
		    1], &x2[i__ - 1], &y2[i__ - 1], &z2[i__ - 1], &data_1.x[j 
		    - 1], &data_1.y[j - 1], &data_1.z__[j - 1], &x2[j - 1], &
		    y2[j - 1], &z2[j - 1], &data_1.bi[i__ - 1], &data_1.bi[j 
		    - 1], &ichk, &inrad1, &inrad2);
	    if (ichk == 1) {
		*ierror = 1;
		s_wsfe(&io___654);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		e_wsfe();
	    } else if (ichk == 2) {
		*iwarn = 1;
		s_wsfe(&io___655);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		e_wsfe();
	    } else if (ichk == 3) {
		*ierror = 1;
		s_wsfe(&io___656);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		e_wsfe();
	    } else if (ichk == 4) {
		*iwarn = 1;
		s_wsfe(&io___657);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		e_wsfe();
	    }
	    if (inrad1 != 0) {
		*iwarn = 1;
		s_wsfe(&io___658);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		e_wsfe();
	    }
	    if (inrad2 != 0) {
		*iwarn = 1;
		s_wsfe(&io___659);
		do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		e_wsfe();
	    }
/* L1: */
	}
    }
    return 0;

} /* segchk_ */

#undef z2
#undef y2
#undef x2


/* Subroutine */ int segxct_(doublereal *s1x, doublereal *s1y, doublereal *
	s1z, doublereal *s2x, doublereal *s2y, doublereal *s2z, doublereal *
	t1x, doublereal *t1y, doublereal *t1z, doublereal *t2x, doublereal *
	t2y, doublereal *t2z, doublereal *srad, doublereal *trad, integer *
	isgchk, integer *inrad1, integer *inrad2)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal den, dsx, dsy, dsz, dtx, dty, dtz, tol, tdx, tdy, tdz, 
	    sdx, sdy, sdz, sxx, txx, csep, slen, tlen, sdts, tdts, dmins, 
	    sdott, radtst;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SEGXCT tests a pair of segments to find intersections at */
/*     midpoints, parallel overlapping segments or the center of a */
/*     segment buried within an adjacent segment. */

/*     INPUT: */
/*     S1X,S1Y,S1Z,S2X,S2Y,S2Z = first and second end of first segment */
/*     T1X,T1Y,T1Z,T2X,T2Y,T2Z = first and second end of second segment */
/*     SRAD = radius of first segment */
/*     TRAD = radius of second segment */

/*     OUTPUT: */
/*     ISGCHK = 1 if segments are parallel and overlapping */
/*              2 if parallel and separated by less than sum of radii */
/*              3 if intersecting at a midpoint */
/*              4 if crossing at a midpoint with separation less than */
/*                the sum of the radii */
/*     INRAD1 = 1 if the center of segment 1 is within segment 2 */
/*     INRAD2 = 1 if the center of segment 2 is within segment 1 */

    *isgchk = 0;
    *inrad1 = 0;
    *inrad2 = 0;
/* Computing 2nd power */
    d__1 = *srad + *trad;
    radtst = d__1 * d__1;
    dsx = *s2x - *s1x;
    dsy = *s2y - *s1y;
    dsz = *s2z - *s1z;
/* Computing 2nd power */
    d__1 = dsx;
/* Computing 2nd power */
    d__2 = dsy;
/* Computing 2nd power */
    d__3 = dsz;
    slen = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    dsx /= slen;
    dsy /= slen;
    dsz /= slen;
    dtx = *t2x - *t1x;
    dty = *t2y - *t1y;
    dtz = *t2z - *t1z;
/* Computing 2nd power */
    d__1 = dtx;
/* Computing 2nd power */
    d__2 = dty;
/* Computing 2nd power */
    d__3 = dtz;
    tlen = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    dtx /= tlen;
    dty /= tlen;
    dtz /= tlen;
/* Computing 2nd power */
    d__1 = *s1x + *s2x - *t1x - *t2x;
/* Computing 2nd power */
    d__2 = *s1y + *s2y - *t1y - *t2y;
/* Computing 2nd power */
    d__3 = *s1z + *s2z - *t1z - *t2z;
    csep = (d__1 * d__1 + d__2 * d__2 + d__3 * d__3) * .25f;
/* Computing 2nd power */
    d__1 = slen + tlen;
    if (csep > d__1 * d__1 * 1.2f && csep > radtst) {
	return 0;
    }
    if (slen < tlen) {
	tol = slen * .001f;
    } else {
	tol = tlen * .001f;
    }
    sdts = dsx * (*s1x - *t1x) + dsy * (*s1y - *t1y) + dsz * (*s1z - *t1z);
    tdts = dtx * (*s1x - *t1x) + dty * (*s1y - *t1y) + dtz * (*s1z - *t1z);
    sdott = dsx * dtx + dsy * dty + dsz * dtz;
/* Computing 2nd power */
    d__1 = sdott;
    den = 1.f - d__1 * d__1;
    if (den < 1e-6f) {

/*     PARALLEL SEGMENTS.  TEST FOR OVERLAP */

	if (sdott > 0.f) {
	    if (sdts < -slen + tol || sdts > tlen - tol) {
		goto L1;
	    }
	} else {
	    if (sdts > -tol || sdts < tol - (slen + tlen)) {
		goto L1;
	    }
	}
	txx = tdts;
	tdx = *t1x + txx * dtx;
	tdy = *t1y + txx * dty;
	tdz = *t1z + txx * dtz;
/* Computing 2nd power */
	d__1 = tdx - *s1x;
/* Computing 2nd power */
	d__2 = tdy - *s1y;
/* Computing 2nd power */
	d__3 = tdz - *s1z;
	dmins = d__1 * d__1 + d__2 * d__2 + d__3 * d__3;
/* Computing 2nd power */
	d__1 = tol;
	if (dmins < d__1 * d__1) {
	    *isgchk = 1;
	} else if (dmins < radtst) {
	    *isgchk = 2;
	}
    } else {

/*     TEST FOR INTERSECTION AT A MIDPOINT */

	sxx = (sdott * tdts - sdts) / den;
	txx = (tdts - sdott * sdts) / den;
	if (sxx < -tol || sxx > slen + tol) {
	    goto L1;
	}
	if (txx < -tol || txx > tlen + tol) {
	    goto L1;
	}
	if ((sxx < tol || sxx > slen - tol) && (txx < tol || txx > tlen - tol)
		) {
	    goto L1;
	}
	sdx = *s1x + sxx * dsx;
	sdy = *s1y + sxx * dsy;
	sdz = *s1z + sxx * dsz;
	tdx = *t1x + txx * dtx;
	tdy = *t1y + txx * dty;
	tdz = *t1z + txx * dtz;
/* Computing 2nd power */
	d__1 = tdx - sdx;
/* Computing 2nd power */
	d__2 = tdy - sdy;
/* Computing 2nd power */
	d__3 = tdz - sdz;
	dmins = d__1 * d__1 + d__2 * d__2 + d__3 * d__3;
/* Computing 2nd power */
	d__1 = tol;
	if (dmins < d__1 * d__1) {
	    *isgchk = 3;
	} else if (dmins < radtst) {
	    *isgchk = 4;
	}
    }

/*     TEST FOR THE CENTER OF ONE SEGMENT WITHIN THE OTHER SEGMENT. */

L1:
    sxx = slen * .5f;
    txx = sxx * sdott + tdts;
    if (txx > 0.f && txx < tlen) {
	sdx = *s1x + sxx * dsx;
	sdy = *s1y + sxx * dsy;
	sdz = *s1z + sxx * dsz;
	tdx = *t1x + txx * dtx;
	tdy = *t1y + txx * dty;
	tdz = *t1z + txx * dtz;
/* Computing 2nd power */
	d__1 = tdx - sdx;
/* Computing 2nd power */
	d__2 = tdy - sdy;
/* Computing 2nd power */
	d__3 = tdz - sdz;
	dmins = d__1 * d__1 + d__2 * d__2 + d__3 * d__3;
/* Computing 2nd power */
	d__1 = *trad;
	if (dmins < d__1 * d__1) {
	    *inrad1 = 1;
	}
    }
    txx = tlen * .5f;
    sxx = txx * sdott - sdts;
    if (sxx > 0.f && sxx < slen) {
	sdx = *s1x + sxx * dsx;
	sdy = *s1y + sxx * dsy;
	sdz = *s1z + sxx * dsz;
	tdx = *t1x + txx * dtx;
	tdy = *t1y + txx * dty;
	tdz = *t1z + txx * dtz;
/* Computing 2nd power */
	d__1 = tdx - sdx;
/* Computing 2nd power */
	d__2 = tdy - sdy;
/* Computing 2nd power */
	d__3 = tdz - sdz;
	dmins = d__1 * d__1 + d__2 * d__2 + d__3 * d__3;
/* Computing 2nd power */
	d__1 = *srad;
	if (dmins < d__1 * d__1) {
	    *inrad2 = 1;
	}
    }
    return 0;
} /* segxct_ */

/* Subroutine */ int couple_(integer *itt1, integer *its1, integer *itt2, 
	integer *its2)
{
    /* Format strings */
    static char fmt_6[] = "(///,36x,\002- - - ISOLATION DATA - - -\002,//,"
	    "6x,\002- - COUPLING BETWEEN - -\002,8x,\002MAXIMUM\002,15x,\002-"
	    " - - FOR MAXIMUM COUPLING - - -\002,/,12x,\002SEG.\002,14x,\002S"
	    "EG.\002,3x,\002COUPLING\002,4x,\002LOAD IMPEDANCE (2ND SEG.)\002"
	    ",7x,\002INPUT IMPEDANCE\002,/,2x,\002TAG/SEG.\002,3x,\002NO.\002"
	    ",4x,\002TAG/SEG.\002,3x,\002NO.\002,6x,\002(DB)\002,8x,\002REA"
	    "L\002,9x,\002IMAG.\002,9x,\002REAL\002,9x,\002IMAG.\002)";
    static char fmt_8[] = "(\002 COUPLE: ERROR - COUPLING=\002,1pe12.5,\002;"
	    " MUST BE BETWEEN\002,\002 0 AND 1.  SEGMENTS:\002,2(1x,i4,1x,i4,"
	    "1x,i5,1x))";
    static char fmt_7[] = "(2(1x,i4,1x,i4,1x,i5,2x),f9.3,2x,2(2x,1pe12.5,1x,"
	    "e12.5),///)";

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);
    double sqrt(doublereal);
    void d_cnjg(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal c__;
    static doublecomplex y11, y12, y21, y22;
    extern doublereal db10_(doublereal *);
    static doublecomplex yin, zin, yy12, crho;
    static doublereal gmax;
    static integer iscy1, iscy2;
    static doublecomplex yload, zload;
    static doublereal dbcoup;
    extern integer isegno_(integer *, integer *);
    extern /* Subroutine */ int yscmat_(integer *, integer *, doublecomplex *,
	     doublecomplex *, doublecomplex *, doublecomplex *);

    /* Fortran I/O blocks */
    static cilist io___684 = { 0, 3, 0, fmt_6, 0 };
    static cilist io___693 = { 0, 3, 0, fmt_8, 0 };
    static cilist io___701 = { 0, 3, 0, fmt_7, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     COUPLE computes the maximum coupling between pairs of segments */
/*     using the Linville algorithm. */

/*     INPUT: */
/*     ITT1,ITS1 = TAG AND SEGMENT NUMBERS FOR FIRST SEGMENT */
/*     ITT2,ITS2 = TAG AND SEGMENT NUMBERS FOR SECOND SEGMENT */


    s_wsfe(&io___684);
    e_wsfe();
    iscy1 = isegno_(itt1, its1);
    iscy2 = isegno_(itt2, its2);
    yscmat_(&iscy1, &iscy2, &y11, &y12, &y21, &y22);
    z__1.r = y12.r * y21.r - y12.i * y21.i, z__1.i = y12.r * y21.i + y12.i * 
	    y21.r;
    yy12.r = z__1.r, yy12.i = z__1.i;
    c__ = z_abs(&yy12) / (y11.r * 2.f * y22.r - yy12.r);
    if (c__ < 0.f || c__ > 1.f) {
	s_wsfe(&io___693);
	do_fio(&c__1, (char *)&c__, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*itt1), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*its1), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&iscy1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*itt2), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*its2), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&iscy2, (ftnlen)sizeof(integer));
	e_wsfe();
	return 0;
    }
    if (c__ < .01f) {
	gmax = (c__ + c__ * .25f * c__ * c__) * .5f;
    } else {
	gmax = (1.f - sqrt(1.f - c__ * c__)) / c__;
    }
    d_cnjg(&z__3, &yy12);
    z__2.r = gmax * z__3.r, z__2.i = gmax * z__3.i;
    d__1 = z_abs(&yy12);
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    crho.r = z__1.r, crho.i = z__1.i;
    z__5.r = 1.f - crho.r, z__5.i = -crho.i;
    z__6.r = crho.r + 1.f, z__6.i = crho.i;
    z_div(&z__4, &z__5, &z__6);
    z__3.r = z__4.r + 1.f, z__3.i = z__4.i;
    d__1 = y22.r;
    z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
    z__1.r = z__2.r - y22.r, z__1.i = z__2.i - y22.i;
    yload.r = z__1.r, yload.i = z__1.i;
    z__3.r = yload.r + y22.r, z__3.i = yload.i + y22.i;
    z_div(&z__2, &yy12, &z__3);
    z__1.r = y11.r - z__2.r, z__1.i = y11.i - z__2.i;
    yin.r = z__1.r, yin.i = z__1.i;
    z_div(&z__1, &c_b336, &yload);
    zload.r = z__1.r, zload.i = z__1.i;
    z_div(&z__1, &c_b336, &yin);
    zin.r = z__1.r, zin.i = z__1.i;
    dbcoup = db10_(&gmax);
    s_wsfe(&io___701);
    do_fio(&c__1, (char *)&(*itt1), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*its1), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&iscy1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*itt2), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*its2), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&iscy2, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&dbcoup, (ftnlen)sizeof(doublereal));
    do_fio(&c__2, (char *)&zload, (ftnlen)sizeof(doublereal));
    do_fio(&c__2, (char *)&zin, (ftnlen)sizeof(doublereal));
    e_wsfe();
    return 0;

} /* couple_ */

/* Subroutine */ int yscmat_(integer *isegy1, integer *isegy2, doublecomplex *
	y11, doublecomplex *y12, doublecomplex *y21, doublecomplex *y22)
{
    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublecomplex vlt;
    extern /* Subroutine */ int cabc_(doublecomplex *);
    static integer neqz2;
    extern /* Subroutine */ int solgf_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, integer *);
    static doublecomplex excit[3630];
    extern /* Subroutine */ int sorvt1_(integer *, doublecomplex *, 
	    doublecomplex *), sorini_(doublecomplex *), netsol_(doublecomplex 
	    *, integer *);
    static integer nprsav, netmxp;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     YSCMAT COMPUTES THE SHORT-CIRCUIT ADMITTANCE PARAMETERS FOR THE */
/*     TWO-PORT NETWORK REPRESENTED BY THE STRUCTURE MODEL EXCITED AT */
/*     SEGMENTS ISEGY1 AND ISEGY2. */

/*     DISCRIPTION: */
/*     THE ADMITTANCE PARAMETERS Y11 AND Y12 ARE COMPUTED BY EXCITING */
/*     SEGMENT ISEGY1 WITH ONE VOLT WHILE SEGMENT ISEGY2 IS SHORT */
/*     CIRCUITED.  Y11 IS THEN THE CURRENT IN THE VOLTAGE SOURCE AND */
/*     Y12 IS THE CURRENT IN SEGMENT ISEGY2.  Y22 IS LIKEWISE DETERMINED */
/*     BY EXCITING SEGMENT ISEGY2 WITH ONE VOLT WITH SEGMENT ISEGY1 SHORT */
/*     CIRCUITED.  A SEGMENT WITHOUT A NETWORK CONNECTION IS SHORT */
/*     CIRCUITED BY DEFAULT, WHILE A NETWORK PORT IS SHORTED BY ADDING A */
/*     VOLTAGE SOURCE WITH ZERO VOLTS. */

/*     INPUT: */
/*     ISEGY1 = SEGMENT NUMBER FOR PORT ONE */
/*     ISEGY2 = SEGMENT NUMBER FOR PORT TWO */

/*     OUTPUT: */
/*     Y11 = INPUT ADMITTANCE AT SEGMENT ISEGY1 WITH SEGMENT ISEGY2 SHORT */
/*           CIRCUITED (MHOS) */
/*     Y12 = TRANSFER ADMITTANCE FOR THE CURRENT IN SEGMENT ISEGY2 WITH */
/*           SEGMENT ISEGY1 EXCITED */
/*     Y21 = TRANSFER ADMITTANCE FOR THE CURRENT IN SEGMENT ISEGY1 WITH */
/*           SEGMENT ISEGY2 EXCITED */
/*     Y22 = INPUT ADMITTANCE AT SEGMENT ISEGY2 WITH SEGMENT ISEGY1 SHORT */
/*           CIRCUITED (MHOS) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


    netmxp = 31;
    vlt.r = 1.f, vlt.i = 0.f;
    if (netdef_1.nonet == 0) {
	goto L1;
    }

/*     SOLUTION WHEN NETWORKS ARE PRESENT */

    nprsav = netcx_1.nprint;
    netcx_1.nprint = 0;
    netcx_1.ntsol = 0;

/*     EXCITE SEGMENT ISEGY1 WITH ONE VOLT; SHORT CURCUIT SEGMENT ISEGY2 */

    netdef_1.nvsor = 2;
    netdef_1.nvsora[0] = *isegy1;
    netdef_1.nvsora[1] = *isegy2;
    netdef_1.svolts[0].r = vlt.r, netdef_1.svolts[0].i = vlt.i;
    netdef_1.svolts[1].r = 0.f, netdef_1.svolts[1].i = 0.f;
    sorini_(excit);
    sorvt1_(isegy1, &vlt, excit);
    netsol_(excit, &netcx_1.ntsol);
    i__1 = *isegy1 - 1;
    y11->r = excit[i__1].r, y11->i = excit[i__1].i;
    i__1 = *isegy2 - 1;
    y12->r = excit[i__1].r, y12->i = excit[i__1].i;
    if (netwrk_1.ntveq > 0) {

/*     ADD NETWORK CURRENTS TO SEGMENT CURRENT */

	i__1 = netwrk_1.ntveq;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (netwrk_1.ntveqa[i__ - 1] == *isegy1) {
		i__2 = netmxp - i__ - 1;
		z__1.r = y11->r + netwrk_1.rhnt[i__2].r, z__1.i = y11->i + 
			netwrk_1.rhnt[i__2].i;
		y11->r = z__1.r, y11->i = z__1.i;
	    }
	    if (netwrk_1.ntveqa[i__ - 1] == *isegy2) {
		i__2 = netmxp - i__ - 1;
		z__1.r = y12->r + netwrk_1.rhnt[i__2].r, z__1.i = y12->i + 
			netwrk_1.rhnt[i__2].i;
		y12->r = z__1.r, y12->i = z__1.i;
	    }
/* L2: */
	}
    }

/*     EXCITE SEGMENT ISEGY2 WITH ONE VOLT; SHORT CIRCUIT SEGMENT ISEGY2 */

    netdef_1.svolts[0].r = 0.f, netdef_1.svolts[0].i = 0.f;
    netdef_1.svolts[1].r = vlt.r, netdef_1.svolts[1].i = vlt.i;
    sorini_(excit);
    sorvt1_(isegy2, &vlt, excit);
    netsol_(excit, &netcx_1.ntsol);
    i__1 = *isegy1 - 1;
    y21->r = excit[i__1].r, y21->i = excit[i__1].i;
    i__1 = *isegy2 - 1;
    y22->r = excit[i__1].r, y22->i = excit[i__1].i;
    if (netwrk_1.ntveq > 0) {

/*     ADD NETWORK CURRENTS TO SEGMENT CURRENT */

	i__1 = netwrk_1.ntveq;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (netwrk_1.ntveqa[i__ - 1] == *isegy1) {
		i__2 = netmxp - i__ - 1;
		z__1.r = y21->r + netwrk_1.rhnt[i__2].r, z__1.i = y21->i + 
			netwrk_1.rhnt[i__2].i;
		y21->r = z__1.r, y21->i = z__1.i;
	    }
	    if (netwrk_1.ntveqa[i__ - 1] == *isegy2) {
		i__2 = netmxp - i__ - 1;
		z__1.r = y22->r + netwrk_1.rhnt[i__2].r, z__1.i = y22->i + 
			netwrk_1.rhnt[i__2].i;
		y22->r = z__1.r, y22->i = z__1.i;
	    }
/* L3: */
	}
    }
    netcx_1.nprint = nprsav;
    return 0;

/*     SOLVE FOR CURRENTS WHEN NO NETWORKS ARE PRESENT */

L1:
    neqz2 = cmb_1.neq2;
    if (neqz2 == 0) {
	neqz2 = 1;
    }

/*     EXCITE SEGMENT ISEGY1 WITH SEGMENT ISEGY2 SHORT CIRCUITED. */

    sorini_(excit);
    sorvt1_(isegy1, &vlt, excit);
    solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
	    cmb_1.cm[cmb_1.id11 - 1], excit, cmb_1.ip, &data_1.np, &data_1.n1,
	     &data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &cmb_1.neq, &
	    cmb_1.neq2, &neqz2);
    cabc_(excit);
    i__1 = *isegy1 - 1;
    y11->r = excit[i__1].r, y11->i = excit[i__1].i;
    i__1 = *isegy2 - 1;
    y12->r = excit[i__1].r, y12->i = excit[i__1].i;

/*     EXCITE SEGMENT ISEGY2 WITH SEGMENT ISEGY1 SHORT CIRCUITED. */

    sorini_(excit);
    sorvt1_(isegy2, &vlt, excit);
    solgf_(cmb_1.cm, &cmb_1.cm[cmb_1.ib11 - 1], &cmb_1.cm[cmb_1.ic11 - 1], &
	    cmb_1.cm[cmb_1.id11 - 1], excit, cmb_1.ip, &data_1.np, &data_1.n1,
	     &data_1.n, &data_1.mp, &data_1.m1, &data_1.m, &cmb_1.neq, &
	    cmb_1.neq2, &neqz2);
    cabc_(excit);
    i__1 = *isegy1 - 1;
    y21->r = excit[i__1].r, y21->i = excit[i__1].i;
    i__1 = *isegy2 - 1;
    y22->r = excit[i__1].r, y22->i = excit[i__1].i;
    return 0;
} /* yscmat_ */

/* Subroutine */ int datagn_(void)
{
    /* Initialized data */

    static char ifx[1*2] = " " "X";
    static char ify[1*2] = " " "Y";
    static char ifz[2*2] = "  " "Z ";
    static doublereal ta = .01745329252;
    static doublereal td = 57.29577951;
    static char ipt[1*4] = "P" "R" "T" "Q";

    /* Format strings */
    static char fmt_40[] = "(///,33x,\002- - - STRUCTURE SPECIFICATION - - "
	    "-\002,//,37x,\002COORDINATES MUST BE INPUT IN\002,/,37x,\002METE"
	    "RS OR BE SCALED TO METERS\002,/,37x,\002BEFORE STRUCTURE INPUT I"
	    "S ENDED\002,//)";
    static char fmt_41[] = "(2x,\002WIRE\002,79x,\002NO. OF\002,4x,\002FIRS"
	    "T\002,2x,\002LAST\002,5x,\002TAG\002,/,2x,\002NO.\002,8x,\002X"
	    "1\002,9x,\002Y1\002,9x,\002Z1\002,10x,\002X2\002,9x,\002Y2\002,9"
	    "x,\002Z2\002,6x,\002RADIUS\002,3x,\002SEG.\002,5x,\002SEG.\002,3"
	    "x,\002SEG.\002,5x,\002NO.\002)";
    static char fmt_48[] = "(\002 DATAGN: STRUCTURE GEOMETRY DATA ERROR\002)";
    static char fmt_49[] = "(1x,a2,i3,i5,7f10.5)";
    static char fmt_43[] = "(1x,i5,3f11.5,1x,4f11.5,2x,i5,4x,i5,1x,i5,3x,i5)";
    static char fmt_61[] = "(9x,\002ABOVE WIRE IS TAPERED.  SEG. LENGTH RATI"
	    "O =\002,f9.5,/,33x,\002RADIUS FROM\002,f9.5,\002 TO\002,f9.5)";
    static char fmt_62[] = "(9x,\002ABOVE WIRE IS TAPERED.  INITIAL SEG. LEN"
	    "GTH =\002,f9.5,\002   LENGTH RATIO =\002,f9.5,/,33x,\002RADIUS F"
	    "ROM\002,f9.5,\002 TO\002,f9.5)";
    static char fmt_67[] = "(9x,\002ABOVE WIRE IS TAPERED.  REQUESTED INITIA"
	    "L AND FINAL \002,\002SEG. LENGTHS =\002,2f9.5,/,33x,\002RADIUS F"
	    "ROM\002,f9.5,\002 TO\002,f9.5,/,33x,\002COMPUTED NUMBER OF SEGME"
	    "NTS = \002,i5,\002   LENGTH RATIO =\002,f9.5)";
    static char fmt_38[] = "(1x,i5,2x,\002ARC RADIUS =\002,f9.5,2x,\002FRO"
	    "M\002,f8.3,\002 TO\002,f8.3,\002 DEGREES\002,11x,f11.5,2x,i5,4x,"
	    "i5,1x,i5,3x,i5)";
    static char fmt_63[] = "(10x,\002THE FOLLOWING WIRE IS A CATENARY,\002,i"
	    "5,1p2e12.5)";
    static char fmt_64[] = "(1x,i5,6x,\002THIS WIRE IS A LOG-SPIRAL OR HELI"
	    "X\002,40x,i5,4x,i5,1x,i5,3x,i5)";
    static char fmt_65[] = "(1x,i5,6x,\002THIS WIRE IS AN ARCHIMEDES SPIRAL "
	    "OR HELIX\002,32x,i5,4x,i5,1x,i5,3x,i5)";
    static char fmt_66[] = "(10x,\002SPIRAL DATA: TURNS=\002,f10.4,\002  LEN"
	    "GTH=\002,1pe12.4,\002  H.RAD=\002,2e12.4,\002  W.RAD=\002,2e12.4)"
	    ;
    static char fmt_51[] = "(1x,i5,a1,f10.5,2f11.5,1x,3f11.5)";
    static char fmt_39[] = "(6x,3f11.5,1x,3f11.5)";
    static char fmt_59[] = "(1x,i5,a1,f10.5,2f11.5,1x,3f11.5,5x,\002SURFAC"
	    "E -\002,i4,\002 BY\002,i3,\002 PATCHES\002)";
    static char fmt_60[] = "(\002 DATAGN: PATCH DATA ERROR\002)";
    static char fmt_44[] = "(6x,\002STRUCTURE REFLECTED ALONG THE AXES\002,3"
	    "(1x,a1),\002.  TAGS INCREMENTED BY\002,i5)";
    static char fmt_45[] = "(6x,\002STRUCTURE ROTATED ABOUT Z-AXIS\002,i3"
	    ",\002 TIMES.  LABELS INCREMENTED BY\002,i5)";
    static char fmt_46[] = "(6x,\002STRUCTURE SCALED BY FACTOR\002,f10.5)";
    static char fmt_47[] = "(6x,\002THE STRUCTURE HAS BEEN MOVED, GM COMMAND"
	    " DATA IS -\002,/,6x,i3,i5,6f10.5,4i5)";
    static char fmt_52[] = "(\002 DATAGN: ERROR - GF MUST BE FIRST COMMAND I"
	    "N GEOMETRY\002,\002 DATA SECTION\002)";
    static char fmt_53[] = "(////,33x,\002- - - - SEGMENTATION DATA - - - "
	    "-\002,//,40x,\002COORDINATES IN METERS\002,//,25x,\002I+ AND I- "
	    "INDICATE THE SEGMENTS BEFORE AND AFTER I\002,//)";
    static char fmt_54[] = "(2x,\002SEG.\002,3x,\002COORDINATES OF SEG. CENT"
	    "ER\002,5x,\002SEG.\002,5x,\002ORIENTATION ANGLES\002,4x,\002WIR"
	    "E\002,4x,\002CONNECTION DATA\002,3x,\002TAG\002,/,2x,\002NO.\002"
	    ",7x,\002X\002,9x,\002Y\002,9x,\002Z\002,7x,\002LENGTH\002,5x,"
	    "\002ALPHA\002,5x,\002BETA\002,6x,\002RADIUS\002,4x,\002I-\002,3x,"
	    "\002I\002,4x,\002I+\002,4x,\002NO.\002)";
    static char fmt_55[] = "(1x,i5,4f10.5,1x,3f10.5,1x,3i5,2x,i5)";
    static char fmt_56[] = "(\002 DATAGN: SEGMENT DATA ERROR\002)";
    static char fmt_57[] = "(////,44x,\002- - - SURFACE PATCH DATA - - -\002"
	    ",//,49x,\002COORDINATES IN METERS\002,//,1x,\002PATCH\002,5x,"
	    "\002COORD. OF PATCH CENTER\002,7x,\002UNIT NORMAL VECTOR\002,6x"
	    ",\002PATCH\002,12x,\002COMPONENTS OF UNIT TANGENT VECTORS\002,/,"
	    "2x,\002NO.\002,6x,\002X\002,9x,\002Y\002,9x,\002Z\002,9x,\002"
	    "X\002,7x,\002Y\002,7x,\002Z\002,7x,\002AREA\002,7x,\002X1\002,6x,"
	    "\002Y1\002,6x,\002Z1\002,7x,\002X2\002,6x,\002Y2\002,6x,\002Z"
	    "2\002)";
    static char fmt_58[] = "(1x,i4,3f10.5,1x,3f8.4,f10.5,1x,3f8.4,1x,3f8.4)";
    static char fmt_50[] = "(\002 DATAGN: NUMBER OF WIRE SEGMENTS AND SURFAC"
	    "E PATCHES\002,\002 EXCEEDS DIMENSION LIMIT.\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double pow_dd(doublereal *, doublereal *), sqrt(doublereal), asin(
	    doublereal);

    /* Local variables */
    static integer i__, j, i1, i2;
    static doublereal f8, f9;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static doublereal x4, y4, z4, x3, y3, z3, f10;
    static char gm[2];
    static integer ns, ix, iy, iz;
    static doublereal xs1;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    static doublereal xw1, yw1, zw1;
#define cab ((doublereal *)&data_1 + 6050)
    static doublereal xw2, yw2, zw2, ys1, zs1, xs2, ys2, zs2;
#define sab ((doublereal *)&data_1 + 7260)
    static doublereal rad;
    static integer itg, isg1, itg1, itg2, isg2, icat;
    extern /* Subroutine */ int gfil_(integer *, char *, ftnlen);
    static integer iphd, isct;
    extern /* Subroutine */ int wire_(doublereal *, doublereal *, doublereal *
	    , doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *, integer *), move_(
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *, integer *, integer *, 
	    integer *, integer *, integer *);
    static doublereal segl1, segl2;
    extern doublereal atgn2_(doublereal *, doublereal *);
    extern /* Subroutine */ int reflc_(integer *, integer *, integer *, 
	    integer *, integer *), patch_(integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *), helix_(integer *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *, integer *);
    static integer ipsav, nwire, mpsav, npsav;
    static doublereal dummy;
    extern /* Subroutine */ int arcnec_(integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *), readgm_(integer *, 
	    char *, integer *, integer *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, char *, 
	    ftnlen, ftnlen);
    static char filnam[80];
    extern /* Subroutine */ int conect_(integer *, integer *);
    static integer ihelix;
    extern /* Subroutine */ int rdlsol_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *), catnry_(doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___739 = { 0, 3, 0, fmt_40, 0 };
    static cilist io___740 = { 0, 3, 0, fmt_41, 0 };
    static cilist io___741 = { 0, 3, 0, fmt_48, 0 };
    static cilist io___742 = { 0, 3, 0, fmt_49, 0 };
    static cilist io___745 = { 0, 3, 0, fmt_43, 0 };
    static cilist io___754 = { 0, 3, 0, fmt_48, 0 };
    static cilist io___755 = { 0, 3, 0, fmt_61, 0 };
    static cilist io___756 = { 0, 3, 0, fmt_62, 0 };
    static cilist io___757 = { 0, 3, 0, fmt_67, 0 };
    static cilist io___758 = { 0, 3, 0, fmt_48, 0 };
    static cilist io___759 = { 0, 3, 0, fmt_38, 0 };
    static cilist io___761 = { 0, 3, 0, fmt_63, 0 };
    static cilist io___762 = { 0, 3, 0, fmt_43, 0 };
    static cilist io___764 = { 0, 3, 0, fmt_64, 0 };
    static cilist io___765 = { 0, 3, 0, fmt_65, 0 };
    static cilist io___766 = { 0, 3, 0, fmt_66, 0 };
    static cilist io___767 = { 0, 3, 0, fmt_51, 0 };
    static cilist io___777 = { 0, 3, 0, fmt_51, 0 };
    static cilist io___778 = { 0, 3, 0, fmt_39, 0 };
    static cilist io___779 = { 0, 3, 0, fmt_59, 0 };
    static cilist io___780 = { 0, 3, 0, fmt_39, 0 };
    static cilist io___781 = { 0, 3, 0, fmt_60, 0 };
    static cilist io___783 = { 0, 3, 0, fmt_44, 0 };
    static cilist io___784 = { 0, 3, 0, fmt_45, 0 };
    static cilist io___786 = { 0, 3, 0, fmt_46, 0 };
    static cilist io___791 = { 0, 3, 0, fmt_47, 0 };
    static cilist io___792 = { 0, 3, 0, fmt_52, 0 };
    static cilist io___796 = { 0, 3, 0, fmt_53, 0 };
    static cilist io___797 = { 0, 3, 0, fmt_54, 0 };
    static cilist io___798 = { 0, 3, 0, fmt_55, 0 };
    static cilist io___799 = { 0, 3, 0, fmt_56, 0 };
    static cilist io___800 = { 0, 3, 0, fmt_57, 0 };
    static cilist io___802 = { 0, 3, 0, fmt_58, 0 };
    static cilist io___803 = { 0, 3, 0, fmt_50, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     DATAGN is the main routine for input of geometry data. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


    data_1.ipsym = 0;
    nwire = 0;
    data_1.n = 0;
    data_1.np = 0;
    data_1.m = 0;
    data_1.mp = 0;
    data_1.n1 = 0;
    data_1.n2 = 1;
    data_1.m1 = 0;
    data_1.m2 = 1;
    isct = 0;
    iphd = 0;

/*     READ GEOMETRY DATA COMMAND AND BRANCH TO SECTION FOR OPERATION */
/*     REQUESTED */

L1:
    readgm_(&c__2, gm, &itg, &ns, &xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &rad, &
	    f8, &f9, &f10, filnam, (ftnlen)2, (ftnlen)80);
/* *** */
    if (data_1.n + data_1.m > data_1.ld) {
	goto L37;
    }
    if (s_cmp(gm, "GF", (ftnlen)2, (ftnlen)2) == 0) {
	goto L27;
    }
    if (iphd == 1) {
	goto L2;
    }
    s_wsfe(&io___739);
    e_wsfe();
    s_wsfe(&io___740);
    e_wsfe();
    iphd = 1;
L2:
    if (s_cmp(gm, "SC", (ftnlen)2, (ftnlen)2) == 0) {
	goto L10;
    }
    isct = 0;
    if (s_cmp(gm, "GW", (ftnlen)2, (ftnlen)2) == 0) {
	goto L3;
    }
    if (s_cmp(gm, "CW", (ftnlen)2, (ftnlen)2) == 0) {
	goto L4;
    }
    if (s_cmp(gm, "GX", (ftnlen)2, (ftnlen)2) == 0) {
	goto L18;
    }
    if (s_cmp(gm, "GR", (ftnlen)2, (ftnlen)2) == 0) {
	goto L19;
    }
    if (s_cmp(gm, "GS", (ftnlen)2, (ftnlen)2) == 0) {
	goto L21;
    }
    if (s_cmp(gm, "SP", (ftnlen)2, (ftnlen)2) == 0) {
	goto L9;
    }
    if (s_cmp(gm, "SM", (ftnlen)2, (ftnlen)2) == 0) {
	goto L13;
    }
    if (s_cmp(gm, "GE", (ftnlen)2, (ftnlen)2) == 0) {
	goto L29;
    }
    if (s_cmp(gm, "GM", (ftnlen)2, (ftnlen)2) == 0) {
	goto L26;
    }
    if (s_cmp(gm, "GA", (ftnlen)2, (ftnlen)2) == 0) {
	goto L8;
    }
    if (s_cmp(gm, "GH", (ftnlen)2, (ftnlen)2) == 0) {
	goto L123;
    }
    s_wsfe(&io___741);
    e_wsfe();
    s_wsfe(&io___742);
    do_fio(&c__1, gm, (ftnlen)2);
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&rad, (ftnlen)sizeof(doublereal));
    e_wsfe();
    s_stop("", (ftnlen)0);

/*     GENERATE SEGMENT DATA FOR STRAIGHT WIRE. */

L3:
    ++nwire;
    i1 = data_1.n + 1;
    i2 = data_1.n + ns;
    s_wsfe(&io___745);
    do_fio(&c__1, (char *)&nwire, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&rad, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i2, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    e_wsfe();
    if (rad != 0.f) {
	xs1 = 1.f;
	ys1 = 1.f;
    } else {
	readgm_(&c__2, gm, &ix, &iy, &xs1, &ys1, &zs1, &segl1, &segl2, &dummy,
		 &dummy, &dummy, &dummy, &dummy, filnam, (ftnlen)2, (ftnlen)
		80);
	if (s_cmp(gm, "GC", (ftnlen)2, (ftnlen)2) != 0) {
	    s_wsfe(&io___754);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	if (ix == 0) {
	    s_wsfe(&io___755);
	    do_fio(&c__1, (char *)&xs1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ys1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&zs1, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	} else if (ix == 1) {
	    rdlsol_(&ns, &xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &segl1, &segl2, &
		    xs1);
	    s_wsfe(&io___756);
	    do_fio(&c__1, (char *)&segl1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&xs1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ys1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&zs1, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	} else if (ix == 2) {
	    ns = 0;
	    rdlsol_(&ns, &xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &segl1, &segl2, &
		    xs1);
	    s_wsfe(&io___757);
	    do_fio(&c__1, (char *)&segl1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&segl2, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ys1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&zs1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&xs1, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
	if (ys1 == 0. || zs1 == 0.) {
	    s_wsfe(&io___758);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	rad = ys1;
	d__1 = zs1 / ys1;
	d__2 = (doublereal) (1.f / (ns - 1.f));
	ys1 = pow_dd(&d__1, &d__2);
    }
    wire_(&xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &rad, &xs1, &ys1, &ns, &itg);
    goto L1;

/*     GENERATE SEGMENT DATA FOR WIRE ARC */

L8:
    ++nwire;
    i1 = data_1.n + 1;
    i2 = data_1.n + ns;
    s_wsfe(&io___759);
    do_fio(&c__1, (char *)&nwire, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i2, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    e_wsfe();
    arcnec_(&itg, &ns, &xw1, &yw1, &zw1, &xw2);
    goto L1;

/*     GENERATE SEGMENT DATA FOR A CATENARY WIRE */

L4:
    ++nwire;
    i1 = data_1.n + 1;
    i2 = data_1.n + ns;
    icat = (integer) (f8 + .5f);
    s_wsfe(&io___761);
    do_fio(&c__1, (char *)&icat, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&f9, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&f10, (ftnlen)sizeof(doublereal));
    e_wsfe();
    catnry_(&xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &rad, &icat, &f9, &f10, &ns, &
	    itg);
    s_wsfe(&io___762);
    do_fio(&c__1, (char *)&nwire, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&rad, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&i2, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    e_wsfe();
    goto L1;
/* *** */

/*     GENERATE HELIX */

L123:
    ++nwire;
    i1 = data_1.n + 1;
    i2 = data_1.n + ns;
    ihelix = (integer) (rad + .5f);
    if (xw2 == 0.f) {
	xw2 = zw1;
    }
    if (zw2 == 0.f) {
	zw2 = yw2;
    }
    if (ihelix == 0) {
	s_wsfe(&io___764);
	do_fio(&c__1, (char *)&nwire, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&i2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
	e_wsfe();
    }
    if (ihelix != 0) {
	s_wsfe(&io___765);
	do_fio(&c__1, (char *)&nwire, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&i2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
	e_wsfe();
    }
    s_wsfe(&io___766);
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    e_wsfe();
    helix_(&ihelix, &xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &ns, &itg);
    goto L1;

/*     GENERATE SINGLE NEW PATCH */

L9:
    i1 = data_1.m + 1;
    ++ns;
    if (itg != 0) {
	goto L17;
    }
    s_wsfe(&io___767);
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, ipt + (ns - 1), (ftnlen)1);
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    e_wsfe();
    if (ns == 2 || ns == 4) {
	isct = 1;
    }
    if (ns > 1) {
	goto L14;
    }
    xw2 *= ta;
    yw2 *= ta;
    goto L16;
L10:
    if (isct == 0) {
	goto L17;
    }
    i1 = data_1.m + 1;
    ++ns;
    if (itg != 0) {
	goto L17;
    }
    if (ns != 2 && ns != 4) {
	goto L17;
    }
    xs1 = x4;
    ys1 = y4;
    zs1 = z4;
    xs2 = x3;
    ys2 = y3;
    zs2 = z3;
    x3 = xw1;
    y3 = yw1;
    z3 = zw1;
    if (ns != 4) {
	goto L11;
    }
    x4 = xw2;
    y4 = yw2;
    z4 = zw2;
L11:
    xw1 = xs1;
    yw1 = ys1;
    zw1 = zs1;
    xw2 = xs2;
    yw2 = ys2;
    zw2 = zs2;
    if (ns == 4) {
	goto L12;
    }
    x4 = xw1 + x3 - xw2;
    y4 = yw1 + y3 - yw2;
    z4 = zw1 + z3 - zw2;
L12:
    s_wsfe(&io___777);
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, ipt + (ns - 1), (ftnlen)1);
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    e_wsfe();
    s_wsfe(&io___778);
    do_fio(&c__1, (char *)&x3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&y3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&z3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&x4, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&y4, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&z4, (ftnlen)sizeof(doublereal));
    e_wsfe();
    goto L16;

/*     GENERATE MULTIPLE-PATCH SURFACE */

L13:
    i1 = data_1.m + 1;
    s_wsfe(&io___779);
    do_fio(&c__1, (char *)&i1, (ftnlen)sizeof(integer));
    do_fio(&c__1, ipt + 1, (ftnlen)1);
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    e_wsfe();
    if (itg < 1 || ns < 1) {
	goto L17;
    }
L14:
    readgm_(&c__2, gm, &ix, &iy, &x3, &y3, &z3, &x4, &y4, &z4, &dummy, &dummy,
	     &dummy, &dummy, filnam, (ftnlen)2, (ftnlen)80);

    if (ns != 2 && itg < 1) {
	goto L15;
    }
    x4 = xw1 + x3 - xw2;
    y4 = yw1 + y3 - yw2;
    z4 = zw1 + z3 - zw2;
L15:
    s_wsfe(&io___780);
    do_fio(&c__1, (char *)&x3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&y3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&z3, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&x4, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&y4, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&z4, (ftnlen)sizeof(doublereal));
    e_wsfe();
    if (s_cmp(gm, "SC", (ftnlen)2, (ftnlen)2) != 0) {
	goto L17;
    }
L16:
    patch_(&itg, &ns, &xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &x3, &y3, &z3, &x4, 
	    &y4, &z4);
    goto L1;
L17:
    s_wsfe(&io___781);
    e_wsfe();
    s_stop("", (ftnlen)0);

/*     REFLECT STRUCTURE ALONG X,Y, OR Z AXES OR ROTATE TO FORM CYLINDER. */

L18:
    iy = ns / 10;
    iz = ns - iy * 10;
    ix = iy / 10;
    iy -= ix * 10;
    if (ix != 0) {
	ix = 1;
    }
    if (iy != 0) {
	iy = 1;
    }
    if (iz != 0) {
	iz = 1;
    }
    s_wsfe(&io___783);
    do_fio(&c__1, ifx + ix, (ftnlen)1);
    do_fio(&c__1, ify + iy, (ftnlen)1);
    do_fio(&c__1, ifz + (iz << 1), (ftnlen)2);
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    e_wsfe();
    goto L20;
L19:
    s_wsfe(&io___784);
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    e_wsfe();
    ix = -1;
L20:
    reflc_(&ix, &iy, &iz, &itg, &ns);
    goto L1;

/*     SCALE STRUCTURE DIMENSIONS BY FACTOR XW1. */

L21:
    if (data_1.n < data_1.n2) {
	goto L23;
    }
    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
	data_1.x[i__ - 1] *= xw1;
	data_1.y[i__ - 1] *= xw1;
	data_1.z__[i__ - 1] *= xw1;
	x2[i__ - 1] *= xw1;
	y2[i__ - 1] *= xw1;
	z2[i__ - 1] *= xw1;
/* L22: */
	data_1.bi[i__ - 1] *= xw1;
    }
L23:
    if (data_1.m < data_1.m2) {
	goto L25;
    }
    yw1 = xw1 * xw1;
    ix = data_1.ld + 1 - data_1.m;
    iy = data_1.ld - data_1.m1;
    i__1 = iy;
    for (i__ = ix; i__ <= i__1; ++i__) {
	data_1.x[i__ - 1] *= xw1;
	data_1.y[i__ - 1] *= xw1;
	data_1.z__[i__ - 1] *= xw1;
/* L24: */
	data_1.bi[i__ - 1] *= yw1;
    }
L25:
    s_wsfe(&io___786);
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    e_wsfe();
    goto L1;

/*     MOVE STRUCTURE OR REPRODUCE ORIGINAL STRUCTURE IN NEW POSITIONS. */

L26:
    itg1 = (integer) (rad + .5f);
    isg1 = (integer) (f8 + .5f);
    itg2 = (integer) (f9 + .5f);
    isg2 = (integer) (f10 + .5f);
    if (isg1 == 0) {
	isg1 = 1;
    }
    if (itg2 == 0 && isg2 == 0) {
	isg2 = data_1.n;
    }
    if (isg2 == 0) {
	isg2 = 1;
    }
    s_wsfe(&io___791);
    do_fio(&c__1, (char *)&itg, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&ns, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&zw2, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&itg1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&isg1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&itg2, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&isg2, (ftnlen)sizeof(integer));
    e_wsfe();
    xw1 *= ta;
    yw1 *= ta;
    zw1 *= ta;
    move_(&xw1, &yw1, &zw1, &xw2, &yw2, &zw2, &ns, &itg, &itg1, &isg1, &itg2, 
	    &isg2);
    goto L1;

/*     READ NUMERICAL GREEN'S FUNCTION TAPE */

L27:
    if (data_1.n + data_1.m == 0) {
	goto L28;
    }
    s_wsfe(&io___792);
    e_wsfe();
    s_stop("", (ftnlen)0);
L28:
    gfil_(&itg, filnam, (ftnlen)80);
    npsav = data_1.np;
    mpsav = data_1.mp;
    ipsav = data_1.ipsym;
    goto L1;

/*     TERMINATE STRUCTURE GEOMETRY INPUT. */

L29:
    ix = data_1.n1 + data_1.m1;
    if (ix == 0) {
	goto L30;
    }
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
L30:
    conect_(&itg, &ns);
    if (ix == 0) {
	goto L31;
    }
    data_1.np = npsav;
    data_1.mp = mpsav;
    data_1.ipsym = ipsav;
L31:
    if (data_1.n + data_1.m > data_1.ld) {
	goto L37;
    }
    if (data_1.n == 0) {
	goto L33;
    }
    s_wsfe(&io___796);
    e_wsfe();
    s_wsfe(&io___797);
    e_wsfe();
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	xw1 = x2[i__ - 1] - data_1.x[i__ - 1];
	yw1 = y2[i__ - 1] - data_1.y[i__ - 1];
	zw1 = z2[i__ - 1] - data_1.z__[i__ - 1];
	data_1.x[i__ - 1] = (data_1.x[i__ - 1] + x2[i__ - 1]) * .5f;
	data_1.y[i__ - 1] = (data_1.y[i__ - 1] + y2[i__ - 1]) * .5f;
	data_1.z__[i__ - 1] = (data_1.z__[i__ - 1] + z2[i__ - 1]) * .5f;
	xw2 = xw1 * xw1 + yw1 * yw1 + zw1 * zw1;
	yw2 = sqrt(xw2);
	yw2 = (xw2 / yw2 + yw2) * .5f;
	data_1.si[i__ - 1] = yw2;
	cab[i__ - 1] = xw1 / yw2;
	sab[i__ - 1] = yw1 / yw2;
	xw2 = zw1 / yw2;
	if (xw2 > 1.f) {
	    xw2 = 1.f;
	}
	if (xw2 < -1.f) {
	    xw2 = -1.f;
	}
	data_1.salp[i__ - 1] = xw2;
	xw2 = asin(xw2) * td;
	yw2 = atgn2_(&yw1, &xw1) * td;
	s_wsfe(&io___798);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_fio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_fio(&c__1, (char *)&xw2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&yw2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_fio(&c__1, (char *)&data_1.icon1[i__ - 1], (ftnlen)sizeof(integer))
		;
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.icon2[i__ - 1], (ftnlen)sizeof(integer))
		;
	do_fio(&c__1, (char *)&data_1.itag[i__ - 1], (ftnlen)sizeof(integer));
	e_wsfe();
	if (data_1.si[i__ - 1] > 1e-20f && data_1.bi[i__ - 1] > 1e-20f) {
	    goto L32;
	}
	s_wsfe(&io___799);
	e_wsfe();
	s_stop("", (ftnlen)0);
L32:
	;
    }
L33:
    if (data_1.m == 0) {
	goto L35;
    }
    s_wsfe(&io___800);
    e_wsfe();
    j = data_1.ld + 1;
    i__1 = data_1.m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	--j;
	xw1 = (t1y[j - 1] * data_1.t2z[j - 1] - t1z[j - 1] * data_1.t2y[j - 1]
		) * data_1.salp[j - 1];
	yw1 = (t1z[j - 1] * data_1.t2x[j - 1] - t1x[j - 1] * data_1.t2z[j - 1]
		) * data_1.salp[j - 1];
	zw1 = (t1x[j - 1] * data_1.t2y[j - 1] - t1y[j - 1] * data_1.t2x[j - 1]
		) * data_1.salp[j - 1];
	s_wsfe(&io___802);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.x[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.y[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.z__[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&xw1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&yw1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zw1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.bi[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&t1x[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&t1y[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&t1z[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.t2x[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.t2y[j - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.t2z[j - 1], (ftnlen)sizeof(doublereal));
	e_wsfe();
/* L34: */
    }
L35:
    return 0;
L37:
    s_wsfe(&io___803);
    e_wsfe();
    s_stop("", (ftnlen)0);

    return 0;
} /* datagn_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x
#undef z2
#undef y2
#undef x2


/* Subroutine */ int rdlsol_(integer *nseg, doublereal *x1, doublereal *y1, 
	doublereal *z1, doublereal *x2, doublereal *y2, doublereal *z2, 
	doublereal *del1, doublereal *del2, doublereal *rdelx)
{
    /* Format strings */
    static char fmt_90[] = "(\002 RDLSOL: ERROR - ILLEGAL STARTING SEGMENT L"
	    "ENGTH\002)";
    static char fmt_92[] = "(\002 RDLSOL: ERROR - ILLEGAL FINAL SEGMENT LENG"
	    "TH\002)";
    static char fmt_91[] = "(\002 RDLSOL: SOLUTION DID NOT CONVERGE\002)";

    /* System generated locals */
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double sqrt(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double log(doublereal), pow_dd(doublereal *, doublereal *), pow_di(
	    doublereal *, integer *);

    /* Local variables */
    static doublereal dn, omr;
    static integer itr;
    static doublereal elen, rdel, rmax, dnewt, dnewt0, dnewt1;
    static integer nxstop;

    /* Fortran I/O blocks */
    static cilist io___805 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___806 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___816 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     RDLSOL SOLVES FOR THE LENGTH RATIO FOR TAPERED SEGMENT LENGTHS */

/*     INPUT: */
/*     NSEG = NUMBER OF SEGMENTS (=0 WHEN DEL1 AND DEL2 ARE SPECIFIED) */
/*     X1,Y1,Z1 = FIRST END OF THE WIRE */
/*     X2,Y2,Z2 = SECOND END OF THE WIRE */
/*     DEL1 = LENGTH OF THE FIRST SEGMENT */
/*     DEL2 = LENGTH OF THE LAST SEGMENT (USED ONLY IF NSEG.LE.0) */

/*     OUTPUT: */
/*     RDELX = RATIO OF LENGTH OF SEGMENT I+1 TO SEGMENT I */
/*     NSEG = NUMBER OF SEGMENTS (RETURNED WHEN DEL1 AND DEL2 SPECIFIED) */

/* Computing 2nd power */
    d__1 = *x2 - *x1;
/* Computing 2nd power */
    d__2 = *y2 - *y1;
/* Computing 2nd power */
    d__3 = *z2 - *z1;
    elen = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    if (*nseg == 1) {
	*rdelx = 1.f;
	return 0;
    } else if (*del1 >= elen || *del1 <= 0.f) {
	s_wsfe(&io___805);
	e_wsfe();
	s_stop("", (ftnlen)0);
    } else if (*nseg < 1) {
	if (*del2 >= elen || *del2 <= 0.f) {
	    s_wsfe(&io___806);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	} else if ((d__1 = (*del1 - *del2) / *del1, abs(d__1)) < 1e-6f) {
	    *rdelx = 1.f;
	    *nseg = (integer) (elen / *del1 + .5f);
	    return 0;
	} else {
	    *rdelx = (elen - *del1) / (elen - *del2);
	    *nseg = (integer) (log(*del2 / *del1) / log(*rdelx) + 1.5f);
	    if (*nseg < 2) {
		*nseg = 2;
	    }
	}
    }
    dnewt0 = (*nseg * *del1 - elen) * 2.f / (*del1 * *nseg * (*nseg - 1.f));
    dnewt1 = (elen * 4.f * (2.f - *nseg) + *del1 * *nseg * (*nseg - 5.f)) / (*
	    del1 * 3.f * *nseg * (1.f - *nseg));
    d__1 = elen / *del1;
    d__2 = (doublereal) (1.f / (*nseg - 1.f));
    rmax = pow_dd(&d__1, &d__2);
    rdel = 1.f;
    nxstop = 0;
    for (itr = 1; itr <= 200; ++itr) {
	if (rdel > rmax) {
	    rdel = rmax;
	}
	dn = pow_di(&rdel, nseg);
	if ((d__1 = dn - 1.f, abs(d__1)) > .1f) {
	    omr = 1.f - rdel;
	    dnewt = -omr * (elen * omr - *del1 * (1.f - dn)) / (*del1 * (1.f 
		    - dn - dn * *nseg * omr / rdel));
	} else {
	    dnewt = dnewt0 + dnewt1 * (rdel - 1.f);
	}
	rdel -= dnewt;
	if (nxstop == 1) {
	    goto L2;
	}
	if ((d__1 = dnewt / rdel, abs(d__1)) < 1e-5f) {
	    nxstop = 1;
	}
/* L1: */
    }
    s_wsfe(&io___816);
    e_wsfe();
L2:
    *rdelx = rdel;
    return 0;

} /* rdlsol_ */

doublereal db10_0_(int n__, doublereal *x)
{
    /* System generated locals */
    doublereal ret_val;

    /* Builtin functions */
    double d_lg10(doublereal *);

    /* Local variables */
    static doublereal f;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     FUNCTION DB10 returns dB for magnitude (20 log) */
/*     Entry DB20 returns dB for mag.**2 (10 log). */

    switch(n__) {
	case 1: goto L_db20;
	}

    f = 10.f;
    goto L1;

L_db20:
    f = 20.f;
L1:
    if (*x < 1e-20f) {
	goto L2;
    }
    ret_val = f * d_lg10(x);
    return ret_val;
L2:
    ret_val = -999.99f;
    ret_val = ret_val;
    return ret_val;
} /* db10_ */

doublereal db10_(doublereal *x)
{
    return db10_0_(0, x);
    }

doublereal db20_(doublereal *x)
{
    return db10_0_(1, x);
    }

/* Subroutine */ int daopen_(integer *iunit, char *fil, char *stat, char *dis,
	 integer *lrecb, ftnlen fil_len, ftnlen stat_len, ftnlen dis_len)
{
    /* Initialized data */

    static integer mxlenr = 8191;

    /* System generated locals */
    olist o__1;

    /* Builtin functions */
    integer f_open(olist *);

    /* Local variables */
    static integer mxlenc;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     DAOPEN OPENS A FILE FOR DIRECT-ACCESS READS AND WRITES OF COMPLEX */
/*     NUMBERS.  BLOCKS (RECORDS) OUTPUT BY THE PROGRAM ARE BROKEN INTO */
/*     SMALLER RECORDS IF REQUIRED BY THE LIMITATION ON RECORD LENGTH */
/*     IMPOSED BY THE COMPUTER SYSTEM. */

/*     INPUT:  (OTHER THAN OBVIOUS FILE PARAMETERS) */
/*     LRECB = NUMBER OF COMPLEX NUMBERS IN A BLOCK (RECORD) OUTPUT BY */
/*             THE PROGRAM */
/*     MXLENR = MAXIMUM RECORD LENGTH (NUMBER OF REAL NUMBERS) SET BY THE */
/*              COMPUTER SYSTEM */
/*     MAXFIL = HIGHEST LOGICAL UNIT NUMBER USED BY THE PROGRAM */

/*     OUTPUT: */
/*     NRPRX(IUNIT) = NUMBER OF LOGICAL RECORDS PER BLOCK FOR LOGICAL */
/*                    UNIT NUMBER IUNIT */
/*     LREC = NUMBER OF COMPLEX NUMBERS IN A LOGICAL RECORD (#< NRPRX) */
/*     LRECL = NUMBER OF COMPLEX NUMBERS IN LOGICAL RECORD # NRPRX */

    mxlenc = mxlenr / 4;
    rstruc_1.nrprx[*iunit - 1] = (*lrecb - 1) / mxlenc + 1;
    if (rstruc_1.nrprx[*iunit - 1] > 1) {
	rstruc_1.lrec[*iunit - 1] = mxlenc;
	rstruc_1.lrecl[*iunit - 1] = *lrecb - (rstruc_1.nrprx[*iunit - 1] - 1)
		 * rstruc_1.lrec[*iunit - 1];
    } else {
	rstruc_1.lrec[*iunit - 1] = *lrecb;
	rstruc_1.lrecl[*iunit - 1] = *lrecb;
    }
/* ***  VAX:   RECL IN WORDS */
/*      OPEN(UNIT=IUNIT,FILE=FIL,STATUS=STAT,FORM='UNFORMATTED', */
/*     &ACCESS='DIRECT',RECL=4*LREC(IUNIT)) */
/* ***  UNIX:  RECL IN BYTES */
    o__1.oerr = 0;
    o__1.ounit = *iunit;
    o__1.ofnmlen = fil_len;
    o__1.ofnm = fil;
    o__1.orl = rstruc_1.lrec[*iunit - 1] << 4;
    o__1.osta = stat;
    o__1.oacc = "DIRECT";
    o__1.ofm = "UNFORMATTED";
    o__1.oblnk = 0;
    f_open(&o__1);
    return 0;
} /* daopen_ */

/* Subroutine */ int recot_(doublecomplex *a, integer *iunit, integer *i1, 
	integer *i2, integer *irec, char *trace, ftnlen trace_len)
{
    /* Format strings */
    static char fmt_90[] = "(\002 RECOT: ERROR WRITING FILE\002,i4,/,\002 PR"
	    "OGRAM RECORD NO.\002,i5,\002 LOGICAL RECORD NO.\002,i5,\002 I1,I"
	    "2=\002,2i7,/,\002 TRACE - \002,a)";

    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer s_wdue(cilist *), do_uio(integer *, char *, ftnlen), e_wdue(void),
	     s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void)
	    ;
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer k, k1, k2, ir, irece, irecs;
    extern /* Subroutine */ int error_(void);

    /* Fortran I/O blocks */
    static cilist io___825 = { 1, 0, 0, 0, 0 };
    static cilist io___827 = { 0, 6, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     RECOT WRITES A RECORD TO A DIRECT-ACCESS FILE */

/*     INPUT: */
/*     A = ARRAY FROM WHICH DATA IS WRITTEN (COMPLEX) */
/*     IUNIT = LOGICAL UNIT NUMBER */
/*     I1,I2 = STARTING AND ENDING LOCATIONS IN ARRAY A TO BE WRITTEN */
/*     IREC = NUMBER OF THE PROGRAM RECORD TO BE WRITTEN TO THE FILE */
/*     TRACE = MESSAGE PRINTED IN CASE OF AN ERROR - WHO CALLED RECOT? */

    /* Parameter adjustments */
    --a;

    /* Function Body */
    irecs = (*irec - 1) * rstruc_1.nrprx[*iunit - 1] + 1;
    irece = irecs + rstruc_1.nrprx[*iunit - 1] - 1;
    k2 = *i1 - 1;
    i__1 = irece;
    for (ir = irecs; ir <= i__1; ++ir) {
	k1 = k2 + 1;
	if (ir < irece) {
	    k2 += rstruc_1.lrec[*iunit - 1];
	} else {
	    k2 += rstruc_1.lrecl[*iunit - 1];
	}
	if (k1 > *i2) {
	    return 0;
	}
	if (k2 > *i2) {
	    k2 = *i2;
	}
	io___825.ciunit = *iunit;
	io___825.cirec = ir;
	i__2 = s_wdue(&io___825);
	if (i__2 != 0) {
	    goto L2;
	}
	i__3 = k2;
	for (k = k1; k <= i__3; ++k) {
	    i__2 = do_uio(&c__2, (char *)&a[k], (ftnlen)sizeof(doublereal));
	    if (i__2 != 0) {
		goto L2;
	    }
	}
	i__2 = e_wdue();
	if (i__2 != 0) {
	    goto L2;
	}
/* L1: */
    }
    return 0;
L2:
    s_wsfe(&io___827);
    do_fio(&c__1, (char *)&(*iunit), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*irec), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&ir, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*i1), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*i2), (ftnlen)sizeof(integer));
    do_fio(&c__1, trace, trace_len);
    e_wsfe();
    error_();
    s_stop("", (ftnlen)0);
    return 0;
} /* recot_ */

/* Subroutine */ int recin_(doublecomplex *a, integer *iunit, integer *i1, 
	integer *i2, integer *irec, char *trace, ftnlen trace_len)
{
    /* Format strings */
    static char fmt_90[] = "(\002 RECIN: ERROR READING FILE\002,i4,/,\002 PR"
	    "OGRAM RECORD NO.\002,i5,\002 I1,I2=\002,2i7,/,\002 TRACE - \002,"
	    "a)";

    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer s_rdue(cilist *), do_uio(integer *, char *, ftnlen), e_rdue(void),
	     s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void)
	    ;
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer k, k1, k2, ir, irece, irecs;
    extern /* Subroutine */ int error_(void);

    /* Fortran I/O blocks */
    static cilist io___833 = { 1, 0, 0, 0, 0 };
    static cilist io___835 = { 0, 6, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     RECIN READS A RECORD FROM A DIRECT-ACCESS FILE */

/*     INPUT: */
/*     IUNIT = LOGICAL UNIT NUMBER */
/*     I1,I2 = STARTING AND ENDING LOCATIONS TO BE FILLED IN ARRAY A */
/*     IREC = NUMBER OF THE RECORD TO BE READ FROM THE FILE */
/*     TRACE = MESSAGE PRINTED IN CASE OF AN ERROR - WHO CALLED RECIN? */

/*     OUTPUT: */
/*     A = ARRAY CONTAINING DATA READ */

    /* Parameter adjustments */
    --a;

    /* Function Body */
    irecs = (*irec - 1) * rstruc_1.nrprx[*iunit - 1] + 1;
    irece = irecs + rstruc_1.nrprx[*iunit - 1] - 1;
    k2 = *i1 - 1;
    i__1 = irece;
    for (ir = irecs; ir <= i__1; ++ir) {
	k1 = k2 + 1;
	if (ir < irece) {
	    k2 += rstruc_1.lrec[*iunit - 1];
	} else {
	    k2 += rstruc_1.lrecl[*iunit - 1];
	}
	if (k1 > *i2) {
	    return 0;
	}
	if (k2 > *i2) {
	    k2 = *i2;
	}
	io___833.ciunit = *iunit;
	io___833.cirec = ir;
	i__2 = s_rdue(&io___833);
	if (i__2 != 0) {
	    goto L2;
	}
	i__3 = k2;
	for (k = k1; k <= i__3; ++k) {
	    i__2 = do_uio(&c__2, (char *)&a[k], (ftnlen)sizeof(doublereal));
	    if (i__2 != 0) {
		goto L2;
	    }
	}
	i__2 = e_rdue();
	if (i__2 != 0) {
	    goto L2;
	}
/* L1: */
    }
    return 0;
L2:
    s_wsfe(&io___835);
    do_fio(&c__1, (char *)&(*iunit), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*irec), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&ir, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*i1), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*i2), (ftnlen)sizeof(integer));
    do_fio(&c__1, trace, trace_len);
    e_wsfe();
    error_();
    s_stop("", (ftnlen)0);
    return 0;
} /* recin_ */

/* Subroutine */ int error_(void)
{
/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     ERROR prints the reason for a file I/O error on VAX/VMS only. */

/*      IMPLICIT INTEGER (A-Z) */
/*      CHARACTER MSG*80 */
/*      CALL ERRSNS(FNUM,RMSSTS,RMSSTV,IUNIT,CONDVAL) */
/*      CALL SYS$GETMSG(%VAL(RMSSTS),MSGLEN,MSG,,,) */
/*      CALL STR$UPCASE(MSG,MSG) */
/*      IND=INDEX(MSG,',') */
/*      WRITE(*,1)MSG(IND+2:MSGLEN) */
/* 1     FORMAT(//,' ERROR: ERROR IN FILE OPERATION --',//,5X,A,//) */
    return 0;
} /* error_ */

/* Subroutine */ int vltcap_(doublereal *xj, doublereal *yj, doublereal *zj, 
	doublereal *dxj, doublereal *dyj, doublereal *dzj, doublereal *slenj, 
	doublereal *aradj, doublecomplex *volts, doublecomplex *e)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublecomplex ex, ey, ez, xk;
    static doublereal xi, yi, zi;
    static doublecomplex tx, ty, tz;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublereal xij, yij, zij;
    static doublecomplex txc, etx, tyc, tzc, txs, tys, tzs;
    static doublereal dzjr;
    static doublecomplex fratx, zrati;
    extern /* Subroutine */ int efvcap_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *), rctran_(doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     VLTCAP evaluates the E field due to charge on segment end caps. */
/*     The field due to a ground plane, either perfectly conducting or */
/*     finitely conducting, is included.  In the Sommerfeld-integral mode */
/*     the quasistatic image is included but not the remaining component */
/*     from the interpolation tables. */

/*     INPUT: */
/*     XJ,YJ,ZJ = COORDINATES OF THE SOURCE SEGMENT */
/*     DXJ,DYJ,DZJ = UNIT VECTOR IN DIRECTION OF THE SOURCE SEGMENT */
/*     SLENJ = LENGTH OF SOURCE SEGMENT */
/*     ARADJ = RADIUS OF SOURCE SEGMENT */
/*     VOLTS = SOURCE VOLTAGE */

/*     OUTPUT: */
/*     E = ARRAY FOR R.H.S. OF MATRIX EQUATION UPDATED TO INCLUDE FIELD */
/*         DUE TO CHARGE ON THE END CAPS OF THE SOURCE SEGMENT. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    if (*zj > 0.f) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	etx.r = gnd_1.etau.r, etx.i = gnd_1.etau.i;
	fratx.r = gnd_1.frati.r, fratx.i = gnd_1.frati.i;
	z_div(&z__1, &gnd_1.xku, &gnd_1.xkl);
	zrati.r = z__1.r, zrati.i = z__1.i;
    } else {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	etx.r = gnd_1.etal.r, etx.i = gnd_1.etal.i;
	z__1.r = -gnd_1.frati.r, z__1.i = -gnd_1.frati.i;
	fratx.r = z__1.r, fratx.i = z__1.i;
	z_div(&z__1, &gnd_1.xkl, &gnd_1.xku);
	zrati.r = z__1.r, zrati.i = z__1.i;
    }

/*     LOOP OVER EVALUATION POINT SEGMENTS */

    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	xi = data_1.x[i__ - 1];
	yi = data_1.y[i__ - 1];
	zi = data_1.z__[i__ - 1];

/*     TEST WHETHER FIELD IS TRANSMITTED ACROSS AN INTERFACE WITH GROUND. */
/*     IF SO THE END CAP FIELD CANNOT BE CALCULATED SO E IS UNALTERED. */

	if (gnd_1.ksymp > 1 && zi * *zj < 0.f) {
	    goto L1;
	}
	xij = xi - *xj;
	yij = yi - *yj;
	zij = zi - *zj;

/*     EVALUATE DIRECT FIELD FROM SOURCE TO EVALUATION POINT */

	efvcap_(&xij, &yij, &zij, dxj, dyj, dzj, slenj, aradj, &xk, &ex, &ey, 
		&ez);
	if (gnd_1.ksymp == 1) {
	    i__2 = i__;
	    i__3 = i__;
	    i__4 = i__ - 1;
	    z__5.r = cab[i__4] * ex.r, z__5.i = cab[i__4] * ex.i;
	    i__5 = i__ - 1;
	    z__6.r = sab[i__5] * ey.r, z__6.i = sab[i__5] * ey.i;
	    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	    i__6 = i__ - 1;
	    z__7.r = data_1.salp[i__6] * ez.r, z__7.i = data_1.salp[i__6] * 
		    ez.i;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__2.r = z__3.r * volts->r - z__3.i * volts->i, z__2.i = z__3.r * 
		    volts->i + z__3.i * volts->r;
	    z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	    e[i__2].r = z__1.r, e[i__2].i = z__1.i;
	    goto L1;
	}

/*     FOR GROUND, EVALUATE FIELD OF THE IMAGE OF THE SOURCE SEGMENT */

	dzjr = -(*dzj);
	zij = zi + *zj;
	efvcap_(&xij, &yij, &zij, dxj, dyj, &dzjr, slenj, aradj, &xk, &tx, &
		ty, &tz);
	if (gnd_1.iperf == 0) {

/*     RCTRAN TRANSFORMS THE IMAGE FIELD FOR REFLECTION COEF. APPROX. */

	    rctran_(&xi, &yi, &zi, xj, yj, zj, &zrati, &etx, &tx, &ty, &tz, &
		    txs, &tys, &tzs, &txc, &tyc, &tzc);
	} else if (gnd_1.iperf == 2) {
	    z__1.r = tx.r * fratx.r - tx.i * fratx.i, z__1.i = tx.r * fratx.i 
		    + tx.i * fratx.r;
	    tx.r = z__1.r, tx.i = z__1.i;
	    z__1.r = ty.r * fratx.r - ty.i * fratx.i, z__1.i = ty.r * fratx.i 
		    + ty.i * fratx.r;
	    ty.r = z__1.r, ty.i = z__1.i;
	    z__1.r = tz.r * fratx.r - tz.i * fratx.i, z__1.i = tz.r * fratx.i 
		    + tz.i * fratx.r;
	    tz.r = z__1.r, tz.i = z__1.i;
	}
	i__2 = i__;
	i__3 = i__;
	z__6.r = ex.r - tx.r, z__6.i = ex.i - tx.i;
	i__4 = i__ - 1;
	z__5.r = cab[i__4] * z__6.r, z__5.i = cab[i__4] * z__6.i;
	z__8.r = ey.r - ty.r, z__8.i = ey.i - ty.i;
	i__5 = i__ - 1;
	z__7.r = sab[i__5] * z__8.r, z__7.i = sab[i__5] * z__8.i;
	z__4.r = z__5.r + z__7.r, z__4.i = z__5.i + z__7.i;
	z__10.r = ez.r - tz.r, z__10.i = ez.i - tz.i;
	i__6 = i__ - 1;
	z__9.r = data_1.salp[i__6] * z__10.r, z__9.i = data_1.salp[i__6] * 
		z__10.i;
	z__3.r = z__4.r + z__9.r, z__3.i = z__4.i + z__9.i;
	z__2.r = z__3.r * volts->r - z__3.i * volts->i, z__2.i = z__3.r * 
		volts->i + z__3.i * volts->r;
	z__1.r = e[i__3].r - z__2.r, z__1.i = e[i__3].i - z__2.i;
	e[i__2].r = z__1.r, e[i__2].i = z__1.i;
L1:
	;
    }
    return 0;
} /* vltcap_ */

#undef sab
#undef cab


/* Subroutine */ int efvcap_(doublereal *xij, doublereal *yij, doublereal *
	zij, doublereal *dxj, doublereal *dyj, doublereal *dzj, doublereal *
	slenj, doublereal *aradj, doublecomplex *xk, doublecomplex *ex, 
	doublecomplex *ey, doublecomplex *ez)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal rh, zp;
    static doublecomplex ecr1, ecr2, ecz1, ecz2;
    static doublereal rhox, rhoy, rhoz;
    extern /* Subroutine */ int efcap_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *);
    static doublereal shalf;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     EFVCAP evaluates the E field due to charged end caps on an */
/*     arbitrarily oriented segment in an infinite medium.  This routine */
/*     transforms coordinates and then calls subroutine EFCAP to evaluate */
/*     the field of the end caps of the segment on the Z axis of a */
/*     cylindrical coordinate system. */

/*     INPUT: */
/*     XIJ,YIJ,ZIJ = COMPONENTS OF VECTOR FROM SOURCE TO EVALUATON POINT */
/*     DXJ,DYJ,DZJ = UNIT VECTOR IN DIRECTION OF THE SOURCE SEGMENT */
/*     SLENJ = LENGTH OF THE SOURCE SEGMENT */
/*     ARADJ = RADIUS OF THE SOURCE SEGMENT */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE SOURCE */

/*     OUTPUT: */
/*     EX,EY,EZ = X,Y,Z COMPONENTS OF E DUE TO CHARGE ON END CAPS FOR */
/*                UNIT CURRENT OUT OF FIRST END OF SEGMENT AND ONTO */
/*                SECOND END OF SEGMENT. */

    shalf = *slenj * .5f;
    zp = *xij * *dxj + *yij * *dyj + *zij * *dzj;
    rhox = *xij - *dxj * zp;
    rhoy = *yij - *dyj * zp;
    rhoz = *zij - *dzj * zp;
    rh = sqrt(rhox * rhox + rhoy * rhoy + rhoz * rhoz);
    if (rh > 1e-12f) {
	rhox /= rh;
	rhoy /= rh;
	rhoz /= rh;
    } else {
	rhox = 0.f;
	rhoy = 0.f;
	rhoz = 0.f;
    }

/*     EFCAP EVALUATES THE FIELD DUE TO UNIT CHARGE DENSITY ON END CAP */

    d__1 = zp + shalf;
    efcap_(aradj, &rh, &d__1, xk, &ecr1, &ecz1);
    d__1 = zp - shalf;
    efcap_(aradj, &rh, &d__1, xk, &ecr2, &ecz2);
    z__2.r = ecz2.r - ecz1.r, z__2.i = ecz2.i - ecz1.i;
    z__1.r = z__2.r / *slenj, z__1.i = z__2.i / *slenj;
    ecz1.r = z__1.r, ecz1.i = z__1.i;
/*      ECR1=(ECR2-ECR1)/SLENJ */
/*      EX=ECZ1*DXJ+ECR1*RHOX */
/*      EY=ECZ1*DYJ+ECR1*RHOY */
/*      EZ=ECZ1*DZJ+ECR1*RHOZ */
    z__1.r = *dxj * ecz1.r, z__1.i = *dxj * ecz1.i;
    ex->r = z__1.r, ex->i = z__1.i;
    z__1.r = *dyj * ecz1.r, z__1.i = *dyj * ecz1.i;
    ey->r = z__1.r, ey->i = z__1.i;
    z__1.r = *dzj * ecz1.r, z__1.i = *dzj * ecz1.i;
    ez->r = z__1.r, ez->i = z__1.i;
    return 0;
} /* efvcap_ */

/* Subroutine */ int facgf_(doublecomplex *a, doublecomplex *b, doublecomplex 
	*c__, doublecomplex *d__, doublecomplex *bx, integer *ip, integer *np,
	 integer *n1, integer *mp, integer *m1, integer *n1c, integer *n2c)
{
    /* System generated locals */
    integer b_dim1, b_offset, c_dim1, c_offset, d_dim1, d_offset, bx_dim1, 
	    bx_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
    doublecomplex z__1, z__2;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *);

    /* Local variables */
    static integer i__, j, k, ib, ic, ii, nic, npb, npc;
    static doublecomplex sum;
    static integer n1cp;
    extern /* Subroutine */ int reblk_(doublecomplex *, doublecomplex *, 
	    integer *, integer *, integer *, integer *, integer *), recin_(
	    doublecomplex *, integer *, integer *, integer *, integer *, char 
	    *, ftnlen), factr_(integer *, doublecomplex *, integer *, integer 
	    *), recot_(doublecomplex *, integer *, integer *, integer *, 
	    integer *, char *, ftnlen), faciod_(doublecomplex *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *),
	     daopen_(integer *, char *, char *, char *, integer *, ftnlen, 
	    ftnlen, ftnlen), solves_(doublecomplex *, integer *, 
	    doublecomplex *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     FACGF computes and factors D-C(INV(A)B) for the NGF solution. */

    /* Parameter adjustments */
    --a;
    --ip;
    bx_dim1 = *n1c;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    c_dim1 = *n1c;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    b_dim1 = *n1c;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    d_dim1 = *n2c;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    if (*n2c == 0) {
	return 0;
    }

/*     CONVERT B FROM BLOCKS OF ROWS ON T15 TO BLOCKS OF COL. ON T12 */

    if (matpar_1.icasx > 2) {
	reblk_(&b[b_offset], &c__[c_offset], n1c, &matpar_1.npbx, n2c, &c__15,
		 &c__12);
    }

/*     COMPUTE INV(A)B AND WRITE ON TAPE14 */

    npb = matpar_1.npbl;
    i__1 = matpar_1.nbbl;
    for (ib = 1; ib <= i__1; ++ib) {
	if (ib == matpar_1.nbbl) {
	    npb = matpar_1.nlbl;
	}
	if (matpar_1.icasx > 1) {
	    i__2 = *n1c * npb;
	    recin_(&bx[bx_offset], &c__12, &c__1, &i__2, &ib, " READ #1 IN F"
		    "ACGF", (ftnlen)17);
	}
	solves_(&a[1], &ip[1], &bx[bx_offset], n1c, &npb, np, n1, mp, m1, &
		c__11);
	if (matpar_1.icasx > 1) {
	    i__2 = *n1c * npb;
	    recot_(&bx[bx_offset], &c__12, &c__1, &i__2, &ib, " WRITE #1 IN "
		    "FACGF", (ftnlen)18);
	}
/* L2: */
    }

/*     COMPUTE D-C(INV(A)B) AND WRITE ON TAPE14 */

    npc = matpar_1.npbl;
    i__1 = matpar_1.nbbl;
    for (ic = 1; ic <= i__1; ++ic) {
	if (ic == matpar_1.nbbl) {
	    npc = matpar_1.nlbl;
	}
	if (matpar_1.icasx > 1) {
	    i__2 = *n1c * npc;
	    recin_(&c__[c_offset], &c__13, &c__1, &i__2, &ic, " READ C IN FA"
		    "CGF", (ftnlen)16);
	    i__2 = *n2c * npc;
	    recin_(&d__[d_offset], &c__14, &c__1, &i__2, &ic, " READ D IN FA"
		    "CGF", (ftnlen)16);
	}
	npb = matpar_1.npbl;
	nic = 0;
	i__2 = matpar_1.nbbl;
	for (ib = 1; ib <= i__2; ++ib) {
	    if (ib == matpar_1.nbbl) {
		npb = matpar_1.nlbl;
	    }
	    if (matpar_1.icasx > 1) {
		i__3 = *n1c * npb;
		recin_(&b[b_offset], &c__12, &c__1, &i__3, &ib, " READ B IN "
			"FACGF", (ftnlen)16);
	    }
	    i__3 = npb;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		ii = i__ + nic;
		i__4 = npc;
		for (j = 1; j <= i__4; ++j) {
		    sum.r = 0.f, sum.i = 0.f;
		    i__5 = *n1c;
		    for (k = 1; k <= i__5; ++k) {
/* L5: */
			i__6 = k + i__ * b_dim1;
			i__7 = k + j * c_dim1;
			z__2.r = b[i__6].r * c__[i__7].r - b[i__6].i * c__[
				i__7].i, z__2.i = b[i__6].r * c__[i__7].i + b[
				i__6].i * c__[i__7].r;
			z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
			sum.r = z__1.r, sum.i = z__1.i;
		    }
/* L6: */
		    i__6 = ii + j * d_dim1;
		    i__7 = ii + j * d_dim1;
		    z__1.r = d__[i__7].r - sum.r, z__1.i = d__[i__7].i - 
			    sum.i;
		    d__[i__6].r = z__1.r, d__[i__6].i = z__1.i;
		}
	    }
/* L7: */
	    nic += matpar_1.npbl;
	}
	if (matpar_1.icasx > 1) {
	    i__2 = *n2c * matpar_1.npbl;
	    recot_(&d__[d_offset], &c__14, &c__1, &i__2, &ic, " WRITE D IN F"
		    "ACGF", (ftnlen)17);
	}
/* L8: */
    }

/*     FACTOR D-C(INV(A)B) */

    n1cp = *n1c + 1;
    if (matpar_1.icasx == 1) {
	factr_(n2c, &d__[d_offset], &ip[n1cp], n2c);
    } else if (matpar_1.icasx == 2 || matpar_1.icasx == 3) {
	npb = matpar_1.npbl;
	ic = 0;
	i__1 = matpar_1.nbbl;
	for (ib = 1; ib <= i__1; ++ib) {
	    if (ib == matpar_1.nbbl) {
		npb = matpar_1.nlbl;
	    }
	    ii = ic + 1;
	    ic += *n2c * npb;
/* L11: */
	    recin_(&b[b_offset], &c__14, &ii, &ic, &ib, " READ B(II->IC) IN "
		    "FACGF", (ftnlen)24);
	}
	factr_(n2c, &b[b_offset], &ip[n1cp], n2c);
	nic = *n2c * *n2c;
	cl__1.cerr = 1;
	cl__1.cunit = 14;
	cl__1.csta = "DELETE";
	i__1 = f_clos(&cl__1);
	if (i__1 != 0) {
	    goto L3;
	}
L3:
	daopen_(&c__14, "TAPED.NEC", "unknown", "DELETE", &nic, (ftnlen)9, (
		ftnlen)7, (ftnlen)6);
	recot_(&b[b_offset], &c__14, &c__1, &nic, &c__1, " WRITE B IN FACGF", 
		(ftnlen)17);
    } else if (matpar_1.icasx == 4) {
	faciod_(&b[b_offset], n2c, &c__1, &ip[n1cp], &matpar_1.nbbl, &
		matpar_1.npbl, &matpar_1.nlbl, &c__14);
    }
    return 0;
} /* facgf_ */

/* Subroutine */ int faciod_(doublecomplex *a, integer *nrow, integer *nop, 
	integer *ip, integer *nbloks, integer *npblk, integer *nlast, integer 
	*iunit)
{
    /* Format strings */
    static char fmt_4[] = "(/,\002 CP TIME TAKEN FOR FACTORIZATION = \002,1p"
	    "e12.5,\002 SEC.\002)";

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i1, i2, i3, i4;
    static doublereal t1, t2;
    static integer ka, kk, it, ix[2420], nbm, krec;
    static doublereal time;
    static integer ixbp;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen), recot_(doublecomplex *, 
	    integer *, integer *, integer *, integer *, char *, ftnlen);
    static integer ixblk1, ixblk2;
    extern /* Subroutine */ int second_(doublereal *), lfactr_(doublecomplex *
	    , integer *, integer *, integer *, integer *, integer *, integer *
	    , integer *), lunscr_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___899 = { 0, 3, 0, fmt_4, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     FACIOD CONTROLS I/O FOR FACTORING A MATRIX STORED ON DISK. */
/*     MULTIPLE SUB-MATRICES FROM THE SOLUTION OF A CIRCULANT MATRIX */
/*     WILL BE FACTORED WHEN THEY ARE STORED SEQUENTIALLY ON THE DISK. */

/*     INPUT */
/*     A = ARRAY FOR SCRATCH STORAGE OF BLOCKS OF MATRIX READ FROM DISK */
/*     NROW = NUMBER OF ROWS IN THE MATRIX */
/*     NOP = NUMBER OF SUB-MATRICES IN A CIRCULANT MATRIX SOLUTION */
/*     NBLOKS = NUMBER OF BLOCKS INTO WHICH EACH MATRIX IS DIVIDED */
/*     NPBLK = NUMBER OF COLUMNS IN THE BLOCKS (EXECPT THE LAST BLOCK) */
/*     NLAST = NUMBER OF COLUMNS IN THE LAST BLOCK */
/*     IUNIT = LOGICAL UNIT NUMBER FOR THE DISK FILE */

/*     OUTPUT: */
/*     IP = ARRAY OF PIVOT-ELEMENT INDICES FROM FACTORING */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --ip;
    a_dim1 = *nrow;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    it = *npblk * *nrow;
    nbm = *nbloks - 1;
    i1 = 1;
    i2 = it;
    i3 = it + 1;
    i4 = it << 1;
    time = 0.f;
    i__1 = *nop;
    for (kk = 1; kk <= i__1; ++kk) {
	ka = (kk - 1) * *nrow + 1;
	krec = (kk - 1) * *nbloks;
	i__2 = nbm;
	for (ixblk1 = 1; ixblk1 <= i__2; ++ixblk1) {
	    i__3 = ixblk1 + krec;
	    recin_(&a[a_offset], iunit, &i1, &i2, &i__3, "First read in FACI"
		    "OD", (ftnlen)20);
	    ixbp = ixblk1 + 1;
	    i__3 = *nbloks;
	    for (ixblk2 = ixbp; ixblk2 <= i__3; ++ixblk2) {
		i__4 = ixblk2 + krec;
		recin_(&a[a_offset], iunit, &i3, &i4, &i__4, "Second read in"
			" FACIOD", (ftnlen)21);
		second_(&t1);
		lfactr_(&a[a_offset], nrow, &ixblk1, &ixblk2, &ix[ka - 1], 
			nbloks, npblk, nlast);
		second_(&t2);
		time = time + t2 - t1;
		if (ixblk2 == ixbp) {
		    i__4 = ixblk1 + krec;
		    recot_(&a[a_offset], iunit, &i1, &i2, &i__4, "First writ"
			    "e in FACIOD", (ftnlen)21);
		}
		i__4 = ixblk2 + krec;
		recot_(&a[a_offset], iunit, &i3, &i4, &i__4, "Second write i"
			"n FACIOD", (ftnlen)22);
/* L1: */
	    }
/* L2: */
	}
/* L3: */
    }
    s_wsfe(&io___899);
    do_fio(&c__1, (char *)&time, (ftnlen)sizeof(doublereal));
    e_wsfe();
    lunscr_(&a[a_offset], nrow, nop, &ip[1], ix, nbloks, npblk, iunit);
    return 0;

} /* faciod_ */

/* Subroutine */ int factr_(integer *n, doublecomplex *a, integer *ip, 
	integer *ndim)
{
    /* Format strings */
    static char fmt_10[] = "(\002 FACTR: PIVOT(\002,i3,\002)=\002,1pe16.8)";

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__, j, k, r__, pj, pr, jp1, rm1, rp1;
    static doublecomplex arj;
    static integer iflg;
    static doublereal dmax__, elmag;

    /* Fortran I/O blocks */
    static cilist io___913 = { 0, 3, 0, fmt_10, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FACTR computes the LU decomposition of the matrix in A.  The */
/*     algorithm is described on pages 411-416 OF A. Ralston--A First */
/*     Course in Numerical Analysis.  Comments below refer to comments in */
/*     Ralston's text.    (MATRIX TRANSPOSED.) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


/*     Un-transpose the matrix for Gauss elimination */

    /* Parameter adjustments */
    --ip;
    a_dim1 = *ndim;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__2 = i__ - 1;
	for (j = 1; j <= i__2; ++j) {
	    i__3 = i__ + j * a_dim1;
	    arj.r = a[i__3].r, arj.i = a[i__3].i;
	    i__3 = i__ + j * a_dim1;
	    i__4 = j + i__ * a_dim1;
	    a[i__3].r = a[i__4].r, a[i__3].i = a[i__4].i;
	    i__3 = j + i__ * a_dim1;
	    a[i__3].r = arj.r, a[i__3].i = arj.i;
/* L11: */
	}
/* L12: */
    }
    iflg = 0;
    i__1 = *n;
    for (r__ = 1; r__ <= i__1; ++r__) {

/*     STEP 1 */

	i__2 = *n;
	for (k = 1; k <= i__2; ++k) {
	    i__3 = k - 1;
	    i__4 = k + r__ * a_dim1;
	    scratm_1.d__[i__3].r = a[i__4].r, scratm_1.d__[i__3].i = a[i__4]
		    .i;
/* L1: */
	}

/*     STEPS 2 AND 3 */

	rm1 = r__ - 1;
	if (rm1 < 1) {
	    goto L4;
	}
	i__2 = rm1;
	for (j = 1; j <= i__2; ++j) {
	    pj = ip[j];
	    i__3 = pj - 1;
	    arj.r = scratm_1.d__[i__3].r, arj.i = scratm_1.d__[i__3].i;
	    i__3 = j + r__ * a_dim1;
	    a[i__3].r = arj.r, a[i__3].i = arj.i;
	    i__3 = pj - 1;
	    i__4 = j - 1;
	    scratm_1.d__[i__3].r = scratm_1.d__[i__4].r, scratm_1.d__[i__3].i 
		    = scratm_1.d__[i__4].i;
	    jp1 = j + 1;
	    i__3 = *n;
	    for (i__ = jp1; i__ <= i__3; ++i__) {
		i__4 = i__ - 1;
		i__5 = i__ - 1;
		i__6 = i__ + j * a_dim1;
		z__2.r = a[i__6].r * arj.r - a[i__6].i * arj.i, z__2.i = a[
			i__6].r * arj.i + a[i__6].i * arj.r;
		z__1.r = scratm_1.d__[i__5].r - z__2.r, z__1.i = scratm_1.d__[
			i__5].i - z__2.i;
		scratm_1.d__[i__4].r = z__1.r, scratm_1.d__[i__4].i = z__1.i;
/* L2: */
	    }
/* L3: */
	}
L4:

/*     STEP 4 */

	i__2 = r__ - 1;
	d_cnjg(&z__2, &scratm_1.d__[r__ - 1]);
	z__1.r = scratm_1.d__[i__2].r * z__2.r - scratm_1.d__[i__2].i * 
		z__2.i, z__1.i = scratm_1.d__[i__2].r * z__2.i + scratm_1.d__[
		i__2].i * z__2.r;
	dmax__ = z__1.r;
	ip[r__] = r__;
	rp1 = r__ + 1;
	if (rp1 > *n) {
	    goto L6;
	}
	i__2 = *n;
	for (i__ = rp1; i__ <= i__2; ++i__) {
	    i__3 = i__ - 1;
	    d_cnjg(&z__2, &scratm_1.d__[i__ - 1]);
	    z__1.r = scratm_1.d__[i__3].r * z__2.r - scratm_1.d__[i__3].i * 
		    z__2.i, z__1.i = scratm_1.d__[i__3].r * z__2.i + 
		    scratm_1.d__[i__3].i * z__2.r;
	    elmag = z__1.r;
	    if (elmag < dmax__) {
		goto L5;
	    }
	    dmax__ = elmag;
	    ip[r__] = i__;
L5:
	    ;
	}
L6:
	if (dmax__ < 1e-10f) {
	    iflg = 1;
	}
	pr = ip[r__];
	i__2 = r__ + r__ * a_dim1;
	i__3 = pr - 1;
	a[i__2].r = scratm_1.d__[i__3].r, a[i__2].i = scratm_1.d__[i__3].i;
	i__2 = pr - 1;
	i__3 = r__ - 1;
	scratm_1.d__[i__2].r = scratm_1.d__[i__3].r, scratm_1.d__[i__2].i = 
		scratm_1.d__[i__3].i;

/*     STEP 5 */

	if (rp1 > *n) {
	    goto L8;
	}
	z_div(&z__1, &c_b336, &a[r__ + r__ * a_dim1]);
	arj.r = z__1.r, arj.i = z__1.i;
	i__2 = *n;
	for (i__ = rp1; i__ <= i__2; ++i__) {
	    i__3 = i__ + r__ * a_dim1;
	    i__4 = i__ - 1;
	    z__1.r = scratm_1.d__[i__4].r * arj.r - scratm_1.d__[i__4].i * 
		    arj.i, z__1.i = scratm_1.d__[i__4].r * arj.i + 
		    scratm_1.d__[i__4].i * arj.r;
	    a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L7: */
	}
L8:
	if (iflg == 0) {
	    goto L9;
	}
	s_wsfe(&io___913);
	do_fio(&c__1, (char *)&r__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&dmax__, (ftnlen)sizeof(doublereal));
	e_wsfe();
	iflg = 0;
L9:
	;
    }
    return 0;

} /* factr_ */

/* Subroutine */ int factrs_(integer *np, integer *nrow, doublecomplex *a, 
	integer *ip, integer *iu1, integer *iu2)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *);

    /* Local variables */
    static integer i__, j, k, j2, ka, kk, ir1, ir2, kkr, nop, irr1, irr2, 
	    lrec, nout, irec2;
    extern /* Subroutine */ int factr_(integer *, doublecomplex *, integer *, 
	    integer *), recin_(doublecomplex *, integer *, integer *, integer 
	    *, integer *, char *, ftnlen);
    static integer icols;
    extern /* Subroutine */ int recot_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen), faciod_(doublecomplex *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *), daopen_(integer *, char *, char *, char *, integer *, 
	    ftnlen, ftnlen, ftnlen);
    static integer icoldx;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     FACTRS, for a symmetric structure, transforms submatrices to form */
/*     matrices of the symmetric modes and calls a routine to factor the */
/*     matrices.  With no symmetry, the routine is called to factor the */
/*     complete matrix. */

/*     INPUT: */
/*     NP = no. equations in a symetric section (col. in transposed mat.) */
/*     NROW = total number of equations (rows of transposed matrix) */
/*     A = input matrix or storage array when matrix is on disk */
/*     IU1 = log. unit no. for input matrix and output of factored matrix */
/*     IU2 = log. unit no. for temporary use in reblocking symmetric mat. */

/*     OUTPUT: */
/*     A = factored matrix (unless written to disk) */
/*     IP = array of pivot element indices */

    /* Parameter adjustments */
    --ip;
    --a;

    /* Function Body */
    nop = *nrow / *np;
    if (matpar_1.icase <= 2) {

/*        FACTOR MATRIX IN MEMORY, WITH OR WITHOUT SYMMETRY. */

	i__1 = nop;
	for (kk = 1; kk <= i__1; ++kk) {
	    ka = (kk - 1) * *np + 1;
/* L1: */
	    factr_(np, &a[ka], &ip[ka], nrow);
	}
	return 0;
    } else if (matpar_1.icase == 3) {

/*        FACTOR MATRIX FROM DISK WHEN NO SYMMETRY EXISTS. */

	faciod_(&a[1], nrow, &nop, &ip[1], &matpar_1.nbloks, &matpar_1.npblk, 
		&matpar_1.nlast, iu1);
	return 0;
    }

/*     REWRITE THE MATRICES BY COLUMNS ON FILE IU2 */

    daopen_(iu2, "TAPE12.NEC", "unknown", "DELETE", np, (ftnlen)10, (ftnlen)7,
	     (ftnlen)6);
    nout = matpar_1.npblk * *nrow;
    irec2 = 0;
    i__1 = nop;
    for (k = 1; k <= i__1; ++k) {
	icols = matpar_1.npblk;
	ir2 = k * *np;
	ir1 = ir2 - *np + 1;
	i__2 = matpar_1.nbloks;
	for (lrec = 1; lrec <= i__2; ++lrec) {
	    if (matpar_1.nbloks > 1 || k == 1) {
		recin_(&a[1], iu1, &c__1, &nout, &lrec, "Read in DO 5 loop i"
			"n FACTRS", (ftnlen)27);
		if (lrec == matpar_1.nbloks) {
		    icols = matpar_1.nlast;
		}
	    }
	    irr1 = ir1;
	    irr2 = ir2;
	    i__3 = icols;
	    for (icoldx = 1; icoldx <= i__3; ++icoldx) {
		++irec2;
		recot_(&a[1], iu2, &irr1, &irr2, &irec2, "Write unit IU2 in "
			"FACTRS", (ftnlen)24);
		irr1 += *nrow;
		irr2 += *nrow;
/* L5: */
	    }
	}
    }
    irec2 = 0;
    if (matpar_1.icase == 4) {
	nout = *np * *np;
	cl__1.cerr = 1;
	cl__1.cunit = *iu1;
	cl__1.csta = "DELETE";
	i__3 = f_clos(&cl__1);
	if (i__3 != 0) {
	    goto L2;
	}
L2:
	daopen_(iu1, "TAPE11.DAT", "unknown", "DELETE", &nout, (ftnlen)10, (
		ftnlen)7, (ftnlen)6);
	i__3 = nop;
	for (kk = 1; kk <= i__3; ++kk) {
	    ir1 = 1 - *np;
	    ir2 = 0;
	    i__2 = *np;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		ir1 += *np;
		ir2 += *np;
		++irec2;
/* L6: */
		recin_(&a[1], iu2, &ir1, &ir2, &irec2, "Read submatrix for I"
			"CASE=4 in FACTRS", (ftnlen)36);
	    }
	    ka = (kk - 1) * *np + 1;
	    factr_(np, &a[1], &ip[ka], np);
	    recot_(&a[1], iu1, &c__1, &nout, &kk, "Writing factored submatri"
		    "ces from FACTRS", (ftnlen)40);
/* L7: */
	}
    } else {
	nout = matpar_1.npsym * *np;
	cl__1.cerr = 1;
	cl__1.cunit = *iu1;
	cl__1.csta = "DELETE";
	i__3 = f_clos(&cl__1);
	if (i__3 != 0) {
	    goto L3;
	}
L3:
	daopen_(iu1, "TAPE11.DAT", "unknown", "DELETE", &nout, (ftnlen)10, (
		ftnlen)7, (ftnlen)6);
	i__3 = nop;
	for (kk = 1; kk <= i__3; ++kk) {
	    kkr = (kk - 1) * matpar_1.nblsym;
	    j2 = matpar_1.npsym;
	    i__2 = matpar_1.nblsym;
	    for (lrec = 1; lrec <= i__2; ++lrec) {
		if (lrec == matpar_1.nblsym) {
		    j2 = matpar_1.nlsym;
		}
		ir1 = 1 - *np;
		ir2 = 0;
		i__1 = j2;
		for (j = 1; j <= i__1; ++j) {
		    ir1 += *np;
		    ir2 += *np;
		    ++irec2;
/* L9: */
		    recin_(&a[1], iu2, &ir1, &ir2, &irec2, "Read submatrix b"
			    "lock for ICASE=5 in FACTRS", (ftnlen)42);
		}
/* L10: */
		i__1 = lrec + kkr;
		recot_(&a[1], iu1, &c__1, &nout, &i__1, "Writing blocks of s"
			"ubmatrices from FACTRS", (ftnlen)41);
	    }
	}
	faciod_(&a[1], np, &nop, &ip[1], &matpar_1.nblsym, &matpar_1.npsym, &
		matpar_1.nlsym, iu1);
    }
    cl__1.cerr = 1;
    cl__1.cunit = *iu2;
    cl__1.csta = "DELETE";
    i__1 = f_clos(&cl__1);
    if (i__1 != 0) {
	goto L4;
    }
L4:
    return 0;
} /* factrs_ */

/* Double Complex */ VOID fbars_(doublecomplex * ret_val, doublecomplex *zx)
{
    /* Initialized data */

    static doublereal tosp = 1.128379167;
    static doublereal accs = 1e-12;
    static doublereal sp = 1.772453851;

    /* System generated locals */
    real r__1;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    void d_cnjg(doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublecomplex z__, zs;
    static doublereal sms, tms;
    static doublecomplex sum, pow, term;
    static integer minus;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     FBARS evaluates FBARS(Z)=1.-SQRT(PI)*Z*CEXP(Z*Z)*ERFC(Z) */
/*     where ERFC=complementary error function. */

    z__.r = zx->r, z__.i = zx->i;
    if (z_abs(&z__) > 3.f) {
	goto L3;
    }

/*     SERIES EXPANSION */

    z__1.r = z__.r * z__.r - z__.i * z__.i, z__1.i = z__.r * z__.i + z__.i * 
	    z__.r;
    zs.r = z__1.r, zs.i = z__1.i;
    sum.r = z__.r, sum.i = z__.i;
    pow.r = z__.r, pow.i = z__.i;
    for (i__ = 1; i__ <= 100; ++i__) {
	z__3.r = -pow.r, z__3.i = -pow.i;
	z__2.r = z__3.r * zs.r - z__3.i * zs.i, z__2.i = z__3.r * zs.i + 
		z__3.i * zs.r;
	d__1 = (doublereal) i__;
	z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
	pow.r = z__1.r, pow.i = z__1.i;
	r__1 = i__ * 2.f + 1.f;
	z__1.r = pow.r / r__1, z__1.i = pow.i / r__1;
	term.r = z__1.r, term.i = z__1.i;
	z__1.r = sum.r + term.r, z__1.i = sum.i + term.i;
	sum.r = z__1.r, sum.i = z__1.i;
	d_cnjg(&z__2, &term);
	z__1.r = term.r * z__2.r - term.i * z__2.i, z__1.i = term.r * z__2.i 
		+ term.i * z__2.r;
	tms = z__1.r;
	d_cnjg(&z__2, &sum);
	z__1.r = sum.r * z__2.r - sum.i * z__2.i, z__1.i = sum.r * z__2.i + 
		sum.i * z__2.r;
	sms = z__1.r;
	if (tms < sms * accs) {
	    goto L2;
	}
/* L1: */
    }
L2:
    z__6.r = tosp * sum.r, z__6.i = tosp * sum.i;
    z__5.r = 1.f - z__6.r, z__5.i = -z__6.i;
    z__4.r = z__5.r * z__.r - z__5.i * z__.i, z__4.i = z__5.r * z__.i + 
	    z__5.i * z__.r;
    z_exp(&z__7, &zs);
    z__3.r = z__4.r * z__7.r - z__4.i * z__7.i, z__3.i = z__4.r * z__7.i + 
	    z__4.i * z__7.r;
    z__2.r = sp * z__3.r, z__2.i = sp * z__3.i;
    z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
     ret_val->r = z__1.r,  ret_val->i = z__1.i;
    return ;

/*     ASYMPTOTIC EXPANSION */

L3:
    if (z__.r >= 0.f) {
	goto L4;
    }
    minus = 1;
    z__1.r = -z__.r, z__1.i = -z__.i;
    z__.r = z__1.r, z__.i = z__1.i;
    goto L5;
L4:
    minus = 0;
L5:
    z__2.r = z__.r * z__.r - z__.i * z__.i, z__2.i = z__.r * z__.i + z__.i * 
	    z__.r;
    z_div(&z__1, &c_b1298, &z__2);
    zs.r = z__1.r, zs.i = z__1.i;
    sum.r = 0.f, sum.i = 0.f;
    term.r = 1.f, term.i = 0.f;
    for (i__ = 1; i__ <= 6; ++i__) {
	z__3.r = -term.r, z__3.i = -term.i;
	r__1 = i__ * 2.f - 1.f;
	z__2.r = r__1 * z__3.r, z__2.i = r__1 * z__3.i;
	z__1.r = z__2.r * zs.r - z__2.i * zs.i, z__1.i = z__2.r * zs.i + 
		z__2.i * zs.r;
	term.r = z__1.r, term.i = z__1.i;
/* L6: */
	z__1.r = sum.r + term.r, z__1.i = sum.i + term.i;
	sum.r = z__1.r, sum.i = z__1.i;
    }
    if (minus == 1) {
	d__1 = sp * 2.f;
	z__3.r = d__1 * z__.r, z__3.i = d__1 * z__.i;
	z__5.r = z__.r * z__.r - z__.i * z__.i, z__5.i = z__.r * z__.i + 
		z__.i * z__.r;
	z_exp(&z__4, &z__5);
	z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i 
		+ z__3.i * z__4.r;
	z__1.r = sum.r - z__2.r, z__1.i = sum.i - z__2.i;
	sum.r = z__1.r, sum.i = z__1.i;
    }
    z__1.r = -sum.r, z__1.i = -sum.i;
     ret_val->r = z__1.r,  ret_val->i = z__1.i;
    return ;
} /* fbars_ */

/* Subroutine */ int fblock_(integer *nrow, integer *ncol, integer *imax, 
	integer *irngf, integer *ipsym)
{
    /* Format strings */
    static char fmt_17[] = "(\002 FBLOCK: ERROR - INSUFFICIENT STORAGE FOR M"
	    "ATRIX\002,2i5)";
    static char fmt_14[] = "(//,\002 MATRIX FILE STORAGE -  NO. BLOCKS=\002,"
	    "i5,\002 COLUMNS PER BLOCK=\002,i5,\002 COLUMNS IN LAST BLOCK="
	    "\002,i5)";
    static char fmt_15[] = "(\002 SUBMATRICES FIT IN CORE\002)";
    static char fmt_16[] = "(\002 SUBMATRIX PARTITIONING -  NO. BLOCKS=\002,"
	    "i5,\002 COLUMNS PER BLOCK=\002,i5,\002 COLUMNS IN LAST BLOCK="
	    "\002,i5)";
    static char fmt_18[] = "(\002 FBLOCK: SYMMETRY ERROR - NROW,NCOL=\002,2i"
	    "5)";
    static char fmt_19[] = "(\002 FBLOCK: ERROR - NUMBER OF SYMMETRIC SECTIO"
	    "NS EXCEEDS\002,\002 LIMIT: MAXSYM =\002,i6,\002 NEEDED:\002,i6)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;
    doublecomplex z__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double cos(doublereal), sin(doublereal);

    /* Local variables */
    static integer i__, j, k, ka, kk;
    static doublereal arg;
    static integer nop, imx1;
    static doublereal phaz;
    static doublecomplex deter;

    /* Fortran I/O blocks */
    static cilist io___944 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___945 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___946 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___947 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___948 = { 0, 3, 0, fmt_15, 0 };
    static cilist io___949 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___950 = { 0, 3, 0, fmt_16, 0 };
    static cilist io___952 = { 0, 3, 0, fmt_18, 0 };
    static cilist io___953 = { 0, 3, 0, fmt_19, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FBLOCK sets parameters for out-of-core solution for the MoM */
/*     matrix (A) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    imx1 = *imax - *irngf;
    if (*nrow * *ncol <= imx1) {
	matpar_1.nbloks = 1;
	matpar_1.npblk = *nrow;
	matpar_1.nlast = *nrow;
	matpar_1.imat = *nrow * *ncol;
	if (*nrow == *ncol) {
	    matpar_1.icase = 1;
	    return 0;
	}
	matpar_1.icase = 2;
    } else if (*nrow == *ncol) {
	matpar_1.icase = 3;
	matpar_1.npblk = *imax / (*ncol << 1);
	matpar_1.npsym = imx1 / *ncol;
	if (matpar_1.npsym < matpar_1.npblk) {
	    matpar_1.npblk = matpar_1.npsym;
	}
	if (matpar_1.npblk < 1) {
	    s_wsfe(&io___944);
	    do_fio(&c__1, (char *)&(*nrow), (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&(*ncol), (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	matpar_1.nbloks = (*nrow - 1) / matpar_1.npblk;
	matpar_1.nlast = *nrow - matpar_1.nbloks * matpar_1.npblk;
	++matpar_1.nbloks;
	matpar_1.nblsym = matpar_1.nbloks;
	matpar_1.npsym = matpar_1.npblk;
	matpar_1.nlsym = matpar_1.nlast;
	matpar_1.imat = matpar_1.npblk * *ncol;
	s_wsfe(&io___945);
	do_fio(&c__1, (char *)&matpar_1.nbloks, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&matpar_1.npblk, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&matpar_1.nlast, (ftnlen)sizeof(integer));
	e_wsfe();
	return 0;
    } else {
	matpar_1.npblk = *imax / *ncol;
	if (matpar_1.npblk < 1) {
	    s_wsfe(&io___946);
	    do_fio(&c__1, (char *)&(*nrow), (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&(*ncol), (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	if (matpar_1.npblk > *nrow) {
	    matpar_1.npblk = *nrow;
	}
	matpar_1.nbloks = (*nrow - 1) / matpar_1.npblk;
	matpar_1.nlast = *nrow - matpar_1.nbloks * matpar_1.npblk;
	++matpar_1.nbloks;
	s_wsfe(&io___947);
	do_fio(&c__1, (char *)&matpar_1.nbloks, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&matpar_1.npblk, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&matpar_1.nlast, (ftnlen)sizeof(integer));
	e_wsfe();
	if (*nrow * *nrow <= imx1) {
	    matpar_1.icase = 4;
	    matpar_1.nblsym = 1;
	    matpar_1.npsym = *nrow;
	    matpar_1.nlsym = *nrow;
	    matpar_1.imat = *nrow * *nrow;
	    s_wsfe(&io___948);
	    e_wsfe();
	} else {
	    matpar_1.icase = 5;
	    matpar_1.npsym = *imax / (*nrow << 1);
	    matpar_1.nblsym = imx1 / *nrow;
	    if (matpar_1.nblsym < matpar_1.npsym) {
		matpar_1.npsym = matpar_1.nblsym;
	    }
	    if (matpar_1.npsym < 1) {
		s_wsfe(&io___949);
		do_fio(&c__1, (char *)&(*nrow), (ftnlen)sizeof(integer));
		do_fio(&c__1, (char *)&(*ncol), (ftnlen)sizeof(integer));
		e_wsfe();
		s_stop("", (ftnlen)0);
	    }
	    matpar_1.nblsym = (*nrow - 1) / matpar_1.npsym;
	    matpar_1.nlsym = *nrow - matpar_1.nblsym * matpar_1.npsym;
	    ++matpar_1.nblsym;
	    s_wsfe(&io___950);
	    do_fio(&c__1, (char *)&matpar_1.nblsym, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&matpar_1.npsym, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&matpar_1.nlsym, (ftnlen)sizeof(integer));
	    e_wsfe();
	    matpar_1.imat = matpar_1.npsym * *nrow;
	}
    }
    nop = *ncol / *nrow;
    if (nop * *nrow != *ncol) {
	s_wsfe(&io___952);
	do_fio(&c__1, (char *)&(*nrow), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*ncol), (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (nop > 20) {
	s_wsfe(&io___953);
	do_fio(&c__1, (char *)&c__20, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&nop, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (*ipsym < 0) {

/*        SET UP SSX MATRIX FOR ROTATIONAL SYMMETRY. */

	phaz = 6.2831853071796 / nop;
	i__1 = nop;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    i__2 = nop;
	    for (j = i__; j <= i__2; ++j) {
		arg = phaz * (doublereal) (i__ - 1) * (doublereal) (j - 1);
		i__3 = i__ + j * 20 - 21;
		d__1 = cos(arg);
		d__2 = sin(arg);
		z__1.r = d__1, z__1.i = d__2;
		smat_1.ssx[i__3].r = z__1.r, smat_1.ssx[i__3].i = z__1.i;
/* L6: */
		i__3 = j + i__ * 20 - 21;
		i__4 = i__ + j * 20 - 21;
		smat_1.ssx[i__3].r = smat_1.ssx[i__4].r, smat_1.ssx[i__3].i = 
			smat_1.ssx[i__4].i;
	    }
	}
    } else {

/*        SET UP SSX MATRIX FOR PLANE SYMMETRY */

	kk = 1;
	smat_1.ssx[0].r = 1.f, smat_1.ssx[0].i = 0.f;
	if (nop != 2 && nop != 4 && nop != 8) {
	    s_stop("", (ftnlen)0);
	}
	ka = nop / 2;
	if (nop == 8) {
	    ka = 3;
	}
	i__3 = ka;
	for (k = 1; k <= i__3; ++k) {
	    i__4 = kk;
	    for (i__ = 1; i__ <= i__4; ++i__) {
		i__2 = kk;
		for (j = 1; j <= i__2; ++j) {
		    i__1 = i__ + j * 20 - 21;
		    deter.r = smat_1.ssx[i__1].r, deter.i = smat_1.ssx[i__1]
			    .i;
		    i__1 = i__ + (j + kk) * 20 - 21;
		    smat_1.ssx[i__1].r = deter.r, smat_1.ssx[i__1].i = 
			    deter.i;
		    i__1 = i__ + kk + (j + kk) * 20 - 21;
		    z__1.r = -deter.r, z__1.i = -deter.i;
		    smat_1.ssx[i__1].r = z__1.r, smat_1.ssx[i__1].i = z__1.i;
/* L9: */
		    i__1 = i__ + kk + j * 20 - 21;
		    smat_1.ssx[i__1].r = deter.r, smat_1.ssx[i__1].i = 
			    deter.i;
		}
	    }
/* L10: */
	    kk <<= 1;
	}
    }
    return 0;

} /* fblock_ */

/* Subroutine */ int fbngf_(integer *neq, integer *neq2, integer *iresrv, 
	integer *ib11, integer *ic11, integer *id11, integer *ix11)
{
    /* Format strings */
    static char fmt_7[] = "(\002 FBNGF: ERROR - INSUFFICIENT STORAGE FOR INT"
	    "ERACTION\002,\002 MATRICES; IRESRV,IMAT,NEQ,NEQ2 =\002,4i5)";
    static char fmt_11[] = "(//,\002 N.G.F. - NUMBER OF NEW UNKNOWNS IS\002,"
	    "i4)";
    static char fmt_8[] = "(\002 FILE STORAGE FOR NEW MATRIX SECTIONS -  ICA"
	    "SX =\002,i2)";
    static char fmt_9[] = "(\002 B FILLED BY ROWS -\002,15x,\002NO. BLOCKS "
	    "=\002,i3,3x,\002ROWS PER BLOCK =\002,i3,3x,\002ROWS IN LAST BLOC"
	    "K =\002,i3)";
    static char fmt_10[] = "(\002 B BY COLUMNS, C AND D BY ROWS -\002,2x,"
	    "\002NO. BLOCKS =\002,i3,4x,\002R/C PER BLOCK =\002,i3,4x,\002R/C"
	    " IN LAST BLOCK =\002,i3)";

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer ir, nbcd, nbln, ndln, iresx;

    /* Fortran I/O blocks */
    static cilist io___967 = { 0, 3, 0, fmt_7, 0 };
    static cilist io___968 = { 0, 3, 0, fmt_11, 0 };
    static cilist io___969 = { 0, 3, 0, fmt_8, 0 };
    static cilist io___970 = { 0, 3, 0, fmt_9, 0 };
    static cilist io___971 = { 0, 3, 0, fmt_10, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FBNGF sets the blocking parameters for the B, C, and D arrays for */
/*     out-of-core storage. */

    iresx = *iresrv - matpar_1.imat;
    nbln = *neq * *neq2;
    ndln = *neq2 * *neq2;
    nbcd = (nbln << 1) + ndln;
    if (nbcd <= iresx) {
	matpar_1.icasx = 1;
	*ib11 = matpar_1.imat + 1;
	matpar_1.nbbx = 1;
	matpar_1.npbx = *neq;
	matpar_1.nlbx = *neq;
	matpar_1.nbbl = 1;
	matpar_1.npbl = *neq2;
	matpar_1.nlbl = *neq2;
    } else if (matpar_1.icase > 2 && nbcd <= *iresrv && nbln <= iresx) {
	matpar_1.icasx = 2;
	*ib11 = 1;
	matpar_1.nbbx = 1;
	matpar_1.npbx = *neq;
	matpar_1.nlbx = *neq;
	matpar_1.nbbl = 1;
	matpar_1.npbl = *neq2;
	matpar_1.nlbl = *neq2;
    } else {
	ir = *iresrv;
	if (matpar_1.icase < 3) {
	    ir = iresx;
	}
	matpar_1.icasx = 3;
	if (ndln > ir) {
	    matpar_1.icasx = 4;
	}
	nbcd = (*neq << 1) + *neq2;
	matpar_1.npbl = ir / nbcd;
	matpar_1.nlbl = ir / (*neq2 << 1);
	if (matpar_1.nlbl < matpar_1.npbl) {
	    matpar_1.npbl = matpar_1.nlbl;
	}
	if (matpar_1.icase > 2) {
	    matpar_1.nlbl = iresx / *neq;
	    if (matpar_1.nlbl < matpar_1.npbl) {
		matpar_1.npbl = matpar_1.nlbl;
	    }
	}
	if (matpar_1.npbl < 1) {
	    s_wsfe(&io___967);
	    do_fio(&c__1, (char *)&(*iresrv), (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&matpar_1.imat, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&(*neq), (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&(*neq2), (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	matpar_1.nbbl = (*neq2 - 1) / matpar_1.npbl;
	matpar_1.nlbl = *neq2 - matpar_1.nbbl * matpar_1.npbl;
	++matpar_1.nbbl;
	nbln = *neq * matpar_1.npbl;
	ir -= nbln;
	matpar_1.npbx = ir / *neq2;
	if (matpar_1.npbx > *neq) {
	    matpar_1.npbx = *neq;
	}
	matpar_1.nbbx = (*neq - 1) / matpar_1.npbx;
	matpar_1.nlbx = *neq - matpar_1.nbbx * matpar_1.npbx;
	++matpar_1.nbbx;
	*ib11 = 1;
	if (matpar_1.icase < 3) {
	    *ib11 = matpar_1.imat + 1;
	}
    }
    *ic11 = *ib11 + nbln;
    *id11 = *ic11 + nbln;
    *ix11 = matpar_1.imat + 1;
    s_wsfe(&io___968);
    do_fio(&c__1, (char *)&(*neq2), (ftnlen)sizeof(integer));
    e_wsfe();
    if (matpar_1.icasx == 1) {
	return 0;
    }
    s_wsfe(&io___969);
    do_fio(&c__1, (char *)&matpar_1.icasx, (ftnlen)sizeof(integer));
    e_wsfe();
    s_wsfe(&io___970);
    do_fio(&c__1, (char *)&matpar_1.nbbx, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&matpar_1.npbx, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&matpar_1.nlbx, (ftnlen)sizeof(integer));
    e_wsfe();
    s_wsfe(&io___971);
    do_fio(&c__1, (char *)&matpar_1.nbbl, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&matpar_1.npbl, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&matpar_1.nlbl, (ftnlen)sizeof(integer));
    e_wsfe();
    return 0;

} /* fbngf_ */

/* Subroutine */ int fitls_(doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh, integer *
	ireg)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double cos(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex rph, sav, rrh, rzh, rrv, rzv;
    static doublereal sfac, zlap;
    extern /* Subroutine */ int fitx_(doublereal *, doublereal *, doublereal *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, integer *);
    static doublereal zmax;
    extern /* Subroutine */ int gfdir_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    );

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FITLS obtains field values by least-squares approximation.  Static */
/*     terms are subtracted from reflected field. */

/*     DETERMINE BEST REGION IF NOT ALREADY FIXED */
    if (*ireg == 3) {
	goto L2;
    }
    if (*ireg != 0) {
	goto L1;
    }
    if (gnrzz_1.rho < gregon_1.rhoa[2] || gnrzz_1.zz > gnrzz_1.rho) {
	goto L1;
    }
    *ireg = 3;
    goto L2;
L1:
    *ireg = 1;
    zmax = gregon_1.zza[0];
    if (gnrzz_1.rho < zmax) {
	zmax = gnrzz_1.rho;
    }
    if (gnrzz_1.zz < zmax) {
	*ireg = 2;
    }
L2:
    fitx_(&gnrzz_1.rho, &gnrzz_1.zz, &gnrzz_1.zzp, erv, ezv, erh, eph, ezh, 
	    ireg);
    if (*ireg != 1) {
	goto L3;
    }
    zlap = zmax * .05f;
    if (gnrzz_1.zz > zmax + zlap) {
	goto L3;
    }
    fitx_(&gnrzz_1.rho, &gnrzz_1.zz, &gnrzz_1.zzp, &rrv, &rzv, &rrh, &rph, &
	    rzh, &c__2);
    sfac = (gnrzz_1.zz - zmax) * 3.141592654f / zlap;
    sfac = (cos(sfac) + 1.f) * .5f;
    z__3.r = rrv.r - erv->r, z__3.i = rrv.i - erv->i;
    z__2.r = sfac * z__3.r, z__2.i = sfac * z__3.i;
    z__1.r = z__2.r + erv->r, z__1.i = z__2.i + erv->i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = rzv.r - ezv->r, z__3.i = rzv.i - ezv->i;
    z__2.r = sfac * z__3.r, z__2.i = sfac * z__3.i;
    z__1.r = z__2.r + ezv->r, z__1.i = z__2.i + ezv->i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__3.r = rrh.r - erh->r, z__3.i = rrh.i - erh->i;
    z__2.r = sfac * z__3.r, z__2.i = sfac * z__3.i;
    z__1.r = z__2.r + erh->r, z__1.i = z__2.i + erh->i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__3.r = rph.r - eph->r, z__3.i = rph.i - eph->i;
    z__2.r = sfac * z__3.r, z__2.i = sfac * z__3.i;
    z__1.r = z__2.r + eph->r, z__1.i = z__2.i + eph->i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__3.r = rzh.r - ezh->r, z__3.i = rzh.i - ezh->i;
    z__2.r = sfac * z__3.r, z__2.i = sfac * z__3.i;
    z__1.r = z__2.r + ezh->r, z__1.i = z__2.i + ezh->i;
    ezh->r = z__1.r, ezh->i = z__1.i;
L3:
    switch (gnrzz_1.icase) {
	case 1:  goto L4;
	case 2:  goto L5;
	case 3:  goto L7;
	case 4:  goto L6;
    }
/*     REMOVE STATIC TERMS FROM REFLECTED FIELD */
L4:
    d__1 = -gnrzz_1.zs;
    gfdir_(&gnrzz_1.rho, &d__1, &gnrzz_1.zo, &gnrzz_1.ck2, &gnrzz_1.ck2, &rrv,
	     &rzv, &rrh, &rph, &rzh);
    sav.r = erv->r, sav.i = erv->i;
    z__3.r = -ezh->r, z__3.i = -ezh->i;
    z__2.r = z__3.r + rrv.r, z__2.i = z__3.i + rrv.i;
    z__4.r = gnrzz_1.con2.r * rrv.r - gnrzz_1.con2.i * rrv.i, z__4.i = 
	    gnrzz_1.con2.r * rrv.i + gnrzz_1.con2.i * rrv.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = gnrzz_1.epsc1.r * ezv->r - gnrzz_1.epsc1.i * ezv->i, z__3.i = 
	    gnrzz_1.epsc1.r * ezv->i + gnrzz_1.epsc1.i * ezv->r;
    z__2.r = z__3.r - rzv.r, z__2.i = z__3.i - rzv.i;
    z__4.r = gnrzz_1.con2.r * rzv.r - gnrzz_1.con2.i * rzv.i, z__4.i = 
	    gnrzz_1.con2.r * rzv.i + gnrzz_1.con2.i * rzv.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__2.r = erh->r - rrh.r, z__2.i = erh->i - rrh.i;
    z__3.r = gnrzz_1.con2.r * rrh.r - gnrzz_1.con2.i * rrh.i, z__3.i = 
	    gnrzz_1.con2.r * rrh.i + gnrzz_1.con2.i * rrh.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = eph->r - rph.r, z__2.i = eph->i - rph.i;
    z__3.r = gnrzz_1.con2.r * rph.r - gnrzz_1.con2.i * rph.i, z__3.i = 
	    gnrzz_1.con2.r * rph.i + gnrzz_1.con2.i * rph.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__4.r = -gnrzz_1.epsc1.r, z__4.i = -gnrzz_1.epsc1.i;
    z__3.r = z__4.r * sav.r - z__4.i * sav.i, z__3.i = z__4.r * sav.i + 
	    z__4.i * sav.r;
    z__2.r = z__3.r + rzh.r, z__2.i = z__3.i + rzh.i;
    z__5.r = gnrzz_1.con2.r * rzh.r - gnrzz_1.con2.i * rzh.i, z__5.i = 
	    gnrzz_1.con2.r * rzh.i + gnrzz_1.con2.i * rzh.r;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L5:
    d__1 = -gnrzz_1.zs;
    gfdir_(&gnrzz_1.rho, &d__1, &gnrzz_1.zo, &gnrzz_1.ck2, &gnrzz_1.ck1, &rrv,
	     &rzv, &rrh, &rph, &rzh);
    z__2.r = erv->r + rrv.r, z__2.i = erv->i + rrv.i;
    z__3.r = gnrzz_1.con2.r * rrv.r - gnrzz_1.con2.i * rrv.i, z__3.i = 
	    gnrzz_1.con2.r * rrv.i + gnrzz_1.con2.i * rrv.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z_div(&z__3, ezv, &gnrzz_1.epsc1);
    z__2.r = z__3.r - rzv.r, z__2.i = z__3.i - rzv.i;
    z__4.r = gnrzz_1.con2.r * rzv.r - gnrzz_1.con2.i * rzv.i, z__4.i = 
	    gnrzz_1.con2.r * rzv.i + gnrzz_1.con2.i * rzv.r;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__2.r = erh->r - rrh.r, z__2.i = erh->i - rrh.i;
    z__3.r = gnrzz_1.con2.r * rrh.r - gnrzz_1.con2.i * rrh.i, z__3.i = 
	    gnrzz_1.con2.r * rrh.i + gnrzz_1.con2.i * rrh.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = eph->r - rph.r, z__2.i = eph->i - rph.i;
    z__3.r = gnrzz_1.con2.r * rph.r - gnrzz_1.con2.i * rph.i, z__3.i = 
	    gnrzz_1.con2.r * rph.i + gnrzz_1.con2.i * rph.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z_div(&z__3, ezh, &gnrzz_1.epsc1);
    z__2.r = z__3.r + rzh.r, z__2.i = z__3.i + rzh.i;
    z__4.r = gnrzz_1.con2.r * rzh.r - gnrzz_1.con2.i * rzh.i, z__4.i = 
	    gnrzz_1.con2.r * rzh.i + gnrzz_1.con2.i * rzh.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L6:
    sav.r = erv->r, sav.i = erv->i;
    z__1.r = -ezh->r, z__1.i = -ezh->i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = -sav.r, z__1.i = -sav.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
L7:
    return 0;
} /* fitls_ */

/* Subroutine */ int fitx_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublecomplex *e1, doublecomplex *e2, doublecomplex *e3, 
	doublecomplex *e4, doublecomplex *e5, integer *ireg)
{
    /* Initialized data */

    static integer nfrow = 32;

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
#define ff ((doublereal *)&fparm_1 + 16)
    static integer ix;
#define cff ((doublecomplex *)&fparm_1)
    static integer ifb, ifx;
    static doublereal rax, sth;
    static doublecomplex exx, rexx;
#define fac1l ((doublecomplex *)&cofit_1)
#define fac2l ((doublecomplex *)&cofit_1 + 96)
#define fac3l ((doublecomplex *)&cofit_1 + 192)
#define fac4l ((doublecomplex *)&cofit_1 + 288)
#define fac5l ((doublecomplex *)&cofit_1 + 384)
    extern /* Subroutine */ int fnfit_(doublereal *, doublereal *, doublereal 
	    *, doublereal *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FITX combines the function values from subroutine FNFIT with the */
/*     coefficients obtained for a least-squares approximation. */

    fparm_1.nfunc = cofit_1.mfunc[(7700 + (0 + (*ireg - 1 << 2)) - 7700) / 4];
    fnfit_(rho, zz, zp, &sth, &exx);
    rax = *zz - *zp * cofit_1.rkfac;
    rax = sqrt(*rho * *rho + rax * rax);
    z__1.r = exx.r / rax, z__1.i = exx.i / rax;
    rexx.r = z__1.r, rexx.i = z__1.i;
    e1->r = 0.f, e1->i = 0.f;
    e2->r = 0.f, e2->i = 0.f;
    e3->r = 0.f, e3->i = 0.f;
    e4->r = 0.f, e4->i = 0.f;
    e5->r = 0.f, e5->i = 0.f;
    ix = 2;
    ifb = nfrow * (*ireg - 1);
    i__1 = fparm_1.nfunf;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ifx = ifb + i__;
	++ix;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = ff[i__2] * fac1l[i__3].r, z__2.i = ff[i__2] * fac1l[i__3].i;
	z__1.r = e1->r + z__2.r, z__1.i = e1->i + z__2.i;
	e1->r = z__1.r, e1->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = ff[i__2] * fac3l[i__3].r, z__2.i = ff[i__2] * fac3l[i__3].i;
	z__1.r = e3->r + z__2.r, z__1.i = e3->i + z__2.i;
	e3->r = z__1.r, e3->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = ff[i__2] * fac4l[i__3].r, z__2.i = ff[i__2] * fac4l[i__3].i;
	z__1.r = e4->r + z__2.r, z__1.i = e4->i + z__2.i;
	e4->r = z__1.r, e4->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = ff[i__2] * fac5l[i__3].r, z__2.i = ff[i__2] * fac5l[i__3].i;
	z__1.r = e5->r + z__2.r, z__1.i = e5->i + z__2.i;
	e5->r = z__1.r, e5->i = z__1.i;
	if (ix == 3) {
	    goto L1;
	}
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = ff[i__2] * fac2l[i__3].r, z__2.i = ff[i__2] * fac2l[i__3].i;
	z__1.r = e2->r + z__2.r, z__1.i = e2->i + z__2.i;
	e2->r = z__1.r, e2->i = z__1.i;
	goto L2;
L1:
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__3.r = ff[i__2] * fac2l[i__3].r, z__3.i = ff[i__2] * fac2l[i__3].i;
	z__2.r = sth * z__3.r, z__2.i = sth * z__3.i;
	z__1.r = e2->r + z__2.r, z__1.i = e2->i + z__2.i;
	e2->r = z__1.r, e2->i = z__1.i;
	ix = 0;
L2:
	;
    }
    if (fparm_1.nfunc == 0) {
	goto L4;
    }
    ifb += fparm_1.nfunf;
    i__1 = fparm_1.nfunc;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ifx = ifb + i__;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = cff[i__2].r * fac1l[i__3].r - cff[i__2].i * fac1l[i__3].i, 
		z__2.i = cff[i__2].r * fac1l[i__3].i + cff[i__2].i * fac1l[
		i__3].r;
	z__1.r = e1->r + z__2.r, z__1.i = e1->i + z__2.i;
	e1->r = z__1.r, e1->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = cff[i__2].r * fac2l[i__3].r - cff[i__2].i * fac2l[i__3].i, 
		z__2.i = cff[i__2].r * fac2l[i__3].i + cff[i__2].i * fac2l[
		i__3].r;
	z__1.r = e2->r + z__2.r, z__1.i = e2->i + z__2.i;
	e2->r = z__1.r, e2->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = cff[i__2].r * fac3l[i__3].r - cff[i__2].i * fac3l[i__3].i, 
		z__2.i = cff[i__2].r * fac3l[i__3].i + cff[i__2].i * fac3l[
		i__3].r;
	z__1.r = e3->r + z__2.r, z__1.i = e3->i + z__2.i;
	e3->r = z__1.r, e3->i = z__1.i;
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = cff[i__2].r * fac4l[i__3].r - cff[i__2].i * fac4l[i__3].i, 
		z__2.i = cff[i__2].r * fac4l[i__3].i + cff[i__2].i * fac4l[
		i__3].r;
	z__1.r = e4->r + z__2.r, z__1.i = e4->i + z__2.i;
	e4->r = z__1.r, e4->i = z__1.i;
/* L3: */
	i__2 = i__ - 1;
	i__3 = ifx - 1;
	z__2.r = cff[i__2].r * fac5l[i__3].r - cff[i__2].i * fac5l[i__3].i, 
		z__2.i = cff[i__2].r * fac5l[i__3].i + cff[i__2].i * fac5l[
		i__3].r;
	z__1.r = e5->r + z__2.r, z__1.i = e5->i + z__2.i;
	e5->r = z__1.r, e5->i = z__1.i;
    }
L4:
    z__2.r = e1->r * rexx.r - e1->i * rexx.i, z__2.i = e1->r * rexx.i + e1->i 
	    * rexx.r;
    z__1.r = sth * z__2.r, z__1.i = sth * z__2.i;
    e1->r = z__1.r, e1->i = z__1.i;
    z__1.r = e2->r * rexx.r - e2->i * rexx.i, z__1.i = e2->r * rexx.i + e2->i 
	    * rexx.r;
    e2->r = z__1.r, e2->i = z__1.i;
    z__1.r = e3->r * rexx.r - e3->i * rexx.i, z__1.i = e3->r * rexx.i + e3->i 
	    * rexx.r;
    e3->r = z__1.r, e3->i = z__1.i;
    z__1.r = e4->r * rexx.r - e4->i * rexx.i, z__1.i = e4->r * rexx.i + e4->i 
	    * rexx.r;
    e4->r = z__1.r, e4->i = z__1.i;
    z__2.r = e5->r * rexx.r - e5->i * rexx.i, z__2.i = e5->r * rexx.i + e5->i 
	    * rexx.r;
    z__1.r = sth * z__2.r, z__1.i = sth * z__2.i;
    e5->r = z__1.r, e5->i = z__1.i;
    return 0;
} /* fitx_ */

#undef fac5l
#undef fac4l
#undef fac3l
#undef fac2l
#undef fac1l
#undef cff
#undef ff


/* Subroutine */ int fnfit_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublereal *sth, doublecomplex *exx)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    double z_abs(doublecomplex *), sqrt(doublereal);

    /* Local variables */
    static doublereal rp;
    static doublecomplex exm, xls, bet1, bet2;
    static doublereal cth1, cth2, rrax;
    extern /* Subroutine */ int sadpt_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *);
    extern /* Double Complex */ VOID zzexp_(doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     FNFIT supplies the function values for the least squares approx. */
/*     of the field crossing an interface. */


/*     FUNCTIONS FOR THE UPPER-MEDIUM RAY.  THE EXPONENTIAL IS HANDLED */
/*     SEPARATELY SO THAT THE VALUES ARE REAL */

    sadpt_(rho, zz, zp, &xls);
    z__3.r = xls.r * xls.r - xls.i * xls.i, z__3.i = xls.r * xls.i + xls.i * 
	    xls.r;
    z__2.r = gparm_1.gck1sq.r - z__3.r, z__2.i = gparm_1.gck1sq.i - z__3.i;
    z_sqrt(&z__1, &z__2);
    bet1.r = z__1.r, bet1.i = z__1.i;
    z__3.r = xls.r * xls.r - xls.i * xls.i, z__3.i = xls.r * xls.i + xls.i * 
	    xls.r;
    z__2.r = gparm_1.gck2sq.r - z__3.r, z__2.i = gparm_1.gck2sq.i - z__3.i;
    z_sqrt(&z__1, &z__2);
    bet2.r = z__1.r, bet2.i = z__1.i;
    z__3.r = -fj.r, z__3.i = -fj.i;
    z__6.r = *zz * bet2.r, z__6.i = *zz * bet2.i;
    z__7.r = *zp * bet1.r, z__7.i = *zp * bet1.i;
    z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
    z__8.r = *rho * xls.r, z__8.i = *rho * xls.i;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z_exp(&z__1, &z__2);
    exx->r = z__1.r, exx->i = z__1.i;
    z_div(&z__1, &gparm_1.gck2, &gparm_1.gck1);
    rrax = *zz - *zp * z_abs(&z__1);
    rrax = 1.f / sqrt(*rho * *rho + rrax * rrax);
    cth2 = *zz * rrax;
    cth1 = *zp * rrax;
    *sth = *rho * rrax;
    fparm_1.ff1 = 1.f;
    fparm_1.ff2 = fparm_1.ff1 * rrax;
    fparm_1.ff3 = fparm_1.ff2 * rrax;
    fparm_1.ff4 = fparm_1.ff1 * cth2;
    fparm_1.ff5 = fparm_1.ff2 * cth2;
    fparm_1.ff6 = fparm_1.ff3 * cth2;
    fparm_1.ff7 = fparm_1.ff4 * cth2;
    fparm_1.ff8 = fparm_1.ff5 * cth2;
    fparm_1.ff9 = fparm_1.ff6 * cth2;
    fparm_1.ff10 = fparm_1.ff7 * cth2;
    fparm_1.ff11 = fparm_1.ff8 * cth2;
    fparm_1.ff12 = fparm_1.ff9 * cth2;
    fparm_1.ff13 = fparm_1.ff1 * cth1;
    fparm_1.ff14 = fparm_1.ff2 * cth1;
    fparm_1.ff15 = fparm_1.ff3 * cth1;
    fparm_1.ff16 = fparm_1.ff4 * cth1;
    fparm_1.ff17 = fparm_1.ff5 * cth1;
    fparm_1.ff18 = fparm_1.ff6 * cth1;
    fparm_1.ff19 = fparm_1.ff7 * cth1;
    fparm_1.ff20 = fparm_1.ff8 * cth1;
    fparm_1.ff21 = fparm_1.ff9 * cth1;
    fparm_1.ff22 = fparm_1.ff10 * cth1;
    fparm_1.ff23 = fparm_1.ff11 * cth1;
    fparm_1.ff24 = fparm_1.ff12 * cth1;
    fparm_1.nfunf = 24;
    if (fparm_1.nfunc == 0) {
	return 0;
    }

/*     FUNCTIONS TO FIT THE LOWER-MEDIUM RAY */

    rp = sqrt(*rho * *rho + *zp * *zp);
    if (rp < 1e-20f) {
	rp = 1e-20f;
    }
    z__2.r = *rho * gparm_1.gck1.r, z__2.i = *rho * gparm_1.gck1.i;
    z__1.r = z__2.r / rp, z__1.i = z__2.i / rp;
    xls.r = z__1.r, xls.i = z__1.i;
    z__4.r = xls.r * xls.r - xls.i * xls.i, z__4.i = xls.r * xls.i + xls.i * 
	    xls.r;
    z__3.r = gparm_1.gck2sq.r - z__4.r, z__3.i = gparm_1.gck2sq.i - z__4.i;
    z_sqrt(&z__2, &z__3);
    z__1.r = -z__2.r, z__1.i = -z__2.i;
    bet2.r = z__1.r, bet2.i = z__1.i;
    z__4.r = -fj.r, z__4.i = -fj.i;
    z__6.r = *zz * bet2.r, z__6.i = *zz * bet2.i;
    z__7.r = rp * gparm_1.gck1.r, z__7.i = rp * gparm_1.gck1.i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    zzexp_(&z__2, &z__3);
    z_div(&z__1, &z__2, exx);
    exm.r = z__1.r, exm.i = z__1.i;
    z__2.r = cth1 * exm.r, z__2.i = cth1 * exm.i;
    z__1.r = *sth * z__2.r, z__1.i = *sth * z__2.i;
    fparm_1.cff1.r = z__1.r, fparm_1.cff1.i = z__1.i;
    z__1.r = cth1 * fparm_1.cff1.r, z__1.i = cth1 * fparm_1.cff1.i;
    fparm_1.cff2.r = z__1.r, fparm_1.cff2.i = z__1.i;
    z__2.r = exm.r / rp, z__2.i = exm.i / rp;
    z__1.r = *sth * z__2.r, z__1.i = *sth * z__2.i;
    fparm_1.cff3.r = z__1.r, fparm_1.cff3.i = z__1.i;
    z__1.r = cth1 * fparm_1.cff3.r, z__1.i = cth1 * fparm_1.cff3.i;
    fparm_1.cff4.r = z__1.r, fparm_1.cff4.i = z__1.i;
    z__1.r = cth2 * fparm_1.cff1.r, z__1.i = cth2 * fparm_1.cff1.i;
    fparm_1.cff5.r = z__1.r, fparm_1.cff5.i = z__1.i;
    z__1.r = cth2 * fparm_1.cff2.r, z__1.i = cth2 * fparm_1.cff2.i;
    fparm_1.cff6.r = z__1.r, fparm_1.cff6.i = z__1.i;
    z__1.r = cth2 * fparm_1.cff3.r, z__1.i = cth2 * fparm_1.cff3.i;
    fparm_1.cff7.r = z__1.r, fparm_1.cff7.i = z__1.i;
    z__1.r = cth2 * fparm_1.cff4.r, z__1.i = cth2 * fparm_1.cff4.i;
    fparm_1.cff8.r = z__1.r, fparm_1.cff8.i = z__1.i;
    fparm_1.nfunc = 8;
    return 0;
} /* fnfit_ */

/* Subroutine */ int gasy1_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublecomplex *xls, integer *iex, doublecomplex *exx, doublecomplex *
	erv, doublecomplex *ezv, doublecomplex *erh, doublecomplex *eph, 
	doublecomplex *ezh)
{
    /* Initialized data */

    static doublecomplex con = {42.398,-42.398};
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex psi, tcv, tcu, zog1, zog2, cgam1, xlss, cgam2, rhoxl;
    extern /* Double Complex */ VOID zzexp_(doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GASY1 evaluates the field transmitted across an interface using */
/*     first order asymptotic approximations (geometric optics.) */

    z__1.r = xls->r * xls->r - xls->i * xls->i, z__1.i = xls->r * xls->i + 
	    xls->i * xls->r;
    xlss.r = z__1.r, xlss.i = z__1.i;
    z__2.r = xlss.r - gparm_1.gck1sq.r, z__2.i = xlss.i - gparm_1.gck1sq.i;
    z_sqrt(&z__1, &z__2);
    cgam1.r = z__1.r, cgam1.i = z__1.i;
    z__2.r = xlss.r - gparm_1.gck2sq.r, z__2.i = xlss.i - gparm_1.gck2sq.i;
    z_sqrt(&z__1, &z__2);
    cgam2.r = z__1.r, cgam2.i = z__1.i;
    if (xls->r <= gparm_1.gck2.r && d_imag(&cgam2) < 0.f) {
	z__1.r = -cgam2.r, z__1.i = -cgam2.i;
	cgam2.r = z__1.r, cgam2.i = z__1.i;
    }
    z_div(&z__1, xls, &gparm_1.gck2);
    if (z_abs(&z__1) > .01f) {
	z__2.r = *rho, z__2.i = 0.;
	z_div(&z__1, &z__2, xls);
	rhoxl.r = z__1.r, rhoxl.i = z__1.i;
    } else {
	z__3.r = *zz, z__3.i = 0.;
	z_div(&z__2, &z__3, &gparm_1.gck2);
	z__5.r = *zp, z__5.i = 0.;
	z_div(&z__4, &z__5, &gparm_1.gck1);
	z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
	rhoxl.r = z__1.r, rhoxl.i = z__1.i;
    }
    z_div(&z__1, &cgam1, &gparm_1.gck1);
    if (z_abs(&z__1) > .01f) {
	z__2.r = *zp, z__2.i = 0.;
	z_div(&z__1, &z__2, &cgam1);
	zog1.r = z__1.r, zog1.i = z__1.i;
    } else {
	z__3.r = *zz, z__3.i = 0.;
	z_div(&z__2, &z__3, &cgam2);
	z__4.r = fj.r * rhoxl.r - fj.i * rhoxl.i, z__4.i = fj.r * rhoxl.i + 
		fj.i * rhoxl.r;
	z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	zog1.r = z__1.r, zog1.i = z__1.i;
    }
    z_div(&z__1, &cgam2, &gparm_1.gck2);
    if (z_abs(&z__1) > .01f) {
	z__2.r = *zz, z__2.i = 0.;
	z_div(&z__1, &z__2, &cgam2);
	zog2.r = z__1.r, zog2.i = z__1.i;
    } else {
	z__3.r = *zp, z__3.i = 0.;
	z_div(&z__2, &z__3, &cgam1);
	z__4.r = fj.r * rhoxl.r - fj.i * rhoxl.i, z__4.i = fj.r * rhoxl.i + 
		fj.i * rhoxl.r;
	z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
	zog2.r = z__1.r, zog2.i = z__1.i;
    }
    z__4.r = gparm_1.gck1sq.r * zog1.r - gparm_1.gck1sq.i * zog1.i, z__4.i = 
	    gparm_1.gck1sq.r * zog1.i + gparm_1.gck1sq.i * zog1.r;
    z__3.r = z__4.r * cgam2.r - z__4.i * cgam2.i, z__3.i = z__4.r * cgam2.i + 
	    z__4.i * cgam2.r;
    z__2.r = z__3.r * cgam2.r - z__3.i * cgam2.i, z__2.i = z__3.r * cgam2.i + 
	    z__3.i * cgam2.r;
    z__7.r = gparm_1.gck2sq.r * zog2.r - gparm_1.gck2sq.i * zog2.i, z__7.i = 
	    gparm_1.gck2sq.r * zog2.i + gparm_1.gck2sq.i * zog2.r;
    z__6.r = z__7.r * cgam1.r - z__7.i * cgam1.i, z__6.i = z__7.r * cgam1.i + 
	    z__7.i * cgam1.r;
    z__5.r = z__6.r * cgam1.r - z__6.i * cgam1.i, z__5.i = z__6.r * cgam1.i + 
	    z__6.i * cgam1.r;
    z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
    psi.r = z__1.r, psi.i = z__1.i;
    z__2.r = cgam1.r * cgam2.r - cgam1.i * cgam2.i, z__2.i = cgam1.r * 
	    cgam2.i + cgam1.i * cgam2.r;
    z_sqrt(&z__3, &psi);
    z_div(&z__1, &z__2, &z__3);
    psi.r = z__1.r, psi.i = z__1.i;
    if (d_imag(&psi) < 0.f) {
	z__1.r = -psi.r, z__1.i = -psi.i;
	psi.r = z__1.r, psi.i = z__1.i;
    }
    z_sqrt(&z__2, &rhoxl);
    z_div(&z__1, &psi, &z__2);
    psi.r = z__1.r, psi.i = z__1.i;
    z__2.r = con.r * gparm_1.gck2.r - con.i * gparm_1.gck2.i, z__2.i = con.r *
	     gparm_1.gck2.i + con.i * gparm_1.gck2.r;
    z__1.r = z__2.r * psi.r - z__2.i * psi.i, z__1.i = z__2.r * psi.i + 
	    z__2.i * psi.r;
    psi.r = z__1.r, psi.i = z__1.i;
    z__4.r = *zp * cgam1.r, z__4.i = *zp * cgam1.i;
    z__5.r = *zz * cgam2.r, z__5.i = *zz * cgam2.i;
    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
    z__7.r = fj.r * xls->r - fj.i * xls->i, z__7.i = fj.r * xls->i + fj.i * 
	    xls->r;
    z__6.r = *rho * z__7.r, z__6.i = *rho * z__7.i;
    z__2.r = z__3.r - z__6.r, z__2.i = z__3.i - z__6.i;
    zzexp_(&z__1, &z__2);
    exx->r = z__1.r, exx->i = z__1.i;
    if (*iex != 0) {
	z__1.r = psi.r * exx->r - psi.i * exx->i, z__1.i = psi.r * exx->i + 
		psi.i * exx->r;
	psi.r = z__1.r, psi.i = z__1.i;
    }
    z__3.r = gparm_1.gck1sq.r * cgam2.r - gparm_1.gck1sq.i * cgam2.i, z__3.i =
	     gparm_1.gck1sq.r * cgam2.i + gparm_1.gck1sq.i * cgam2.r;
    z__4.r = gparm_1.gck2sq.r * cgam1.r - gparm_1.gck2sq.i * cgam1.i, z__4.i =
	     gparm_1.gck2sq.r * cgam1.i + gparm_1.gck2sq.i * cgam1.r;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z_div(&z__1, &psi, &z__2);
    tcv.r = z__1.r, tcv.i = z__1.i;
    z__2.r = cgam1.r + cgam2.r, z__2.i = cgam1.i + cgam2.i;
    z_div(&z__1, &psi, &z__2);
    tcu.r = z__1.r, tcu.i = z__1.i;
    z__3.r = fj.r * tcv.r - fj.i * tcv.i, z__3.i = fj.r * tcv.i + fj.i * 
	    tcv.r;
    z__2.r = z__3.r * xls->r - z__3.i * xls->i, z__2.i = z__3.r * xls->i + 
	    z__3.i * xls->r;
    z__1.r = z__2.r * cgam2.r - z__2.i * cgam2.i, z__1.i = z__2.r * cgam2.i + 
	    z__2.i * cgam2.r;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = tcv.r * xlss.r - tcv.i * xlss.i, z__1.i = tcv.r * xlss.i + tcv.i 
	    * xlss.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__3.r = -tcv.r, z__3.i = -tcv.i;
    z__2.r = z__3.r * xlss.r - z__3.i * xlss.i, z__2.i = z__3.r * xlss.i + 
	    z__3.i * xlss.r;
    z__1.r = z__2.r + tcu.r, z__1.i = z__2.i + tcu.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__3.r = fj.r * tcv.r - fj.i * tcv.i, z__3.i = fj.r * tcv.i + fj.i * 
	    tcv.r;
    z_div(&z__2, &z__3, &rhoxl);
    z__1.r = z__2.r - tcu.r, z__1.i = z__2.i - tcu.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__3.r = fj.r * tcv.r - fj.i * tcv.i, z__3.i = fj.r * tcv.i + fj.i * 
	    tcv.r;
    z__2.r = z__3.r * xls->r - z__3.i * xls->i, z__2.i = z__3.r * xls->i + 
	    z__3.i * xls->r;
    z__1.r = z__2.r * cgam1.r - z__2.i * cgam1.i, z__1.i = z__2.r * cgam1.i + 
	    z__2.i * cgam1.r;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
} /* gasy1_ */

/* Subroutine */ int gasy2_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublecomplex *xls, integer *iex, doublecomplex *erv, doublecomplex *
	ezv, doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};
    static doublecomplex ck1x = {0.,0.};
    static doublecomplex ck2x = {0.,0.};

    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14;

    /* Builtin functions */
    double d_imag(doublecomplex *);
    void z_sqrt(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    double sqrt(doublereal);

    /* Local variables */
    static doublecomplex t1, t2, t3, t4, t5, t6, t7, bb, fp, u12, fs, dp0, 
	    dp1, dp2, gp0, gp1, ft1, ft2, ft3, gp2;
    static doublereal zz2, zz4;
    static doublecomplex cgg, gam, den, vp12, exx, cgg2, cgg4, gam2, gam4;
    static doublereal zxx;
    static doublecomplex xls2, den32, fmhf, fjor, xlsq;
    extern /* Double Complex */ VOID fbars_(doublecomplex *, doublecomplex *),
	     zzexp_(doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GASY2 evaluates the field transmitted across an interface using */
/*     asymptotic approximations with surface wave and higher order */
/*     saddle-point terms. */

    z__1.r = gparm_1.gck1.r - ck1x.r, z__1.i = gparm_1.gck1.i - ck1x.i;
    t1.r = z__1.r, t1.i = z__1.i;
    z__1.r = gparm_1.gck2.r - ck2x.r, z__1.i = gparm_1.gck2.i - ck2x.i;
    t2.r = z__1.r, t2.i = z__1.i;
    zxx = gparm_1.gck2.r * 1e-8f;
    if ((d__1 = t1.r, abs(d__1)) > zxx || (d__2 = d_imag(&t1), abs(d__2)) > 
	    zxx) {
	goto L1;
    }
    if ((d__1 = t2.r, abs(d__1)) > zxx || (d__2 = d_imag(&t2), abs(d__2)) > 
	    zxx) {
	goto L1;
    }
    goto L2;
/*     COMPUTE CONSTANTS THAT DEPEND ONLY ON GCK1 AND GCK2 */
L1:
    ck1x.r = gparm_1.gck1.r, ck1x.i = gparm_1.gck1.i;
    ck2x.r = gparm_1.gck2.r, ck2x.i = gparm_1.gck2.i;
    z__2.r = gparm_1.gck1sq.r + gparm_1.gck2sq.r, z__2.i = gparm_1.gck1sq.i + 
	    gparm_1.gck2sq.i;
    z_sqrt(&z__1, &z__2);
    gasav_1.cd.r = z__1.r, gasav_1.cd.i = z__1.i;
    z__1.r = gparm_1.gck1.r * gparm_1.gck2.r - gparm_1.gck1.i * 
	    gparm_1.gck2.i, z__1.i = gparm_1.gck1.r * gparm_1.gck2.i + 
	    gparm_1.gck1.i * gparm_1.gck2.r;
    gasav_1.aa.r = z__1.r, gasav_1.aa.i = z__1.i;
    z__5.r = gasav_1.aa.r * gasav_1.aa.r - gasav_1.aa.i * gasav_1.aa.i, 
	    z__5.i = gasav_1.aa.r * gasav_1.aa.i + gasav_1.aa.i * 
	    gasav_1.aa.r;
    z__4.r = z__5.r * gasav_1.aa.r - z__5.i * gasav_1.aa.i, z__4.i = z__5.r * 
	    gasav_1.aa.i + z__5.i * gasav_1.aa.r;
    z_sqrt(&z__3, &z__4);
    z__2.r = fj.r * z__3.r - fj.i * z__3.i, z__2.i = fj.r * z__3.i + fj.i * 
	    z__3.r;
    z__8.r = gparm_1.gck2sq.r * gparm_1.gck2sq.r - gparm_1.gck2sq.i * 
	    gparm_1.gck2sq.i, z__8.i = gparm_1.gck2sq.r * gparm_1.gck2sq.i + 
	    gparm_1.gck2sq.i * gparm_1.gck2sq.r;
    z__9.r = gparm_1.gck1sq.r * gparm_1.gck1sq.r - gparm_1.gck1sq.i * 
	    gparm_1.gck1sq.i, z__9.i = gparm_1.gck1sq.r * gparm_1.gck1sq.i + 
	    gparm_1.gck1sq.i * gparm_1.gck1sq.r;
    z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
    z_sqrt(&z__10, &gasav_1.cd);
    z__6.r = z__7.r * z__10.r - z__7.i * z__10.i, z__6.i = z__7.r * z__10.i + 
	    z__7.i * z__10.r;
    z_div(&z__1, &z__2, &z__6);
    gasav_1.aa.r = z__1.r, gasav_1.aa.i = z__1.i;
    z__2.r = gparm_1.gck1.r * gparm_1.gck2.r - gparm_1.gck1.i * 
	    gparm_1.gck2.i, z__2.i = gparm_1.gck1.r * gparm_1.gck2.i + 
	    gparm_1.gck1.i * gparm_1.gck2.r;
    z_div(&z__1, &z__2, &gasav_1.cd);
    gasav_1.xlp.r = z__1.r, gasav_1.xlp.i = z__1.i;
    z__3.r = gasav_1.xlp.r * gasav_1.xlp.r - gasav_1.xlp.i * gasav_1.xlp.i, 
	    z__3.i = gasav_1.xlp.r * gasav_1.xlp.i + gasav_1.xlp.i * 
	    gasav_1.xlp.r;
    z__2.r = z__3.r - gparm_1.gck1sq.r, z__2.i = z__3.i - gparm_1.gck1sq.i;
    z_sqrt(&z__1, &z__2);
    gasav_1.pg1.r = z__1.r, gasav_1.pg1.i = z__1.i;
    z__3.r = gasav_1.xlp.r * gasav_1.xlp.r - gasav_1.xlp.i * gasav_1.xlp.i, 
	    z__3.i = gasav_1.xlp.r * gasav_1.xlp.i + gasav_1.xlp.i * 
	    gasav_1.xlp.r;
    z__2.r = z__3.r - gparm_1.gck2sq.r, z__2.i = z__3.i - gparm_1.gck2sq.i;
    z_sqrt(&z__1, &z__2);
    gasav_1.pg2.r = z__1.r, gasav_1.pg2.i = z__1.i;
    if (d_imag(&gasav_1.pg2) < 0.f) {
	z__1.r = -gasav_1.pg2.r, z__1.i = -gasav_1.pg2.i;
	gasav_1.pg2.r = z__1.r, gasav_1.pg2.i = z__1.i;
    }
/*     END OF CONSTANTS.  NOW CALCULATE SADDLE-POINT TERMS. */
L2:
    z__1.r = 0.f / *rho, z__1.i = .125f / *rho;
    fjor.r = z__1.r, fjor.i = z__1.i;
    zz2 = *zz * *zz;
    zz4 = zz2 * zz2;
    z__1.r = xls->r * xls->r - xls->i * xls->i, z__1.i = xls->r * xls->i + 
	    xls->i * xls->r;
    xls2.r = z__1.r, xls2.i = z__1.i;
    z_sqrt(&z__1, xls);
    xlsq.r = z__1.r, xlsq.i = z__1.i;
    z__1.r = xls2.r - gparm_1.gck1sq.r, z__1.i = xls2.i - gparm_1.gck1sq.i;
    cgg2.r = z__1.r, cgg2.i = z__1.i;
    z__1.r = cgg2.r * cgg2.r - cgg2.i * cgg2.i, z__1.i = cgg2.r * cgg2.i + 
	    cgg2.i * cgg2.r;
    cgg4.r = z__1.r, cgg4.i = z__1.i;
    z_sqrt(&z__1, &cgg2);
    cgg.r = z__1.r, cgg.i = z__1.i;
    z__4.r = *zp * xls->r, z__4.i = *zp * xls->i;
    z_div(&z__3, &z__4, &cgg);
    z__5.r = *rho * fj.r, z__5.i = *rho * fj.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z_div(&z__1, xls, &z__2);
    gam.r = z__1.r, gam.i = z__1.i;
    z__1.r = gam.r * gam.r - gam.i * gam.i, z__1.i = gam.r * gam.i + gam.i * 
	    gam.r;
    gam2.r = z__1.r, gam2.i = z__1.i;
    z__1.r = gam2.r * gam2.r - gam2.i * gam2.i, z__1.i = gam2.r * gam2.i + 
	    gam2.i * gam2.r;
    gam4.r = z__1.r, gam4.i = z__1.i;
    z__5.r = -gparm_1.gck2sq.r, z__5.i = -gparm_1.gck2sq.i;
    z__4.r = z__5.r * cgg2.r - z__5.i * cgg2.i, z__4.i = z__5.r * cgg2.i + 
	    z__5.i * cgg2.r;
    z__3.r = z__4.r * cgg.r - z__4.i * cgg.i, z__3.i = z__4.r * cgg.i + 
	    z__4.i * cgg.r;
    z__9.r = gparm_1.gck1sq.r * gam2.r - gparm_1.gck1sq.i * gam2.i, z__9.i = 
	    gparm_1.gck1sq.r * gam2.i + gparm_1.gck1sq.i * gam2.r;
    z__8.r = z__9.r * gam.r - z__9.i * gam.i, z__8.i = z__9.r * gam.i + 
	    z__9.i * gam.r;
    z__7.r = zz2 * z__8.r, z__7.i = zz2 * z__8.i;
    z__6.r = *zp * z__7.r, z__6.i = *zp * z__7.i;
    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
    z_div(&z__1, &c_b336, &z__2);
    den.r = z__1.r, den.i = z__1.i;
    z__5.r = cgg2.r * cgg.r - cgg2.i * cgg.i, z__5.i = cgg2.r * cgg.i + 
	    cgg2.i * cgg.r;
    z__4.r = z__5.r * gam2.r - z__5.i * gam2.i, z__4.i = z__5.r * gam2.i + 
	    z__5.i * gam2.r;
    z__3.r = z__4.r * gam.r - z__4.i * gam.i, z__3.i = z__4.r * gam.i + 
	    z__4.i * gam.r;
    z__2.r = z__3.r * den.r - z__3.i * den.i, z__2.i = z__3.r * den.i + 
	    z__3.i * den.r;
    z_sqrt(&z__1, &z__2);
    fmhf.r = z__1.r, fmhf.i = z__1.i;
    if (d_imag(&fmhf) < 0.f) {
	z__1.r = -fmhf.r, z__1.i = -fmhf.i;
	fmhf.r = z__1.r, fmhf.i = z__1.i;
    }
    z__4.r = cgg.r * gam.r - cgg.i * gam.i, z__4.i = cgg.r * gam.i + cgg.i * 
	    gam.r;
    z__3.r = z__4.r * den.r - z__4.i * den.i, z__3.i = z__4.r * den.i + 
	    z__4.i * den.r;
    z__2.r = z__3.r * fmhf.r - z__3.i * fmhf.i, z__2.i = z__3.r * fmhf.i + 
	    z__3.i * fmhf.r;
    z__1.r = z__2.r / 24.f, z__1.i = z__2.i / 24.f;
    den32.r = z__1.r, den32.i = z__1.i;
    z__3.r = zz4 * gam4.r, z__3.i = zz4 * gam4.i;
    z__5.r = xls2.r * 4.f, z__5.i = xls2.i * 4.f;
    z__4.r = z__5.r + gparm_1.gck1sq.r, z__4.i = z__5.i + gparm_1.gck1sq.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__8.r = xls2.r * 4.f, z__8.i = xls2.i * 4.f;
    z__7.r = z__8.r + gparm_1.gck2sq.r, z__7.i = z__8.i + gparm_1.gck2sq.i;
    z__6.r = cgg4.r * z__7.r - cgg4.i * z__7.i, z__6.i = cgg4.r * z__7.i + 
	    cgg4.i * z__7.r;
    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
    ft1.r = z__1.r, ft1.i = z__1.i;
    z__5.r = gparm_1.gck1sq.r * gparm_1.gck2sq.r - gparm_1.gck1sq.i * 
	    gparm_1.gck2sq.i, z__5.i = gparm_1.gck1sq.r * gparm_1.gck2sq.i + 
	    gparm_1.gck1sq.i * gparm_1.gck2sq.r;
    z__4.r = z__5.r * cgg.r - z__5.i * cgg.i, z__4.i = z__5.r * cgg.i + 
	    z__5.i * cgg.r;
    z__3.r = z__4.r * gam.r - z__4.i * gam.i, z__3.i = z__4.r * gam.i + 
	    z__4.i * gam.r;
    z__2.r = *zp * z__3.r, z__2.i = *zp * z__3.i;
    z__10.r = xls2.r * 10.f, z__10.i = xls2.i * 10.f;
    z__9.r = z__10.r * cgg2.r - z__10.i * cgg2.i, z__9.i = z__10.r * cgg2.i + 
	    z__10.i * cgg2.r;
    z__8.r = z__9.r * gam2.r - z__9.i * gam2.i, z__8.i = z__9.r * gam2.i + 
	    z__9.i * gam2.r;
    z__7.r = zz2 * z__8.r, z__7.i = zz2 * z__8.i;
    z__6.r = z__7.r - ft1.r, z__6.i = z__7.i - ft1.i;
    z__1.r = z__2.r * z__6.r - z__2.i * z__6.i, z__1.i = z__2.r * z__6.i + 
	    z__2.i * z__6.r;
    ft1.r = z__1.r, ft1.i = z__1.i;
    z__5.r = gparm_1.gck2sq.r * gparm_1.gck2sq.r - gparm_1.gck2sq.i * 
	    gparm_1.gck2sq.i, z__5.i = gparm_1.gck2sq.r * gparm_1.gck2sq.i + 
	    gparm_1.gck2sq.i * gparm_1.gck2sq.r;
    z__4.r = z__5.r * cgg4.r - z__5.i * cgg4.i, z__4.i = z__5.r * cgg4.i + 
	    z__5.i * cgg4.r;
    z__3.r = z__4.r * cgg4.r - z__4.i * cgg4.i, z__3.i = z__4.r * cgg4.i + 
	    z__4.i * cgg4.r;
    z__12.r = gparm_1.gck1sq.r * gparm_1.gck1sq.r - gparm_1.gck1sq.i * 
	    gparm_1.gck1sq.i, z__12.i = gparm_1.gck1sq.r * gparm_1.gck1sq.i + 
	    gparm_1.gck1sq.i * gparm_1.gck1sq.r;
    z__11.r = zz4 * z__12.r, z__11.i = zz4 * z__12.i;
    z__10.r = zz2 * z__11.r, z__10.i = zz2 * z__11.i;
    z__9.r = *zp * z__10.r, z__9.i = *zp * z__10.i;
    z__8.r = *zp * z__9.r, z__8.i = *zp * z__9.i;
    z__7.r = z__8.r * gam4.r - z__8.i * gam4.i, z__7.i = z__8.r * gam4.i + 
	    z__8.i * gam4.r;
    z__6.r = z__7.r * gam4.r - z__7.i * gam4.i, z__6.i = z__7.r * gam4.i + 
	    z__7.i * gam4.r;
    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
    z__1.r = z__2.r - ft1.r, z__1.i = z__2.i - ft1.i;
    ft1.r = z__1.r, ft1.i = z__1.i;
    d__1 = *zz * 9.f;
    z__5.r = d__1 * ft1.r, z__5.i = d__1 * ft1.i;
    z__4.r = z__5.r * den32.r - z__5.i * den32.i, z__4.i = z__5.r * den32.i + 
	    z__5.i * den32.r;
    z__3.r = z__4.r * den.r - z__4.i * den.i, z__3.i = z__4.r * den.i + 
	    z__4.i * den.r;
    z__2.r = z__3.r * den.r - z__3.i * den.i, z__2.i = z__3.r * den.i + 
	    z__3.i * den.r;
    z__6.r = *zz * fmhf.r, z__6.i = *zz * fmhf.i;
    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
    ft1.r = z__1.r, ft1.i = z__1.i;
    z__3.r = gparm_1.gck2sq.r * cgg4.r - gparm_1.gck2sq.i * cgg4.i, z__3.i = 
	    gparm_1.gck2sq.r * cgg4.i + gparm_1.gck2sq.i * cgg4.r;
    z__2.r = z__3.r * cgg.r - z__3.i * cgg.i, z__2.i = z__3.r * cgg.i + 
	    z__3.i * cgg.r;
    z__7.r = zz4 * gparm_1.gck1sq.r, z__7.i = zz4 * gparm_1.gck1sq.i;
    z__6.r = *zp * z__7.r, z__6.i = *zp * z__7.i;
    z__5.r = z__6.r * gam4.r - z__6.i * gam4.i, z__5.i = z__6.r * gam4.i + 
	    z__6.i * gam4.r;
    z__4.r = z__5.r * gam.r - z__5.i * gam.i, z__4.i = z__5.r * gam.i + 
	    z__5.i * gam.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    ft2.r = z__1.r, ft2.i = z__1.i;
    z__4.r = xls->r * 36.f, z__4.i = xls->i * 36.f;
    z__3.r = z__4.r * ft2.r - z__4.i * ft2.i, z__3.i = z__4.r * ft2.i + 
	    z__4.i * ft2.r;
    z__2.r = z__3.r * den32.r - z__3.i * den32.i, z__2.i = z__3.r * den32.i + 
	    z__3.i * den32.r;
    z__1.r = z__2.r * den.r - z__2.i * den.i, z__1.i = z__2.r * den.i + 
	    z__2.i * den.r;
    ft2.r = z__1.r, ft2.i = z__1.i;
    z__3.r = cgg2.r * 12.f, z__3.i = cgg2.i * 12.f;
    z__2.r = z__3.r * gam2.r - z__3.i * gam2.i, z__2.i = z__3.r * gam2.i + 
	    z__3.i * gam2.r;
    z__1.r = z__2.r * den32.r - z__2.i * den32.i, z__1.i = z__2.r * den32.i + 
	    z__2.i * den32.r;
    ft3.r = z__1.r, ft3.i = z__1.i;
    z__2.r = gparm_1.gck2.r * 42.398f - gparm_1.gck2.i * -42.398f, z__2.i = 
	    gparm_1.gck2.r * -42.398f + gparm_1.gck2.i * 42.398f;
    d__1 = sqrt(*rho);
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    exx.r = z__1.r, exx.i = z__1.i;
    if (*iex != 0) {
	z__6.r = zz2 * gam.r, z__6.i = zz2 * gam.i;
	z__7.r = *zp * cgg.r, z__7.i = *zp * cgg.i;
	z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
	z__9.r = fj.r * xls->r - fj.i * xls->i, z__9.i = fj.r * xls->i + fj.i 
		* xls->r;
	z__8.r = *rho * z__9.r, z__8.i = *rho * z__9.i;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z__3.r = -z__4.r, z__3.i = -z__4.i;
	zzexp_(&z__2, &z__3);
	z__1.r = exx.r * z__2.r - exx.i * z__2.i, z__1.i = exx.r * z__2.i + 
		exx.i * z__2.r;
	exx.r = z__1.r, exx.i = z__1.i;
    }
    z__3.r = fjor.r * 3.f, z__3.i = fjor.i * 3.f;
    z__2.r = xls->r - z__3.r, z__2.i = xls->i - z__3.i;
    z__1.r = z__2.r * xlsq.r - z__2.i * xlsq.i, z__1.i = z__2.r * xlsq.i + 
	    z__2.i * xlsq.r;
    t1.r = z__1.r, t1.i = z__1.i;
    z__2.r = xls->r - fjor.r, z__2.i = xls->i - fjor.i;
    z_div(&z__1, &z__2, &xlsq);
    t2.r = z__1.r, t2.i = z__1.i;
    z_div(&z__3, &fjor, xls);
    z__2.r = z__3.r + 1.f, z__2.i = z__3.i;
    z_div(&z__1, &z__2, &xlsq);
    t3.r = z__1.r, t3.i = z__1.i;
    z__3.r = xls->r * 4.f, z__3.i = xls->i * 4.f;
    z__4.r = fjor.r * 6.f, z__4.i = fjor.i * 6.f;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * xlsq.r - z__2.i * xlsq.i, z__1.i = z__2.r * xlsq.i + 
	    z__2.i * xlsq.r;
    t4.r = z__1.r, t4.i = z__1.i;
    z__3.r = xls->r * 2.5f, z__3.i = xls->i * 2.5f;
    z__4.r = fjor.r * 1.5f, z__4.i = fjor.i * 1.5f;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * xlsq.r - z__2.i * xlsq.i, z__1.i = z__2.r * xlsq.i + 
	    z__2.i * xlsq.r;
    t5.r = z__1.r, t5.i = z__1.i;
    z__4.r = fjor.r * 7.f, z__4.i = fjor.i * 7.f;
    z__3.r = xls->r - z__4.r, z__3.i = xls->i - z__4.i;
    z__2.r = z__3.r * xls->r - z__3.i * xls->i, z__2.i = z__3.r * xls->i + 
	    z__3.i * xls->r;
    z__1.r = z__2.r * xlsq.r - z__2.i * xlsq.i, z__1.i = z__2.r * xlsq.i + 
	    z__2.i * xlsq.r;
    t6.r = z__1.r, t6.i = z__1.i;
    z__3.r = xls->r * 2.5f, z__3.i = xls->i * 2.5f;
    z__4.r = fjor.r * 10.5f, z__4.i = fjor.i * 10.5f;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * xlsq.r - z__2.i * xlsq.i, z__1.i = z__2.r * xlsq.i + 
	    z__2.i * xlsq.r;
    t7.r = z__1.r, t7.i = z__1.i;
    z__3.r = *zz * gam.r, z__3.i = *zz * gam.i;
    z__2.r = cgg.r + z__3.r, z__2.i = cgg.i + z__3.i;
    z_div(&z__1, &c_b336, &z__2);
    dp0.r = z__1.r, dp0.i = z__1.i;
    z__3.r = -dp0.r, z__3.i = -dp0.i;
    z__2.r = z__3.r * xls->r - z__3.i * xls->i, z__2.i = z__3.r * xls->i + 
	    z__3.i * xls->r;
    z__4.r = cgg.r * gam.r - cgg.i * gam.i, z__4.i = cgg.r * gam.i + cgg.i * 
	    gam.r;
    z_div(&z__1, &z__2, &z__4);
    dp1.r = z__1.r, dp1.i = z__1.i;
    z__6.r = zz2 * gparm_1.gck1sq.r, z__6.i = zz2 * gparm_1.gck1sq.i;
    z__5.r = *zz * z__6.r, z__5.i = *zz * z__6.i;
    z__7.r = cgg2.r * cgg.r - cgg2.i * cgg.i, z__7.i = cgg2.r * cgg.i + 
	    cgg2.i * cgg.r;
    z_div(&z__4, &z__5, &z__7);
    z__9.r = gam2.r * gam.r - gam2.i * gam.i, z__9.i = gam2.r * gam.i + 
	    gam2.i * gam.r;
    z_div(&z__8, &gparm_1.gck2sq, &z__9);
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = z__3.r * dp0.r - z__3.i * dp0.i, z__2.i = z__3.r * dp0.i + 
	    z__3.i * dp0.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    dp2.r = z__1.r, dp2.i = z__1.i;
    d__1 = *zz * 2.f;
    z__4.r = d__1 * dp1.r, z__4.i = d__1 * dp1.i;
    z__3.r = z__4.r * dp1.r - z__4.i * dp1.i, z__3.i = z__4.r * dp1.i + 
	    z__4.i * dp1.r;
    z_div(&z__2, &z__3, &dp0);
    z__1.r = dp2.r + z__2.r, z__1.i = dp2.i + z__2.i;
    dp2.r = z__1.r, dp2.i = z__1.i;
    z__2.r = xls->r * t3.r - xls->i * t3.i, z__2.i = xls->r * t3.i + xls->i * 
	    t3.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    d__1 = *zz * .5f;
    z__4.r = d__1 * t2.r, z__4.i = d__1 * t2.i;
    z__3.r = z__4.r * dp0.r - z__4.i * dp0.i, z__3.i = z__4.r * dp0.i + 
	    z__4.i * dp0.r;
    z_div(&z__2, &z__3, xls);
    z__6.r = xls->r * t3.r - xls->i * t3.i, z__6.i = xls->r * t3.i + xls->i * 
	    t3.r;
    z__5.r = z__6.r * dp1.r - z__6.i * dp1.i, z__5.i = z__6.r * dp1.i + 
	    z__6.i * dp1.r;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    d__1 = *zz * -.25f;
    z__7.r = d__1 * t1.r, z__7.i = d__1 * t1.i;
    z__6.r = z__7.r * dp0.r - z__7.i * dp0.i, z__6.i = z__7.r * dp0.i + 
	    z__7.i * dp0.r;
    z_div(&z__5, &z__6, &xls2);
    z__8.r = t2.r * dp1.r - t2.i * dp1.i, z__8.i = t2.r * dp1.i + t2.i * 
	    dp1.r;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__3.r = zz2 * z__4.r, z__3.i = zz2 * z__4.i;
    z_div(&z__2, &z__3, xls);
    z__10.r = xls->r * t3.r - xls->i * t3.i, z__10.i = xls->r * t3.i + xls->i 
	    * t3.r;
    z__9.r = z__10.r * dp2.r - z__10.i * dp2.i, z__9.i = z__10.r * dp2.i + 
	    z__10.i * dp2.r;
    z__1.r = z__2.r + z__9.r, z__1.i = z__2.i + z__9.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__4.r = gp0.r * ft1.r - gp0.i * ft1.i, z__4.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__5.r = gp1.r * ft2.r - gp1.i * ft2.i, z__5.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
    z__6.r = gp2.r * ft3.r - gp2.i * ft3.i, z__6.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    u12.r = z__1.r, u12.i = z__1.i;
    z__4.r = gparm_1.gck1sq.r * gam.r - gparm_1.gck1sq.i * gam.i, z__4.i = 
	    gparm_1.gck1sq.r * gam.i + gparm_1.gck1sq.i * gam.r;
    z__3.r = *zz * z__4.r, z__3.i = *zz * z__4.i;
    z__5.r = gparm_1.gck2sq.r * cgg.r - gparm_1.gck2sq.i * cgg.i, z__5.i = 
	    gparm_1.gck2sq.r * cgg.i + gparm_1.gck2sq.i * cgg.r;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z_div(&z__1, &c_b336, &z__2);
    dp0.r = z__1.r, dp0.i = z__1.i;
    z__4.r = -xls->r, z__4.i = -xls->i;
    z_div(&z__6, &gparm_1.gck1sq, &gam);
    z_div(&z__8, &gparm_1.gck2sq, &cgg);
    z__7.r = *zz * z__8.r, z__7.i = *zz * z__8.i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    z__2.r = z__3.r * dp0.r - z__3.i * dp0.i, z__2.i = z__3.r * dp0.i + 
	    z__3.i * dp0.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    dp1.r = z__1.r, dp1.i = z__1.i;
    z__2.r = *zz, z__2.i = 0.;
    z_div(&z__1, &z__2, &cgg);
    dp2.r = z__1.r, dp2.i = z__1.i;
    z__4.r = gparm_1.gck1sq.r * gparm_1.gck2sq.r - gparm_1.gck1sq.i * 
	    gparm_1.gck2sq.i, z__4.i = gparm_1.gck1sq.r * gparm_1.gck2sq.i + 
	    gparm_1.gck1sq.i * gparm_1.gck2sq.r;
    z__7.r = dp2.r * dp2.r - dp2.i * dp2.i, z__7.i = dp2.r * dp2.i + dp2.i * 
	    dp2.r;
    z__6.r = z__7.r * dp2.r - z__7.i * dp2.i, z__6.i = z__7.r * dp2.i + 
	    z__7.i * dp2.r;
    z__9.r = gam2.r * gam.r - gam2.i * gam.i, z__9.i = gam2.r * gam.i + 
	    gam2.i * gam.r;
    z_div(&z__8, &c_b336, &z__9);
    z__5.r = z__6.r + z__8.r, z__5.i = z__6.i + z__8.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    z__2.r = z__3.r * dp0.r - z__3.i * dp0.i, z__2.i = z__3.r * dp0.i + 
	    z__3.i * dp0.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    dp2.r = z__1.r, dp2.i = z__1.i;
    d__1 = *zz * 2.f;
    z__4.r = d__1 * dp1.r, z__4.i = d__1 * dp1.i;
    z__3.r = z__4.r * dp1.r - z__4.i * dp1.i, z__3.i = z__4.r * dp1.i + 
	    z__4.i * dp1.r;
    z_div(&z__2, &z__3, &dp0);
    z__1.r = dp2.r + z__2.r, z__1.i = dp2.i + z__2.i;
    dp2.r = z__1.r, dp2.i = z__1.i;
    z__3.r = *zz * gam.r, z__3.i = *zz * gam.i;
    z__2.r = z__3.r * t1.r - z__3.i * t1.i, z__2.i = z__3.r * t1.i + z__3.i * 
	    t1.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    z__5.r = xls->r * t1.r - xls->i * t1.i, z__5.i = xls->r * t1.i + xls->i * 
	    t1.r;
    z_div(&z__4, &z__5, &gam);
    z__8.r = gam.r * 1.5f, z__8.i = gam.i * 1.5f;
    z__7.r = zz2 * z__8.r, z__7.i = zz2 * z__8.i;
    z__6.r = z__7.r * t2.r - z__7.i * t2.i, z__6.i = z__7.r * t2.i + z__7.i * 
	    t2.r;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__2.r = z__3.r * dp0.r - z__3.i * dp0.i, z__2.i = z__3.r * dp0.i + 
	    z__3.i * dp0.r;
    z__11.r = *zz * gam.r, z__11.i = *zz * gam.i;
    z__10.r = z__11.r * t1.r - z__11.i * t1.i, z__10.i = z__11.r * t1.i + 
	    z__11.i * t1.r;
    z__9.r = z__10.r * dp1.r - z__10.i * dp1.i, z__9.i = z__10.r * dp1.i + 
	    z__10.i * dp1.r;
    z__1.r = z__2.r + z__9.r, z__1.i = z__2.i + z__9.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    z__2.r = *zz * gam.r, z__2.i = *zz * gam.i;
    z__8.r = t3.r * .75f, z__8.i = t3.i * .75f;
    z__7.r = *zz * z__8.r, z__7.i = *zz * z__8.i;
    z__6.r = z__7.r * dp0.r - z__7.i * dp0.i, z__6.i = z__7.r * dp0.i + 
	    z__7.i * dp0.r;
    z__10.r = t2.r * 3.f, z__10.i = t2.i * 3.f;
    z__9.r = z__10.r * dp1.r - z__10.i * dp1.i, z__9.i = z__10.r * dp1.i + 
	    z__10.i * dp1.r;
    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
    z__4.r = zz2 * z__5.r, z__4.i = zz2 * z__5.i;
    z__11.r = t1.r * dp2.r - t1.i * dp2.i, z__11.i = t1.r * dp2.i + t1.i * 
	    dp2.r;
    z__3.r = z__4.r + z__11.r, z__3.i = z__4.i + z__11.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__7.r = -xls2.r, z__7.i = -xls2.i;
    z__6.r = z__7.r * t1.r - z__7.i * t1.i, z__6.i = z__7.r * t1.i + z__7.i * 
	    t1.r;
    z__5.r = z__6.r * dp0.r - z__6.i * dp0.i, z__5.i = z__6.r * dp0.i + 
	    z__6.i * dp0.r;
    z_div(&z__4, &z__5, &gam2);
    z__11.r = *zz * t4.r, z__11.i = *zz * t4.i;
    z__10.r = z__11.r * dp0.r - z__11.i * dp0.i, z__10.i = z__11.r * dp0.i + 
	    z__11.i * dp0.r;
    z__14.r = xls->r * 2.f, z__14.i = xls->i * 2.f;
    z__13.r = z__14.r * t1.r - z__14.i * t1.i, z__13.i = z__14.r * t1.i + 
	    z__14.i * t1.r;
    z__12.r = z__13.r * dp1.r - z__13.i * dp1.i, z__12.i = z__13.r * dp1.i + 
	    z__13.i * dp1.r;
    z__9.r = z__10.r + z__12.r, z__9.i = z__10.i + z__12.i;
    z__8.r = *zz * z__9.r, z__8.i = *zz * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z_div(&z__2, &z__3, &gam);
    z__1.r = z__2.r + gp2.r, z__1.i = z__2.i + gp2.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__5.r = gp0.r * ft1.r - gp0.i * ft1.i, z__5.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__6.r = gp1.r * ft2.r - gp1.i * ft2.i, z__6.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__4.r = z__5.r - z__6.r, z__4.i = z__5.i - z__6.i;
    z__7.r = gp2.r * ft3.r - gp2.i * ft3.i, z__7.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
    z__2.r = z__3.r * exx.r - z__3.i * exx.i, z__2.i = z__3.r * exx.i + 
	    z__3.i * exx.r;
    z__1.r = z__2.r * fj.r - z__2.i * fj.i, z__1.i = z__2.r * fj.i + z__2.i * 
	    fj.r;
    erv->r = z__1.r, erv->i = z__1.i;
    z__2.r = xls2.r * xls->r - xls2.i * xls->i, z__2.i = xls2.r * xls->i + 
	    xls2.i * xls->r;
    z__1.r = z__2.r * t3.r - z__2.i * t3.i, z__1.i = z__2.r * t3.i + z__2.i * 
	    t3.r;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__1.r = gp2.r * dp0.r - gp2.i * dp0.i, z__1.i = gp2.r * dp0.i + gp2.i * 
	    dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    z__3.r = t5.r * dp0.r - t5.i * dp0.i, z__3.i = t5.r * dp0.i + t5.i * 
	    dp0.r;
    z__2.r = *zz * z__3.r, z__2.i = *zz * z__3.i;
    z__4.r = gp2.r * dp1.r - gp2.i * dp1.i, z__4.i = gp2.r * dp1.i + gp2.i * 
	    dp1.r;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    z__8.r = xls->r * 3.75f, z__8.i = xls->i * 3.75f;
    z__9.r = fjor.r * .75f, z__9.i = fjor.i * .75f;
    z__7.r = z__8.r + z__9.r, z__7.i = z__8.i + z__9.i;
    z_div(&z__6, &z__7, &xlsq);
    z__5.r = z__6.r * dp0.r - z__6.i * dp0.i, z__5.i = z__6.r * dp0.i + 
	    z__6.i * dp0.r;
    z__4.r = *zz * z__5.r, z__4.i = *zz * z__5.i;
    z__11.r = t5.r * 2.f, z__11.i = t5.i * 2.f;
    z__10.r = z__11.r * dp1.r - z__11.i * dp1.i, z__10.i = z__11.r * dp1.i + 
	    z__11.i * dp1.r;
    z__3.r = z__4.r + z__10.r, z__3.i = z__4.i + z__10.i;
    z__2.r = zz2 * z__3.r, z__2.i = zz2 * z__3.i;
    z__12.r = gp2.r * dp2.r - gp2.i * dp2.i, z__12.i = gp2.r * dp2.i + gp2.i *
	     dp2.r;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__4.r = gp0.r * ft1.r - gp0.i * ft1.i, z__4.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__5.r = gp1.r * ft2.r - gp1.i * ft2.i, z__5.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
    z__6.r = gp2.r * ft3.r - gp2.i * ft3.i, z__6.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__1.r = t6.r * dp0.r - t6.i * dp0.i, z__1.i = t6.r * dp0.i + t6.i * 
	    dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    z__3.r = t7.r * dp0.r - t7.i * dp0.i, z__3.i = t7.r * dp0.i + t7.i * 
	    dp0.r;
    z__2.r = *zz * z__3.r, z__2.i = *zz * z__3.i;
    z__4.r = t6.r * dp1.r - t6.i * dp1.i, z__4.i = t6.r * dp1.i + t6.i * 
	    dp1.r;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    z__8.r = xls->r * 3.75f, z__8.i = xls->i * 3.75f;
    z__9.r = fjor.r * 5.25f, z__9.i = fjor.i * 5.25f;
    z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
    z_div(&z__6, &z__7, &xlsq);
    z__5.r = z__6.r * dp0.r - z__6.i * dp0.i, z__5.i = z__6.r * dp0.i + 
	    z__6.i * dp0.r;
    z__4.r = *zz * z__5.r, z__4.i = *zz * z__5.i;
    z__11.r = t7.r * 2.f, z__11.i = t7.i * 2.f;
    z__10.r = z__11.r * dp1.r - z__11.i * dp1.i, z__10.i = z__11.r * dp1.i + 
	    z__11.i * dp1.r;
    z__3.r = z__4.r + z__10.r, z__3.i = z__4.i + z__10.i;
    z__2.r = zz2 * z__3.r, z__2.i = zz2 * z__3.i;
    z__12.r = t6.r * dp2.r - t6.i * dp2.i, z__12.i = t6.r * dp2.i + t6.i * 
	    dp2.r;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__6.r = gp0.r * ft1.r - gp0.i * ft1.i, z__6.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__7.r = gp1.r * ft2.r - gp1.i * ft2.i, z__7.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
    z__8.r = gp2.r * ft3.r - gp2.i * ft3.i, z__8.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__3.r = -z__4.r, z__3.i = -z__4.i;
    z__2.r = z__3.r * exx.r - z__3.i * exx.i, z__2.i = z__3.r * exx.i + 
	    z__3.i * exx.r;
    z__1.r = z__2.r + u12.r, z__1.i = z__2.i + u12.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = t1.r * dp0.r - t1.i * dp0.i, z__1.i = t1.r * dp0.i + t1.i * 
	    dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    z__4.r = t2.r * 1.5f, z__4.i = t2.i * 1.5f;
    z__3.r = z__4.r * dp0.r - z__4.i * dp0.i, z__3.i = z__4.r * dp0.i + 
	    z__4.i * dp0.r;
    z__2.r = *zz * z__3.r, z__2.i = *zz * z__3.i;
    z__5.r = t1.r * dp1.r - t1.i * dp1.i, z__5.i = t1.r * dp1.i + t1.i * 
	    dp1.r;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    z__6.r = t3.r * .75f, z__6.i = t3.i * .75f;
    z__5.r = z__6.r * dp0.r - z__6.i * dp0.i, z__5.i = z__6.r * dp0.i + 
	    z__6.i * dp0.r;
    z__4.r = *zz * z__5.r, z__4.i = *zz * z__5.i;
    z__8.r = t2.r * 3.f, z__8.i = t2.i * 3.f;
    z__7.r = z__8.r * dp1.r - z__8.i * dp1.i, z__7.i = z__8.r * dp1.i + 
	    z__8.i * dp1.r;
    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
    z__2.r = zz2 * z__3.r, z__2.i = zz2 * z__3.i;
    z__9.r = t1.r * dp2.r - t1.i * dp2.i, z__9.i = t1.r * dp2.i + t1.i * 
	    dp2.r;
    z__1.r = z__2.r + z__9.r, z__1.i = z__2.i + z__9.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__7.r = gp0.r * ft1.r - gp0.i * ft1.i, z__7.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__8.r = gp1.r * ft2.r - gp1.i * ft2.i, z__8.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__6.r = z__7.r - z__8.r, z__6.i = z__7.i - z__8.i;
    z__9.r = gp2.r * ft3.r - gp2.i * ft3.i, z__9.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
    z__4.r = z__5.r * exx.r - z__5.i * exx.i, z__4.i = z__5.r * exx.i + 
	    z__5.i * exx.r;
    z__3.r = z__4.r * fj.r - z__4.i * fj.i, z__3.i = z__4.r * fj.i + z__4.i * 
	    fj.r;
    z__2.r = z__3.r / *rho, z__2.i = z__3.i / *rho;
    z__1.r = z__2.r - u12.r, z__1.i = z__2.i - u12.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__2.r = cgg.r * t1.r - cgg.i * t1.i, z__2.i = cgg.r * t1.i + cgg.i * 
	    t1.r;
    z__1.r = z__2.r * dp0.r - z__2.i * dp0.i, z__1.i = z__2.r * dp0.i + 
	    z__2.i * dp0.r;
    gp0.r = z__1.r, gp0.i = z__1.i;
    z__6.r = xls->r * t1.r - xls->i * t1.i, z__6.i = xls->r * t1.i + xls->i * 
	    t1.r;
    z_div(&z__5, &z__6, &cgg);
    z__8.r = cgg.r * 1.5f, z__8.i = cgg.i * 1.5f;
    z__7.r = z__8.r * t2.r - z__8.i * t2.i, z__7.i = z__8.r * t2.i + z__8.i * 
	    t2.r;
    z__4.r = z__5.r + z__7.r, z__4.i = z__5.i + z__7.i;
    z__3.r = z__4.r * dp0.r - z__4.i * dp0.i, z__3.i = z__4.r * dp0.i + 
	    z__4.i * dp0.r;
    z__2.r = *zz * z__3.r, z__2.i = *zz * z__3.i;
    z__10.r = cgg.r * t1.r - cgg.i * t1.i, z__10.i = cgg.r * t1.i + cgg.i * 
	    t1.r;
    z__9.r = z__10.r * dp1.r - z__10.i * dp1.i, z__9.i = z__10.r * dp1.i + 
	    z__10.i * dp1.r;
    z__1.r = z__2.r + z__9.r, z__1.i = z__2.i + z__9.i;
    gp1.r = z__1.r, gp1.i = z__1.i;
    z__9.r = -xls2.r, z__9.i = -xls2.i;
    z__8.r = z__9.r * t1.r - z__9.i * t1.i, z__8.i = z__9.r * t1.i + z__9.i * 
	    t1.r;
    z_div(&z__7, &z__8, &cgg2);
    z__6.r = z__7.r + t4.r, z__6.i = z__7.i + t4.i;
    z__5.r = z__6.r * dp0.r - z__6.i * dp0.i, z__5.i = z__6.r * dp0.i + 
	    z__6.i * dp0.r;
    z__4.r = *zz * z__5.r, z__4.i = *zz * z__5.i;
    z__12.r = xls->r * 2.f, z__12.i = xls->i * 2.f;
    z__11.r = z__12.r * t1.r - z__12.i * t1.i, z__11.i = z__12.r * t1.i + 
	    z__12.i * t1.r;
    z__10.r = z__11.r * dp1.r - z__11.i * dp1.i, z__10.i = z__11.r * dp1.i + 
	    z__11.i * dp1.r;
    z__3.r = z__4.r + z__10.r, z__3.i = z__4.i + z__10.i;
    z__2.r = zz2 * z__3.r, z__2.i = zz2 * z__3.i;
    z_div(&z__1, &z__2, &cgg);
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__8.r = t3.r * .75f, z__8.i = t3.i * .75f;
    z__7.r = z__8.r * dp0.r - z__8.i * dp0.i, z__7.i = z__8.r * dp0.i + 
	    z__8.i * dp0.r;
    z__6.r = *zz * z__7.r, z__6.i = *zz * z__7.i;
    z__10.r = t2.r * 3.f, z__10.i = t2.i * 3.f;
    z__9.r = z__10.r * dp1.r - z__10.i * dp1.i, z__9.i = z__10.r * dp1.i + 
	    z__10.i * dp1.r;
    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
    z__4.r = zz2 * z__5.r, z__4.i = zz2 * z__5.i;
    z__11.r = t1.r * dp2.r - t1.i * dp2.i, z__11.i = t1.r * dp2.i + t1.i * 
	    dp2.r;
    z__3.r = z__4.r + z__11.r, z__3.i = z__4.i + z__11.i;
    z__2.r = cgg.r * z__3.r - cgg.i * z__3.i, z__2.i = cgg.r * z__3.i + cgg.i 
	    * z__3.r;
    z__1.r = gp2.r + z__2.r, z__1.i = gp2.i + z__2.i;
    gp2.r = z__1.r, gp2.i = z__1.i;
    z__5.r = gp0.r * ft1.r - gp0.i * ft1.i, z__5.i = gp0.r * ft1.i + gp0.i * 
	    ft1.r;
    z__6.r = gp1.r * ft2.r - gp1.i * ft2.i, z__6.i = gp1.r * ft2.i + gp1.i * 
	    ft2.r;
    z__4.r = z__5.r - z__6.r, z__4.i = z__5.i - z__6.i;
    z__7.r = gp2.r * ft3.r - gp2.i * ft3.i, z__7.i = gp2.r * ft3.i + gp2.i * 
	    ft3.r;
    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
    z__2.r = z__3.r * exx.r - z__3.i * exx.i, z__2.i = z__3.r * exx.i + 
	    z__3.i * exx.r;
    z__1.r = z__2.r * fj.r - z__2.i * fj.i, z__1.i = z__2.r * fj.i + z__2.i * 
	    fj.r;
    ezh->r = z__1.r, ezh->i = z__1.i;
/*     ADD POLE CONTRIBUTION (SURFACE WAVE) */
    z__4.r = -cgg.r, z__4.i = -cgg.i;
    z__3.r = *zp * z__4.r, z__3.i = *zp * z__4.i;
    z__5.r = zz2 * gam.r, z__5.i = zz2 * gam.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__7.r = fj.r * xls->r - fj.i * xls->i, z__7.i = fj.r * xls->i + fj.i * 
	    xls->r;
    z__6.r = *rho * z__7.r, z__6.i = *rho * z__7.i;
    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
    fs.r = z__1.r, fs.i = z__1.i;
    z__4.r = -gasav_1.pg1.r, z__4.i = -gasav_1.pg1.i;
    z__3.r = *zp * z__4.r, z__3.i = *zp * z__4.i;
    z__5.r = *zz * gasav_1.pg2.r, z__5.i = *zz * gasav_1.pg2.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z__7.r = fj.r * gasav_1.xlp.r - fj.i * gasav_1.xlp.i, z__7.i = fj.r * 
	    gasav_1.xlp.i + fj.i * gasav_1.xlp.r;
    z__6.r = *rho * z__7.r, z__6.i = *rho * z__7.i;
    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
    fp.r = z__1.r, fp.i = z__1.i;
    z__2.r = fp.r - fs.r, z__2.i = fp.i - fs.i;
    z_sqrt(&z__1, &z__2);
    bb.r = z__1.r, bb.i = z__1.i;
    z__4.r = exx.r * .70710678f, z__4.i = exx.i * .70710678f;
    z__3.r = z__4.r * gasav_1.aa.r - z__4.i * gasav_1.aa.i, z__3.i = z__4.r * 
	    gasav_1.aa.i + z__4.i * gasav_1.aa.r;
    z_div(&z__2, &z__3, &bb);
    z__7.r = fj.r * bb.r - fj.i * bb.i, z__7.i = fj.r * bb.i + fj.i * bb.r;
    fbars_(&z__6, &z__7);
    z__9.r = bb.r * bb.r - bb.i * bb.i, z__9.i = bb.r * bb.i + bb.i * bb.r;
    z_div(&z__8, &c_b1298, &z__9);
    z__5.r = z__6.r + z__8.r, z__5.i = z__6.i + z__8.i;
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    vp12.r = z__1.r, vp12.i = z__1.i;
    z__6.r = fjor.r * 3.f, z__6.i = fjor.i * 3.f;
    z__5.r = gasav_1.xlp.r - z__6.r, z__5.i = gasav_1.xlp.i - z__6.i;
    z__4.r = vp12.r * z__5.r - vp12.i * z__5.i, z__4.i = vp12.r * z__5.i + 
	    vp12.i * z__5.r;
    z__3.r = z__4.r * gparm_1.gck2sq.r - z__4.i * gparm_1.gck2sq.i, z__3.i = 
	    z__4.r * gparm_1.gck2sq.i + z__4.i * gparm_1.gck2sq.r;
    z_div(&z__2, &z__3, &gasav_1.cd);
    z__1.r = erv->r + z__2.r, z__1.i = erv->i + z__2.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__4.r = gasav_1.xlp.r + fjor.r, z__4.i = gasav_1.xlp.i + fjor.i;
    z__3.r = vp12.r * z__4.r - vp12.i * z__4.i, z__3.i = vp12.r * z__4.i + 
	    vp12.i * z__4.r;
    z__2.r = z__3.r * gasav_1.xlp.r - z__3.i * gasav_1.xlp.i, z__2.i = z__3.r 
	    * gasav_1.xlp.i + z__3.i * gasav_1.xlp.r;
    z__1.r = ezv->r + z__2.r, z__1.i = ezv->i + z__2.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__5.r = fjor.r * 7.f, z__5.i = fjor.i * 7.f;
    z__4.r = gasav_1.xlp.r - z__5.r, z__4.i = gasav_1.xlp.i - z__5.i;
    z__3.r = vp12.r * z__4.r - vp12.i * z__4.i, z__3.i = vp12.r * z__4.i + 
	    vp12.i * z__4.r;
    z__2.r = z__3.r * gasav_1.xlp.r - z__3.i * gasav_1.xlp.i, z__2.i = z__3.r 
	    * gasav_1.xlp.i + z__3.i * gasav_1.xlp.r;
    z__1.r = erh->r - z__2.r, z__1.i = erh->i - z__2.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__4.r = vp12.r * fj.r - vp12.i * fj.i, z__4.i = vp12.r * fj.i + vp12.i * 
	    fj.r;
    z__6.r = fjor.r * 3.f, z__6.i = fjor.i * 3.f;
    z__5.r = gasav_1.xlp.r - z__6.r, z__5.i = gasav_1.xlp.i - z__6.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    z__2.r = z__3.r / *rho, z__2.i = z__3.i / *rho;
    z__1.r = eph->r + z__2.r, z__1.i = eph->i + z__2.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__6.r = fjor.r * 3.f, z__6.i = fjor.i * 3.f;
    z__5.r = gasav_1.xlp.r - z__6.r, z__5.i = gasav_1.xlp.i - z__6.i;
    z__4.r = vp12.r * z__5.r - vp12.i * z__5.i, z__4.i = vp12.r * z__5.i + 
	    vp12.i * z__5.r;
    z__3.r = z__4.r * gparm_1.gck1sq.r - z__4.i * gparm_1.gck1sq.i, z__3.i = 
	    z__4.r * gparm_1.gck1sq.i + z__4.i * gparm_1.gck1sq.r;
    z_div(&z__2, &z__3, &gasav_1.cd);
    z__1.r = ezh->r - z__2.r, z__1.i = ezh->i - z__2.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
} /* gasy2_ */

/* Subroutine */ int gasy3_(doublereal *zz, doublereal *zp, integer *iex, 
	doublecomplex *ezv, doublecomplex *erh, doublecomplex *eph)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};
    static doublecomplex ck1x = {0.,0.};
    static doublecomplex ck2x = {0.,0.};

    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9;

    /* Builtin functions */
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex t1, t2, u12, fp2, fp4, exx;
    static doublereal zxx;
    extern /* Double Complex */ VOID zzexp_(doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GASY3 evaluates the field transmitted across an interface at */
/*     normal incidence using an asymptotic approximation with higher */
/*     order terms. */

    z__1.r = gparm_1.gck1.r - ck1x.r, z__1.i = gparm_1.gck1.i - ck1x.i;
    t1.r = z__1.r, t1.i = z__1.i;
    z__1.r = gparm_1.gck2.r - ck2x.r, z__1.i = gparm_1.gck2.i - ck2x.i;
    t2.r = z__1.r, t2.i = z__1.i;
    zxx = gparm_1.gck2.r * 1e-8f;
    if ((d__1 = t1.r, abs(d__1)) > zxx || (d__2 = d_imag(&t1), abs(d__2)) > 
	    zxx) {
	goto L1;
    }
    if ((d__1 = t2.r, abs(d__1)) > zxx || (d__2 = d_imag(&t2), abs(d__2)) > 
	    zxx) {
	goto L1;
    }
    goto L2;
/*     COMPUTE CONSTANTS THAT DEPEND ONLY ON GCK1 AND GCK2 */
L1:
    ck1x.r = gparm_1.gck1.r, ck1x.i = gparm_1.gck1.i;
    ck2x.r = gparm_1.gck2.r, ck2x.i = gparm_1.gck2.i;
    z__1.r = gparm_1.gck1.r + gparm_1.gck2.r, z__1.i = gparm_1.gck1.i + 
	    gparm_1.gck2.i;
    gasav_1.gg2.r = z__1.r, gasav_1.gg2.i = z__1.i;
    z__2.r = -fj.r, z__2.i = -fj.i;
    z_div(&z__1, &z__2, &gasav_1.gg2);
    gasav_1.gx0.r = z__1.r, gasav_1.gx0.i = z__1.i;
    z__3.r = -fj.r, z__3.i = -fj.i;
    z_div(&z__5, &c_b336, &gparm_1.gck1);
    z_div(&z__6, &c_b336, &gparm_1.gck2);
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__7.r = gasav_1.gg2.r * gasav_1.gg2.r - gasav_1.gg2.i * gasav_1.gg2.i, 
	    z__7.i = gasav_1.gg2.r * gasav_1.gg2.i + gasav_1.gg2.i * 
	    gasav_1.gg2.r;
    z_div(&z__1, &z__2, &z__7);
    gasav_1.gx2.r = z__1.r, gasav_1.gx2.i = z__1.i;
    z__2.r = gparm_1.gck1.r * gparm_1.gck2.r - gparm_1.gck1.i * 
	    gparm_1.gck2.i, z__2.i = gparm_1.gck1.r * gparm_1.gck2.i + 
	    gparm_1.gck1.i * gparm_1.gck2.r;
    z_div(&z__1, &gasav_1.gx0, &z__2);
    gasav_1.gg0.r = z__1.r, gasav_1.gg0.i = z__1.i;
    z__3.r = -fj.r, z__3.i = -fj.i;
    z__6.r = gparm_1.gck1.r * gparm_1.gck1sq.r - gparm_1.gck1.i * 
	    gparm_1.gck1sq.i, z__6.i = gparm_1.gck1.r * gparm_1.gck1sq.i + 
	    gparm_1.gck1.i * gparm_1.gck1sq.r;
    z_div(&z__5, &c_b336, &z__6);
    z__8.r = gparm_1.gck2.r * gparm_1.gck2sq.r - gparm_1.gck2.i * 
	    gparm_1.gck2sq.i, z__8.i = gparm_1.gck2.r * gparm_1.gck2sq.i + 
	    gparm_1.gck2.i * gparm_1.gck2sq.r;
    z_div(&z__7, &c_b336, &z__8);
    z__4.r = z__5.r + z__7.r, z__4.i = z__5.i + z__7.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__9.r = gasav_1.gg2.r * gasav_1.gg2.r - gasav_1.gg2.i * gasav_1.gg2.i, 
	    z__9.i = gasav_1.gg2.r * gasav_1.gg2.i + gasav_1.gg2.i * 
	    gasav_1.gg2.r;
    z_div(&z__1, &z__2, &z__9);
    gasav_1.gg2.r = z__1.r, gasav_1.gg2.i = z__1.i;
    z__2.r = -fj.r, z__2.i = -fj.i;
    z_div(&z__1, &z__2, &gparm_1.gck2);
    gasav_1.fa2.r = z__1.r, gasav_1.fa2.i = z__1.i;
    z_div(&z__1, &fj, &gparm_1.gck1);
    gasav_1.fb2.r = z__1.r, gasav_1.fb2.i = z__1.i;
    z__2.r = fj.r * -3.f, z__2.i = fj.i * -3.f;
    z__3.r = gparm_1.gck2.r * gparm_1.gck2sq.r - gparm_1.gck2.i * 
	    gparm_1.gck2sq.i, z__3.i = gparm_1.gck2.r * gparm_1.gck2sq.i + 
	    gparm_1.gck2.i * gparm_1.gck2sq.r;
    z_div(&z__1, &z__2, &z__3);
    gasav_1.fa4.r = z__1.r, gasav_1.fa4.i = z__1.i;
    z__2.r = fj.r * 3.f, z__2.i = fj.i * 3.f;
    z__3.r = gparm_1.gck1.r * gparm_1.gck1sq.r - gparm_1.gck1.i * 
	    gparm_1.gck1sq.i, z__3.i = gparm_1.gck1.r * gparm_1.gck1sq.i + 
	    gparm_1.gck1.i * gparm_1.gck1sq.r;
    z_div(&z__1, &z__2, &z__3);
    gasav_1.fb4.r = z__1.r, gasav_1.fb4.i = z__1.i;
/*     END OF CONSTANTS */
L2:
    z__2.r = *zz * gasav_1.fa2.r, z__2.i = *zz * gasav_1.fa2.i;
    z__3.r = *zp * gasav_1.fb2.r, z__3.i = *zp * gasav_1.fb2.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    fp2.r = z__1.r, fp2.i = z__1.i;
    z__2.r = *zz * gasav_1.fa4.r, z__2.i = *zz * gasav_1.fa4.i;
    z__3.r = *zp * gasav_1.fb4.r, z__3.i = *zp * gasav_1.fb4.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    fp4.r = z__1.r, fp4.i = z__1.i;
    z_div(&z__1, &c_b1407, &fp2);
    t1.r = z__1.r, t1.i = z__1.i;
    z__2.r = gparm_1.gck2.r * 0.f - gparm_1.gck2.i * -29.98f, z__2.i = 
	    gparm_1.gck2.r * -29.98f + gparm_1.gck2.i * 0.f;
    z__1.r = z__2.r * t1.r - z__2.i * t1.i, z__1.i = z__2.r * t1.i + z__2.i * 
	    t1.r;
    t2.r = z__1.r, t2.i = z__1.i;
    z__2.r = t1.r * t2.r - t1.i * t2.i, z__2.i = t1.r * t2.i + t1.i * t2.r;
    z__7.r = gasav_1.gg2.r * 2.f, z__7.i = gasav_1.gg2.i * 2.f;
    z__6.r = z__7.r * fp2.r - z__7.i * fp2.i, z__6.i = z__7.r * fp2.i + 
	    z__7.i * fp2.r;
    z__8.r = gasav_1.gg0.r * fp4.r - gasav_1.gg0.i * fp4.i, z__8.i = 
	    gasav_1.gg0.r * fp4.i + gasav_1.gg0.i * fp4.r;
    z__5.r = z__6.r - z__8.r, z__5.i = z__6.i - z__8.i;
    z__9.r = fp2.r * fp2.r - fp2.i * fp2.i, z__9.i = fp2.r * fp2.i + fp2.i * 
	    fp2.r;
    z_div(&z__4, &z__5, &z__9);
    z__3.r = gasav_1.gg0.r + z__4.r, z__3.i = gasav_1.gg0.i + z__4.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__4.r = gasav_1.gx2.r * fp2.r - gasav_1.gx2.i * fp2.i, z__4.i = 
	    gasav_1.gx2.r * fp2.i + gasav_1.gx2.i * fp2.r;
    z__6.r = gasav_1.gx0.r * fp4.r - gasav_1.gx0.i * fp4.i, z__6.i = 
	    gasav_1.gx0.r * fp4.i + gasav_1.gx0.i * fp4.r;
    z__5.r = z__6.r / 3.f, z__5.i = z__6.i / 3.f;
    z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
    z__2.r = t2.r * z__3.r - t2.i * z__3.i, z__2.i = t2.r * z__3.i + t2.i * 
	    z__3.r;
    z__7.r = fp2.r * fp2.r - fp2.i * fp2.i, z__7.i = fp2.r * fp2.i + fp2.i * 
	    fp2.r;
    z_div(&z__1, &z__2, &z__7);
    u12.r = z__1.r, u12.i = z__1.i;
    if (*iex == 0) {
	goto L3;
    }
    z__3.r = -fj.r, z__3.i = -fj.i;
    z__5.r = *zz * gparm_1.gck2.r, z__5.i = *zz * gparm_1.gck2.i;
    z__6.r = *zp * gparm_1.gck1.r, z__6.i = *zp * gparm_1.gck1.i;
    z__4.r = z__5.r - z__6.r, z__4.i = z__5.i - z__6.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    zzexp_(&z__1, &z__2);
    exx.r = z__1.r, exx.i = z__1.i;
    z__1.r = ezv->r * exx.r - ezv->i * exx.i, z__1.i = ezv->r * exx.i + 
	    ezv->i * exx.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__3.r = t2.r * gasav_1.gx0.r - t2.i * gasav_1.gx0.i, z__3.i = t2.r * 
	    gasav_1.gx0.i + t2.i * gasav_1.gx0.r;
    z__2.r = z__3.r + u12.r, z__2.i = z__3.i + u12.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    u12.r = z__1.r, u12.i = z__1.i;
L3:
    z__2.r = ezv->r * -.5f, z__2.i = ezv->i * -.5f;
    z__1.r = z__2.r + u12.r, z__1.i = z__2.i + u12.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = -erh->r, z__1.i = -erh->i;
    eph->r = z__1.r, eph->i = z__1.i;
    if (*iex == 0) {
	z__4.r = t1.r * .5f, z__4.i = t1.i * .5f;
	z__3.r = z__4.r * t2.r - z__4.i * t2.i, z__3.i = z__4.r * t2.i + 
		z__4.i * t2.r;
	z__2.r = z__3.r * gasav_1.gg0.r - z__3.i * gasav_1.gg0.i, z__2.i = 
		z__3.r * gasav_1.gg0.i + z__3.i * gasav_1.gg0.r;
	z__1.r = eph->r - z__2.r, z__1.i = eph->i - z__2.i;
	eph->r = z__1.r, eph->i = z__1.i;
    }
    return 0;
} /* gasy3_ */

/* Subroutine */ int geasy_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublecomplex *erv, doublecomplex *ezv, doublecomplex *erh, 
	doublecomplex *eph, doublecomplex *ezh)
{
    /* Initialized data */

    static doublereal alim = .2;
    static doublereal blim = .1;

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *), sqrt(doublereal);

    /* Local variables */
    static doublereal bb, aa1, aa2;
    static doublecomplex fph, frh, grh, gph, fzh, gzh, frv, vph, vrh, grv, 
	    exx, xls, fzv, gzv, vzv;
    static doublereal zxx;
    static integer ierr;
    static doublecomplex xlsx;
    extern /* Subroutine */ int gasy1_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    ), gasy2_(doublereal *, doublereal *, doublereal *, doublecomplex 
	    *, integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *), gasy3_(doublereal *, 
	    doublereal *, integer *, doublecomplex *, doublecomplex *, 
	    doublecomplex *), sadpt_(doublereal *, doublereal *, doublereal *,
	     doublecomplex *), sdlpt_(doublecomplex *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GEASY calls appropriate routines for asymptotic approximations */
/*     of the E field. */
    sadpt_(rho, zz, zp, &xls);
    sdlpt_(&xls, &ierr);
    if (*zz > (*zz - *zp) * .05f) {
	goto L1;
    }
    zxx = -(*zp);
    z_div(&z__1, &gparm_1.gck2, &gparm_1.gck1);
    bb = z_abs(&z__1);
    bb /= sqrt(1.f - bb * bb);
/*     BB=TAN(ABS(TOTALLY REFELECTING ANGLE)) */
    if (*rho < zxx * bb) {
	goto L5;
    }
    bb = (blim + bb) / (1.f - blim * bb);
/*     BB=TAN(CABS(TOTALLY REFELECTING ANGLE)+ATAN(BLIM)) */
    if (*rho < zxx * bb) {
	goto L4;
    }
L1:
    zxx = (*zz - *zp) * alim;
    if (*rho < zxx) {
	goto L2;
    }
    if (*zz * gparm_1.gck2.r > 100.f) {
	goto L5;
    }

/*     CALL GASY2 FOR ASYMPTOTIC APPROX. WITH HIGHER ORDER TERMS AND */
/*     SURFACE WAVE */

    gasy2_(rho, zz, zp, &xls, &c__1, erv, ezv, erh, eph, ezh);
/*     ADD FIRST ORDER ASYMPTOTIC FOR RAY IN LOWER MEDIUM */
    z__2.r = *rho * gparm_1.gck1.r, z__2.i = *rho * gparm_1.gck1.i;
    d__1 = sqrt(*rho * *rho + *zp * *zp);
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    xls.r = z__1.r, xls.i = z__1.i;
    gasy1_(rho, zz, zp, &xls, &c__1, &exx, &frv, &fzv, &frh, &fph, &fzh);
    z__1.r = erv->r + frv.r, z__1.i = erv->i + frv.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = ezv->r + fzv.r, z__1.i = ezv->i + fzv.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__1.r = erh->r + frh.r, z__1.i = erh->i + frh.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = eph->r + fph.r, z__1.i = eph->i + fph.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__1.r = ezh->r + fzh.r, z__1.i = ezh->i + fzh.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L2:
    if (*rho < alim * .001f) {
	goto L3;
    }

/*     GET FIRST ORDER G.O. FOR ACTUAL COORD. AND INTERPOLATE FOR HIGHER */
/*     ORDER TERMS BETWEEN RHO=0. (GASY3) AND RHO=ZXX (GASY2-GASY1) */

    sadpt_(&zxx, zz, zp, &xlsx);
    sdlpt_(&xlsx, &ierr);
    gasy2_(&zxx, zz, zp, &xlsx, &c__0, &frv, &fzv, &frh, &fph, &fzh);
    gasy1_(&zxx, zz, zp, &xlsx, &c__0, &exx, &grv, &gzv, &grh, &gph, &gzh);
    z__1.r = frv.r - grv.r, z__1.i = frv.i - grv.i;
    frv.r = z__1.r, frv.i = z__1.i;
    z__1.r = fzv.r - gzv.r, z__1.i = fzv.i - gzv.i;
    fzv.r = z__1.r, fzv.i = z__1.i;
    z__1.r = frh.r - grh.r, z__1.i = frh.i - grh.i;
    frh.r = z__1.r, frh.i = z__1.i;
    z__1.r = fph.r - gph.r, z__1.i = fph.i - gph.i;
    fph.r = z__1.r, fph.i = z__1.i;
    z__1.r = fzh.r - gzh.r, z__1.i = fzh.i - gzh.i;
    fzh.r = z__1.r, fzh.i = z__1.i;
    gasy3_(zz, zp, &c__0, &vzv, &vrh, &vph);
    gasy1_(rho, zz, zp, &xls, &c__0, &exx, erv, ezv, erh, eph, ezh);
    aa1 = *rho * *rho / (zxx * zxx);
    aa2 = (*rho + zxx) * (*rho - zxx) / (zxx * zxx);
    z__4.r = *rho * frv.r, z__4.i = *rho * frv.i;
    z__3.r = z__4.r / zxx, z__3.i = z__4.i / zxx;
    z__2.r = erv->r + z__3.r, z__2.i = erv->i + z__3.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    erv->r = z__1.r, erv->i = z__1.i;
    z__4.r = aa1 * fzv.r, z__4.i = aa1 * fzv.i;
    z__3.r = ezv->r + z__4.r, z__3.i = ezv->i + z__4.i;
    z__5.r = aa2 * vzv.r, z__5.i = aa2 * vzv.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__4.r = aa1 * frh.r, z__4.i = aa1 * frh.i;
    z__3.r = erh->r + z__4.r, z__3.i = erh->i + z__4.i;
    z__5.r = aa2 * vrh.r, z__5.i = aa2 * vrh.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    erh->r = z__1.r, erh->i = z__1.i;
    z__4.r = aa1 * fph.r, z__4.i = aa1 * fph.i;
    z__3.r = eph->r + z__4.r, z__3.i = eph->i + z__4.i;
    z__5.r = aa2 * vph.r, z__5.i = aa2 * vph.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    eph->r = z__1.r, eph->i = z__1.i;
    z__4.r = *rho * fzh.r, z__4.i = *rho * fzh.i;
    z__3.r = z__4.r / zxx, z__3.i = z__4.i / zxx;
    z__2.r = ezh->r + z__3.r, z__2.i = ezh->i + z__3.i;
    z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
	    z__2.i * exx.r;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
/*     CALL GASY3 FOR ASYMPTOTIC APPROX. FOR NORMAL INCIDENCE */
L3:
    gasy3_(zz, zp, &c__1, ezv, erh, eph);
    erv->r = 0.f, erv->i = 0.f;
    ezh->r = 0.f, ezh->i = 0.f;
    return 0;
/*     USE FIRST ORDER G.O. ONLY */
L4:
    z__2.r = *rho * gparm_1.gck1.r, z__2.i = *rho * gparm_1.gck1.i;
    d__1 = sqrt(*rho * *rho + *zp * *zp);
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    xls.r = z__1.r, xls.i = z__1.i;
L5:
    gasy1_(rho, zz, zp, &xls, &c__1, &exx, erv, ezv, erh, eph, ezh);
    return 0;
} /* geasy_ */

/* Subroutine */ int gfdir_(doublereal *rho, doublereal *zs, doublereal *zo, 
	doublecomplex *ckfs, doublecomplex *ck, doublecomplex *erv, 
	doublecomplex *ezv, doublecomplex *erh, doublecomplex *eph, 
	doublecomplex *ezh)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static doublecomplex t1, t2;
    static doublereal zd, rr, rr2;
    static doublecomplex con, exf;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GFDIR computes the E field of a point source in an infinite medium */
/*     with wave number CK. */

    z__1.r = 0.f * ckfs->r - -29.98f * ckfs->i, z__1.i = 0.f * ckfs->i + 
	    -29.98f * ckfs->r;
    con.r = z__1.r, con.i = z__1.i;
    zd = *zo - *zs;
    r__ = sqrt(*rho * *rho + zd * zd);
    rr = 1.f / r__;
    rr2 = rr * rr;
    z__1.r = r__ * ck->r, z__1.i = r__ * ck->i;
    t2.r = z__1.r, t2.i = z__1.i;
    z__1.r = ck->r * ck->r - ck->i * ck->i, z__1.i = ck->r * ck->i + ck->i * 
	    ck->r;
    t1.r = z__1.r, t1.i = z__1.i;
    z__7.r = -fj.r, z__7.i = -fj.i;
    z__6.r = z__7.r * t2.r - z__7.i * t2.i, z__6.i = z__7.r * t2.i + z__7.i * 
	    t2.r;
    z_exp(&z__5, &z__6);
    z__4.r = con.r * z__5.r - con.i * z__5.i, z__4.i = con.r * z__5.i + con.i 
	    * z__5.r;
    z__3.r = rr2 * z__4.r, z__3.i = rr2 * z__4.i;
    z__2.r = rr * z__3.r, z__2.i = rr * z__3.i;
    z_div(&z__1, &z__2, &t1);
    exf.r = z__1.r, exf.i = z__1.i;
    z__5.r = fj.r * ck->r - fj.i * ck->i, z__5.i = fj.r * ck->i + fj.i * 
	    ck->r;
    z__4.r = rr * z__5.r, z__4.i = rr * z__5.i;
    z__3.r = rr2 + z__4.r, z__3.i = z__4.i;
    z__2.r = z__3.r * 3.f, z__2.i = z__3.i * 3.f;
    z__1.r = z__2.r - t1.r, z__1.i = z__2.i - t1.i;
    t1.r = z__1.r, t1.i = z__1.i;
    z__3.r = t2.r - fj.r, z__3.i = t2.i - fj.i;
    z__2.r = z__3.r * t2.r - z__3.i * t2.i, z__2.i = z__3.r * t2.i + z__3.i * 
	    t2.r;
    z__1.r = z__2.r - 1.f, z__1.i = z__2.i;
    t2.r = z__1.r, t2.i = z__1.i;
    d__1 = *rho * zd;
    z__2.r = d__1 * t1.r, z__2.i = d__1 * t1.i;
    z__1.r = z__2.r * exf.r - z__2.i * exf.i, z__1.i = z__2.r * exf.i + 
	    z__2.i * exf.r;
    erv->r = z__1.r, erv->i = z__1.i;
    d__1 = zd * zd;
    z__3.r = d__1 * t1.r, z__3.i = d__1 * t1.i;
    z__2.r = z__3.r + t2.r, z__2.i = z__3.i + t2.i;
    z__1.r = z__2.r * exf.r - z__2.i * exf.i, z__1.i = z__2.r * exf.i + 
	    z__2.i * exf.r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    d__1 = *rho * *rho;
    z__3.r = d__1 * t1.r, z__3.i = d__1 * t1.i;
    z__2.r = z__3.r + t2.r, z__2.i = z__3.i + t2.i;
    z__1.r = z__2.r * exf.r - z__2.i * exf.i, z__1.i = z__2.r * exf.i + 
	    z__2.i * exf.r;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = -t2.r, z__2.i = -t2.i;
    z__1.r = z__2.r * exf.r - z__2.i * exf.i, z__1.i = z__2.r * exf.i + 
	    z__2.i * exf.r;
    eph->r = z__1.r, eph->i = z__1.i;
    ezh->r = erv->r, ezh->i = erv->i;
    return 0;
} /* gfdir_ */

/* Subroutine */ int gfil_(integer *iprt, char *filnam, ftnlen filnam_len)
{
    /* Initialized data */

    static integer igfl = 20;

    /* Format strings */
    static char fmt_16[] = "(////)";
    static char fmt_14[] = "(5x,\002****************************************"
	    "**********\002,\002**********************************\002)";
    static char fmt_17[] = "(5x,\002**\002,80x,\002**\002)";
    static char fmt_18[] = "(5x,\002** NUMERICAL GREEN'S FUNCTION FILE \002,"
	    "a,\002**\002,/,5x,\002** NO. SEGMENTS =\002,i4,10x,\002NO. PATCH"
	    "ES =\002,i4,34x,\002**\002)";
    static char fmt_19[] = "(5x,\002** NO. SYMMETRIC SECTIONS =\002,i4,51x"
	    ",\002**\002)";
    static char fmt_20[] = "(5x,\002** N.G.F. MATRIX -  CORE STORAGE =\002,i"
	    "7,\002 COMPLEX NUMBERS,  CASE\002,i2,16x,\002**\002)";
    static char fmt_21[] = "(5x,\002**\002,19x,\002MATRIX SIZE =\002,i7,\002"
	    " COMPLEX NUMBERS\002,25x,\002**\002)";
    static char fmt_22[] = "(5x,\002** FREQUENCY =\002,1pe12.5,\002 MHZ.\002"
	    ",51x,\002**\002)";
    static char fmt_23[] = "(5x,\002** PERFECT GROUND\002,65x,\002**\002)";
    static char fmt_27[] = "(5x,\002** FINITE GROUND.  REFLECTION COEFFICIEN"
	    "T APPROXIMATION\002,27x,\002**\002)";
    static char fmt_28[] = "(5x,\002** FINITE GROUND.  SOMMERFELD SOLUTIO"
	    "N\002,44x,\002**\002)";
    static char fmt_24[] = "(5x,\002** GROUND PARAMETERS - DIELECTRIC CONSTA"
	    "NT =\002,1pe12.5,26x,\002**\002,/,5x,\002**\002,21x,\002CONDUCTI"
	    "VITY =\002,e12.5,\002 MHOS/M.\002,25x,\002**\002)";
    static char fmt_15[] = "(5x,\002** \002,a,\002 **\002)";
    static char fmt_25[] = "(39x,\002NUMERICAL GREEN'S FUNCTION DATA\002,/,4"
	    "1x,\002COORDINAT\002,\002ES OF SEGMENT ENDS\002,/,51x,\002(METER"
	    "S)\002,/,5x,\002SEG.\002,11x,\002- - - END ONE - - -\002,26x,"
	    "\002- - - END TWO - - -\002,/,6x,\002NO.\002,6x,\002X\002,14x"
	    ",\002Y\002,14x,\002Z\002,14x,\002X\002,14x,\002Y\002,14x,\002"
	    "Z\002)";
    static char fmt_26[] = "(1x,i7,1p6e15.6)";

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1;
    olist o__1;
    cllist cl__1;
    alist al__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen), f_open(olist *), f_rew(
	    alist *), s_rsue(cilist *), do_uio(integer *, char *, ftnlen), 
	    e_rsue(void), f_clos(cllist *), s_wsfe(cilist *), e_wsfe(void), 
	    do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, j, k;
    static doublereal dx, xi, yi, zi;
    static integer iop, nop, nbl2, irec;
    static doublecomplex epsc;
    static integer npeq, iout;
    extern /* Subroutine */ int recot_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static char ngffil[80];
    extern /* Subroutine */ int daopen_(integer *, char *, char *, char *, 
	    integer *, ftnlen, ftnlen, ftnlen), gndino_(doublecomplex *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___1101 = { 0, 0, 0, 0, 0 };
    static cilist io___1102 = { 0, 0, 0, 0, 0 };
    static cilist io___1104 = { 0, 0, 0, 0, 0 };
    static cilist io___1105 = { 0, 0, 0, 0, 0 };
    static cilist io___1106 = { 0, 0, 0, 0, 0 };
    static cilist io___1107 = { 0, 0, 0, 0, 0 };
    static cilist io___1108 = { 0, 0, 0, 0, 0 };
    static cilist io___1109 = { 0, 0, 0, 0, 0 };
    static cilist io___1115 = { 0, 0, 0, 0, 0 };
    static cilist io___1116 = { 0, 0, 0, 0, 0 };
    static cilist io___1117 = { 0, 0, 0, 0, 0 };
    static cilist io___1118 = { 0, 0, 0, 0, 0 };
    static cilist io___1119 = { 0, 0, 0, 0, 0 };
    static cilist io___1120 = { 0, 0, 0, 0, 0 };
    static cilist io___1124 = { 0, 0, 0, 0, 0 };
    static cilist io___1125 = { 0, 0, 0, 0, 0 };
    static cilist io___1127 = { 0, 0, 0, 0, 0 };
    static cilist io___1129 = { 0, 0, 0, 0, 0 };
    static cilist io___1132 = { 0, 0, 0, 0, 0 };
    static cilist io___1133 = { 0, 3, 0, fmt_16, 0 };
    static cilist io___1134 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___1135 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___1136 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___1137 = { 0, 3, 0, fmt_18, 0 };
    static cilist io___1138 = { 0, 3, 0, fmt_19, 0 };
    static cilist io___1139 = { 0, 3, 0, fmt_20, 0 };
    static cilist io___1141 = { 0, 3, 0, fmt_21, 0 };
    static cilist io___1142 = { 0, 3, 0, fmt_22, 0 };
    static cilist io___1143 = { 0, 3, 0, fmt_23, 0 };
    static cilist io___1144 = { 0, 3, 0, fmt_27, 0 };
    static cilist io___1145 = { 0, 3, 0, fmt_28, 0 };
    static cilist io___1146 = { 0, 3, 0, fmt_24, 0 };
    static cilist io___1147 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___1148 = { 0, 3, 0, fmt_15, 0 };
    static cilist io___1149 = { 0, 3, 0, fmt_17, 0 };
    static cilist io___1150 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___1151 = { 0, 3, 0, fmt_14, 0 };
    static cilist io___1152 = { 0, 3, 0, fmt_16, 0 };
    static cilist io___1153 = { 0, 3, 0, fmt_25, 0 };
    static cilist io___1154 = { 0, 3, 0, fmt_26, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GFIL reads the N.G.F. file written by a previous solution. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

/* *** */
    s_copy(ngffil, filnam, (ftnlen)80, filnam_len);
    if (s_cmp(filnam, " ", filnam_len, (ftnlen)1) == 0) {
	s_copy(ngffil, "NGFD.NEC", (ftnlen)80, (ftnlen)8);
    }
    o__1.oerr = 0;
    o__1.ounit = igfl;
    o__1.ofnmlen = 80;
    o__1.ofnm = ngffil;
    o__1.orl = 0;
    o__1.osta = "OLD";
    o__1.oacc = 0;
    o__1.ofm = "UNFORMATTED";
    o__1.oblnk = 0;
    f_open(&o__1);
    al__1.aerr = 0;
    al__1.aunit = igfl;
    f_rew(&al__1);
    io___1101.ciunit = igfl;
    s_rsue(&io___1101);
    do_uio(&c__1, (char *)&data_1.n1, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.np, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.m1, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.mp, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&frqdat_1.fmhzs, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&data_1.ipsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.ksymp, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.iperf, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.nradl, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&setgn_1.geps, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.gsig, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.ueps, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.usig, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&gnd_1.scnrad, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&gnd_1.scnwrd, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&zload_1.nlodf, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&inscom_1.ninsf, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&ninfo_1.kcom, (ftnlen)sizeof(integer));
    e_rsue();
    data_1.n = data_1.n1;
    data_1.m = data_1.m1;
    data_1.n2 = data_1.n1 + 1;
    data_1.m2 = data_1.m1 + 1;
    if (data_1.n1 > 0) {

/*        READ SEG. DATA AND CONVERT BACK TO END COORD. */
	io___1102.ciunit = igfl;
	s_rsue(&io___1102);
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.n1;
	for (i__ = 1; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1104.ciunit = igfl;
	s_rsue(&io___1104);
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.n1;
	for (i__ = 1; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1105.ciunit = igfl;
	s_rsue(&io___1105);
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.salp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1106.ciunit = igfl;
	s_rsue(&io___1106);
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.icon1[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	i__2 = data_1.n1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.icon2[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	e_rsue();
	io___1107.ciunit = igfl;
	s_rsue(&io___1107);
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.itag[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	e_rsue();
	if (zload_1.nlodf != 0) {
	    io___1108.ciunit = igfl;
	    s_rsue(&io___1108);
	    i__1 = data_1.n1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		do_uio(&c__2, (char *)&zload_1.zarray[i__ - 1], (ftnlen)
			sizeof(doublereal));
	    }
	    e_rsue();
	}
	if (inscom_1.ninsf != 0) {
	    io___1109.ciunit = igfl;
	    s_rsue(&io___1109);
	    i__1 = data_1.n1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		do_uio(&c__2, (char *)&inscom_1.ceins[i__ - 1], (ftnlen)
			sizeof(doublereal));
		do_uio(&c__1, (char *)&inscom_1.brins[i__ - 1], (ftnlen)
			sizeof(doublereal));
	    }
	    e_rsue();
	}
	i__1 = data_1.n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    xi = data_1.x[i__ - 1];
	    yi = data_1.y[i__ - 1];
	    zi = data_1.z__[i__ - 1];
	    dx = data_1.si[i__ - 1] * .5f;
	    data_1.x[i__ - 1] = xi - data_1.alp[i__ - 1] * dx;
	    data_1.y[i__ - 1] = yi - data_1.bet[i__ - 1] * dx;
	    data_1.z__[i__ - 1] = zi - data_1.salp[i__ - 1] * dx;
	    data_1.si[i__ - 1] = xi + data_1.alp[i__ - 1] * dx;
	    data_1.alp[i__ - 1] = yi + data_1.bet[i__ - 1] * dx;
	    data_1.bet[i__ - 1] = zi + data_1.salp[i__ - 1] * dx;
/* L1: */
	}
    }
    if (data_1.m1 > 0) {
	j = data_1.ld - data_1.m1 + 1;

/*        READ PATCH DATA */
	io___1115.ciunit = igfl;
	s_rsue(&io___1115);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.ld;
	for (i__ = j; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1116.ciunit = igfl;
	s_rsue(&io___1116);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.ld;
	for (i__ = j; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1117.ciunit = igfl;
	s_rsue(&io___1117);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.salp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1118.ciunit = igfl;
	s_rsue(&io___1118);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1119.ciunit = igfl;
	s_rsue(&io___1119);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2z[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
    }
    io___1120.ciunit = igfl;
    s_rsue(&io___1120);
    do_uio(&c__1, (char *)&matpar_1.icase, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nbloks, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.npblk, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nlast, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nblsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.npsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nlsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.imat, (ftnlen)sizeof(integer));
    e_rsue();
    if (gnd_1.iperf == 2) {
	d__1 = -setgn_1.gsig / (constn_1.tp * frqdat_1.fmhzs * 1e6f * 
		constn_1.epsrz);
	z__1.r = setgn_1.geps, z__1.i = d__1;
	epsc.r = z__1.r, epsc.i = z__1.i;
	gndino_(&epsc, &igfl);
    }
    cmb_1.neq = data_1.n1 + (data_1.m1 << 1);
    npeq = data_1.np + (data_1.mp << 1);
    nop = cmb_1.neq / npeq;
    if (nop > 1) {
	io___1124.ciunit = igfl;
	s_rsue(&io___1124);
	i__1 = nop;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = nop;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		do_uio(&c__2, (char *)&smat_1.ssx[i__ + j * 20 - 21], (ftnlen)
			sizeof(doublereal));
	    }
	}
	e_rsue();
    }
    io___1125.ciunit = igfl;
    s_rsue(&io___1125);
    i__2 = cmb_1.neq;
    for (i__ = 1; i__ <= i__2; ++i__) {
	do_uio(&c__1, (char *)&cmb_1.ip[i__ - 1], (ftnlen)sizeof(integer));
    }
    do_uio(&c__5, ninfo_1.comin, (ftnlen)78);
    e_rsue();

/*     READ MATRIX A AND WRITE TAPE11 FOR OUT OF CORE */

    if (matpar_1.icase <= 2) {
	iout = cmb_1.neq * npeq;
	io___1127.ciunit = igfl;
	s_rsue(&io___1127);
	i__2 = iout;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__2, (char *)&cmb_1.cm[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
    } else if (matpar_1.icase == 4) {
	iout = npeq * npeq;
	cl__1.cerr = 1;
	cl__1.cunit = 11;
	cl__1.csta = "DELETE";
	i__2 = f_clos(&cl__1);
	if (i__2 != 0) {
	    goto L2;
	}
L2:
	daopen_(&c__11, "TAPE11.NEC", "unknown", "DELETE", &iout, (ftnlen)10, 
		(ftnlen)7, (ftnlen)6);
	i__2 = nop;
	for (k = 1; k <= i__2; ++k) {
	    io___1129.ciunit = igfl;
	    s_rsue(&io___1129);
	    i__1 = iout;
	    for (j = 1; j <= i__1; ++j) {
		do_uio(&c__2, (char *)&cmb_1.cm[j - 1], (ftnlen)sizeof(
			doublereal));
	    }
	    e_rsue();
/* L6: */
	    recot_(cmb_1.cm, &c__11, &c__1, &iout, &k, "Write for ICASE=4 in"
		    " GFIL", (ftnlen)25);
	}
    } else {
	iout = matpar_1.npsym * npeq;
	cl__1.cerr = 1;
	cl__1.cunit = 11;
	cl__1.csta = "DELETE";
	i__2 = f_clos(&cl__1);
	if (i__2 != 0) {
	    goto L3;
	}
L3:
	daopen_(&c__11, "TAPE11.NEC", "unknown", "DELETE", &iout, (ftnlen)10, 
		(ftnlen)7, (ftnlen)6);
	irec = 0;
	i__2 = nop;
	for (iop = 1; iop <= i__2; ++iop) {
	    i__1 = matpar_1.nblsym;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		++irec;
		io___1132.ciunit = igfl;
		s_rsue(&io___1132);
		i__3 = iout;
		for (j = 1; j <= i__3; ++j) {
		    do_uio(&c__2, (char *)&cmb_1.cm[j - 1], (ftnlen)sizeof(
			    doublereal));
		}
		e_rsue();
/* L8: */
		recot_(cmb_1.cm, &c__11, &c__1, &iout, &irec, "Write for ICA"
			"SE=5 in GFIL", (ftnlen)25);
	    }
	}
    }
    al__1.aerr = 0;
    al__1.aunit = igfl;
    f_rew(&al__1);

/*     PRINT N.G.F. HEADING */

    s_wsfe(&io___1133);
    e_wsfe();
    s_wsfe(&io___1134);
    e_wsfe();
    s_wsfe(&io___1135);
    e_wsfe();
    s_wsfe(&io___1136);
    e_wsfe();
    s_wsfe(&io___1137);
    do_fio(&c__1, filnam, (ftnlen)47);
    do_fio(&c__1, (char *)&data_1.n1, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&data_1.m1, (ftnlen)sizeof(integer));
    e_wsfe();
    if (nop > 1) {
	s_wsfe(&io___1138);
	do_fio(&c__1, (char *)&nop, (ftnlen)sizeof(integer));
	e_wsfe();
    }
    s_wsfe(&io___1139);
    do_fio(&c__1, (char *)&matpar_1.imat, (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&matpar_1.icase, (ftnlen)sizeof(integer));
    e_wsfe();
    if (matpar_1.icase > 2) {
	nbl2 = cmb_1.neq * npeq;
	s_wsfe(&io___1141);
	do_fio(&c__1, (char *)&nbl2, (ftnlen)sizeof(integer));
	e_wsfe();
    }
    s_wsfe(&io___1142);
    do_fio(&c__1, (char *)&frqdat_1.fmhzs, (ftnlen)sizeof(doublereal));
    e_wsfe();
    if (gnd_1.ksymp == 2 && gnd_1.iperf == 1) {
	s_wsfe(&io___1143);
	e_wsfe();
    }
    if (gnd_1.ksymp == 2 && gnd_1.iperf == 0) {
	s_wsfe(&io___1144);
	e_wsfe();
    }
    if (gnd_1.ksymp == 2 && gnd_1.iperf == 2) {
	s_wsfe(&io___1145);
	e_wsfe();
    }
    if (gnd_1.ksymp == 2 && gnd_1.iperf != 1) {
	s_wsfe(&io___1146);
	do_fio(&c__1, (char *)&setgn_1.geps, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&setgn_1.gsig, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    s_wsfe(&io___1147);
    e_wsfe();
    i__1 = ninfo_1.kcom;
    for (j = 1; j <= i__1; ++j) {
/* L12: */
	s_wsfe(&io___1148);
	do_fio(&c__1, ninfo_1.comin + (j - 1) * 78, (ftnlen)78);
	e_wsfe();
    }
    s_wsfe(&io___1149);
    e_wsfe();
    s_wsfe(&io___1150);
    e_wsfe();
    s_wsfe(&io___1151);
    e_wsfe();
    s_wsfe(&io___1152);
    e_wsfe();
    if (*iprt == 0) {
	return 0;
    }
    s_wsfe(&io___1153);
    e_wsfe();
    i__1 = data_1.n1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L13: */
	s_wsfe(&io___1154);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_fio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_fio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	do_fio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	e_wsfe();
    }
    return 0;

} /* gfil_ */

/* Subroutine */ int gfout_(char *filnam, ftnlen filnam_len)
{
    /* Initialized data */

    static integer igfl = 20;

    /* Format strings */
    static char fmt_13[] = "(///,\002 ****NUMERICAL GREEN'S FUNCTION WRITTEN"
	    " ON FILE \002,a,/,5x,\002MATRIX STORAGE -\002,i7,\002 COMPLEX NU"
	    "MBERS\002,///)";

    /* System generated locals */
    integer i__1, i__2, i__3;
    olist o__1;
    alist al__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen), f_open(olist *), s_wsue(
	    cilist *), do_uio(integer *, char *, ftnlen), e_wsue(void), f_rew(
	    alist *), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void);

    /* Local variables */
    static integer i__, j, k, iop, nop, irec, npeq, iout;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static char ngffil[80];
    extern /* Subroutine */ int gndout_(integer *);

    /* Fortran I/O blocks */
    static cilist io___1159 = { 0, 0, 0, 0, 0 };
    static cilist io___1160 = { 0, 0, 0, 0, 0 };
    static cilist io___1162 = { 0, 0, 0, 0, 0 };
    static cilist io___1163 = { 0, 0, 0, 0, 0 };
    static cilist io___1164 = { 0, 0, 0, 0, 0 };
    static cilist io___1165 = { 0, 0, 0, 0, 0 };
    static cilist io___1166 = { 0, 0, 0, 0, 0 };
    static cilist io___1167 = { 0, 0, 0, 0, 0 };
    static cilist io___1169 = { 0, 0, 0, 0, 0 };
    static cilist io___1170 = { 0, 0, 0, 0, 0 };
    static cilist io___1171 = { 0, 0, 0, 0, 0 };
    static cilist io___1172 = { 0, 0, 0, 0, 0 };
    static cilist io___1173 = { 0, 0, 0, 0, 0 };
    static cilist io___1174 = { 0, 0, 0, 0, 0 };
    static cilist io___1175 = { 0, 0, 0, 0, 0 };
    static cilist io___1176 = { 0, 0, 0, 0, 0 };
    static cilist io___1178 = { 0, 0, 0, 0, 0 };
    static cilist io___1180 = { 0, 0, 0, 0, 0 };
    static cilist io___1182 = { 0, 0, 0, 0, 0 };
    static cilist io___1184 = { 0, 0, 0, 0, 0 };
    static cilist io___1185 = { 0, 3, 0, fmt_13, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GFOUT writes a N.G.F. file. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    s_copy(ngffil, filnam, (ftnlen)80, filnam_len);
    if (s_cmp(filnam, " ", filnam_len, (ftnlen)1) == 0) {
	s_copy(ngffil, "NGFD.NEC", (ftnlen)80, (ftnlen)8);
    }
    o__1.oerr = 0;
    o__1.ounit = igfl;
    o__1.ofnmlen = 80;
    o__1.ofnm = ngffil;
    o__1.orl = 0;
    o__1.osta = "unknown";
    o__1.oacc = 0;
    o__1.ofm = "UNFORMATTED";
    o__1.oblnk = 0;
    f_open(&o__1);
    cmb_1.neq = data_1.n + (data_1.m << 1);
    npeq = data_1.np + (data_1.mp << 1);
    nop = cmb_1.neq / npeq;
    io___1159.ciunit = igfl;
    s_wsue(&io___1159);
    do_uio(&c__1, (char *)&data_1.n, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.np, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.m, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&data_1.mp, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&frqdat_1.fmhz, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&data_1.ipsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.ksymp, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.iperf, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&gnd_1.nradl, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&setgn_1.geps, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.gsig, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.ueps, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&setgn_1.usig, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&gnd_1.scnrad, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&gnd_1.scnwrd, (ftnlen)sizeof(doublereal));
    do_uio(&c__1, (char *)&zload_1.nload, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&inscom_1.nins, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&ninfo_1.kcom, (ftnlen)sizeof(integer));
    e_wsue();
    if (data_1.n > 0) {
	io___1160.ciunit = igfl;
	s_wsue(&io___1160);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.n;
	for (i__ = 1; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1162.ciunit = igfl;
	s_wsue(&io___1162);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.n;
	for (i__ = 1; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1163.ciunit = igfl;
	s_wsue(&io___1163);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.salp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1164.ciunit = igfl;
	s_wsue(&io___1164);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.icon1[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	i__2 = data_1.n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.icon2[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	e_wsue();
	io___1165.ciunit = igfl;
	s_wsue(&io___1165);
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.itag[i__ - 1], (ftnlen)sizeof(
		    integer));
	}
	e_wsue();
	if (zload_1.nload > 0) {
	    io___1166.ciunit = igfl;
	    s_wsue(&io___1166);
	    i__1 = data_1.n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		do_uio(&c__2, (char *)&zload_1.zarray[i__ - 1], (ftnlen)
			sizeof(doublereal));
	    }
	    e_wsue();
	}
	if (inscom_1.nins > 0) {
	    io___1167.ciunit = igfl;
	    s_wsue(&io___1167);
	    i__1 = data_1.n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		do_uio(&c__2, (char *)&inscom_1.ceins[i__ - 1], (ftnlen)
			sizeof(doublereal));
		do_uio(&c__1, (char *)&inscom_1.brins[i__ - 1], (ftnlen)
			sizeof(doublereal));
	    }
	    e_wsue();
	}
    }
    if (data_1.m > 0) {
	j = data_1.ld - data_1.m + 1;
	io___1169.ciunit = igfl;
	s_wsue(&io___1169);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.ld;
	for (i__ = j; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.z__[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1170.ciunit = igfl;
	s_wsue(&io___1170);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__3 = data_1.ld;
	for (i__ = j; i__ <= i__3; ++i__) {
	    do_uio(&c__1, (char *)&data_1.alp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1171.ciunit = igfl;
	s_wsue(&io___1171);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.bet[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.salp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1172.ciunit = igfl;
	s_wsue(&io___1172);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2x[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	i__2 = data_1.ld;
	for (i__ = j; i__ <= i__2; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2y[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
	io___1173.ciunit = igfl;
	s_wsue(&io___1173);
	i__1 = data_1.ld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    do_uio(&c__1, (char *)&data_1.t2z[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
    }
    io___1174.ciunit = igfl;
    s_wsue(&io___1174);
    do_uio(&c__1, (char *)&matpar_1.icase, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nbloks, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.npblk, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nlast, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nblsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.npsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.nlsym, (ftnlen)sizeof(integer));
    do_uio(&c__1, (char *)&matpar_1.imat, (ftnlen)sizeof(integer));
    e_wsue();
    if (gnd_1.iperf == 2) {
	gndout_(&igfl);
    }
    if (nop > 1) {
	io___1175.ciunit = igfl;
	s_wsue(&io___1175);
	i__1 = nop;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = nop;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		do_uio(&c__2, (char *)&smat_1.ssx[i__ + j * 20 - 21], (ftnlen)
			sizeof(doublereal));
	    }
	}
	e_wsue();
    }
    io___1176.ciunit = igfl;
    s_wsue(&io___1176);
    i__2 = cmb_1.neq;
    for (i__ = 1; i__ <= i__2; ++i__) {
	do_uio(&c__1, (char *)&cmb_1.ip[i__ - 1], (ftnlen)sizeof(integer));
    }
    do_uio(&c__5, ninfo_1.comin, (ftnlen)78);
    e_wsue();
    if (matpar_1.icase <= 2) {
	iout = cmb_1.neq * npeq;
	io___1178.ciunit = igfl;
	s_wsue(&io___1178);
	i__2 = iout;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    do_uio(&c__2, (char *)&cmb_1.cm[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_wsue();
    } else if (matpar_1.icase == 3) {
	iout = matpar_1.npblk * cmb_1.neq;
	i__2 = matpar_1.nbloks;
	for (irec = 1; irec <= i__2; ++irec) {
	    recin_(cmb_1.cm, &c__11, &c__1, &iout, &irec, "Read for ICASE=3 "
		    "in GFOUT", (ftnlen)25);
/* L6: */
	    io___1180.ciunit = igfl;
	    s_wsue(&io___1180);
	    i__1 = iout;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		do_uio(&c__2, (char *)&cmb_1.cm[i__ - 1], (ftnlen)sizeof(
			doublereal));
	    }
	    e_wsue();
	}
    } else if (matpar_1.icase == 4) {
	iout = npeq * npeq;
	i__1 = nop;
	for (k = 1; k <= i__1; ++k) {
	    recin_(cmb_1.cm, &c__11, &c__1, &iout, &k, "Read for ICASE=4 in "
		    "GFOUT", (ftnlen)25);
/* L4: */
	    io___1182.ciunit = igfl;
	    s_wsue(&io___1182);
	    i__2 = iout;
	    for (j = 1; j <= i__2; ++j) {
		do_uio(&c__2, (char *)&cmb_1.cm[j - 1], (ftnlen)sizeof(
			doublereal));
	    }
	    e_wsue();
	}
    } else if (matpar_1.icase == 5) {
	iout = matpar_1.npsym * npeq;
	irec = 0;
	i__2 = nop;
	for (iop = 1; iop <= i__2; ++iop) {
	    i__1 = matpar_1.nblsym;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		++irec;
		recin_(cmb_1.cm, &c__11, &c__1, &iout, &irec, "Read for ICAS"
			"E=5 in GFOUT", (ftnlen)25);
/* L9: */
		io___1184.ciunit = igfl;
		s_wsue(&io___1184);
		i__3 = iout;
		for (j = 1; j <= i__3; ++j) {
		    do_uio(&c__2, (char *)&cmb_1.cm[j - 1], (ftnlen)sizeof(
			    doublereal));
		}
		e_wsue();
	    }
/* L11: */
	}
    }
    al__1.aerr = 0;
    al__1.aunit = igfl;
    f_rew(&al__1);
    s_wsfe(&io___1185);
    do_fio(&c__1, ngffil, (ftnlen)70);
    do_fio(&c__1, (char *)&matpar_1.imat, (ftnlen)sizeof(integer));
    e_wsfe();
    return 0;

} /* gfout_ */

/* Subroutine */ int gh_(doublereal *z__, doublecomplex *rkj)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r__, rs;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GH evaluates the integrand for H field of a wire. */

    rs = *z__ - tmh_1.zp;
    rs = tmh_1.rh2 + rs * rs;
    r__ = sqrt(rs);
    z__1.r = r__ * tmh_1.xkj.r, z__1.i = r__ * tmh_1.xkj.i;
    rkj->r = z__1.r, rkj->i = z__1.i;
    z__3.r = rkj->r + 1.f, z__3.i = rkj->i;
    z__5.r = -rkj->r, z__5.i = -rkj->i;
    z_exp(&z__4, &z__5);
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    d__1 = rs * r__;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    rkj->r = z__1.r, rkj->i = z__1.i;
    return 0;
} /* gh_ */

/* Subroutine */ int gndef_(doublereal *rhox, doublereal *zsx, doublereal *
	zox, integer *idirx, doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex ck, dph, drh, dzh, rph, sav, drv, rrh;
    static integer irt;
    static doublecomplex dzv, rzh, rrv, rzv;
    static integer ireg;
    extern /* Subroutine */ int gfdir_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    ), geasy_(doublereal *, doublereal *, doublereal *, doublecomplex 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *), trxfld_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GNDEF returns the field at RHO,ZO due to a source at ZS on */
/*     the Z axis.  Any positions of source and observer with respect */
/*     to the interface are allowed.  Asymptotic approx. is used for */
/*     points outside of the interpolation/l.s. approximation region. */

/*     IRT=1 FOR SOURCE Z .LT. 0., OBS Z .GE. 0. */
/*     IRT=2 FOR SOURCE Z .GE. 0., OBS Z .LT. 0. */
/*     IRT=3/4 FOR REFLECTED FIELD ABOVE/BELOW GROUND */
    gnrzz_1.rho = *rhox;
    gnrzz_1.zs = *zsx;
    gnrzz_1.zo = *zox;
    if (gnrzz_1.zs >= 0.f) {
	goto L1;
    }
    if (gnrzz_1.zo >= 0.f) {
	irt = 1;
    }
    if (gnrzz_1.zo < 0.f) {
	irt = 4;
    }
    goto L2;
L1:
    if (gnrzz_1.zo >= 0.f) {
	irt = 3;
    }
    if (gnrzz_1.zo < 0.f) {
	irt = 2;
    }
L2:
    switch (irt) {
	case 1:  goto L3;
	case 2:  goto L4;
	case 3:  goto L5;
	case 4:  goto L6;
    }
L3:
    gnrzz_1.zz = gnrzz_1.zo;
    gnrzz_1.zzp = gnrzz_1.zs;
    goto L7;
L4:
    gnrzz_1.zz = gnrzz_1.zs;
    gnrzz_1.zzp = gnrzz_1.zo;
    goto L7;
L5:
    gnrzz_1.zz = gnrzz_1.zs + gnrzz_1.zo;
    gnrzz_1.zzp = 0.f;
    ck.r = gnrzz_1.ck2.r, ck.i = gnrzz_1.ck2.i;
    goto L7;
L6:
    gnrzz_1.zz = 0.f;
    gnrzz_1.zzp = gnrzz_1.zs + gnrzz_1.zo;
    ck.r = gnrzz_1.ck1.r, ck.i = gnrzz_1.ck1.i;
L7:
    gnrzz_1.azp = -gnrzz_1.zzp;

/*     SOMMERFELD TERM,  CHOICE OF INTERPOLATION/L.S. APPROX. OR */
/*     ASYMPTOTIC APPROX. */
    if (glock_1.iglock == 2) {
	goto L15;
    }
    if (glock_1.iglock == 3) {
	goto L8;
    }
    if (*idirx == -1) {
	goto L8;
    }
    if (gnrzz_1.rho > gregon_1.rhmx2) {
	goto L8;
    }
    if (gnrzz_1.zz > gregon_1.zzmx2) {
	goto L8;
    }
    if (-gnrzz_1.zzp > gregon_1.zpmxx) {
	goto L8;
    }
    if (-gnrzz_1.zzp > gregon_1.zpmx2 && gnrzz_1.rho > gregon_1.elm) {
	goto L8;
    }
L15:
    ireg = 0;
    gnrzz_1.icase = 3;
    trxfld_(erv, ezv, erh, eph, ezh, &ireg);
    if (glock_1.iglock == 1) {
	glock_1.iglock = 2;
    }
    goto L9;
L8:
    geasy_(&gnrzz_1.rho, &gnrzz_1.zz, &gnrzz_1.zzp, erv, ezv, erh, eph, ezh);
    if (glock_1.iglock == 1) {
	glock_1.iglock = 3;
    }
L9:
    switch (irt) {
	case 1:  goto L11;
	case 2:  goto L10;
	case 3:  goto L12;
	case 4:  goto L12;
    }
L10:
    sav.r = erv->r, sav.i = erv->i;
    z__1.r = -ezh->r, z__1.i = -ezh->i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = -sav.r, z__1.i = -sav.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
L11:
    return 0;

/*     IMAGE TERM FOR REFLECTED FIELD */
L12:
    d__1 = -gnrzz_1.zo;
    gfdir_(&gnrzz_1.rho, &gnrzz_1.zs, &d__1, &gnrzz_1.ck2, &ck, &rrv, &rzv, &
	    rrh, &rph, &rzh);
    if (*idirx == 1) {
	goto L13;
    }

/*     DIRECT FIELD TERM IF IDIRX.NE.1 */
    gfdir_(&gnrzz_1.rho, &gnrzz_1.zs, &gnrzz_1.zo, &gnrzz_1.ck2, &ck, &drv, &
	    dzv, &drh, &dph, &dzh);
    z__1.r = rrv.r - drv.r, z__1.i = rrv.i - drv.i;
    rrv.r = z__1.r, rrv.i = z__1.i;
    z__1.r = rzv.r - dzv.r, z__1.i = rzv.i - dzv.i;
    rzv.r = z__1.r, rzv.i = z__1.i;
    z__1.r = rrh.r - drh.r, z__1.i = rrh.i - drh.i;
    rrh.r = z__1.r, rrh.i = z__1.i;
    z__1.r = rph.r - dph.r, z__1.i = rph.i - dph.i;
    rph.r = z__1.r, rph.i = z__1.i;
    z__1.r = rzh.r - dzh.r, z__1.i = rzh.i - dzh.i;
    rzh.r = z__1.r, rzh.i = z__1.i;
L13:
    if (irt == 4) {
	goto L14;
    }
    sav.r = erv->r, sav.i = erv->i;
    z__2.r = -ezh->r, z__2.i = -ezh->i;
    z__1.r = z__2.r - rrv.r, z__1.i = z__2.i - rrv.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__2.r = gnrzz_1.epsc1.r * ezv->r - gnrzz_1.epsc1.i * ezv->i, z__2.i = 
	    gnrzz_1.epsc1.r * ezv->i + gnrzz_1.epsc1.i * ezv->r;
    z__1.r = z__2.r - rzv.r, z__1.i = z__2.i - rzv.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__1.r = erh->r - rrh.r, z__1.i = erh->i - rrh.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = eph->r - rph.r, z__1.i = eph->i - rph.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__3.r = -gnrzz_1.epsc1.r, z__3.i = -gnrzz_1.epsc1.i;
    z__2.r = z__3.r * sav.r - z__3.i * sav.i, z__2.i = z__3.r * sav.i + 
	    z__3.i * sav.r;
    z__1.r = z__2.r - rzh.r, z__1.i = z__2.i - rzh.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L14:
    z__1.r = erv->r - rrv.r, z__1.i = erv->i - rrv.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z_div(&z__2, ezv, &gnrzz_1.epsc1);
    z__1.r = z__2.r - rzv.r, z__1.i = z__2.i - rzv.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__1.r = erh->r - rrh.r, z__1.i = erh->i - rrh.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = eph->r - rph.r, z__1.i = eph->i - rph.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z_div(&z__2, ezh, &gnrzz_1.epsc1);
    z__1.r = z__2.r - rzh.r, z__1.i = z__2.i - rzh.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
} /* gndef_ */

/* Subroutine */ int gndnew_(integer *ifln, char *somfix, ftnlen somfix_len)
{
    /* Format strings */
    static char fmt_90[] = "(\002 GNDNEW: ERROR OPENING FILE FOR OUTPUT: "
	    "\002,a)";

    /* System generated locals */
    integer i__1;
    olist o__1;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *), f_open(olist *), s_wsfe(cilist *), do_fio(
	    integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int gndout_(integer *);

    /* Fortran I/O blocks */
    static cilist io___1202 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GNDNEW opens a file for writing the Sommerfeld integral tables */
/*     and calls GNDOUT to write the file. */

    cl__1.cerr = 1;
    cl__1.cunit = *ifln;
    cl__1.csta = 0;
    i__1 = f_clos(&cl__1);
    if (i__1 != 0) {
	goto L1;
    }
L1:
    o__1.oerr = 1;
    o__1.ounit = *ifln;
    o__1.ofnmlen = somfix_len;
    o__1.ofnm = somfix;
    o__1.orl = 0;
    o__1.osta = "unknown";
    o__1.oacc = 0;
    o__1.ofm = "UNFORMATTED";
    o__1.oblnk = 0;
    i__1 = f_open(&o__1);
    if (i__1 != 0) {
	goto L2;
    }
    gndout_(ifln);
    cl__1.cerr = 0;
    cl__1.cunit = *ifln;
    cl__1.csta = 0;
    f_clos(&cl__1);
    return 0;
L2:
    s_wsfe(&io___1202);
    do_fio(&c__1, somfix, somfix_len);
    e_wsfe();
    s_stop("", (ftnlen)0);

    return 0;
} /* gndnew_ */

/* Subroutine */ int gndino_(doublecomplex *epsxx, integer *ifln)
{
    /* Initialized data */

    static doublereal pi = 3.141592654;

    /* Format strings */
    static char fmt_90[] = "(/,\002 GNDINO: UNABLE TO OPEN FILE \002,a)";
    static char fmt_93[] = "(\002 WILL COMPUTE SOMMERFELD-GROUND TABLES\002)";
    static char fmt_91[] = "(/,\002 GNDINO: EPSC FROM FILE =\002,1p2e12.5,/,"
	    "14x,\002SHOULD BE \002,2e12.5)";
    static char fmt_92[] = "(\002 GNDINO: ERROR READING SOMNTX FILE\002)";

    /* System generated locals */
    address a__1[3];
    integer i__1[3], i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3;
    olist o__1;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);
    integer i_indx(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer f_open(olist *), s_wsfe(cilist *), e_wsfe(void), s_cmp(char *, 
	    char *, ftnlen, ftnlen), s_rsue(cilist *), do_uio(integer *, char 
	    *, ftnlen), e_rsue(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void z_sqrt(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, ir, ix, iblk, idot;
    static char fsuf[10], fnum[5];
    static integer mfun, npts;
    extern /* Subroutine */ int gndnew_(integer *, char *, ftnlen);
    static char somfix[40];
    extern /* Subroutine */ int somntx_(doublecomplex *, integer *);

    /* Fortran I/O blocks */
    static icilist io___1208 = { 0, fnum, 0, "(I5)", 5, 1 };
    static cilist io___1211 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___1212 = { 0, 3, 0, fmt_93, 0 };
    static cilist io___1213 = { 0, 0, 0, 0, 0 };
    static cilist io___1214 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___1215 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___1216 = { 0, 3, 0, fmt_93, 0 };
    static cilist io___1218 = { 0, 0, 0, 0, 0 };
    static cilist io___1219 = { 0, 0, 0, 0, 0 };
    static cilist io___1220 = { 0, 0, 0, 0, 0 };
    static cilist io___1221 = { 0, 0, 0, 0, 0 };
    static cilist io___1222 = { 0, 0, 0, 0, 0 };
    static cilist io___1225 = { 0, 0, 0, 0, 0 };
    static cilist io___1226 = { 0, 0, 0, 0, 0 };
    static cilist io___1227 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___1229 = { 0, 0, 0, 0, 0 };
    static cilist io___1230 = { 0, 0, 0, 0, 0 };
    static cilist io___1231 = { 0, 0, 0, 0, 0 };
    static cilist io___1232 = { 0, 0, 0, 0, 0 };
    static cilist io___1233 = { 0, 0, 0, 0, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GNDINO reads the file of interpolation tables and least-squares */
/*     approximation parameters and sets other related constants. */

/*     INPUT: */
/*     EPSXX = COMPLEX RELATIVE PERMITTIVITY OF THE GROUND */
/*     IFLN = LOGICAL UNIT NUMBER OF THE FILE TO BE READ FROM THE */
/*            SOMMERFELD GROUND FILE OR NGF FILE. */

    if (*ifln == 21) {
	z__2.r = gndcom_1.epscx.r - epsxx->r, z__2.i = gndcom_1.epscx.i - 
		epsxx->i;
	z_div(&z__1, &z__2, epsxx);
	if (z_abs(&z__1) < 1e-4f) {
	    return 0;
	}
	if (gndfil_1.nsfile > 0) {
	    idot = i_indx(gndfil_1.somfil, ".", (ftnlen)40, (ftnlen)1);
	    iblk = i_indx(gndfil_1.somfil, " ", (ftnlen)40, (ftnlen)1);
	    if (idot > 0) {
		s_copy(fsuf, gndfil_1.somfil + (idot - 1), (ftnlen)10, iblk - 
			1 - (idot - 1));
	    } else {
		s_copy(fsuf, ".NEC", (ftnlen)10, (ftnlen)4);
		idot = iblk;
	    }
	    s_wsfi(&io___1208);
	    do_fio(&c__1, (char *)&gndfil_1.nsfile, (ftnlen)sizeof(integer));
	    e_wsfi();
	    ix = 5;
	    if (gndfil_1.nsfile > 9) {
		ix = 4;
	    }
	    if (gndfil_1.nsfile > 99) {
		ix = 3;
	    }
/* Writing concatenation */
	    i__1[0] = idot - 1, a__1[0] = gndfil_1.somfil;
	    i__1[1] = 5 - (ix - 1), a__1[1] = fnum + (ix - 1);
	    i__1[2] = 10, a__1[2] = fsuf;
	    s_cat(somfix, a__1, i__1, &c__3, (ftnlen)40);
	} else {
	    s_copy(somfix, gndfil_1.somfil, (ftnlen)40, (ftnlen)40);
	}
	++gndfil_1.nsfile;
	o__1.oerr = 1;
	o__1.ounit = *ifln;
	o__1.ofnmlen = 40;
	o__1.ofnm = somfix;
	o__1.orl = 0;
	o__1.osta = "OLD";
	o__1.oacc = 0;
	o__1.ofm = "UNFORMATTED";
	o__1.oblnk = 0;
	i__2 = f_open(&o__1);
	if (i__2 != 0) {
	    goto L4;
	}
    }
    goto L1;
L4:
    s_wsfe(&io___1211);
    do_fio(&c__1, somfix, (ftnlen)40);
    e_wsfe();
    s_wsfe(&io___1212);
    e_wsfe();
    somntx_(epsxx, &c__0);
    gndcom_1.epscx.r = epsxx->r, gndcom_1.epscx.i = epsxx->i;
    gndcom_1.nreg = 3;
    if (s_cmp(gndfil_1.somfil, "NOFILE", (ftnlen)40, (ftnlen)6) != 0) {
	gndnew_(ifln, somfix, (ftnlen)40);
    }
    goto L5;

/*     READ L.S. FIT FILE */

L1:
    io___1213.ciunit = *ifln;
    s_rsue(&io___1213);
    do_uio(&c__1, (char *)&gndcom_1.nreg, (ftnlen)sizeof(integer));
    do_uio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal));
    e_rsue();
    z__2.r = gndcom_1.epscx.r - epsxx->r, z__2.i = gndcom_1.epscx.i - 
	    epsxx->i;
    z_div(&z__1, &z__2, epsxx);
    if (z_abs(&z__1) > .001f) {
	s_wsfe(&io___1214);
	do_fio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&(*epsxx), (ftnlen)sizeof(doublereal));
	e_wsfe();
	if (*ifln != 21) {
	    s_wsfe(&io___1215);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	s_wsfe(&io___1216);
	e_wsfe();
	somntx_(epsxx, &c__0);
	gndcom_1.epscx.r = epsxx->r, gndcom_1.epscx.i = epsxx->i;
	gndcom_1.nreg = 3;
	if (s_cmp(gndfil_1.somfil, "NOFILE", (ftnlen)40, (ftnlen)6) != 0) {
	    gndnew_(ifln, somfix, (ftnlen)40);
	}
    } else {
	i__2 = gndcom_1.nreg;
	for (ir = 1; ir <= i__2; ++ir) {
	    io___1218.ciunit = *ifln;
	    s_rsue(&io___1218);
	    do_uio(&c__1, (char *)&gndcom_1.xrh1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dxrh, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nxrh, (ftnlen)sizeof(integer));
	    do_uio(&c__1, (char *)&gndcom_1.xzz1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dxzz, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nxzz, (ftnlen)sizeof(integer));
	    do_uio(&c__1, (char *)&gndcom_1.xzp1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dxzp, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nxzp, (ftnlen)sizeof(integer));
	    e_rsue();
	    io___1219.ciunit = *ifln;
	    s_rsue(&io___1219);
	    do_uio(&c__1, (char *)&gndcom_1.srh1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dsrh, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nsrh, (ftnlen)sizeof(integer));
	    do_uio(&c__1, (char *)&gndcom_1.szz1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dszz, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nszz, (ftnlen)sizeof(integer));
	    do_uio(&c__1, (char *)&gndcom_1.szp1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.dszp, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.nszp, (ftnlen)sizeof(integer));
	    e_rsue();
	    io___1220.ciunit = *ifln;
	    s_rsue(&io___1220);
	    do_uio(&c__1, (char *)&gregon_1.rhoa[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_uio(&c__1, (char *)&gregon_1.rhob[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_uio(&c__1, (char *)&gregon_1.zza[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_uio(&c__1, (char *)&gregon_1.zzb[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_uio(&c__1, (char *)&gregon_1.zpa[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_uio(&c__1, (char *)&gregon_1.zpb[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    e_rsue();
	    io___1221.ciunit = *ifln;
	    s_rsue(&io___1221);
	    do_uio(&c__1, (char *)&gndcom_1.res1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.res2, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.res3, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.res4, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.res5, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.rex1, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.rex2, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.rex3, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.rex4, (ftnlen)sizeof(doublereal));
	    do_uio(&c__1, (char *)&gndcom_1.rex5, (ftnlen)sizeof(doublereal));
	    e_rsue();
	    io___1222.ciunit = *ifln;
	    s_rsue(&io___1222);
	    do_uio(&c__1, (char *)&cofit_1.mfunf[ir - 1], (ftnlen)sizeof(
		    integer));
	    do_uio(&c__1, (char *)&cofit_1.mfunc[ir - 1], (ftnlen)sizeof(
		    integer));
	    e_rsue();
	    mfun = cofit_1.mfunf[ir - 1] + cofit_1.mfunc[ir - 1];
	    i__3 = mfun;
	    for (i__ = 1; i__ <= i__3; ++i__) {
/* L2: */
		io___1225.ciunit = *ifln;
		s_rsue(&io___1225);
		do_uio(&c__2, (char *)&cofit_1.fac1[i__ + (ir << 5) - 33], (
			ftnlen)sizeof(doublereal));
		do_uio(&c__2, (char *)&cofit_1.fac2[i__ + (ir << 5) - 33], (
			ftnlen)sizeof(doublereal));
		do_uio(&c__2, (char *)&cofit_1.fac3[i__ + (ir << 5) - 33], (
			ftnlen)sizeof(doublereal));
		do_uio(&c__2, (char *)&cofit_1.fac4[i__ + (ir << 5) - 33], (
			ftnlen)sizeof(doublereal));
		do_uio(&c__2, (char *)&cofit_1.fac5[i__ + (ir << 5) - 33], (
			ftnlen)sizeof(doublereal));
		e_rsue();
	    }
/* L3: */
	}

/*        READ INTERPOLATION FILE */

	io___1226.ciunit = *ifln;
	s_rsue(&io___1226);
	do_uio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.rh1[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.zz1[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.zp1[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.drh[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.dzz[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.dzp[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.drzzp[0], (ftnlen)sizeof(doublereal));
	do_uio(&c__3, (char *)&gridy_1.nrh[0], (ftnlen)sizeof(integer));
	do_uio(&c__3, (char *)&gridy_1.nzz[0], (ftnlen)sizeof(integer));
	do_uio(&c__3, (char *)&gridy_1.nzp[0], (ftnlen)sizeof(integer));
	do_uio(&c__3, (char *)&gridy_1.npt[0], (ftnlen)sizeof(integer));
	e_rsue();
	z__2.r = gndcom_1.epscx.r - epsxx->r, z__2.i = gndcom_1.epscx.i - 
		epsxx->i;
	z_div(&z__1, &z__2, epsxx);
	if (z_abs(&z__1) > .001f) {
	    s_wsfe(&io___1227);
	    do_fio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal))
		    ;
	    do_fio(&c__2, (char *)&(*epsxx), (ftnlen)sizeof(doublereal));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	npts = gridy_1.npt[0] + gridy_1.npt[1] + gridy_1.npt[2];
	io___1229.ciunit = *ifln;
	s_rsue(&io___1229);
	i__2 = npts;
	for (ix = 1; ix <= i__2; ++ix) {
	    do_uio(&c__2, (char *)&gridy_1.a1[ix - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1230.ciunit = *ifln;
	s_rsue(&io___1230);
	i__2 = npts;
	for (ix = 1; ix <= i__2; ++ix) {
	    do_uio(&c__2, (char *)&gridy_1.a2[ix - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1231.ciunit = *ifln;
	s_rsue(&io___1231);
	i__2 = npts;
	for (ix = 1; ix <= i__2; ++ix) {
	    do_uio(&c__2, (char *)&gridy_1.a3[ix - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1232.ciunit = *ifln;
	s_rsue(&io___1232);
	i__2 = npts;
	for (ix = 1; ix <= i__2; ++ix) {
	    do_uio(&c__2, (char *)&gridy_1.a4[ix - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
	io___1233.ciunit = *ifln;
	s_rsue(&io___1233);
	i__2 = npts;
	for (ix = 1; ix <= i__2; ++ix) {
	    do_uio(&c__2, (char *)&gridy_1.a5[ix - 1], (ftnlen)sizeof(
		    doublereal));
	}
	e_rsue();
    }
L5:
    gridy_1.zpm1 = gridy_1.zp1[0] + gridy_1.dzp[0] * (gridy_1.nzp[0] - 1);
    gridy_1.zpm2 = gridy_1.zp1[1] + gridy_1.dzp[1] * (gridy_1.nzp[1] - 1);
    gridy_1.zpmm1 = gridy_1.zp1[1];
    gridy_1.zpmm2 = gridy_1.zp1[2];
    gridy_1.zpd1 = pi / (gridy_1.zpm1 - gridy_1.zpmm1);
    gridy_1.zpd2 = pi / (gridy_1.zpm2 - gridy_1.zpmm2);
    gridy_1.indi[0] = 0;
    gridy_1.indi[1] = gridy_1.npt[0];
    gridy_1.indi[2] = gridy_1.npt[0] + gridy_1.npt[1];
    d__1 = pi * 2.f;
    gnrzz_1.ck2.r = d__1, gnrzz_1.ck2.i = 0.;
    z_sqrt(&z__2, epsxx);
    z__1.r = gnrzz_1.ck2.r * z__2.r - gnrzz_1.ck2.i * z__2.i, z__1.i = 
	    gnrzz_1.ck2.r * z__2.i + gnrzz_1.ck2.i * z__2.r;
    gnrzz_1.ck1.r = z__1.r, gnrzz_1.ck1.i = z__1.i;
    z__1.r = gnrzz_1.ck1.r * gnrzz_1.ck1.r - gnrzz_1.ck1.i * gnrzz_1.ck1.i, 
	    z__1.i = gnrzz_1.ck1.r * gnrzz_1.ck1.i + gnrzz_1.ck1.i * 
	    gnrzz_1.ck1.r;
    gnrzz_1.ck1sq.r = z__1.r, gnrzz_1.ck1sq.i = z__1.i;
    z__1.r = gnrzz_1.ck2.r * gnrzz_1.ck2.r - gnrzz_1.ck2.i * gnrzz_1.ck2.i, 
	    z__1.i = gnrzz_1.ck2.r * gnrzz_1.ck2.i + gnrzz_1.ck2.i * 
	    gnrzz_1.ck2.r;
    gnrzz_1.ck2sq.r = z__1.r, gnrzz_1.ck2sq.i = z__1.i;
    z__1.r = gnrzz_1.ck1sq.r + gnrzz_1.ck2sq.r, z__1.i = gnrzz_1.ck1sq.i + 
	    gnrzz_1.ck2sq.i;
    gnrzz_1.cks12.r = z__1.r, gnrzz_1.cks12.i = z__1.i;
    gnrzz_1.con1.r = -0.f, gnrzz_1.con1.i = -188.37f;
    z__2.r = gnrzz_1.ck1sq.r - gnrzz_1.ck2sq.r, z__2.i = gnrzz_1.ck1sq.i - 
	    gnrzz_1.ck2sq.i;
    z_div(&z__1, &z__2, &gnrzz_1.cks12);
    gnrzz_1.con2.r = z__1.r, gnrzz_1.con2.i = z__1.i;
    z__2.r = gnrzz_1.ck2sq.r * gnrzz_1.con2.r - gnrzz_1.ck2sq.i * 
	    gnrzz_1.con2.i, z__2.i = gnrzz_1.ck2sq.r * gnrzz_1.con2.i + 
	    gnrzz_1.ck2sq.i * gnrzz_1.con2.r;
    z_div(&z__1, &z__2, &gnrzz_1.cks12);
    gnrzz_1.con3.r = z__1.r, gnrzz_1.con3.i = z__1.i;
    z__3.r = gnrzz_1.con1.r * 2.f, z__3.i = gnrzz_1.con1.i * 2.f;
    z__2.r = z__3.r * gnrzz_1.ck2sq.r - z__3.i * gnrzz_1.ck2sq.i, z__2.i = 
	    z__3.r * gnrzz_1.ck2sq.i + z__3.i * gnrzz_1.ck2sq.r;
    z_div(&z__1, &z__2, &gnrzz_1.cks12);
    gnrzz_1.con4.r = z__1.r, gnrzz_1.con4.i = z__1.i;
    z__1.r = gnrzz_1.ck2.r * 0.f - gnrzz_1.ck2.i * 1.f, z__1.i = 
	    gnrzz_1.ck2.r * 1.f + gnrzz_1.ck2.i * 0.f;
    gnrzz_1.xjk.r = z__1.r, gnrzz_1.xjk.i = z__1.i;
    gnrzz_1.epsc1.r = epsxx->r, gnrzz_1.epsc1.i = epsxx->i;
    z_div(&z__1, &gnrzz_1.ck2, &gnrzz_1.ck1);
    cofit_1.rkfac = z_abs(&z__1);
    gregon_1.elm = gridy_1.drh[0] * (gridy_1.nrh[0] - 1);
    gregon_1.elmx = gregon_1.elm * .95f;
/*     SET LIMITS FOR INTEGRATION AND USE OF ASYMPTOTIC.  ZPMXX ALLOWS */
/*     EXTRAPOLATION BY ONE INTERVAL (DZP). */
    gregon_1.rhmx1 = 1.f;
    gregon_1.zzmx1 = 1.f;
    gregon_1.zpmx1 = gregon_1.zpb[0];
    gregon_1.rhmx2 = 2.f;
    gregon_1.zzmx2 = 2.f;
    gregon_1.zpmx2 = gregon_1.zpb[0] * 1.2f;
    gregon_1.zpmxx = gridy_1.zp1[2] + gridy_1.dzp[2] * gridy_1.nzp[2];
    gregon_1.scfac = pi / (gregon_1.elm - gregon_1.elmx);
    return 0;

} /* gndino_ */

/* Subroutine */ int gndout_(integer *ifln)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsue(cilist *), do_uio(integer *, char *, ftnlen), e_wsue(void);

    /* Local variables */
    static integer i__, ir, ix, mfun, npts;

    /* Fortran I/O blocks */
    static cilist io___1234 = { 0, 0, 0, 0, 0 };
    static cilist io___1236 = { 0, 0, 0, 0, 0 };
    static cilist io___1237 = { 0, 0, 0, 0, 0 };
    static cilist io___1238 = { 0, 0, 0, 0, 0 };
    static cilist io___1239 = { 0, 0, 0, 0, 0 };
    static cilist io___1240 = { 0, 0, 0, 0, 0 };
    static cilist io___1243 = { 0, 0, 0, 0, 0 };
    static cilist io___1244 = { 0, 0, 0, 0, 0 };
    static cilist io___1246 = { 0, 0, 0, 0, 0 };
    static cilist io___1248 = { 0, 0, 0, 0, 0 };
    static cilist io___1249 = { 0, 0, 0, 0, 0 };
    static cilist io___1250 = { 0, 0, 0, 0, 0 };
    static cilist io___1251 = { 0, 0, 0, 0, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GNDOUT writes the Sommerfeld interpolation tables and */
/*     least-squares approximation parameters on a file using logical */
/*     unit number IFLN */


    io___1234.ciunit = *ifln;
    s_wsue(&io___1234);
    do_uio(&c__1, (char *)&gndcom_1.nreg, (ftnlen)sizeof(integer));
    do_uio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal));
    e_wsue();
    i__1 = gndcom_1.nreg;
    for (ir = 1; ir <= i__1; ++ir) {
	io___1236.ciunit = *ifln;
	s_wsue(&io___1236);
	do_uio(&c__1, (char *)&gndcom_1.xrh1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dxrh, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nxrh, (ftnlen)sizeof(integer));
	do_uio(&c__1, (char *)&gndcom_1.xzz1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dxzz, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nxzz, (ftnlen)sizeof(integer));
	do_uio(&c__1, (char *)&gndcom_1.xzp1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dxzp, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nxzp, (ftnlen)sizeof(integer));
	e_wsue();
	io___1237.ciunit = *ifln;
	s_wsue(&io___1237);
	do_uio(&c__1, (char *)&gndcom_1.srh1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dsrh, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nsrh, (ftnlen)sizeof(integer));
	do_uio(&c__1, (char *)&gndcom_1.szz1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dszz, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nszz, (ftnlen)sizeof(integer));
	do_uio(&c__1, (char *)&gndcom_1.szp1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.dszp, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.nszp, (ftnlen)sizeof(integer));
	e_wsue();
	io___1238.ciunit = *ifln;
	s_wsue(&io___1238);
	do_uio(&c__1, (char *)&gregon_1.rhoa[ir - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&gregon_1.rhob[ir - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&gregon_1.zza[ir - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&gregon_1.zzb[ir - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&gregon_1.zpa[ir - 1], (ftnlen)sizeof(
		doublereal));
	do_uio(&c__1, (char *)&gregon_1.zpb[ir - 1], (ftnlen)sizeof(
		doublereal));
	e_wsue();
	io___1239.ciunit = *ifln;
	s_wsue(&io___1239);
	do_uio(&c__1, (char *)&gndcom_1.res1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.res2, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.res3, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.res4, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.res5, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.rex1, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.rex2, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.rex3, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.rex4, (ftnlen)sizeof(doublereal));
	do_uio(&c__1, (char *)&gndcom_1.rex5, (ftnlen)sizeof(doublereal));
	e_wsue();
	io___1240.ciunit = *ifln;
	s_wsue(&io___1240);
	do_uio(&c__1, (char *)&cofit_1.mfunf[ir - 1], (ftnlen)sizeof(integer))
		;
	do_uio(&c__1, (char *)&cofit_1.mfunc[ir - 1], (ftnlen)sizeof(integer))
		;
	e_wsue();
	mfun = cofit_1.mfunf[ir - 1] + cofit_1.mfunc[ir - 1];
	i__2 = mfun;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L6: */
	    io___1243.ciunit = *ifln;
	    s_wsue(&io___1243);
	    do_uio(&c__2, (char *)&cofit_1.fac1[i__ + (ir << 5) - 33], (
		    ftnlen)sizeof(doublereal));
	    do_uio(&c__2, (char *)&cofit_1.fac2[i__ + (ir << 5) - 33], (
		    ftnlen)sizeof(doublereal));
	    do_uio(&c__2, (char *)&cofit_1.fac3[i__ + (ir << 5) - 33], (
		    ftnlen)sizeof(doublereal));
	    do_uio(&c__2, (char *)&cofit_1.fac4[i__ + (ir << 5) - 33], (
		    ftnlen)sizeof(doublereal));
	    do_uio(&c__2, (char *)&cofit_1.fac5[i__ + (ir << 5) - 33], (
		    ftnlen)sizeof(doublereal));
	    e_wsue();
	}
/* L7: */
    }
    io___1244.ciunit = *ifln;
    s_wsue(&io___1244);
    do_uio(&c__2, (char *)&gndcom_1.epscx, (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.rh1[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.zz1[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.zp1[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.drh[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.dzz[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.dzp[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.drzzp[0], (ftnlen)sizeof(doublereal));
    do_uio(&c__3, (char *)&gridy_1.nrh[0], (ftnlen)sizeof(integer));
    do_uio(&c__3, (char *)&gridy_1.nzz[0], (ftnlen)sizeof(integer));
    do_uio(&c__3, (char *)&gridy_1.nzp[0], (ftnlen)sizeof(integer));
    do_uio(&c__3, (char *)&gridy_1.npt[0], (ftnlen)sizeof(integer));
    e_wsue();
    npts = gridy_1.npt[0] + gridy_1.npt[1] + gridy_1.npt[2];
    io___1246.ciunit = *ifln;
    s_wsue(&io___1246);
    i__1 = npts;
    for (ix = 1; ix <= i__1; ++ix) {
	do_uio(&c__2, (char *)&gridy_1.a1[ix - 1], (ftnlen)sizeof(doublereal))
		;
    }
    e_wsue();
    io___1248.ciunit = *ifln;
    s_wsue(&io___1248);
    i__1 = npts;
    for (ix = 1; ix <= i__1; ++ix) {
	do_uio(&c__2, (char *)&gridy_1.a2[ix - 1], (ftnlen)sizeof(doublereal))
		;
    }
    e_wsue();
    io___1249.ciunit = *ifln;
    s_wsue(&io___1249);
    i__1 = npts;
    for (ix = 1; ix <= i__1; ++ix) {
	do_uio(&c__2, (char *)&gridy_1.a3[ix - 1], (ftnlen)sizeof(doublereal))
		;
    }
    e_wsue();
    io___1250.ciunit = *ifln;
    s_wsue(&io___1250);
    i__1 = npts;
    for (ix = 1; ix <= i__1; ++ix) {
	do_uio(&c__2, (char *)&gridy_1.a4[ix - 1], (ftnlen)sizeof(doublereal))
		;
    }
    e_wsue();
    io___1251.ciunit = *ifln;
    s_wsue(&io___1251);
    i__1 = npts;
    for (ix = 1; ix <= i__1; ++ix) {
	do_uio(&c__2, (char *)&gridy_1.a5[ix - 1], (ftnlen)sizeof(doublereal))
		;
    }
    e_wsue();
    return 0;
} /* gndout_ */

/* Subroutine */ int helix_(integer *ihlx, doublereal *turns, doublereal *
	zlen, doublereal *hrad1, doublereal *hrad2, doublereal *wrad1, 
	doublereal *wrad2, integer *ns, integer *itg)
{
    /* Initialized data */

    static doublereal tp = 6.2831853071796;

    /* Format strings */
    static char fmt_90[] = "(10x,\002TOTAL LENGTH OF WIRE IN THE SPIRAL ="
	    " \002,1pe12.5)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *), cos(doublereal), sin(
	    doublereal), sqrt(doublereal);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static integer ist;
    static doublereal sum, hfac, hrad, ahlx, tinc, thet, zhlx, thmax, radrat;
    static integer ismall;

    /* Fortran I/O blocks */
    static cilist io___1268 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     HELIX generates segment geometry data for a helix, log spiral or */
/*     Archimedes spiral.  The spiral starts on the x axis at y=z=0 and */
/*     has its axis along the z axis. */

/*     INPUT: */
/*     IHLX = 0 for a log spiral, 1 for an Archimedes spiral. */
/*     TURNS = number of turns (may be fractional), positive for a */
/*             right-hand spiral relative to the positive z axis, */
/*             negative for left-hand. */
/*     ZLEN = length of the helix or spiral along the z axis. */
/*     HRAD1 = starting radius of the spiral.  Starting point is X=HRAD1. */
/*     HRAD2 = final radius of the spiral. */
/*     WRAD1, WRAD2 = starting and final segment radius. */
/*     NS = number of segments. */
/*     ITG = tag number assigned to all segments. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ist = data_1.n + 1;
    data_1.n += *ns;
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    if (*ns < 1) {
	return 0;
    }
    d__1 = *wrad2 / *wrad1;
    d__2 = (doublereal) (1.f / (*ns - 1.f));
    radrat = pow_dd(&d__1, &d__2);
    thmax = tp * abs(*turns);
    if (*ihlx == 0) {
	d__1 = *hrad2 / *hrad1;
	d__2 = 1.f / thmax;
	ahlx = pow_dd(&d__1, &d__2);
	if ((d__1 = ahlx - 1.f, abs(d__1)) > .02f) {
	    ismall = 0;
	    hfac = *zlen / (*hrad2 / *hrad1 - 1.f);
	} else {
	    ismall = 1;
	}
    } else {
	ahlx = (*hrad2 - *hrad1) / thmax;
    }
    sum = 0.f;
    tinc = thmax / *ns;
    thet = 0.f;
    i__1 = data_1.n;
    for (i__ = ist; i__ <= i__1; ++i__) {
	thet += tinc;
	data_1.itag[i__ - 1] = *itg;
	if (i__ == ist) {
	    data_1.x[i__ - 1] = *hrad1;
	    data_1.y[i__ - 1] = 0.f;
	    data_1.z__[i__ - 1] = 0.f;
	    data_1.bi[i__ - 1] = *wrad1;
	} else {
	    data_1.x[i__ - 1] = x2[i__ - 2];
	    data_1.y[i__ - 1] = y2[i__ - 2];
	    data_1.z__[i__ - 1] = z2[i__ - 2];
	    data_1.bi[i__ - 1] = data_1.bi[i__ - 2] * radrat;
	}
	if (i__ == data_1.n) {
	    hrad = *hrad2;
	    zhlx = *zlen;
	} else {

/*     LOG SPIRAL - RADIUS AND POSITION ALONG Z AXIS */

	    if (*ihlx == 0) {
		hrad = *hrad1 * pow_dd(&ahlx, &thet);
		if (ismall == 0) {
		    zhlx = hfac * (pow_dd(&ahlx, &thet) - 1.f);
		} else {
		    zhlx = *zlen * (thet / thmax) * ((ahlx - 1.f) * .5f * (
			    thet - thmax) + 1.f);
		}
	    } else {

/*     ARCHIMEDES SPIRAL */

		hrad = *hrad1 + ahlx * thet;
		zhlx = *zlen * thet / thmax;
	    }
	}
	x2[i__ - 1] = hrad * cos(thet);
	y2[i__ - 1] = hrad * sin(thet);
	if (*turns < 0.f) {
	    y2[i__ - 1] = -y2[i__ - 1];
	}
	z2[i__ - 1] = zhlx;
/* Computing 2nd power */
	d__1 = x2[i__ - 1] - data_1.x[i__ - 1];
/* Computing 2nd power */
	d__2 = y2[i__ - 1] - data_1.y[i__ - 1];
/* Computing 2nd power */
	d__3 = z2[i__ - 1] - data_1.z__[i__ - 1];
	sum += sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
/* L1: */
    }
    s_wsfe(&io___1268);
    do_fio(&c__1, (char *)&sum, (ftnlen)sizeof(doublereal));
    e_wsfe();
    return 0;
} /* helix_ */

#undef z2
#undef y2
#undef x2


/* Subroutine */ int hintg_(doublereal *xi, doublereal *yi, doublereal *zi)
{
    /* Initialized data */

    static doublereal fpi = 12.56637062;

    /* System generated locals */
    integer i__1;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_sqrt(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static integer ip;
    static doublecomplex xk;
    static doublereal px, py, rx, ry, rz;
    static doublecomplex f1x, f1y, f1z, f2x, f2y, f2z, gam;
    static doublereal cth;
    static doublecomplex hxc, hyc, hzc;
    static doublereal rfl;
    static doublecomplex rkj, rrh;
    static doublereal rsq;
    static doublecomplex rrv;
    static doublereal t1zr, t2zr, xymag;
    static doublecomplex zrati;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     HINTG computes the H field of current on a patch. */

    if (datap_1.zpatj < 0.f) {
	goto L1;
    }
    xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
    goto L2;
L1:
    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
L2:
    rx = *xi - datap_1.xpatj;
    ry = *yi - datap_1.ypatj;
    rfl = -1.f;
    datap_1.h1x.r = 0.f, datap_1.h1x.i = 0.f;
    datap_1.h1y.r = 0.f, datap_1.h1y.i = 0.f;
    datap_1.h1z.r = 0.f, datap_1.h1z.i = 0.f;
    datap_1.h2x.r = 0.f, datap_1.h2x.i = 0.f;
    datap_1.h2y.r = 0.f, datap_1.h2y.i = 0.f;
    datap_1.h2z.r = 0.f, datap_1.h2z.i = 0.f;
    i__1 = gnd_1.ksymp;
    for (ip = 1; ip <= i__1; ++ip) {
	rfl = -rfl;
	rz = *zi - datap_1.zpatj * rfl;
	rsq = rx * rx + ry * ry + rz * rz;
	if (rsq < 1e-20f) {
	    goto L7;
	}
	r__ = sqrt(rsq);
	z__2.r = xk.r * 0.f - xk.i * 1.f, z__2.i = xk.r * 1.f + xk.i * 0.f;
	z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
	rkj.r = z__1.r, rkj.i = z__1.i;
	z__5.r = rkj.r + 1.f, z__5.i = rkj.i;
	z__4.r = -z__5.r, z__4.i = -z__5.i;
	z__7.r = -rkj.r, z__7.i = -rkj.i;
	z_exp(&z__6, &z__7);
	z__3.r = z__4.r * z__6.r - z__4.i * z__6.i, z__3.i = z__4.r * z__6.i 
		+ z__4.i * z__6.r;
	z__2.r = datap_1.spatj * z__3.r, z__2.i = datap_1.spatj * z__3.i;
	d__1 = fpi * rsq * r__;
	z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
	gam.r = z__1.r, gam.i = z__1.i;
	z__1.r = rx * gam.r, z__1.i = rx * gam.i;
	hxc.r = z__1.r, hxc.i = z__1.i;
	z__1.r = ry * gam.r, z__1.i = ry * gam.i;
	hyc.r = z__1.r, hyc.i = z__1.i;
	z__1.r = rz * gam.r, z__1.i = rz * gam.i;
	hzc.r = z__1.r, hzc.i = z__1.i;
	t1zr = datap_1.t1zj * rfl;
	t2zr = datap_1.t2zj * rfl;
	z__2.r = t1zr * hyc.r, z__2.i = t1zr * hyc.i;
	z__3.r = datap_1.t1yj * hzc.r, z__3.i = datap_1.t1yj * hzc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f1x.r = z__1.r, f1x.i = z__1.i;
	z__2.r = datap_1.t1xj * hzc.r, z__2.i = datap_1.t1xj * hzc.i;
	z__3.r = t1zr * hxc.r, z__3.i = t1zr * hxc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f1y.r = z__1.r, f1y.i = z__1.i;
	z__2.r = datap_1.t1yj * hxc.r, z__2.i = datap_1.t1yj * hxc.i;
	z__3.r = datap_1.t1xj * hyc.r, z__3.i = datap_1.t1xj * hyc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f1z.r = z__1.r, f1z.i = z__1.i;
	z__2.r = t2zr * hyc.r, z__2.i = t2zr * hyc.i;
	z__3.r = datap_1.t2yj * hzc.r, z__3.i = datap_1.t2yj * hzc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f2x.r = z__1.r, f2x.i = z__1.i;
	z__2.r = datap_1.t2xj * hzc.r, z__2.i = datap_1.t2xj * hzc.i;
	z__3.r = t2zr * hxc.r, z__3.i = t2zr * hxc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f2y.r = z__1.r, f2y.i = z__1.i;
	z__2.r = datap_1.t2yj * hxc.r, z__2.i = datap_1.t2yj * hxc.i;
	z__3.r = datap_1.t2xj * hyc.r, z__3.i = datap_1.t2xj * hyc.i;
	z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	f2z.r = z__1.r, f2z.i = z__1.i;
	if (ip == 1) {
	    goto L6;
	}
	if (gnd_1.iperf != 1) {
	    goto L3;
	}
	z__1.r = -f1x.r, z__1.i = -f1x.i;
	f1x.r = z__1.r, f1x.i = z__1.i;
	z__1.r = -f1y.r, z__1.i = -f1y.i;
	f1y.r = z__1.r, f1y.i = z__1.i;
	z__1.r = -f1z.r, z__1.i = -f1z.i;
	f1z.r = z__1.r, f1z.i = z__1.i;
	z__1.r = -f2x.r, z__1.i = -f2x.i;
	f2x.r = z__1.r, f2x.i = z__1.i;
	z__1.r = -f2y.r, z__1.i = -f2y.i;
	f2y.r = z__1.r, f2y.i = z__1.i;
	z__1.r = -f2z.r, z__1.i = -f2z.i;
	f2z.r = z__1.r, f2z.i = z__1.i;
	goto L6;
L3:
	z_div(&z__1, &gnd_1.xku, &gnd_1.xkl);
	zrati.r = z__1.r, zrati.i = z__1.i;
	if (datap_1.zpatj < 0.f) {
	    z_div(&z__1, &gnd_1.xkl, &gnd_1.xku);
	    zrati.r = z__1.r, zrati.i = z__1.i;
	}
	xymag = sqrt(rx * rx + ry * ry);
	if (xymag > 1e-10f) {
	    goto L4;
	}
	px = 0.f;
	py = 0.f;
	cth = 1.f;
	rrv.r = 1.f, rrv.i = 0.f;
	goto L5;
L4:
	px = -ry / xymag;
	py = rx / xymag;
	cth = abs(rz) / r__;
	z__4.r = zrati.r * zrati.r - zrati.i * zrati.i, z__4.i = zrati.r * 
		zrati.i + zrati.i * zrati.r;
	d__1 = 1.f - cth * cth;
	z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
	z_sqrt(&z__1, &z__2);
	rrv.r = z__1.r, rrv.i = z__1.i;
L5:
	z__1.r = cth * zrati.r, z__1.i = cth * zrati.i;
	rrh.r = z__1.r, rrh.i = z__1.i;
	z__2.r = rrh.r - rrv.r, z__2.i = rrh.i - rrv.i;
	z__3.r = rrh.r + rrv.r, z__3.i = rrh.i + rrv.i;
	z_div(&z__1, &z__2, &z__3);
	rrh.r = z__1.r, rrh.i = z__1.i;
	z__1.r = zrati.r * rrv.r - zrati.i * rrv.i, z__1.i = zrati.r * rrv.i 
		+ zrati.i * rrv.r;
	rrv.r = z__1.r, rrv.i = z__1.i;
	z__3.r = cth - rrv.r, z__3.i = -rrv.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z__4.r = cth + rrv.r, z__4.i = rrv.i;
	z_div(&z__1, &z__2, &z__4);
	rrv.r = z__1.r, rrv.i = z__1.i;
	z__3.r = px * f1x.r, z__3.i = px * f1x.i;
	z__4.r = py * f1y.r, z__4.i = py * f1y.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__5.r = rrv.r - rrh.r, z__5.i = rrv.i - rrh.i;
	z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i 
		+ z__2.i * z__5.r;
	gam.r = z__1.r, gam.i = z__1.i;
	z__2.r = f1x.r * rrh.r - f1x.i * rrh.i, z__2.i = f1x.r * rrh.i + 
		f1x.i * rrh.r;
	z__3.r = px * gam.r, z__3.i = px * gam.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	f1x.r = z__1.r, f1x.i = z__1.i;
	z__2.r = f1y.r * rrh.r - f1y.i * rrh.i, z__2.i = f1y.r * rrh.i + 
		f1y.i * rrh.r;
	z__3.r = py * gam.r, z__3.i = py * gam.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	f1y.r = z__1.r, f1y.i = z__1.i;
	z__1.r = f1z.r * rrh.r - f1z.i * rrh.i, z__1.i = f1z.r * rrh.i + 
		f1z.i * rrh.r;
	f1z.r = z__1.r, f1z.i = z__1.i;
	z__3.r = px * f2x.r, z__3.i = px * f2x.i;
	z__4.r = py * f2y.r, z__4.i = py * f2y.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__5.r = rrv.r - rrh.r, z__5.i = rrv.i - rrh.i;
	z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i 
		+ z__2.i * z__5.r;
	gam.r = z__1.r, gam.i = z__1.i;
	z__2.r = f2x.r * rrh.r - f2x.i * rrh.i, z__2.i = f2x.r * rrh.i + 
		f2x.i * rrh.r;
	z__3.r = px * gam.r, z__3.i = px * gam.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	f2x.r = z__1.r, f2x.i = z__1.i;
	z__2.r = f2y.r * rrh.r - f2y.i * rrh.i, z__2.i = f2y.r * rrh.i + 
		f2y.i * rrh.r;
	z__3.r = py * gam.r, z__3.i = py * gam.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	f2y.r = z__1.r, f2y.i = z__1.i;
	z__1.r = f2z.r * rrh.r - f2z.i * rrh.i, z__1.i = f2z.r * rrh.i + 
		f2z.i * rrh.r;
	f2z.r = z__1.r, f2z.i = z__1.i;
L6:
	z__1.r = datap_1.h1x.r + f1x.r, z__1.i = datap_1.h1x.i + f1x.i;
	datap_1.h1x.r = z__1.r, datap_1.h1x.i = z__1.i;
	z__1.r = datap_1.h1y.r + f1y.r, z__1.i = datap_1.h1y.i + f1y.i;
	datap_1.h1y.r = z__1.r, datap_1.h1y.i = z__1.i;
	z__1.r = datap_1.h1z.r + f1z.r, z__1.i = datap_1.h1z.i + f1z.i;
	datap_1.h1z.r = z__1.r, datap_1.h1z.i = z__1.i;
	z__1.r = datap_1.h2x.r + f2x.r, z__1.i = datap_1.h2x.i + f2x.i;
	datap_1.h2x.r = z__1.r, datap_1.h2x.i = z__1.i;
	z__1.r = datap_1.h2y.r + f2y.r, z__1.i = datap_1.h2y.i + f2y.i;
	datap_1.h2y.r = z__1.r, datap_1.h2y.i = z__1.i;
	z__1.r = datap_1.h2z.r + f2z.r, z__1.i = datap_1.h2z.i + f2z.i;
	datap_1.h2z.r = z__1.r, datap_1.h2z.i = z__1.i;
L7:
	;
    }
    return 0;
} /* hintg_ */

/* Subroutine */ int hsfld_(doublereal *xi, doublereal *yi, doublereal *zi)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double log(doublereal);
    void z_sqrt(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer ip;
    static doublereal rh;
    static doublecomplex xk, qx, qy, qz;
    static doublereal zp, px, py;
    static doublecomplex hpc;
    static doublereal cth;
    static doublecomplex hpk;
    static doublereal rfl;
    static doublecomplex hps, rrh;
    static doublereal xij;
    static doublecomplex etx;
    static doublereal yij, zij, phx, phy, phz;
    static doublecomplex rrv;
    static doublereal rmag, rhox, rhoy, rhoz, salpr, xspec, yspec;
    extern /* Subroutine */ int hsflx_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    static doublereal xymag;
    static doublecomplex zrati, zratx;
    static doublereal rhospc;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     HSFLD computes the H field for constant, sine, and cosine current */
/*     On a segment including ground effects.  The thin-wire approx. is */
/*     implemented with a filament of current on the wire axis. */

    if (dataj_1.zj >= 0.f) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	etx.r = gnd_1.etau.r, etx.i = gnd_1.etau.i;
    } else {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	etx.r = gnd_1.etal.r, etx.i = gnd_1.etal.i;
    }
    xij = *xi - dataj_1.xj;
    yij = *yi - dataj_1.yj;
    rfl = -1.f;
    i__1 = gnd_1.ksymp;
    for (ip = 1; ip <= i__1; ++ip) {
	rfl = -rfl;
	salpr = dataj_1.dzj * rfl;
	zij = *zi - rfl * dataj_1.zj;
	zp = xij * dataj_1.dxj + yij * dataj_1.dyj + zij * salpr;
	rhox = xij - dataj_1.dxj * zp;
	rhoy = yij - dataj_1.dyj * zp;
	rhoz = zij - salpr * zp;
	rh = sqrt(rhox * rhox + rhoy * rhoy + rhoz * rhoz);

/*     SET H FIELD TO ZERO INSIDE THE SEGMENT */

	if (rh < dataj_1.aradj * .999f) {
	    dataj_1.exk.r = 0.f, dataj_1.exk.i = 0.f;
	    dataj_1.eyk.r = 0.f, dataj_1.eyk.i = 0.f;
	    dataj_1.ezk.r = 0.f, dataj_1.ezk.i = 0.f;
	    dataj_1.exs.r = 0.f, dataj_1.exs.i = 0.f;
	    dataj_1.eys.r = 0.f, dataj_1.eys.i = 0.f;
	    dataj_1.ezs.r = 0.f, dataj_1.ezs.i = 0.f;
	    dataj_1.exc.r = 0.f, dataj_1.exc.i = 0.f;
	    dataj_1.eyc.r = 0.f, dataj_1.eyc.i = 0.f;
	    dataj_1.ezc.r = 0.f, dataj_1.ezc.i = 0.f;
	    goto L9;
	}
	rhox /= rh;
	rhoy /= rh;
	rhoz /= rh;
	phx = dataj_1.dyj * rhoz - salpr * rhoy;
	phy = salpr * rhox - dataj_1.dxj * rhoz;
	phz = dataj_1.dxj * rhoy - dataj_1.dyj * rhox;
	hsflx_(&dataj_1.slenj, &rh, &zp, &xk, &hpk, &hps, &hpc);

/*     STORE DIRECT FIELD COMPONENT */

	if (ip != 2) {
	    z__1.r = phx * hpk.r, z__1.i = phx * hpk.i;
	    dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
	    z__1.r = phy * hpk.r, z__1.i = phy * hpk.i;
	    dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
	    z__1.r = phz * hpk.r, z__1.i = phz * hpk.i;
	    dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
	    z__1.r = phx * hps.r, z__1.i = phx * hps.i;
	    dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
	    z__1.r = phy * hps.r, z__1.i = phy * hps.i;
	    dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
	    z__1.r = phz * hps.r, z__1.i = phz * hps.i;
	    dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
	    z__1.r = phx * hpc.r, z__1.i = phx * hpc.i;
	    dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
	    z__1.r = phy * hpc.r, z__1.i = phy * hpc.i;
	    dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
	    z__1.r = phz * hpc.r, z__1.i = phz * hpc.i;
	    dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
	    goto L9;
	}

/*     ADD IMAGE FIELD FOR PERFECT GROUND */

	if (gnd_1.iperf == 1) {
	    z__2.r = phx * hpk.r, z__2.i = phx * hpk.i;
	    z__1.r = dataj_1.exk.r - z__2.r, z__1.i = dataj_1.exk.i - z__2.i;
	    dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
	    z__2.r = phy * hpk.r, z__2.i = phy * hpk.i;
	    z__1.r = dataj_1.eyk.r - z__2.r, z__1.i = dataj_1.eyk.i - z__2.i;
	    dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
	    z__2.r = phz * hpk.r, z__2.i = phz * hpk.i;
	    z__1.r = dataj_1.ezk.r - z__2.r, z__1.i = dataj_1.ezk.i - z__2.i;
	    dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
	    z__2.r = phx * hps.r, z__2.i = phx * hps.i;
	    z__1.r = dataj_1.exs.r - z__2.r, z__1.i = dataj_1.exs.i - z__2.i;
	    dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
	    z__2.r = phy * hps.r, z__2.i = phy * hps.i;
	    z__1.r = dataj_1.eys.r - z__2.r, z__1.i = dataj_1.eys.i - z__2.i;
	    dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
	    z__2.r = phz * hps.r, z__2.i = phz * hps.i;
	    z__1.r = dataj_1.ezs.r - z__2.r, z__1.i = dataj_1.ezs.i - z__2.i;
	    dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
	    z__2.r = phx * hpc.r, z__2.i = phx * hpc.i;
	    z__1.r = dataj_1.exc.r - z__2.r, z__1.i = dataj_1.exc.i - z__2.i;
	    dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
	    z__2.r = phy * hpc.r, z__2.i = phy * hpc.i;
	    z__1.r = dataj_1.eyc.r - z__2.r, z__1.i = dataj_1.eyc.i - z__2.i;
	    dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
	    z__2.r = phz * hpc.r, z__2.i = phz * hpc.i;
	    z__1.r = dataj_1.ezc.r - z__2.r, z__1.i = dataj_1.ezc.i - z__2.i;
	    dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
	    goto L9;
	}

/*     ADD IMAGE FIELD FOR FINITELY CONDUCTING GROUND, REFLECTION COEF. */

	if (dataj_1.zj > 0.f) {
	    z_div(&z__1, &gnd_1.xku, &gnd_1.xkl);
	    zrati.r = z__1.r, zrati.i = z__1.i;
	} else {
	    z_div(&z__1, &gnd_1.xkl, &gnd_1.xku);
	    zrati.r = z__1.r, zrati.i = z__1.i;
	}
	zratx.r = zrati.r, zratx.i = zrati.i;
	rmag = sqrt(zp * zp + rh * rh);
	xymag = sqrt(xij * xij + yij * yij);

/*     SET PARAMETERS FOR RADIAL WIRE GROUND SCREEN. */

	if (gnd_1.nradl > 0) {
	    xspec = (*xi * dataj_1.zj + *zi * dataj_1.xj) / (*zi + dataj_1.zj)
		    ;
	    yspec = (*yi * dataj_1.zj + *zi * dataj_1.yj) / (*zi + dataj_1.zj)
		    ;
/* Computing 2nd power */
	    d__1 = gnd_1.nradl * gnd_1.scnwrd;
	    rhospc = sqrt(xspec * xspec + yspec * yspec + d__1 * d__1);
	    if (rhospc <= gnd_1.scnrad) {
		z__5.r = constn_1.rmuz * 0.f, z__5.i = constn_1.rmuz * 1.f;
		z__4.r = gnd_1.omegag * z__5.r, z__4.i = gnd_1.omegag * 
			z__5.i;
		z__3.r = rhospc * z__4.r, z__3.i = rhospc * z__4.i;
		d__1 = (doublereal) gnd_1.nradl;
		z__2.r = z__3.r / d__1, z__2.i = z__3.i / d__1;
		d__2 = log(rhospc / (gnd_1.nradl * gnd_1.scnwrd));
		z__1.r = d__2 * z__2.r, z__1.i = d__2 * z__2.i;
		rrv.r = z__1.r, rrv.i = z__1.i;
		z__2.r = rrv.r * zrati.r - rrv.i * zrati.i, z__2.i = rrv.r * 
			zrati.i + rrv.i * zrati.r;
		z__4.r = etx.r * zrati.r - etx.i * zrati.i, z__4.i = etx.r * 
			zrati.i + etx.i * zrati.r;
		z__3.r = z__4.r + rrv.r, z__3.i = z__4.i + rrv.i;
		z_div(&z__1, &z__2, &z__3);
		zratx.r = z__1.r, zratx.i = z__1.i;
	    }
	}

/*     CALCULATION OF REFLECTION COEFFICIENTS WHEN GROUND IS SPECIFIED. */

	if (xymag > 1e-10f) {
	    px = -yij / xymag;
	    py = xij / xymag;
	    cth = abs(zij) / rmag;
	    z__4.r = zratx.r * zratx.r - zratx.i * zratx.i, z__4.i = zratx.r *
		     zratx.i + zratx.i * zratx.r;
	    d__1 = 1.f - cth * cth;
	    z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	    z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
	    z_sqrt(&z__1, &z__2);
	    rrv.r = z__1.r, rrv.i = z__1.i;
	} else {
	    px = 0.f;
	    py = 0.f;
	    cth = 1.f;
	    rrv.r = 1.f, rrv.i = 0.f;
	}
	z__1.r = cth * zratx.r, z__1.i = cth * zratx.i;
	rrh.r = z__1.r, rrh.i = z__1.i;
	z__3.r = rrh.r - rrv.r, z__3.i = rrh.i - rrv.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z__4.r = rrh.r + rrv.r, z__4.i = rrh.i + rrv.i;
	z_div(&z__1, &z__2, &z__4);
	rrh.r = z__1.r, rrh.i = z__1.i;
	z__1.r = zratx.r * rrv.r - zratx.i * rrv.i, z__1.i = zratx.r * rrv.i 
		+ zratx.i * rrv.r;
	rrv.r = z__1.r, rrv.i = z__1.i;
	z__2.r = cth - rrv.r, z__2.i = -rrv.i;
	z__3.r = cth + rrv.r, z__3.i = rrv.i;
	z_div(&z__1, &z__2, &z__3);
	rrv.r = z__1.r, rrv.i = z__1.i;
	d__1 = phx * px + phy * py;
	z__2.r = rrv.r - rrh.r, z__2.i = rrv.i - rrh.i;
	z__1.r = d__1 * z__2.r, z__1.i = d__1 * z__2.i;
	qy.r = z__1.r, qy.i = z__1.i;
	z__2.r = px * qy.r, z__2.i = px * qy.i;
	z__3.r = phx * rrh.r, z__3.i = phx * rrh.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	qx.r = z__1.r, qx.i = z__1.i;
	z__2.r = py * qy.r, z__2.i = py * qy.i;
	z__3.r = phy * rrh.r, z__3.i = phy * rrh.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	qy.r = z__1.r, qy.i = z__1.i;
	z__1.r = phz * rrh.r, z__1.i = phz * rrh.i;
	qz.r = z__1.r, qz.i = z__1.i;
	z__2.r = hpk.r * qx.r - hpk.i * qx.i, z__2.i = hpk.r * qx.i + hpk.i * 
		qx.r;
	z__1.r = dataj_1.exk.r - z__2.r, z__1.i = dataj_1.exk.i - z__2.i;
	dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
	z__2.r = hpk.r * qy.r - hpk.i * qy.i, z__2.i = hpk.r * qy.i + hpk.i * 
		qy.r;
	z__1.r = dataj_1.eyk.r - z__2.r, z__1.i = dataj_1.eyk.i - z__2.i;
	dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
	z__2.r = hpk.r * qz.r - hpk.i * qz.i, z__2.i = hpk.r * qz.i + hpk.i * 
		qz.r;
	z__1.r = dataj_1.ezk.r - z__2.r, z__1.i = dataj_1.ezk.i - z__2.i;
	dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
	z__2.r = hps.r * qx.r - hps.i * qx.i, z__2.i = hps.r * qx.i + hps.i * 
		qx.r;
	z__1.r = dataj_1.exs.r - z__2.r, z__1.i = dataj_1.exs.i - z__2.i;
	dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
	z__2.r = hps.r * qy.r - hps.i * qy.i, z__2.i = hps.r * qy.i + hps.i * 
		qy.r;
	z__1.r = dataj_1.eys.r - z__2.r, z__1.i = dataj_1.eys.i - z__2.i;
	dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
	z__2.r = hps.r * qz.r - hps.i * qz.i, z__2.i = hps.r * qz.i + hps.i * 
		qz.r;
	z__1.r = dataj_1.ezs.r - z__2.r, z__1.i = dataj_1.ezs.i - z__2.i;
	dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
	z__2.r = hpc.r * qx.r - hpc.i * qx.i, z__2.i = hpc.r * qx.i + hpc.i * 
		qx.r;
	z__1.r = dataj_1.exc.r - z__2.r, z__1.i = dataj_1.exc.i - z__2.i;
	dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
	z__2.r = hpc.r * qy.r - hpc.i * qy.i, z__2.i = hpc.r * qy.i + hpc.i * 
		qy.r;
	z__1.r = dataj_1.eyc.r - z__2.r, z__1.i = dataj_1.eyc.i - z__2.i;
	dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
	z__2.r = hpc.r * qz.r - hpc.i * qz.i, z__2.i = hpc.r * qz.i + hpc.i * 
		qz.r;
	z__1.r = dataj_1.ezc.r - z__2.r, z__1.i = dataj_1.ezc.i - z__2.i;
	dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
L9:
	;
    }
    return 0;
} /* hsfld_ */

/* Subroutine */ int intreg_(doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double cos(doublereal);

    /* Local variables */
    static doublecomplex fph, frh, fzh, frv, fzv;
    static doublereal cosx;
    extern /* Subroutine */ int intrpc_(integer *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    );

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     INTREG determines which interpolation grid to use and smooths the */
/*     transitions. */

    if (gnrzz_1.azp > gridy_1.zpm1) {
	goto L2;
    }
    intrpc_(&c__1, erv, ezv, erh, eph, ezh);
    if (gnrzz_1.azp < gridy_1.zpmm1) {
	return 0;
    }
    intrpc_(&c__2, &frv, &fzv, &frh, &fph, &fzh);
    cosx = (cos(gridy_1.zpd1 * (gnrzz_1.azp - gridy_1.zpmm1)) + 1.f) * .5f;
    goto L3;
L2:
    if (gnrzz_1.azp > gridy_1.zpm2) {
	goto L4;
    }
    intrpc_(&c__2, erv, ezv, erh, eph, ezh);
    if (gnrzz_1.azp < gridy_1.zpmm2) {
	return 0;
    }
    intrpc_(&c__3, &frv, &fzv, &frh, &fph, &fzh);
    cosx = (cos(gridy_1.zpd2 * (gnrzz_1.azp - gridy_1.zpmm2)) + 1.f) * .5f;
L3:
    z__3.r = erv->r - frv.r, z__3.i = erv->i - frv.i;
    z__2.r = cosx * z__3.r, z__2.i = cosx * z__3.i;
    z__1.r = z__2.r + frv.r, z__1.i = z__2.i + frv.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = ezv->r - fzv.r, z__3.i = ezv->i - fzv.i;
    z__2.r = cosx * z__3.r, z__2.i = cosx * z__3.i;
    z__1.r = z__2.r + fzv.r, z__1.i = z__2.i + fzv.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__3.r = erh->r - frh.r, z__3.i = erh->i - frh.i;
    z__2.r = cosx * z__3.r, z__2.i = cosx * z__3.i;
    z__1.r = z__2.r + frh.r, z__1.i = z__2.i + frh.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__3.r = eph->r - fph.r, z__3.i = eph->i - fph.i;
    z__2.r = cosx * z__3.r, z__2.i = cosx * z__3.i;
    z__1.r = z__2.r + fph.r, z__1.i = z__2.i + fph.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__3.r = ezh->r - fzh.r, z__3.i = ezh->i - fzh.i;
    z__2.r = cosx * z__3.r, z__2.i = cosx * z__3.i;
    z__1.r = z__2.r + fzh.r, z__1.i = z__2.i + fzh.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L4:
    intrpc_(&c__3, erv, ezv, erh, eph, ezh);
    return 0;
} /* intreg_ */

/* Subroutine */ int intrpc_(integer *kreg, doublecomplex *erv, doublecomplex 
	*ezv, doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static doublecomplex rf1, rf2, rf3, rf4, rph, sav, rrh, rzh;
    static doublereal rsq, zmp;
    static doublecomplex rrv, rzv, ekr1, ekr2, xkr1, xkr2, exjk, cons;
    extern /* Subroutine */ int gfdir_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    ), intrpd_(integer *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     INTRPC converts the transmitted field for a buried source to the */
/*     reflected or transmitted field specified by ICASE. The static */
/*     terms are omitted from the reflected field. */

    intrpd_(kreg, erv, ezv, erh, eph, ezh);
    switch (gnrzz_1.icase) {
	case 1:  goto L1;
	case 2:  goto L3;
	case 3:  goto L7;
	case 4:  goto L7;
    }
/*     REFLECTED FIELD ABOVE GROUND */
L1:
    if (*kreg > 1) {
	goto L2;
    }
    r__ = sqrt(gnrzz_1.rho * gnrzz_1.rho + gnrzz_1.zz * gnrzz_1.zz);
    z__5.r = -gnrzz_1.xjk.r, z__5.i = -gnrzz_1.xjk.i;
    z__4.r = r__ * z__5.r, z__4.i = r__ * z__5.i;
    z_exp(&z__3, &z__4);
    z__2.r = gnrzz_1.con4.r * z__3.r - gnrzz_1.con4.i * z__3.i, z__2.i = 
	    gnrzz_1.con4.r * z__3.i + gnrzz_1.con4.i * z__3.r;
    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
    exjk.r = z__1.r, exjk.i = z__1.i;
    sav.r = erv->r, sav.i = erv->i;
    z__1.r = -ezh->r, z__1.i = -ezh->i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = gnrzz_1.epsc1.r * ezv->r - gnrzz_1.epsc1.i * ezv->i, z__1.i = 
	    gnrzz_1.epsc1.r * ezv->i + gnrzz_1.epsc1.i * ezv->r;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__1.r = erh->r - exjk.r, z__1.i = erh->i - exjk.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__1.r = eph->r + exjk.r, z__1.i = eph->i + exjk.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__2.r = -gnrzz_1.epsc1.r, z__2.i = -gnrzz_1.epsc1.i;
    z__1.r = z__2.r * sav.r - z__2.i * sav.i, z__1.i = z__2.r * sav.i + 
	    z__2.i * sav.r;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L2:
    d__1 = -gnrzz_1.zs;
    gfdir_(&gnrzz_1.rho, &d__1, &gnrzz_1.zo, &gnrzz_1.ck2, &gnrzz_1.ck2, &rrv,
	     &rzv, &rrh, &rph, &rzh);
    sav.r = erv->r, sav.i = erv->i;
    z__3.r = -ezh->r, z__3.i = -ezh->i;
    z__2.r = z__3.r + rrv.r, z__2.i = z__3.i + rrv.i;
    z__4.r = gnrzz_1.con2.r * rrv.r - gnrzz_1.con2.i * rrv.i, z__4.i = 
	    gnrzz_1.con2.r * rrv.i + gnrzz_1.con2.i * rrv.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = gnrzz_1.epsc1.r * ezv->r - gnrzz_1.epsc1.i * ezv->i, z__3.i = 
	    gnrzz_1.epsc1.r * ezv->i + gnrzz_1.epsc1.i * ezv->r;
    z__2.r = z__3.r - rzv.r, z__2.i = z__3.i - rzv.i;
    z__4.r = gnrzz_1.con2.r * rzv.r - gnrzz_1.con2.i * rzv.i, z__4.i = 
	    gnrzz_1.con2.r * rzv.i + gnrzz_1.con2.i * rzv.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__2.r = erh->r - rrh.r, z__2.i = erh->i - rrh.i;
    z__3.r = gnrzz_1.con2.r * rrh.r - gnrzz_1.con2.i * rrh.i, z__3.i = 
	    gnrzz_1.con2.r * rrh.i + gnrzz_1.con2.i * rrh.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = eph->r - rph.r, z__2.i = eph->i - rph.i;
    z__3.r = gnrzz_1.con2.r * rph.r - gnrzz_1.con2.i * rph.i, z__3.i = 
	    gnrzz_1.con2.r * rph.i + gnrzz_1.con2.i * rph.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__4.r = -gnrzz_1.epsc1.r, z__4.i = -gnrzz_1.epsc1.i;
    z__3.r = z__4.r * sav.r - z__4.i * sav.i, z__3.i = z__4.r * sav.i + 
	    z__4.i * sav.r;
    z__2.r = z__3.r + rzh.r, z__2.i = z__3.i + rzh.i;
    z__5.r = gnrzz_1.con2.r * rzh.r - gnrzz_1.con2.i * rzh.i, z__5.i = 
	    gnrzz_1.con2.r * rzh.i + gnrzz_1.con2.i * rzh.r;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
/*     REFLECTED FIELD BELOW GROUND */
L3:
    if (*kreg > 1) {
	goto L6;
    }
    zmp = gnrzz_1.zo + gnrzz_1.zs;
    rsq = gnrzz_1.rho * gnrzz_1.rho + zmp * zmp;
    r__ = sqrt(rsq);
    z__2.r = gnrzz_1.con1.r * 2.f, z__2.i = gnrzz_1.con1.i * 2.f;
    z__3.r = r__ * gnrzz_1.cks12.r, z__3.i = r__ * gnrzz_1.cks12.i;
    z_div(&z__1, &z__2, &z__3);
    cons.r = z__1.r, cons.i = z__1.i;
    z__2.r = gnrzz_1.ck1.r * -0.f - gnrzz_1.ck1.i * -1.f, z__2.i = 
	    gnrzz_1.ck1.r * -1.f + gnrzz_1.ck1.i * -0.f;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    xkr1.r = z__1.r, xkr1.i = z__1.i;
    z__2.r = gnrzz_1.ck2.r * -0.f - gnrzz_1.ck2.i * -1.f, z__2.i = 
	    gnrzz_1.ck2.r * -1.f + gnrzz_1.ck2.i * -0.f;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    xkr2.r = z__1.r, xkr2.i = z__1.i;
    z_exp(&z__1, &xkr1);
    ekr1.r = z__1.r, ekr1.i = z__1.i;
    z_exp(&z__1, &xkr2);
    ekr2.r = z__1.r, ekr2.i = z__1.i;
    z__1.r = r__ * gnrzz_1.ck1.r, z__1.i = r__ * gnrzz_1.ck1.i;
    if (z_abs(&z__1) < .1f) {
	goto L4;
    }
    z__5.r = 1.f - xkr1.r, z__5.i = -xkr1.i;
    z__4.r = z__5.r * ekr1.r - z__5.i * ekr1.i, z__4.i = z__5.r * ekr1.i + 
	    z__5.i * ekr1.r;
    z__7.r = 1.f - xkr2.r, z__7.i = -xkr2.i;
    z__6.r = z__7.r * ekr2.r - z__7.i * ekr2.i, z__6.i = z__7.r * ekr2.i + 
	    z__7.i * ekr2.r;
    z__3.r = z__4.r - z__6.r, z__3.i = z__4.i - z__6.i;
    z__2.r = z__3.r * cons.r - z__3.i * cons.i, z__2.i = z__3.r * cons.i + 
	    z__3.i * cons.r;
    z__1.r = z__2.r / rsq, z__1.i = z__2.i / rsq;
    rf1.r = z__1.r, rf1.i = z__1.i;
    goto L5;
L4:
    z__7.r = xkr1.r * .0333333f, z__7.i = xkr1.i * .0333333f;
    z__6.r = z__7.r + .125f, z__6.i = z__7.i;
    z__5.r = z__6.r * xkr1.r - z__6.i * xkr1.i, z__5.i = z__6.r * xkr1.i + 
	    z__6.i * xkr1.r;
    z__4.r = z__5.r + .33333333f, z__4.i = z__5.i;
    z__3.r = z__4.r * xkr1.r - z__4.i * xkr1.i, z__3.i = z__4.r * xkr1.i + 
	    z__4.i * xkr1.r;
    z__2.r = z__3.r + .5f, z__2.i = z__3.i;
    z__1.r = z__2.r * gnrzz_1.ck1sq.r - z__2.i * gnrzz_1.ck1sq.i, z__1.i = 
	    z__2.r * gnrzz_1.ck1sq.i + z__2.i * gnrzz_1.ck1sq.r;
    rf1.r = z__1.r, rf1.i = z__1.i;
    z__7.r = xkr2.r * .0333333f, z__7.i = xkr2.i * .0333333f;
    z__6.r = z__7.r + .125f, z__6.i = z__7.i;
    z__5.r = z__6.r * xkr2.r - z__6.i * xkr2.i, z__5.i = z__6.r * xkr2.i + 
	    z__6.i * xkr2.r;
    z__4.r = z__5.r + .33333333f, z__4.i = z__5.i;
    z__3.r = z__4.r * xkr2.r - z__4.i * xkr2.i, z__3.i = z__4.r * xkr2.i + 
	    z__4.i * xkr2.r;
    z__2.r = z__3.r + .5f, z__2.i = z__3.i;
    z__1.r = z__2.r * gnrzz_1.ck2sq.r - z__2.i * gnrzz_1.ck2sq.i, z__1.i = 
	    z__2.r * gnrzz_1.ck2sq.i + z__2.i * gnrzz_1.ck2sq.r;
    rf2.r = z__1.r, rf2.i = z__1.i;
    z__2.r = rf1.r - rf2.r, z__2.i = rf1.i - rf2.i;
    z__1.r = z__2.r * cons.r - z__2.i * cons.i, z__1.i = z__2.r * cons.i + 
	    z__2.i * cons.r;
    rf1.r = z__1.r, rf1.i = z__1.i;
L5:
    z__3.r = gnrzz_1.ck1sq.r * ekr1.r - gnrzz_1.ck1sq.i * ekr1.i, z__3.i = 
	    gnrzz_1.ck1sq.r * ekr1.i + gnrzz_1.ck1sq.i * ekr1.r;
    z__4.r = gnrzz_1.ck2sq.r * ekr2.r - gnrzz_1.ck2sq.i * ekr2.i, z__4.i = 
	    gnrzz_1.ck2sq.r * ekr2.i + gnrzz_1.ck2sq.i * ekr2.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r * cons.r - z__2.i * cons.i, z__1.i = z__2.r * cons.i + 
	    z__2.i * cons.r;
    rf2.r = z__1.r, rf2.i = z__1.i;
    z__3.r = rf1.r * 3.f, z__3.i = rf1.i * 3.f;
    z__2.r = z__3.r - rf2.r, z__2.i = z__3.i - rf2.i;
    z__1.r = z__2.r / rsq, z__1.i = z__2.i / rsq;
    rf3.r = z__1.r, rf3.i = z__1.i;
    z__2.r = cons.r * gnrzz_1.ck1sq.r - cons.i * gnrzz_1.ck1sq.i, z__2.i = 
	    cons.r * gnrzz_1.ck1sq.i + cons.i * gnrzz_1.ck1sq.r;
    z__1.r = z__2.r * ekr1.r - z__2.i * ekr1.i, z__1.i = z__2.r * ekr1.i + 
	    z__2.i * ekr1.r;
    rf4.r = z__1.r, rf4.i = z__1.i;
    d__1 = gnrzz_1.rho * zmp;
    z__2.r = d__1 * rf3.r, z__2.i = d__1 * rf3.i;
    z__1.r = erv->r + z__2.r, z__1.i = erv->i + z__2.i;
    erv->r = z__1.r, erv->i = z__1.i;
    d__1 = zmp * zmp;
    z__5.r = d__1 * rf3.r, z__5.i = d__1 * rf3.i;
    z__4.r = z__5.r - rf1.r, z__4.i = z__5.i - rf1.i;
    z__3.r = z__4.r + rf2.r, z__3.i = z__4.i + rf2.i;
    z__2.r = ezv->r - z__3.r, z__2.i = ezv->i - z__3.i;
    z_div(&z__1, &z__2, &gnrzz_1.epsc1);
    ezv->r = z__1.r, ezv->i = z__1.i;
    d__1 = gnrzz_1.rho * gnrzz_1.rho;
    z__4.r = d__1 * rf3.r, z__4.i = d__1 * rf3.i;
    z__3.r = z__4.r - rf1.r, z__3.i = z__4.i - rf1.i;
    z__2.r = erh->r - z__3.r, z__2.i = erh->i - z__3.i;
    z__1.r = z__2.r - rf4.r, z__1.i = z__2.i - rf4.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = eph->r - rf1.r, z__2.i = eph->i - rf1.i;
    z__1.r = z__2.r + rf4.r, z__1.i = z__2.i + rf4.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__1.r = -erv->r, z__1.i = -erv->i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L6:
    d__1 = -gnrzz_1.zs;
    gfdir_(&gnrzz_1.rho, &d__1, &gnrzz_1.zo, &gnrzz_1.ck2, &gnrzz_1.ck1, &rrv,
	     &rzv, &rrh, &rph, &rzh);
    z__2.r = erv->r + rrv.r, z__2.i = erv->i + rrv.i;
    z__3.r = gnrzz_1.con2.r * rrv.r - gnrzz_1.con2.i * rrv.i, z__3.i = 
	    gnrzz_1.con2.r * rrv.i + gnrzz_1.con2.i * rrv.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z_div(&z__3, ezv, &gnrzz_1.epsc1);
    z__2.r = z__3.r - rzv.r, z__2.i = z__3.i - rzv.i;
    z__4.r = gnrzz_1.con2.r * rzv.r - gnrzz_1.con2.i * rzv.i, z__4.i = 
	    gnrzz_1.con2.r * rzv.i + gnrzz_1.con2.i * rzv.r;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__2.r = erh->r - rrh.r, z__2.i = erh->i - rrh.i;
    z__3.r = gnrzz_1.con2.r * rrh.r - gnrzz_1.con2.i * rrh.i, z__3.i = 
	    gnrzz_1.con2.r * rrh.i + gnrzz_1.con2.i * rrh.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = eph->r - rph.r, z__2.i = eph->i - rph.i;
    z__3.r = gnrzz_1.con2.r * rph.r - gnrzz_1.con2.i * rph.i, z__3.i = 
	    gnrzz_1.con2.r * rph.i + gnrzz_1.con2.i * rph.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z_div(&z__3, ezh, &gnrzz_1.epsc1);
    z__2.r = z__3.r + rzh.r, z__2.i = z__3.i + rzh.i;
    z__4.r = gnrzz_1.con2.r * rzh.r - gnrzz_1.con2.i * rzh.i, z__4.i = 
	    gnrzz_1.con2.r * rzh.i + gnrzz_1.con2.i * rzh.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
/*     TRANSMITTED FIELD.  STATIC TERMS ADDED FOR KREG.EQ.1 */
L7:
    if (*kreg > 1) {
	goto L8;
    }
    zmp = gnrzz_1.zz - gnrzz_1.zzp;
    rsq = gnrzz_1.rho * gnrzz_1.rho + zmp * zmp;
    r__ = sqrt(rsq);
    z__3.r = gnrzz_1.con1.r * 2.f, z__3.i = gnrzz_1.con1.i * 2.f;
    z__6.r = -gnrzz_1.xjk.r, z__6.i = -gnrzz_1.xjk.i;
    z__5.r = r__ * z__6.r, z__5.i = r__ * z__6.i;
    z_exp(&z__4, &z__5);
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    d__1 = rsq * r__;
    z__7.r = d__1 * gnrzz_1.cks12.r, z__7.i = d__1 * gnrzz_1.cks12.i;
    z_div(&z__1, &z__2, &z__7);
    exjk.r = z__1.r, exjk.i = z__1.i;
    d__1 = 3.f / rsq;
    z__4.r = gnrzz_1.xjk.r * 3.f, z__4.i = gnrzz_1.xjk.i * 3.f;
    z__3.r = z__4.r / r__, z__3.i = z__4.i / r__;
    z__2.r = d__1 + z__3.r, z__2.i = z__3.i;
    z__1.r = z__2.r - gnrzz_1.ck2sq.r, z__1.i = z__2.i - gnrzz_1.ck2sq.i;
    rf1.r = z__1.r, rf1.i = z__1.i;
    z__2.r = r__ * gnrzz_1.xjk.r, z__2.i = r__ * gnrzz_1.xjk.i;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    rf2.r = z__1.r, rf2.i = z__1.i;
    d__1 = gnrzz_1.rho * zmp;
    z__2.r = d__1 * rf1.r, z__2.i = d__1 * rf1.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    sav.r = z__1.r, sav.i = z__1.i;
    z__1.r = erv->r + sav.r, z__1.i = erv->i + sav.i;
    erv->r = z__1.r, erv->i = z__1.i;
    d__1 = zmp * zmp;
    z__5.r = d__1 * rf1.r, z__5.i = d__1 * rf1.i;
    z__4.r = z__5.r - rf2.r, z__4.i = z__5.i - rf2.i;
    z__6.r = rsq * gnrzz_1.ck2sq.r, z__6.i = rsq * gnrzz_1.ck2sq.i;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = ezv->r + z__2.r, z__1.i = ezv->i + z__2.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    d__1 = gnrzz_1.rho * gnrzz_1.rho;
    z__4.r = d__1 * rf1.r, z__4.i = d__1 * rf1.i;
    z__3.r = z__4.r - rf2.r, z__3.i = z__4.i - rf2.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = erh->r + z__2.r, z__1.i = erh->i + z__2.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__2.r = rf2.r * exjk.r - rf2.i * exjk.i, z__2.i = rf2.r * exjk.i + rf2.i 
	    * exjk.r;
    z__1.r = eph->r + z__2.r, z__1.i = eph->i + z__2.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__1.r = ezh->r + sav.r, z__1.i = ezh->i + sav.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
L8:
    if (gnrzz_1.icase == 3) {
	return 0;
    }
    sav.r = erv->r, sav.i = erv->i;
    z__1.r = -ezh->r, z__1.i = -ezh->i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__1.r = -sav.r, z__1.i = -sav.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
} /* intrpc_ */

/* Subroutine */ int intrpd_(integer *kreg, doublecomplex *e1, doublecomplex *
	e2, doublecomplex *e3, doublecomplex *e4, doublecomplex *e5)
{
    /* Format strings */
    static char fmt_8[] = "(\002 INTRPD: ERROR - POINT OUT OF GRID; RHO,ZZ,A"
	    "ZP=\002,1p3e12.5)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15, z__16, z__17, z__18, z__19, 
	    z__20, z__21;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_exp(
	    doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static doublereal r__, x, y, z__;
    static doublecomplex f1, f2, f3, f4, f5;
    static doublereal dx, dy, dz;
    static integer ix, iy, iz;
    static doublereal xm, ym, zm, xp, yp, zp, rz;
    static integer i111, i211, i121, i221, i112, i212, i122, i222;
    static doublereal sf1, sf2, sf3, cth;
    static integer ndx, ndy, ndz;
    static doublereal sth, rsq, zmp, sfac;
    static doublecomplex exjk;
    static doublereal dxyz;

    /* Fortran I/O blocks */
    static cilist io___1400 = { 0, 3, 0, fmt_8, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     INTRPD obtains field values by 3 dim. interpolation.  The 1./R */
/*     terms are added for KREG.EQ.1 and the values are multiplied by */
/*     required 1./R and exponential factors for each KREG. */

    ndx = gridy_1.nrh[*kreg - 1];
    ndy = gridy_1.nzz[*kreg - 1];
    ndz = gridy_1.nzp[*kreg - 1];
    dx = gridy_1.drh[*kreg - 1];
    dy = gridy_1.dzz[*kreg - 1];
    dz = gridy_1.dzp[*kreg - 1];
    dxyz = gridy_1.drzzp[*kreg - 1];
    x = gnrzz_1.rho - gridy_1.rh1[*kreg - 1];
    y = gnrzz_1.zz - gridy_1.zz1[*kreg - 1];
    z__ = gnrzz_1.azp - gridy_1.zp1[*kreg - 1];
    ix = (integer) (x / dx) + 1;
    iy = (integer) (y / dy) + 1;
    iz = (integer) (z__ / dz) + 1;
    if (y < -1e-6f) {
	goto L7;
    }
    if (z__ < -1e-6f) {
	goto L7;
    }
    if (ix > ndx) {
	goto L7;
    }
    if (iy > ndy) {
	goto L7;
    }
    if (iz > ndz && *kreg < 3) {
	goto L7;
    }
    if (ix == ndx) {
	ix = ndx - 1;
    }
    if (iy == ndy) {
	iy = ndy - 1;
    }
    if (iz >= ndz) {
	iz = ndz - 1;
    }
    i111 = ndx * (ndy * (iz - 1) + iy - 1) + ix + gridy_1.indi[*kreg - 1];
    i211 = i111 + 1;
    i121 = i111 + ndx;
    i221 = i121 + 1;
    i112 = i111 + ndx * ndy;
    i212 = i112 + 1;
    i122 = i112 + ndx;
    i222 = i122 + 1;
    xp = x - ix * dx;
    xm = -(xp + dx);
    yp = y - iy * dy;
    ym = -(yp + dy);
    zp = z__ - iz * dz;
    zm = -(zp + dz);
    xp = -xp / dxyz;
    xm = -xm / dxyz;
    i__1 = i111 - 1;
    z__6.r = zp * gridy_1.a1[i__1].r, z__6.i = zp * gridy_1.a1[i__1].i;
    i__2 = i112 - 1;
    z__7.r = zm * gridy_1.a1[i__2].r, z__7.i = zm * gridy_1.a1[i__2].i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = yp * z__5.r, z__4.i = yp * z__5.i;
    i__3 = i121 - 1;
    z__10.r = zp * gridy_1.a1[i__3].r, z__10.i = zp * gridy_1.a1[i__3].i;
    i__4 = i122 - 1;
    z__11.r = zm * gridy_1.a1[i__4].r, z__11.i = zm * gridy_1.a1[i__4].i;
    z__9.r = z__10.r + z__11.r, z__9.i = z__10.i + z__11.i;
    z__8.r = ym * z__9.r, z__8.i = ym * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = xp * z__3.r, z__2.i = xp * z__3.i;
    i__5 = i211 - 1;
    z__16.r = zp * gridy_1.a1[i__5].r, z__16.i = zp * gridy_1.a1[i__5].i;
    i__6 = i212 - 1;
    z__17.r = zm * gridy_1.a1[i__6].r, z__17.i = zm * gridy_1.a1[i__6].i;
    z__15.r = z__16.r + z__17.r, z__15.i = z__16.i + z__17.i;
    z__14.r = yp * z__15.r, z__14.i = yp * z__15.i;
    i__7 = i221 - 1;
    z__20.r = zp * gridy_1.a1[i__7].r, z__20.i = zp * gridy_1.a1[i__7].i;
    i__8 = i222 - 1;
    z__21.r = zm * gridy_1.a1[i__8].r, z__21.i = zm * gridy_1.a1[i__8].i;
    z__19.r = z__20.r + z__21.r, z__19.i = z__20.i + z__21.i;
    z__18.r = ym * z__19.r, z__18.i = ym * z__19.i;
    z__13.r = z__14.r + z__18.r, z__13.i = z__14.i + z__18.i;
    z__12.r = xm * z__13.r, z__12.i = xm * z__13.i;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    e1->r = z__1.r, e1->i = z__1.i;
    i__1 = i111 - 1;
    z__6.r = zp * gridy_1.a2[i__1].r, z__6.i = zp * gridy_1.a2[i__1].i;
    i__2 = i112 - 1;
    z__7.r = zm * gridy_1.a2[i__2].r, z__7.i = zm * gridy_1.a2[i__2].i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = yp * z__5.r, z__4.i = yp * z__5.i;
    i__3 = i121 - 1;
    z__10.r = zp * gridy_1.a2[i__3].r, z__10.i = zp * gridy_1.a2[i__3].i;
    i__4 = i122 - 1;
    z__11.r = zm * gridy_1.a2[i__4].r, z__11.i = zm * gridy_1.a2[i__4].i;
    z__9.r = z__10.r + z__11.r, z__9.i = z__10.i + z__11.i;
    z__8.r = ym * z__9.r, z__8.i = ym * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = xp * z__3.r, z__2.i = xp * z__3.i;
    i__5 = i211 - 1;
    z__16.r = zp * gridy_1.a2[i__5].r, z__16.i = zp * gridy_1.a2[i__5].i;
    i__6 = i212 - 1;
    z__17.r = zm * gridy_1.a2[i__6].r, z__17.i = zm * gridy_1.a2[i__6].i;
    z__15.r = z__16.r + z__17.r, z__15.i = z__16.i + z__17.i;
    z__14.r = yp * z__15.r, z__14.i = yp * z__15.i;
    i__7 = i221 - 1;
    z__20.r = zp * gridy_1.a2[i__7].r, z__20.i = zp * gridy_1.a2[i__7].i;
    i__8 = i222 - 1;
    z__21.r = zm * gridy_1.a2[i__8].r, z__21.i = zm * gridy_1.a2[i__8].i;
    z__19.r = z__20.r + z__21.r, z__19.i = z__20.i + z__21.i;
    z__18.r = ym * z__19.r, z__18.i = ym * z__19.i;
    z__13.r = z__14.r + z__18.r, z__13.i = z__14.i + z__18.i;
    z__12.r = xm * z__13.r, z__12.i = xm * z__13.i;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    e2->r = z__1.r, e2->i = z__1.i;
    i__1 = i111 - 1;
    z__6.r = zp * gridy_1.a3[i__1].r, z__6.i = zp * gridy_1.a3[i__1].i;
    i__2 = i112 - 1;
    z__7.r = zm * gridy_1.a3[i__2].r, z__7.i = zm * gridy_1.a3[i__2].i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = yp * z__5.r, z__4.i = yp * z__5.i;
    i__3 = i121 - 1;
    z__10.r = zp * gridy_1.a3[i__3].r, z__10.i = zp * gridy_1.a3[i__3].i;
    i__4 = i122 - 1;
    z__11.r = zm * gridy_1.a3[i__4].r, z__11.i = zm * gridy_1.a3[i__4].i;
    z__9.r = z__10.r + z__11.r, z__9.i = z__10.i + z__11.i;
    z__8.r = ym * z__9.r, z__8.i = ym * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = xp * z__3.r, z__2.i = xp * z__3.i;
    i__5 = i211 - 1;
    z__16.r = zp * gridy_1.a3[i__5].r, z__16.i = zp * gridy_1.a3[i__5].i;
    i__6 = i212 - 1;
    z__17.r = zm * gridy_1.a3[i__6].r, z__17.i = zm * gridy_1.a3[i__6].i;
    z__15.r = z__16.r + z__17.r, z__15.i = z__16.i + z__17.i;
    z__14.r = yp * z__15.r, z__14.i = yp * z__15.i;
    i__7 = i221 - 1;
    z__20.r = zp * gridy_1.a3[i__7].r, z__20.i = zp * gridy_1.a3[i__7].i;
    i__8 = i222 - 1;
    z__21.r = zm * gridy_1.a3[i__8].r, z__21.i = zm * gridy_1.a3[i__8].i;
    z__19.r = z__20.r + z__21.r, z__19.i = z__20.i + z__21.i;
    z__18.r = ym * z__19.r, z__18.i = ym * z__19.i;
    z__13.r = z__14.r + z__18.r, z__13.i = z__14.i + z__18.i;
    z__12.r = xm * z__13.r, z__12.i = xm * z__13.i;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    e3->r = z__1.r, e3->i = z__1.i;
    i__1 = i111 - 1;
    z__6.r = zp * gridy_1.a4[i__1].r, z__6.i = zp * gridy_1.a4[i__1].i;
    i__2 = i112 - 1;
    z__7.r = zm * gridy_1.a4[i__2].r, z__7.i = zm * gridy_1.a4[i__2].i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = yp * z__5.r, z__4.i = yp * z__5.i;
    i__3 = i121 - 1;
    z__10.r = zp * gridy_1.a4[i__3].r, z__10.i = zp * gridy_1.a4[i__3].i;
    i__4 = i122 - 1;
    z__11.r = zm * gridy_1.a4[i__4].r, z__11.i = zm * gridy_1.a4[i__4].i;
    z__9.r = z__10.r + z__11.r, z__9.i = z__10.i + z__11.i;
    z__8.r = ym * z__9.r, z__8.i = ym * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = xp * z__3.r, z__2.i = xp * z__3.i;
    i__5 = i211 - 1;
    z__16.r = zp * gridy_1.a4[i__5].r, z__16.i = zp * gridy_1.a4[i__5].i;
    i__6 = i212 - 1;
    z__17.r = zm * gridy_1.a4[i__6].r, z__17.i = zm * gridy_1.a4[i__6].i;
    z__15.r = z__16.r + z__17.r, z__15.i = z__16.i + z__17.i;
    z__14.r = yp * z__15.r, z__14.i = yp * z__15.i;
    i__7 = i221 - 1;
    z__20.r = zp * gridy_1.a4[i__7].r, z__20.i = zp * gridy_1.a4[i__7].i;
    i__8 = i222 - 1;
    z__21.r = zm * gridy_1.a4[i__8].r, z__21.i = zm * gridy_1.a4[i__8].i;
    z__19.r = z__20.r + z__21.r, z__19.i = z__20.i + z__21.i;
    z__18.r = ym * z__19.r, z__18.i = ym * z__19.i;
    z__13.r = z__14.r + z__18.r, z__13.i = z__14.i + z__18.i;
    z__12.r = xm * z__13.r, z__12.i = xm * z__13.i;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    e4->r = z__1.r, e4->i = z__1.i;
    i__1 = i111 - 1;
    z__6.r = zp * gridy_1.a5[i__1].r, z__6.i = zp * gridy_1.a5[i__1].i;
    i__2 = i112 - 1;
    z__7.r = zm * gridy_1.a5[i__2].r, z__7.i = zm * gridy_1.a5[i__2].i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = yp * z__5.r, z__4.i = yp * z__5.i;
    i__3 = i121 - 1;
    z__10.r = zp * gridy_1.a5[i__3].r, z__10.i = zp * gridy_1.a5[i__3].i;
    i__4 = i122 - 1;
    z__11.r = zm * gridy_1.a5[i__4].r, z__11.i = zm * gridy_1.a5[i__4].i;
    z__9.r = z__10.r + z__11.r, z__9.i = z__10.i + z__11.i;
    z__8.r = ym * z__9.r, z__8.i = ym * z__9.i;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = xp * z__3.r, z__2.i = xp * z__3.i;
    i__5 = i211 - 1;
    z__16.r = zp * gridy_1.a5[i__5].r, z__16.i = zp * gridy_1.a5[i__5].i;
    i__6 = i212 - 1;
    z__17.r = zm * gridy_1.a5[i__6].r, z__17.i = zm * gridy_1.a5[i__6].i;
    z__15.r = z__16.r + z__17.r, z__15.i = z__16.i + z__17.i;
    z__14.r = yp * z__15.r, z__14.i = yp * z__15.i;
    i__7 = i221 - 1;
    z__20.r = zp * gridy_1.a5[i__7].r, z__20.i = zp * gridy_1.a5[i__7].i;
    i__8 = i222 - 1;
    z__21.r = zm * gridy_1.a5[i__8].r, z__21.i = zm * gridy_1.a5[i__8].i;
    z__19.r = z__20.r + z__21.r, z__19.i = z__20.i + z__21.i;
    z__18.r = ym * z__19.r, z__18.i = ym * z__19.i;
    z__13.r = z__14.r + z__18.r, z__13.i = z__14.i + z__18.i;
    z__12.r = xm * z__13.r, z__12.i = xm * z__13.i;
    z__1.r = z__2.r + z__12.r, z__1.i = z__2.i + z__12.i;
    e5->r = z__1.r, e5->i = z__1.i;
    zmp = gnrzz_1.zz + gnrzz_1.azp;
    rsq = gnrzz_1.rho * gnrzz_1.rho + zmp * zmp;
    switch (*kreg) {
	case 1:  goto L1;
	case 2:  goto L4;
	case 3:  goto L5;
    }
L1:
    r__ = sqrt(rsq);
    sth = zmp / r__;
    cth = gnrzz_1.rho / r__;
    if (cth < .1f) {
	goto L2;
    }
    sf1 = (1.f - sth) / cth;
    sf2 = sf1 / cth;
    goto L3;
L2:
    sf2 = gnrzz_1.rho / zmp;
    sf2 = (1.f - sf2 * .25f * sf2) * .5f / zmp;
    sf1 = gnrzz_1.rho * sf2;
    sf2 = r__ * sf2;
L3:
    sf3 = sth - sf2;
    sfac = -gnrzz_1.azp / r__;
    z__2.r = sf1 * gnrzz_1.con3.r, z__2.i = sf1 * gnrzz_1.con3.i;
    z__4.r = sfac * gnrzz_1.con2.r, z__4.i = sfac * gnrzz_1.con2.i;
    z__3.r = cth * z__4.r, z__3.i = cth * z__4.i;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    f1.r = z__1.r, f1.i = z__1.i;
    z__3.r = sfac * gnrzz_1.con2.r, z__3.i = sfac * gnrzz_1.con2.i;
    z__2.r = sth * z__3.r, z__2.i = sth * z__3.i;
    z__1.r = gnrzz_1.con3.r - z__2.r, z__1.i = gnrzz_1.con3.i - z__2.i;
    f2.r = z__1.r, f2.i = z__1.i;
    d__1 = sf2 - 1.f;
    z__3.r = d__1 * gnrzz_1.con3.r, z__3.i = d__1 * gnrzz_1.con3.i;
    z__5.r = sfac * gnrzz_1.con2.r, z__5.i = sfac * gnrzz_1.con2.i;
    z__4.r = sf3 * z__5.r, z__4.i = sf3 * z__5.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    f3.r = z__1.r, f3.i = z__1.i;
    z__4.r = sfac * gnrzz_1.con2.r, z__4.i = sfac * gnrzz_1.con2.i;
    z__3.r = gnrzz_1.con3.r - z__4.r, z__3.i = gnrzz_1.con3.i - z__4.i;
    z__2.r = sf2 * z__3.r, z__2.i = sf2 * z__3.i;
    z__1.r = z__2.r - 1.f, z__1.i = z__2.i;
    f4.r = z__1.r, f4.i = z__1.i;
    z__5.r = -gnrzz_1.con3.r, z__5.i = -gnrzz_1.con3.i;
    z__4.r = z__5.r * gnrzz_1.ck1sq.r - z__5.i * gnrzz_1.ck1sq.i, z__4.i = 
	    z__5.r * gnrzz_1.ck1sq.i + z__5.i * gnrzz_1.ck1sq.r;
    z_div(&z__3, &z__4, &gnrzz_1.ck2sq);
    z__2.r = sf1 * z__3.r, z__2.i = sf1 * z__3.i;
    z__7.r = sfac * gnrzz_1.con2.r, z__7.i = sfac * gnrzz_1.con2.i;
    z__6.r = cth * z__7.r, z__6.i = cth * z__7.i;
    z__1.r = z__2.r - z__6.r, z__1.i = z__2.i - z__6.i;
    f5.r = z__1.r, f5.i = z__1.i;
    z__4.r = -gnrzz_1.xjk.r, z__4.i = -gnrzz_1.xjk.i;
    z__3.r = r__ * z__4.r, z__3.i = r__ * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
    exjk.r = z__1.r, exjk.i = z__1.i;
    z__3.r = f1.r * gnrzz_1.con1.r - f1.i * gnrzz_1.con1.i, z__3.i = f1.r * 
	    gnrzz_1.con1.i + f1.i * gnrzz_1.con1.r;
    z__2.r = e1->r + z__3.r, z__2.i = e1->i + z__3.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    e1->r = z__1.r, e1->i = z__1.i;
    z__3.r = f2.r * gnrzz_1.con1.r - f2.i * gnrzz_1.con1.i, z__3.i = f2.r * 
	    gnrzz_1.con1.i + f2.i * gnrzz_1.con1.r;
    z__2.r = e2->r + z__3.r, z__2.i = e2->i + z__3.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    e2->r = z__1.r, e2->i = z__1.i;
    z__3.r = f3.r * gnrzz_1.con1.r - f3.i * gnrzz_1.con1.i, z__3.i = f3.r * 
	    gnrzz_1.con1.i + f3.i * gnrzz_1.con1.r;
    z__2.r = e3->r + z__3.r, z__2.i = e3->i + z__3.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    e3->r = z__1.r, e3->i = z__1.i;
    z__3.r = f4.r * gnrzz_1.con1.r - f4.i * gnrzz_1.con1.i, z__3.i = f4.r * 
	    gnrzz_1.con1.i + f4.i * gnrzz_1.con1.r;
    z__2.r = e4->r + z__3.r, z__2.i = e4->i + z__3.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    e4->r = z__1.r, e4->i = z__1.i;
    z__3.r = f5.r * gnrzz_1.con1.r - f5.i * gnrzz_1.con1.i, z__3.i = f5.r * 
	    gnrzz_1.con1.i + f5.i * gnrzz_1.con1.r;
    z__2.r = e5->r + z__3.r, z__2.i = e5->i + z__3.i;
    z__1.r = z__2.r * exjk.r - z__2.i * exjk.i, z__1.i = z__2.r * exjk.i + 
	    z__2.i * exjk.r;
    e5->r = z__1.r, e5->i = z__1.i;
    return 0;
L4:
    rz = sqrt(gnrzz_1.rho * gnrzz_1.rho + gnrzz_1.zz * gnrzz_1.zz);
    z__5.r = rz * gnrzz_1.ck2.r, z__5.i = rz * gnrzz_1.ck2.i;
    z__6.r = gnrzz_1.azp * gnrzz_1.ck1.r, z__6.i = gnrzz_1.azp * 
	    gnrzz_1.ck1.i;
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z__3.r = z__4.r * -0.f - z__4.i * -1.f, z__3.i = z__4.r * -1.f + z__4.i * 
	    -0.f;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / rsq, z__1.i = z__2.i / rsq;
    exjk.r = z__1.r, exjk.i = z__1.i;
    goto L6;
L5:
    rz = sqrt(gnrzz_1.rho * gnrzz_1.rho + gnrzz_1.azp * gnrzz_1.azp);
    z__5.r = gnrzz_1.zz * gnrzz_1.ck2.r, z__5.i = gnrzz_1.zz * gnrzz_1.ck2.i;
    z__6.r = rz * gnrzz_1.ck1.r, z__6.i = rz * gnrzz_1.ck1.i;
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z__3.r = z__4.r * -0.f - z__4.i * -1.f, z__3.i = z__4.r * -1.f + z__4.i * 
	    -0.f;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / rsq, z__1.i = z__2.i / rsq;
    exjk.r = z__1.r, exjk.i = z__1.i;
L6:
    z__1.r = e1->r * exjk.r - e1->i * exjk.i, z__1.i = e1->r * exjk.i + e1->i 
	    * exjk.r;
    e1->r = z__1.r, e1->i = z__1.i;
    z__1.r = e2->r * exjk.r - e2->i * exjk.i, z__1.i = e2->r * exjk.i + e2->i 
	    * exjk.r;
    e2->r = z__1.r, e2->i = z__1.i;
    z__1.r = e3->r * exjk.r - e3->i * exjk.i, z__1.i = e3->r * exjk.i + e3->i 
	    * exjk.r;
    e3->r = z__1.r, e3->i = z__1.i;
    z__1.r = e4->r * exjk.r - e4->i * exjk.i, z__1.i = e4->r * exjk.i + e4->i 
	    * exjk.r;
    e4->r = z__1.r, e4->i = z__1.i;
    z__1.r = e5->r * exjk.r - e5->i * exjk.i, z__1.i = e5->r * exjk.i + e5->i 
	    * exjk.r;
    e5->r = z__1.r, e5->i = z__1.i;
    return 0;
L7:
    s_wsfe(&io___1400);
    do_fio(&c__1, (char *)&gnrzz_1.rho, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&gnrzz_1.zz, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&gnrzz_1.azp, (ftnlen)sizeof(doublereal));
    e_wsfe();
    s_stop("", (ftnlen)0);

    return 0;
} /* intrpd_ */

integer isegno_(integer *itagi, integer *mx)
{
    /* Format strings */
    static char fmt_6[] = "(4x,\002ISEGNO: ERROR - PARAMETER SPECIFYING SEGM"
	    "ENT POSITIO\002,\002N IN A GROUP OF EQUAL TAGS MUST NOT BE ZER"
	    "O\002)";
    static char fmt_7[] = "(///,10x,\002ISEGNO: ERROR - NO SEGMENT HAS A TAG"
	    "-SEGMENT\002,\002 REFERENCE OF\002,2i7)";

    /* System generated locals */
    integer ret_val, i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, icnt;

    /* Fortran I/O blocks */
    static cilist io___1401 = { 0, 3, 0, fmt_6, 0 };
    static cilist io___1404 = { 0, 3, 0, fmt_7, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ISEGNO returns the segment number of the Mth segment having the */
/*     tag number ITAGI.  If ITAGI=0 segment number M is returned. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (*mx == 0) {
	s_wsfe(&io___1401);
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (*itagi == 0) {
	ret_val = *mx;
	return ret_val;
    }
    if (data_1.n >= 1) {
	icnt = 0;
	i__1 = data_1.n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (data_1.itag[i__ - 1] == *itagi) {
		++icnt;
		if (icnt == *mx) {
		    ret_val = i__;
		    return ret_val;
		}
	    }
/* L3: */
	}
    }
    s_wsfe(&io___1404);
    do_fio(&c__1, (char *)&(*itagi), (ftnlen)sizeof(integer));
    do_fio(&c__1, (char *)&(*mx), (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);

    return ret_val;
} /* isegno_ */

/* Subroutine */ int lfactr_(doublecomplex *a, integer *nrow, integer *ix1, 
	integer *ix2, integer *ip, integer *nbloks, integer *npblk, integer *
	nlast)
{
    /* Format strings */
    static char fmt_17[] = "(\002 LFACTR: PIVOT(\002,i3,\002)=\002,1pe16.8)";

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__, j, k, r__, j1, j2;
    static logical l1, l2, l3;
    static integer r1, r2, pj, pr, jp1;
    static doublecomplex ajr;
    static integer j2p1, j2p2, ixj, iflg;
    static doublereal dmax__, elmag;

    /* Fortran I/O blocks */
    static cilist io___1426 = { 0, 3, 0, fmt_17, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     LFACTR PERFORMS GAUSS-DOOLITTLE MANIPULATIONS ON THE TWO BLOCKS OF */
/*     THE TRANSPOSED MATRIX IN CORE STORAGE.  THE GAUSS-DOOLITTLE */
/*     ALGORITHM IS PRESENTED ON PAGES 411-416 OF A. RALSTON -- A FIRST */
/*     COURSE IN NUMERICAL ANALYSIS.  COMMENTS BELOW REFER TO COMMENTS IN */
/*     RALSTONS TEXT. */

/*     INPUT: */
/*     A = ARRAY CONTAINING TWO BLOCKS OF THE MATRIX FOR ELIMINATION */
/*     NROW = NUMBER OF ROWS IN EACH BLOCK */
/*     IX1 = NUMBER OF THE FIRST BLOCK STORED IN A */
/*     IX2 = NUMBER OF THE SECOND BLOCK STORED IN A */
/*     NBLOKS = NUMBER OF BLOCKS INTO WHICH EACH MATRIX IS DIVIDED */
/*     NPBLK = NUMBER OF COLUMNS IN THE BLOCKS (EXECPT THE LAST BLOCK) */
/*     NLAST = NUMBER OF COLUMNS IN THE LAST BLOCK */

/*     OUTPUT: */
/*     A = ARRAY CONTAINING COMPLETELY OR PARTIALLY FACTORED BLOCKS */
/*     IP = ARRAY OF PIVOT-ELEMENT INDICES FROM FACTORING */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --ip;
    a_dim1 = *nrow;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    iflg = 0;

/*     INITIALIZE R1,R2,J1,J2 */

    l1 = *ix1 == 1 && *ix2 == 2;
    l2 = *ix2 - 1 == *ix1;
    l3 = *ix2 == *nbloks;
    if (l1) {
	goto L1;
    }
    goto L2;
L1:
    r1 = 1;
    r2 = *npblk << 1;
    j1 = 1;
    j2 = -1;
    goto L5;
L2:
    r1 = *npblk + 1;
    r2 = *npblk << 1;
    j1 = (*ix1 - 1) * *npblk + 1;
    if (l2) {
	goto L3;
    }
    goto L4;
L3:
    j2 = j1 + *npblk - 2;
    goto L5;
L4:
    j2 = j1 + *npblk - 1;
L5:
    if (l3) {
	r2 = *npblk + *nlast;
    }
    i__1 = r2;
    for (r__ = r1; r__ <= i__1; ++r__) {

/*     STEP 1 */

	i__2 = *nrow;
	for (k = j1; k <= i__2; ++k) {
	    i__3 = k - 1;
	    i__4 = k + r__ * a_dim1;
	    scratm_1.d__[i__3].r = a[i__4].r, scratm_1.d__[i__3].i = a[i__4]
		    .i;
/* L6: */
	}

/*     STEPS 2 AND 3 */

	if (l1 || l2) {
	    ++j2;
	}
	if (j1 > j2) {
	    goto L9;
	}
	ixj = 0;
	i__2 = j2;
	for (j = j1; j <= i__2; ++j) {
	    ++ixj;
	    pj = ip[j];
	    i__3 = pj - 1;
	    ajr.r = scratm_1.d__[i__3].r, ajr.i = scratm_1.d__[i__3].i;
	    i__3 = j + r__ * a_dim1;
	    a[i__3].r = ajr.r, a[i__3].i = ajr.i;
	    i__3 = pj - 1;
	    i__4 = j - 1;
	    scratm_1.d__[i__3].r = scratm_1.d__[i__4].r, scratm_1.d__[i__3].i 
		    = scratm_1.d__[i__4].i;
	    jp1 = j + 1;
	    i__3 = *nrow;
	    for (i__ = jp1; i__ <= i__3; ++i__) {
		i__4 = i__ - 1;
		i__5 = i__ - 1;
		i__6 = i__ + ixj * a_dim1;
		z__2.r = a[i__6].r * ajr.r - a[i__6].i * ajr.i, z__2.i = a[
			i__6].r * ajr.i + a[i__6].i * ajr.r;
		z__1.r = scratm_1.d__[i__5].r - z__2.r, z__1.i = scratm_1.d__[
			i__5].i - z__2.i;
		scratm_1.d__[i__4].r = z__1.r, scratm_1.d__[i__4].i = z__1.i;
/* L7: */
	    }
/* L8: */
	}
L9:

/*     STEP 4 */

	j2p1 = j2 + 1;
	if (l1 || l2) {
	    goto L11;
	}
	if (*nrow < j2p1) {
	    goto L16;
	}
	i__2 = *nrow;
	for (i__ = j2p1; i__ <= i__2; ++i__) {
	    i__3 = i__ + r__ * a_dim1;
	    i__4 = i__ - 1;
	    a[i__3].r = scratm_1.d__[i__4].r, a[i__3].i = scratm_1.d__[i__4]
		    .i;
/* L10: */
	}
	goto L16;
L11:
	i__2 = j2p1 - 1;
	d_cnjg(&z__2, &scratm_1.d__[j2p1 - 1]);
	z__1.r = scratm_1.d__[i__2].r * z__2.r - scratm_1.d__[i__2].i * 
		z__2.i, z__1.i = scratm_1.d__[i__2].r * z__2.i + scratm_1.d__[
		i__2].i * z__2.r;
	dmax__ = z__1.r;
	ip[j2p1] = j2p1;
	j2p2 = j2 + 2;
	if (j2p2 > *nrow) {
	    goto L13;
	}
	i__2 = *nrow;
	for (i__ = j2p2; i__ <= i__2; ++i__) {
	    i__3 = i__ - 1;
	    d_cnjg(&z__2, &scratm_1.d__[i__ - 1]);
	    z__1.r = scratm_1.d__[i__3].r * z__2.r - scratm_1.d__[i__3].i * 
		    z__2.i, z__1.i = scratm_1.d__[i__3].r * z__2.i + 
		    scratm_1.d__[i__3].i * z__2.r;
	    elmag = z__1.r;
	    if (elmag < dmax__) {
		goto L12;
	    }
	    dmax__ = elmag;
	    ip[j2p1] = i__;
L12:
	    ;
	}
L13:
	if (dmax__ < 1e-10f) {
	    iflg = 1;
	}
	pr = ip[j2p1];
	i__2 = j2p1 + r__ * a_dim1;
	i__3 = pr - 1;
	a[i__2].r = scratm_1.d__[i__3].r, a[i__2].i = scratm_1.d__[i__3].i;
	i__2 = pr - 1;
	i__3 = j2p1 - 1;
	scratm_1.d__[i__2].r = scratm_1.d__[i__3].r, scratm_1.d__[i__2].i = 
		scratm_1.d__[i__3].i;

/*     STEP 5 */

	if (j2p2 > *nrow) {
	    goto L15;
	}
	z_div(&z__1, &c_b336, &a[j2p1 + r__ * a_dim1]);
	ajr.r = z__1.r, ajr.i = z__1.i;
	i__2 = *nrow;
	for (i__ = j2p2; i__ <= i__2; ++i__) {
	    i__3 = i__ + r__ * a_dim1;
	    i__4 = i__ - 1;
	    z__1.r = scratm_1.d__[i__4].r * ajr.r - scratm_1.d__[i__4].i * 
		    ajr.i, z__1.i = scratm_1.d__[i__4].r * ajr.i + 
		    scratm_1.d__[i__4].i * ajr.r;
	    a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L14: */
	}
L15:
	if (iflg == 0) {
	    goto L16;
	}
	s_wsfe(&io___1426);
	do_fio(&c__1, (char *)&j2, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&dmax__, (ftnlen)sizeof(doublereal));
	e_wsfe();
	iflg = 0;
L16:
	;
    }
    return 0;

} /* lfactr_ */

/* Subroutine */ int load_(doublereal *fmhz, doublecomplex *xk)
{
    /* Format strings */
    static char fmt_25[] = "(//,7x,\002LOCATION\002,10x,\002RESISTANCE\002,3"
	    "x,\002INDUCTANCE\002,2x,\002CAPACITANCE\002,7x,\002IMPEDANCE (OH"
	    "MS)\002,5x,\002CONDUCTIVITY\002,4x,\002TYPE\002,/,4x,\002ITAG"
	    "\002,\002 FROM THRU\002,10x,\002OHMS\002,8x,\002HENRYS\002,7x"
	    ",\002FARADS\002,8x,\002REAL\002,6x,\002IMAGINARY\002,4x,\002MHOS"
	    "/METER\002)";
    static char fmt_26[] = "(/,10x,\002NOTE: SOME OF THE ABOVE SEGMENTS HAVE"
	    " BEEN\002,\002 LOADED TWICE - IMPEDANCES ADDED\002)";
    static char fmt_27[] = "(/,10x,\002LOAD: IMPROPER LOAD TYPE CHOSEN, REQU"
	    "ESTED TYPE\002,\002 IS \002,i3)";
    static char fmt_29[] = "(\002 LOAD: ERROR - LOADING MAY NOT BE ADDED TO "
	    "SEGMENTS IN\002,\002 N.G.F. SECTION\002)";
    static char fmt_30[] = "(\002 LOAD: ERROR IN SPECIFYING LOADED SEGMENT"
	    "S\002)";
    static char fmt_28[] = "(/,10x,\002LOAD: LD COMMAND ERROR, NO SEGMENT HA"
	    "S A TAG NO.= \002,i5)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);

    /* Local variables */
    static integer i__, l1, l2;
    static doublecomplex zt;
    static integer nop;
    static doublereal rmu;
    static integer ichk;
    static doublecomplex omgj;
    static doublereal wlam;
    static integer jump;
    extern /* Subroutine */ int prnt_(integer *, integer *, integer *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, char *, ftnlen);
    extern /* Double Complex */ VOID zint_(doublecomplex *, doublereal *, 
	    doublereal *, doublereal *);
    static integer iwarn, istep, ldtags;

    /* Fortran I/O blocks */
    static cilist io___1429 = { 0, 3, 0, fmt_25, 0 };
    static cilist io___1433 = { 0, 3, 0, fmt_26, 0 };
    static cilist io___1438 = { 0, 3, 0, fmt_27, 0 };
    static cilist io___1441 = { 0, 3, 0, fmt_29, 0 };
    static cilist io___1442 = { 0, 3, 0, fmt_30, 0 };
    static cilist io___1445 = { 0, 3, 0, fmt_28, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     LOAD calculates the impedance of specified segments for various */
/*     types of loading. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    z__2.r = constn_1.tp * 0.f, z__2.i = constn_1.tp * 1e6f;
    z__1.r = *fmhz * z__2.r, z__1.i = *fmhz * z__2.i;
    omgj.r = z__1.r, omgj.i = z__1.i;
    wlam = constn_1.cvel / (*fmhz * 1e6f);

/*     PRINT HEADING */

    s_wsfe(&io___1429);
    e_wsfe();

/*     INITIALIZE D ARRAY, USED FOR TEMPORARY STORAGE OF LOADING */
/*     INFORMATION. */

    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
/* L1: */
	i__2 = i__ - 1;
	zload_1.zarray[i__2].r = 0.f, zload_1.zarray[i__2].i = 0.f;
    }
    iwarn = 0;

/*     CYCLE OVER LOADING COMMANDS */

    istep = 0;
L2:
    ++istep;
    if (istep > zload_1.nload) {
	if (iwarn == 1) {
	    s_wsfe(&io___1433);
	    e_wsfe();
	}
	if (data_1.n1 + (data_1.m1 << 1) > 0) {
	    return 0;
	}
	nop = data_1.n / data_1.np;
	if (nop == 1) {
	    return 0;
	}
	i__2 = data_1.np;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i__1 = i__ - 1;
	    zt.r = zload_1.zarray[i__1].r, zt.i = zload_1.zarray[i__1].i;
	    l1 = i__;
	    i__1 = nop;
	    for (l2 = 2; l2 <= i__1; ++l2) {
		l1 += data_1.np;
/* L3: */
		i__3 = l1 - 1;
		zload_1.zarray[i__3].r = zt.r, zload_1.zarray[i__3].i = zt.i;
	    }
	}
	return 0;
    }
    if (zload_1.ldtyp[istep - 1] > 5) {
	s_wsfe(&io___1438);
	do_fio(&c__1, (char *)&zload_1.ldtyp[istep - 1], (ftnlen)sizeof(
		integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    ldtags = zload_1.ldtag[istep - 1];
    jump = zload_1.ldtyp[istep - 1] + 1;

/*     SEARCH SEGMENTS FOR PROPER ITAGS */

    l1 = data_1.n2;
    l2 = data_1.n;
    if (ldtags == 0) {
	if (zload_1.ldtagf[istep - 1] != 0) {
	    l1 = zload_1.ldtagf[istep - 1];
	}
	if (zload_1.ldtagt[istep - 1] != 0) {
	    l2 = zload_1.ldtagt[istep - 1];
	}
	if (l1 <= data_1.n1) {
	    s_wsfe(&io___1441);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	if (l2 > data_1.n || l1 > l2) {
	    s_wsfe(&io___1442);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
    }
    ichk = 0;
    i__3 = l2;
    for (i__ = l1; i__ <= i__3; ++i__) {
	if (ldtags != 0) {
	    if (ldtags != data_1.itag[i__ - 1]) {
		goto L17;
	    }
	    if (zload_1.ldtagf[istep - 1] == 0) {
		ichk = 1;
	    } else {
		++ichk;
		if (ichk < zload_1.ldtagf[istep - 1] || ichk > zload_1.ldtagt[
			istep - 1]) {
		    goto L17;
		}
	    }
	} else {
	    ichk = 1;
	}

/*     CALCULATION OF LAMDA*IMPED. PER UNIT LENGTH, JUMP TO APPROPRIATE */
/*     SECTION FOR LOADING TYPE */

	if (jump == 1) {
	    i__1 = istep - 1;
	    i__2 = istep - 1;
	    z__2.r = zload_1.zli[i__2] * omgj.r, z__2.i = zload_1.zli[i__2] * 
		    omgj.i;
	    z__1.r = zload_1.zlr[i__1] + z__2.r, z__1.i = z__2.i;
	    zt.r = z__1.r, zt.i = z__1.i;
	    if ((d__1 = zload_1.zlc[istep - 1], abs(d__1)) > 1e-20f) {
		i__1 = istep - 1;
		z__3.r = zload_1.zlc[i__1] * omgj.r, z__3.i = zload_1.zlc[
			i__1] * omgj.i;
		z_div(&z__2, &c_b336, &z__3);
		z__1.r = zt.r + z__2.r, z__1.i = zt.i + z__2.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	} else if (jump == 2) {
	    i__1 = istep - 1;
	    z__1.r = zload_1.zlc[i__1] * omgj.r, z__1.i = zload_1.zlc[i__1] * 
		    omgj.i;
	    zt.r = z__1.r, zt.i = z__1.i;
	    if ((d__1 = zload_1.zli[istep - 1], abs(d__1)) > 1e-20f) {
		i__1 = istep - 1;
		z__3.r = zload_1.zli[i__1] * omgj.r, z__3.i = zload_1.zli[
			i__1] * omgj.i;
		z_div(&z__2, &c_b336, &z__3);
		z__1.r = zt.r + z__2.r, z__1.i = zt.i + z__2.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	    if ((d__1 = zload_1.zlr[istep - 1], abs(d__1)) > 1e-20f) {
		d__2 = 1.f / zload_1.zlr[istep - 1];
		z__1.r = zt.r + d__2, z__1.i = zt.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	    z_div(&z__1, &c_b336, &zt);
	    zt.r = z__1.r, zt.i = z__1.i;
	} else if (jump == 3) {
	    i__1 = istep - 1;
	    i__2 = istep - 1;
	    z__3.r = zload_1.zli[i__2] * omgj.r, z__3.i = zload_1.zli[i__2] * 
		    omgj.i;
	    z__2.r = zload_1.zlr[i__1] + z__3.r, z__2.i = z__3.i;
	    i__4 = i__ - 1;
	    z__1.r = data_1.si[i__4] * z__2.r, z__1.i = data_1.si[i__4] * 
		    z__2.i;
	    zt.r = z__1.r, zt.i = z__1.i;
	    if ((d__1 = zload_1.zlc[istep - 1], abs(d__1)) > 1e-20f) {
		i__1 = istep - 1;
		z__4.r = zload_1.zlc[i__1] * omgj.r, z__4.i = zload_1.zlc[
			i__1] * omgj.i;
		i__2 = i__ - 1;
		z__3.r = data_1.si[i__2] * z__4.r, z__3.i = data_1.si[i__2] * 
			z__4.i;
		z_div(&z__2, &c_b336, &z__3);
		z__1.r = zt.r + z__2.r, z__1.i = zt.i + z__2.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	} else if (jump == 4) {
	    i__1 = istep - 1;
	    z__2.r = zload_1.zlc[i__1] * omgj.r, z__2.i = zload_1.zlc[i__1] * 
		    omgj.i;
	    i__2 = i__ - 1;
	    z__1.r = data_1.si[i__2] * z__2.r, z__1.i = data_1.si[i__2] * 
		    z__2.i;
	    zt.r = z__1.r, zt.i = z__1.i;
	    if ((d__1 = zload_1.zli[istep - 1], abs(d__1)) > 1e-20f) {
		i__1 = istep - 1;
		z__4.r = zload_1.zli[i__1] * omgj.r, z__4.i = zload_1.zli[
			i__1] * omgj.i;
		i__2 = i__ - 1;
		z__3.r = data_1.si[i__2] * z__4.r, z__3.i = data_1.si[i__2] * 
			z__4.i;
		z_div(&z__2, &c_b336, &z__3);
		z__1.r = zt.r + z__2.r, z__1.i = zt.i + z__2.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	    if ((d__1 = zload_1.zlr[istep - 1], abs(d__1)) > 1e-20f) {
		d__2 = 1.f / (zload_1.zlr[istep - 1] * data_1.si[i__ - 1]);
		z__1.r = zt.r + d__2, z__1.i = zt.i;
		zt.r = z__1.r, zt.i = z__1.i;
	    }
	    z_div(&z__1, &c_b336, &zt);
	    zt.r = z__1.r, zt.i = z__1.i;
	} else if (jump == 5) {
	    i__1 = istep - 1;
	    i__2 = istep - 1;
	    z__1.r = zload_1.zlr[i__1], z__1.i = zload_1.zli[i__2];
	    zt.r = z__1.r, zt.i = z__1.i;
	} else if (jump == 6) {
	    rmu = zload_1.zli[istep - 1];
	    if (rmu == 0.f) {
		rmu = 1.f;
	    }
	    d__1 = zload_1.zlr[istep - 1] * wlam;
	    d__2 = data_1.bi[i__ - 1] / wlam;
	    zint_(&z__3, &d__1, &rmu, &d__2);
	    i__1 = i__ - 1;
	    z__2.r = data_1.si[i__1] * z__3.r, z__2.i = data_1.si[i__1] * 
		    z__3.i;
	    z__1.r = z__2.r / wlam, z__1.i = z__2.i / wlam;
	    zt.r = z__1.r, zt.i = z__1.i;
	}
	i__1 = i__ - 1;
	if ((d__1 = zload_1.zarray[i__1].r, abs(d__1)) + (d__2 = d_imag(&
		zload_1.zarray[i__ - 1]), abs(d__2)) > 1e-20f) {
	    iwarn = 1;
	}
	i__1 = i__ - 1;
	i__2 = i__ - 1;
	i__4 = i__ - 1;
	z__3.r = data_1.si[i__4] * xk->r, z__3.i = data_1.si[i__4] * xk->i;
	z_div(&z__2, &zt, &z__3);
	z__1.r = zload_1.zarray[i__2].r + z__2.r, z__1.i = zload_1.zarray[
		i__2].i + z__2.i;
	zload_1.zarray[i__1].r = z__1.r, zload_1.zarray[i__1].i = z__1.i;
L17:
	;
    }
    if (ichk == 0) {
	s_wsfe(&io___1445);
	do_fio(&c__1, (char *)&ldtags, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }

/*     PRINTING THE SEGMENT LOADING DATA, JUMP TO PROPER PRINT */

    if (jump == 1) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &zload_1.zlr[istep - 1], &zload_1.zli[istep - 1], &
		zload_1.zlc[istep - 1], &c_b332, &c_b332, &c_b332, " SERIES ",
		 (ftnlen)8);
    } else if (jump == 2) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &zload_1.zlr[istep - 1], &zload_1.zli[istep - 1], &
		zload_1.zlc[istep - 1], &c_b332, &c_b332, &c_b332, "PARALLEL",
		 (ftnlen)8);
    } else if (jump == 3) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &zload_1.zlr[istep - 1], &zload_1.zli[istep - 1], &
		zload_1.zlc[istep - 1], &c_b332, &c_b332, &c_b332, " SERIES "
		"(PER METER) ", (ftnlen)20);
    } else if (jump == 4) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &zload_1.zlr[istep - 1], &zload_1.zli[istep - 1], &
		zload_1.zlc[istep - 1], &c_b332, &c_b332, &c_b332, "PARALLEL"
		" (PER METER)", (ftnlen)20);
    } else if (jump == 5) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &c_b332, &c_b332, &c_b332, &zload_1.zlr[istep - 1], &
		zload_1.zli[istep - 1], &c_b332, "FIXED IMPEDANCE ", (ftnlen)
		16);
    } else if (jump == 6) {
	prnt_(&ldtags, &zload_1.ldtagf[istep - 1], &zload_1.ldtagt[istep - 1],
		 &c_b332, &c_b332, &c_b332, &c_b332, &c_b332, &zload_1.zlr[
		istep - 1], "  WIRE  ", (ftnlen)8);
    }
    goto L2;

} /* load_ */

/* Subroutine */ int ltsolv_(doublecomplex *a, integer *nrow, integer *ip, 
	doublecomplex *b, integer *neq, integer *nrh, integer *nbloks, 
	integer *npblk, integer *nlast, integer *krec, integer *iunit)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, 
	    i__6;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, j, k, i2, k2, ic, kp, jm1, jp1, ipi, jst;
    static doublecomplex sum;
    static integer ibrec;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static integer ixblk1;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     LTSOLV SOLVES THE MATRIX EQ. Y(R)*LU(T)=B(R) WHERE (R) DENOTES ROW */
/*     VECTOR AND LU(T) DENOTES THE LU DECOMPOSITION OF THE TRANSPOSE OF */
/*     THE ORIGINAL COEFFICIENT MATRIX.  THE LU(T) DECOMPOSITION IS */
/*     STORED UNIT IUNIT. */

/*     INPUT: */
/*     A = ARRAY FOR STORAGE OF MATRIX BLOCKS READ FROM DISK */
/*     NROW = NUMBER OF ROWS IN EACH BLOCK */
/*     IP = ARRAY OF PIVOT-ELEMENT INDICES */
/*     B = ARRAY REPRESENTING RIGHT-HAND SIDE(S) OF THE MATRIX EQUATION */
/*     NEQ = NUMBER OF EQUATIONS (NROW * NUMBER OF SYMETRIC SECTIONS) */
/*     NRH = NUMBER OF RIGHT-HAND SIDE VECTORS TO BE SOLVED */
/*     NBLOKS = NUMBER OF BLOCKS INTO WHICH EACH MATRIX IS DIVIDED */
/*     NPBLK = NUMBER OF COLUMNS IN THE BLOCKS (EXECPT THE LAST BLOCK) */
/*     NLAST = NUMBER OF COLUMNS IN THE LAST BLOCK */
/*     KREC = INCREMENT ADDED TO BLOCK NUMBER TO GET RECORD IN THE RIGHT */
/*            SUBMATRIX */
/*     IUNIT = LOGICAL UNIT NUMBER FOR THE DISK FILE */

/*     OUTPUT: */
/*     B = SOLUTION VECTOR(S) FOR EACH OF THE NRH RIGHT-HAND SIDES */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


/*     FORWARD SUBSTITUTION */

    /* Parameter adjustments */
    a_dim1 = *nrow;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ip;
    b_dim1 = *neq;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    i2 = *npblk * *nrow;
    i__1 = *nbloks;
    for (ixblk1 = 1; ixblk1 <= i__1; ++ixblk1) {
	i__2 = ixblk1 + *krec;
	recin_(&a[a_offset], iunit, &c__1, &i2, &i__2, "First read in LTSOLV",
		 (ftnlen)20);
	k2 = *npblk;
	if (ixblk1 == *nbloks) {
	    k2 = *nlast;
	}
	jst = (ixblk1 - 1) * *npblk;
	i__2 = *nrh;
	for (ic = 1; ic <= i__2; ++ic) {
	    j = jst;
	    i__3 = k2;
	    for (k = 1; k <= i__3; ++k) {
		jm1 = j;
		++j;
		sum.r = 0.f, sum.i = 0.f;
		if (jm1 < 1) {
		    goto L2;
		}
		i__4 = jm1;
		for (i__ = 1; i__ <= i__4; ++i__) {
/* L1: */
		    i__5 = i__ + k * a_dim1;
		    i__6 = i__ + ic * b_dim1;
		    z__2.r = a[i__5].r * b[i__6].r - a[i__5].i * b[i__6].i, 
			    z__2.i = a[i__5].r * b[i__6].i + a[i__5].i * b[
			    i__6].r;
		    z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
		    sum.r = z__1.r, sum.i = z__1.i;
		}
L2:
		i__5 = j + ic * b_dim1;
		i__6 = j + ic * b_dim1;
		z__2.r = b[i__6].r - sum.r, z__2.i = b[i__6].i - sum.i;
		z_div(&z__1, &z__2, &a[j + k * a_dim1]);
		b[i__5].r = z__1.r, b[i__5].i = z__1.i;
/* L3: */
	    }
/* L4: */
	}
    }

/*     BACKWARD SUBSTITUTION */

    jst = *nrow + 1;
    i__2 = *nbloks;
    for (ixblk1 = 1; ixblk1 <= i__2; ++ixblk1) {
	ibrec = *nbloks - ixblk1 + 1;
	if (ibrec < *nbloks) {
	    i__1 = ibrec + *krec;
	    recin_(&a[a_offset], iunit, &c__1, &i2, &i__1, "Second read in L"
		    "TSOLV", (ftnlen)21);
	}
	k2 = *npblk;
	if (ixblk1 == 1) {
	    k2 = *nlast;
	}
	i__1 = *nrh;
	for (ic = 1; ic <= i__1; ++ic) {
	    kp = k2 + 1;
	    j = jst;
	    i__3 = k2;
	    for (k = 1; k <= i__3; ++k) {
		--kp;
		jp1 = j;
		--j;
		sum.r = 0.f, sum.i = 0.f;
		if (*nrow < jp1) {
		    goto L6;
		}
		i__5 = *nrow;
		for (i__ = jp1; i__ <= i__5; ++i__) {
/* L5: */
		    i__6 = i__ + kp * a_dim1;
		    i__4 = i__ + ic * b_dim1;
		    z__2.r = a[i__6].r * b[i__4].r - a[i__6].i * b[i__4].i, 
			    z__2.i = a[i__6].r * b[i__4].i + a[i__6].i * b[
			    i__4].r;
		    z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
		    sum.r = z__1.r, sum.i = z__1.i;
		}
		i__6 = j + ic * b_dim1;
		i__4 = j + ic * b_dim1;
		z__1.r = b[i__4].r - sum.r, z__1.i = b[i__4].i - sum.i;
		b[i__6].r = z__1.r, b[i__6].i = z__1.i;
L6:
		;
	    }
/* L7: */
	}
/* L8: */
	jst -= k2;
    }

/*     UNSCRAMBLE SOLUTION */

    i__2 = *nrh;
    for (ic = 1; ic <= i__2; ++ic) {
	i__1 = *nrow;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    ipi = ip[i__];
/* L9: */
	    i__3 = ipi - 1;
	    i__6 = i__ + ic * b_dim1;
	    scratm_2.y[i__3].r = b[i__6].r, scratm_2.y[i__3].i = b[i__6].i;
	}
	i__3 = *nrow;
	for (i__ = 1; i__ <= i__3; ++i__) {
/* L10: */
	    i__6 = i__ + ic * b_dim1;
	    i__1 = i__ - 1;
	    b[i__6].r = scratm_2.y[i__1].r, b[i__6].i = scratm_2.y[i__1].i;
	}
    }
    return 0;
} /* ltsolv_ */

/* Subroutine */ int lunscr_(doublecomplex *a, integer *nrow, integer *nop, 
	integer *ip, integer *ix, integer *nbloks, integer *npblk, integer *
	iunit)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;

    /* Local variables */
    static integer i__, j, k, i1, i2, k1, j2, ka, kk, nm1, ixi, ixk, ipt, 
	    krec;
    static doublecomplex temp;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen), recot_(doublecomplex *, 
	    integer *, integer *, integer *, integer *, char *, ftnlen);
    static integer ixblk1;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     LUNSCR UNSCRAMBLES THE FACTORED MATRIX ON DISK ACCORDING TO ROW */
/*     INTERCHANGES USED FOR PIVOT ELEMENTS.  MULTIPLE SUB-MATRICES FROM */
/*     THE SOLUTION OF A CIRCULANT MATRIX WILL BE PROCESSED WHEN THEY ARE */
/*     STORED SEQUENTIALLY ON THE DISK. */

/*     INPUT: */
/*     A = ARRAY FOR STORAGE OF THE MATRIX BLOCK WHILE IT IS PROCESSED */
/*     NROW = NUMBER OF ROWS IN THE BLOCK */
/*     NOP = NUMBER OF SUB-MATRICES IN A CIRCULANT MATRIX SOLUTION */
/*     IX = ARRAY OF PIVOT-ELEMENT INDICES */
/*     NBLOKS = NUMBER OF BLOCKS INTO WHICH EACH MATRIX IS DIVIDED */
/*     NPBLK = NUMBER OF COLUMNS IN THE BLOCKS (EXECPT THE LAST BLOCK) */
/*     IUNIT = LOGICAL UNIT NUMBER FOR THE DISK FILE */

/*     OUTPUT: */
/*     IP = ARRAY OF PIVOT-ELEMENT INDICES FROM FACTORING */

    /* Parameter adjustments */
    --ix;
    --ip;
    a_dim1 = *nrow;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    i1 = 1;
    i2 = *npblk * *nrow;
    nm1 = *nrow - 1;
    i__1 = *nop;
    for (kk = 1; kk <= i__1; ++kk) {
	ka = (kk - 1) * *nrow;
	krec = (kk - 1) * *nbloks;
	i__2 = *nbloks;
	for (ixblk1 = 1; ixblk1 <= i__2; ++ixblk1) {
	    i__3 = ixblk1 + krec;
	    recin_(&a[a_offset], iunit, &i1, &i2, &i__3, "Read in sub. LUNSCR"
		    , (ftnlen)19);
	    k1 = (ixblk1 - 1) * *npblk + 2;
	    if (nm1 < k1) {
		goto L3;
	    }
	    j2 = 0;
	    i__3 = nm1;
	    for (k = k1; k <= i__3; ++k) {
		if (j2 < *npblk) {
		    ++j2;
		}
		ixk = ix[k + ka];
		i__4 = j2;
		for (j = 1; j <= i__4; ++j) {
		    i__5 = k + j * a_dim1;
		    temp.r = a[i__5].r, temp.i = a[i__5].i;
		    i__5 = k + j * a_dim1;
		    i__6 = ixk + j * a_dim1;
		    a[i__5].r = a[i__6].r, a[i__5].i = a[i__6].i;
		    i__5 = ixk + j * a_dim1;
		    a[i__5].r = temp.r, a[i__5].i = temp.i;
/* L1: */
		}
/* L2: */
	    }
L3:
	    i__3 = ixblk1 + krec;
	    recot_(&a[a_offset], iunit, &i1, &i2, &i__3, "Write in sub. LUNS"
		    "CR", (ftnlen)20);
/* L4: */
	}
	i__2 = *nrow;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    ip[i__ + ka] = i__;
/* L6: */
	}
	i__2 = *nrow;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    ixi = ix[i__ + ka];
	    ipt = ip[i__ + ka];
	    ip[i__ + ka] = ip[ixi + ka];
	    ip[ixi + ka] = ipt;
/* L7: */
	}
/* L9: */
    }
    return 0;
} /* lunscr_ */

/* Subroutine */ int move_(doublereal *rox, doublereal *roy, doublereal *roz, 
	doublereal *xs, doublereal *ys, doublereal *zs, integer *nrpt, 
	integer *itgi, integer *it1, integer *is1, integer *it2, integer *is2)
{
    /* Format strings */
    static char fmt_90[] = "(/,\002 MOVE: ERROR - SEGMENTS FROM AN NGF FILE "
	    "CAN NOT BE\002,\002 MOVED\002)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    double sin(doublereal), cos(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, k, i1, i2;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static integer ii, ir, kr, ix;
    static doublereal xi, yi, zi, xx, xy, xz, yx, yy, yz, zx, zy, zz;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    static integer ldi;
    static doublereal cph, cth, cps, sph, sth;
    static integer nrp;
    static doublereal sps;
    extern integer isegno_(integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1501 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     MOVE moves the structure with respect to its coordinate system or */
/*     reproduces the structure in new positions.  The structure is */
/*     rotated about X,Y,Z axes by ROX,ROY,ROZ respectively, then */
/*     shifted by XS,YS,ZS. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (abs(*rox) + abs(*roy) > 1e-10f) {
	data_1.ipsym *= 3;
    }
    sps = sin(*rox);
    cps = cos(*rox);
    sth = sin(*roy);
    cth = cos(*roy);
    sph = sin(*roz);
    cph = cos(*roz);
    xx = cph * cth;
    xy = cph * sth * sps - sph * cps;
    xz = cph * sth * cps + sph * sps;
    yx = sph * cth;
    yy = sph * sth * sps + cph * cps;
    yz = sph * sth * cps - cph * sps;
    zx = -sth;
    zy = cth * sps;
    zz = cth * cps;
    nrp = *nrpt;
    if (*nrpt == 0) {
	nrp = 1;
    }
    ix = 1;
    if (data_1.n >= data_1.n2) {
	i1 = isegno_(it1, is1);
	i2 = isegno_(it2, is2);
	if (i1 < data_1.n2) {
	    i1 = data_1.n2;
	}
	if (i2 < data_1.n2) {
	    s_wsfe(&io___1501);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	if (i1 != 1 || i2 != data_1.n) {
	    ix = 2;
	}
	k = data_1.n;
	if (*nrpt == 0) {
	    k = i1 - 1;
	}
	i__1 = nrp;
	for (ir = 1; ir <= i__1; ++ir) {
	    i__2 = i2;
	    for (i__ = i1; i__ <= i__2; ++i__) {
		++k;
		xi = data_1.x[i__ - 1];
		yi = data_1.y[i__ - 1];
		zi = data_1.z__[i__ - 1];
		data_1.x[k - 1] = xi * xx + yi * xy + zi * xz + *xs;
		data_1.y[k - 1] = xi * yx + yi * yy + zi * yz + *ys;
		data_1.z__[k - 1] = xi * zx + yi * zy + zi * zz + *zs;
		xi = x2[i__ - 1];
		yi = y2[i__ - 1];
		zi = z2[i__ - 1];
		x2[k - 1] = xi * xx + yi * xy + zi * xz + *xs;
		y2[k - 1] = xi * yx + yi * yy + zi * yz + *ys;
		z2[k - 1] = xi * zx + yi * zy + zi * zz + *zs;
		data_1.bi[k - 1] = data_1.bi[i__ - 1];
		data_1.itag[k - 1] = data_1.itag[i__ - 1];
		if (data_1.itag[i__ - 1] != 0) {
		    data_1.itag[k - 1] = data_1.itag[i__ - 1] + *itgi;
		}
/* L1: */
	    }
	    i1 = data_1.n + 1;
	    i2 = k;
	    if (*nrpt > 0) {
		data_1.n = k;
	    }
/* L2: */
	}
    }
    if (data_1.m >= data_1.m2) {
	i1 = data_1.m2;
	k = data_1.m;
	ldi = data_1.ld + 1;
	if (*nrpt == 0) {
	    k = data_1.m1;
	}
	i__1 = nrp;
	for (ii = 1; ii <= i__1; ++ii) {
	    i__2 = data_1.m;
	    for (i__ = i1; i__ <= i__2; ++i__) {
		++k;
		ir = ldi - i__;
		kr = ldi - k;
		xi = data_1.x[ir - 1];
		yi = data_1.y[ir - 1];
		zi = data_1.z__[ir - 1];
		data_1.x[kr - 1] = xi * xx + yi * xy + zi * xz + *xs;
		data_1.y[kr - 1] = xi * yx + yi * yy + zi * yz + *ys;
		data_1.z__[kr - 1] = xi * zx + yi * zy + zi * zz + *zs;
		xi = t1x[ir - 1];
		yi = t1y[ir - 1];
		zi = t1z[ir - 1];
		t1x[kr - 1] = xi * xx + yi * xy + zi * xz;
		t1y[kr - 1] = xi * yx + yi * yy + zi * yz;
		t1z[kr - 1] = xi * zx + yi * zy + zi * zz;
		xi = data_1.t2x[ir - 1];
		yi = data_1.t2y[ir - 1];
		zi = data_1.t2z[ir - 1];
		data_1.t2x[kr - 1] = xi * xx + yi * xy + zi * xz;
		data_1.t2y[kr - 1] = xi * yx + yi * yy + zi * yz;
		data_1.t2z[kr - 1] = xi * zx + yi * zy + zi * zz;
		data_1.salp[kr - 1] = data_1.salp[ir - 1];
		data_1.bi[kr - 1] = data_1.bi[ir - 1];
/* L4: */
	    }
	    i1 = data_1.m + 1;
	    data_1.m = k;
/* L5: */
	}
    }
    if (*nrpt == 0 && ix == 1) {
	return 0;
    }
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    return 0;

} /* move_ */

#undef t1z
#undef t1y
#undef t1x
#undef z2
#undef y2
#undef x2


/* Subroutine */ int nfpat_(void)
{
    /* Format strings */
    static char fmt_10[] = "(///,38x,\002- - - NEAR ELECTRIC FIELDS - - -"
	    "\002,//,14x,\002-  LOCATION  -\002,21x,\002-  EX  -\002,15x,\002"
	    "-  EY  -\002,15x,\002-  EZ  -\002,/,8x,\002X\002,11x,\002Y\002,1"
	    "1x,\002Z\002,11x,\002MAGNITUDE\002,3x,\002PHASE\002,6x,\002MAGNI"
	    "TUDE\002,3x,\002PHASE\002,6x,\002MAGNITUDE\002,3x,\002PHASE\002,"
	    "/,6x,\002METERS\002,6x,\002METERS\002,6x,\002METERS\002,9x,\002V"
	    "OLTS/M\002,3x,\002DEGREES\002,6x,\002VOLTS/M\002,3x,\002DEGREE"
	    "S\002,6x,\002VOLTS/M\002,3x,\002DEGREES\002)";
    static char fmt_12[] = "(///,38x,\002- - - NEAR MAGNETIC FIELDS - - -"
	    "\002,//,14x,\002-  LOCATION  -\002,21x,\002-  HX  -\002,15x,\002"
	    "-  HY  -\002,15x,\002-  HZ  -\002,/,8x,\002X\002,11x,\002Y\002,1"
	    "1x,\002Z\002,11x,\002MAGNITUDE\002,3x,\002PHASE\002,6x,\002MAGNI"
	    "TUDE\002,3x,\002PHASE\002,6x,\002MAGNITUDE\002,3x,\002PHASE\002,"
	    "/,6x,\002METERS\002,6x,\002METERS\002,6x,\002METERS\002,10x,\002"
	    "AMPS/M\002,3x,\002DEGREES\002,7x,\002AMPS/M\002,3x,\002DEGREE"
	    "S\002,7x,\002AMPS/M\002,3x,\002DEGREES\002)";
    static char fmt_11[] = "(2x,3f12.4,1x,3(3x,1pe11.4,2x,0pf7.2))";

    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double cos(doublereal), sin(doublereal), z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, j, kk;
    static doublecomplex ex, ey, ez;
    static doublereal cph, cth, xob, sph, yob, zob, sth, tmp1, tmp2, tmp3, 
	    tmp4, tmp5, tmp6;
    extern doublereal cang_(doublecomplex *);
    static doublereal xnrt, ynrt, znrt;
    extern /* Subroutine */ int nefld_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *), nhfld_(
	    doublereal *, doublereal *, doublereal *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Fortran I/O blocks */
    static cilist io___1511 = { 0, 3, 0, fmt_10, 0 };
    static cilist io___1512 = { 0, 3, 0, fmt_12, 0 };
    static cilist io___1535 = { 0, 3, 0, fmt_11, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NFPAT computes near E or H fields over a range of points. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (nfdat_1.nfeh == 0) {
	s_wsfe(&io___1511);
	e_wsfe();
    } else {
	s_wsfe(&io___1512);
	e_wsfe();
    }
    znrt = nfdat_1.znr - nfdat_1.dznr;
    i__1 = nfdat_1.nrz;
    for (i__ = 1; i__ <= i__1; ++i__) {
	znrt += nfdat_1.dznr;
	if (nfdat_1.near__ != 0) {
	    cph = cos(constn_1.dtorad * znrt);
	    sph = sin(constn_1.dtorad * znrt);
	}
	ynrt = nfdat_1.ynr - nfdat_1.dynr;
	i__2 = nfdat_1.nry;
	for (j = 1; j <= i__2; ++j) {
	    ynrt += nfdat_1.dynr;
	    if (nfdat_1.near__ != 0) {
		cth = cos(constn_1.dtorad * ynrt);
		sth = sin(constn_1.dtorad * ynrt);
	    }
	    xnrt = nfdat_1.xnr - nfdat_1.dxnr;
	    i__3 = nfdat_1.nrx;
	    for (kk = 1; kk <= i__3; ++kk) {
		xnrt += nfdat_1.dxnr;
		if (nfdat_1.near__ != 0) {
		    xob = xnrt * sth * cph;
		    yob = xnrt * sth * sph;
		    zob = xnrt * cth;
		} else {
		    xob = xnrt;
		    yob = ynrt;
		    zob = znrt;
		}
		tmp1 = xob;
		tmp2 = yob;
		tmp3 = zob;
		if (nfdat_1.nfeh == 0) {
		    nefld_(&tmp1, &tmp2, &tmp3, &ex, &ey, &ez);
		} else {
		    nhfld_(&tmp1, &tmp2, &tmp3, &ex, &ey, &ez);
		}
		tmp1 = z_abs(&ex);
		tmp2 = cang_(&ex);
		tmp3 = z_abs(&ey);
		tmp4 = cang_(&ey);
		tmp5 = z_abs(&ez);
		tmp6 = cang_(&ez);
		s_wsfe(&io___1535);
		do_fio(&c__1, (char *)&xob, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&yob, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&zob, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp4, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp5, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp6, (ftnlen)sizeof(doublereal));
		e_wsfe();
/* L9: */
	    }
	}
    }
    return 0;

} /* nfpat_ */

/* Subroutine */ int nfline_(void)
{
    /* Format strings */
    static char fmt_10[] = "(///,38x,\002- - - NEAR ELECTRIC FIELDS - - -"
	    "\002,/)";
    static char fmt_91[] = "(\002 Unit Vectors:\002,6x,\002X\002,8x,\002Y"
	    "\002,8x,\002Z\002,/,\002 Axial\002,7x,\002= \002,3f9.5,/,\002 Tr"
	    "ansverse1 = \002,2f9.5,/,\002 Transverse2 = \002,3f9.5,/)";
    static char fmt_12[] = "(14x,\002-  LOCATION  -\002,20x,\002- Axial -"
	    "\002,11x,\002- Transverse1 -\002,7x,\002- Transverse2 -\002,/,8x,"
	    "\002X\002,11x,\002Y\002,11x,\002Z\002,11x,\002MAGNITUDE\002,3x"
	    ",\002PHASE\002,6x,\002MAGNITUDE\002,3x,\002PHASE\002,6x,\002MAGN"
	    "ITUDE\002,3x,\002PHASE\002,/,6x,\002METERS\002,6x,\002METERS\002"
	    ",6x,\002METERS\002,9x,a5,\002/M\002,3x,\002DEGREES\002,6x,a5,"
	    "\002/M\002,3x,\002DEGREES\002,6x,a5,\002/M\002,3x,\002DEGREES"
	    "\002)";
    static char fmt_11[] = "(///,38x,\002- - - NEAR MAGNETIC FIELDS - - -"
	    "\002,/)";
    static char fmt_94[] = "(2x,3f12.4,1x,3(3x,1pe11.4,2x,0pf7.2))";
    static char fmt_92[] = "(//,\002 Line integral of E       = \002,1p2e12."
	    "5,\002 Volts\002,/,\002 Cumulative line integral = \002,2e12.5"
	    ",\002 Volts\002)";
    static char fmt_93[] = "(//,\002 Line integral of H       = \002,1p2e12."
	    "5,\002 Amps\002,/,\002 Cumulative line integral = \002,2e12.5"
	    ",\002 Amps\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double sqrt(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    double z_abs(doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublecomplex ea, eh, ev;
    static doublereal dx;
    static doublecomplex ex, ey, ez;
    static doublereal dy, dz, xob, yob, zob, uax, uay, uaz, uhx, uhy, uvx, 
	    uvy, uvz;
    extern doublereal cang_(doublecomplex *);
    static doublereal eaph, dlen, ehph, evph, eamag, ehmag;
    extern /* Subroutine */ int nefld_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *), nhfld_(
	    doublereal *, doublereal *, doublereal *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    static doublereal evmag, uhmag;
    static doublecomplex enint;

    /* Fortran I/O blocks */
    static cilist io___1549 = { 0, 3, 0, fmt_10, 0 };
    static cilist io___1550 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___1551 = { 0, 3, 0, fmt_12, 0 };
    static cilist io___1552 = { 0, 3, 0, fmt_11, 0 };
    static cilist io___1553 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___1554 = { 0, 3, 0, fmt_12, 0 };
    static cilist io___1572 = { 0, 3, 0, fmt_94, 0 };
    static cilist io___1573 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___1574 = { 0, 3, 0, fmt_93, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NFLINE computes near E or H fields along a line in space. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    dx = nfdat_1.dxnr - nfdat_1.xnr;
    dy = nfdat_1.dynr - nfdat_1.ynr;
    dz = nfdat_1.dznr - nfdat_1.znr;
    if (nfdat_1.nrx > 1) {
	dx /= nfdat_1.nrx - 1.f;
	dy /= nfdat_1.nrx - 1.f;
	dz /= nfdat_1.nrx - 1.f;
    }
/* Computing 2nd power */
    d__1 = dx;
/* Computing 2nd power */
    d__2 = dy;
/* Computing 2nd power */
    d__3 = dz;
    dlen = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    if (dlen > 1e-20f) {
	uax = dx / dlen;
	uay = dy / dlen;
	uaz = dz / dlen;
    } else {
	uax = 1.f;
	uay = 0.f;
	uaz = 0.f;
    }
    uhx = -uay;
    uhy = uax;
/* Computing 2nd power */
    d__1 = uhx;
/* Computing 2nd power */
    d__2 = uhy;
    uhmag = sqrt(d__1 * d__1 + d__2 * d__2);
    if (uhmag > 1e-20f) {
	uhx /= uhmag;
	uhy /= uhmag;
	uvx = -uaz * uhy;
	uvy = uaz * uhx;
	uvz = uax * uhy - uay * uhx;
    } else {
	uhx = 1.f;
	uhy = 0.f;
	uvx = 0.f;
	uvy = 1.f;
	uvz = 0.f;
	if (uaz < 0.f) {
	    uvy = -1.f;
	}
    }
    if (nfdat_1.nfeh == 0) {
	s_wsfe(&io___1549);
	e_wsfe();
	s_wsfe(&io___1550);
	do_fio(&c__1, (char *)&uax, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uay, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uaz, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uhx, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uhy, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvx, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvy, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvz, (ftnlen)sizeof(doublereal));
	e_wsfe();
	s_wsfe(&io___1551);
	do_fio(&c__1, "VOLTS", (ftnlen)5);
	do_fio(&c__1, "VOLTS", (ftnlen)5);
	do_fio(&c__1, "VOLTS", (ftnlen)5);
	e_wsfe();
    } else {
	s_wsfe(&io___1552);
	e_wsfe();
	s_wsfe(&io___1553);
	do_fio(&c__1, (char *)&uax, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uay, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uaz, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uhx, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uhy, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvx, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvy, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&uvz, (ftnlen)sizeof(doublereal));
	e_wsfe();
	s_wsfe(&io___1554);
	do_fio(&c__1, " AMPS", (ftnlen)5);
	do_fio(&c__1, " AMPS", (ftnlen)5);
	do_fio(&c__1, " AMPS", (ftnlen)5);
	e_wsfe();
    }
    enint.r = 0.f, enint.i = 0.f;
    xob = nfdat_1.xnr;
    yob = nfdat_1.ynr;
    zob = nfdat_1.znr;
    i__1 = nfdat_1.nrx;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ > 1) {
	    xob += dx;
	    yob += dy;
	    zob += dz;
	}
	if (nfdat_1.nfeh == 0) {
	    nefld_(&xob, &yob, &zob, &ex, &ey, &ez);
	} else {
	    nhfld_(&xob, &yob, &zob, &ex, &ey, &ez);
	}
	z__3.r = uax * ex.r, z__3.i = uax * ex.i;
	z__4.r = uay * ey.r, z__4.i = uay * ey.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__5.r = uaz * ez.r, z__5.i = uaz * ez.i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	ea.r = z__1.r, ea.i = z__1.i;
	z__2.r = uhx * ex.r, z__2.i = uhx * ex.i;
	z__3.r = uhy * ey.r, z__3.i = uhy * ey.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	eh.r = z__1.r, eh.i = z__1.i;
	z__3.r = uvx * ex.r, z__3.i = uvx * ex.i;
	z__4.r = uvy * ey.r, z__4.i = uvy * ey.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__5.r = uvz * ez.r, z__5.i = uvz * ez.i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	ev.r = z__1.r, ev.i = z__1.i;
	if (i__ == 1 || i__ == nfdat_1.nrx) {
	    z__2.r = ea.r * .5f, z__2.i = ea.i * .5f;
	    z__1.r = enint.r + z__2.r, z__1.i = enint.i + z__2.i;
	    enint.r = z__1.r, enint.i = z__1.i;
	} else {
	    z__1.r = enint.r + ea.r, z__1.i = enint.i + ea.i;
	    enint.r = z__1.r, enint.i = z__1.i;
	}
	eamag = z_abs(&ea);
	eaph = cang_(&ea);
	ehmag = z_abs(&eh);
	ehph = cang_(&eh);
	evmag = z_abs(&ev);
	evph = cang_(&ev);
	s_wsfe(&io___1572);
	do_fio(&c__1, (char *)&xob, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&yob, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&zob, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&eamag, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&eaph, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ehmag, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ehph, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&evmag, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&evph, (ftnlen)sizeof(doublereal));
	e_wsfe();
/* L1: */
    }
    if (nfdat_1.nrx > 1) {
	z__1.r = dlen * enint.r, z__1.i = dlen * enint.i;
	enint.r = z__1.r, enint.i = z__1.i;
    } else {
	enint.r = 0.f, enint.i = 0.f;
    }
    if (nfdat_1.nfeh == 0) {
	z__1.r = nfdat_1.enintg.r + enint.r, z__1.i = nfdat_1.enintg.i + 
		enint.i;
	nfdat_1.enintg.r = z__1.r, nfdat_1.enintg.i = z__1.i;
	s_wsfe(&io___1573);
	do_fio(&c__2, (char *)&enint, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&nfdat_1.enintg, (ftnlen)sizeof(doublereal));
	e_wsfe();
    } else {
	z__1.r = nfdat_1.hnintg.r + enint.r, z__1.i = nfdat_1.hnintg.i + 
		enint.i;
	nfdat_1.hnintg.r = z__1.r, nfdat_1.hnintg.i = z__1.i;
	s_wsfe(&io___1574);
	do_fio(&c__2, (char *)&enint, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&nfdat_1.hnintg, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

} /* nfline_ */

/* Subroutine */ int nhfld_(doublereal *xob, doublereal *yob, doublereal *zob,
	 doublecomplex *hx, doublecomplex *hy, doublecomplex *hz)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static integer i__, jc, jl;
#define xs ((doublereal *)&data_1)
#define ys ((doublereal *)&data_1 + 1210)
#define zs ((doublereal *)&data_1 + 2420)
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex acx, bcx, ccx, con;
    static doublereal delt;
    static doublecomplex exmx, exmy, exmz, expx, expy, expz, eypx, eymx, eypy,
	     eymy, eypz, eymz, ezpx, ezmx, ezpy, ezmy, ezpz, ezmz;
    extern /* Subroutine */ int nefld_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *), hsfld_(
	    doublereal *, doublereal *, doublereal *), hintg_(doublereal *, 
	    doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     NHFLD computes the near field at specified points in space after */
/*     the structure currents have been computed. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (gnd_1.iperf == 2) {
	goto L6;
    }
    hx->r = 0.f, hx->i = 0.f;
    hy->r = 0.f, hy->i = 0.f;
    hz->r = 0.f, hz->i = 0.f;
    if (data_1.n == 0) {
	goto L4;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	dataj_1.slenj = data_1.si[i__ - 1];
	dataj_1.aradj = data_1.bi[i__ - 1];
	dataj_1.xj = data_1.x[i__ - 1];
	dataj_1.yj = data_1.y[i__ - 1];
	dataj_1.zj = data_1.z__[i__ - 1];
	dataj_1.dxj = cab[i__ - 1];
	dataj_1.dyj = sab[i__ - 1];
	dataj_1.dzj = data_1.salp[i__ - 1];
	i__2 = i__ - 1;
	dataj_1.xksj.r = crnt_1.xks[i__2].r, dataj_1.xksj.i = crnt_1.xks[i__2]
		.i;
	hsfld_(xob, yob, zob);
	i__2 = i__ - 1;
	acx.r = crnt_1.aix[i__2].r, acx.i = crnt_1.aix[i__2].i;
	i__2 = i__ - 1;
	bcx.r = crnt_1.bix[i__2].r, bcx.i = crnt_1.bix[i__2].i;
	i__2 = i__ - 1;
	ccx.r = crnt_1.cix[i__2].r, ccx.i = crnt_1.cix[i__2].i;
	z__4.r = dataj_1.exk.r * acx.r - dataj_1.exk.i * acx.i, z__4.i = 
		dataj_1.exk.r * acx.i + dataj_1.exk.i * acx.r;
	z__3.r = hx->r + z__4.r, z__3.i = hx->i + z__4.i;
	z__5.r = dataj_1.exs.r * bcx.r - dataj_1.exs.i * bcx.i, z__5.i = 
		dataj_1.exs.r * bcx.i + dataj_1.exs.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.exc.r * ccx.r - dataj_1.exc.i * ccx.i, z__6.i = 
		dataj_1.exc.r * ccx.i + dataj_1.exc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	hx->r = z__1.r, hx->i = z__1.i;
	z__4.r = dataj_1.eyk.r * acx.r - dataj_1.eyk.i * acx.i, z__4.i = 
		dataj_1.eyk.r * acx.i + dataj_1.eyk.i * acx.r;
	z__3.r = hy->r + z__4.r, z__3.i = hy->i + z__4.i;
	z__5.r = dataj_1.eys.r * bcx.r - dataj_1.eys.i * bcx.i, z__5.i = 
		dataj_1.eys.r * bcx.i + dataj_1.eys.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.eyc.r * ccx.r - dataj_1.eyc.i * ccx.i, z__6.i = 
		dataj_1.eyc.r * ccx.i + dataj_1.eyc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	hy->r = z__1.r, hy->i = z__1.i;
/* L3: */
	z__4.r = dataj_1.ezk.r * acx.r - dataj_1.ezk.i * acx.i, z__4.i = 
		dataj_1.ezk.r * acx.i + dataj_1.ezk.i * acx.r;
	z__3.r = hz->r + z__4.r, z__3.i = hz->i + z__4.i;
	z__5.r = dataj_1.ezs.r * bcx.r - dataj_1.ezs.i * bcx.i, z__5.i = 
		dataj_1.ezs.r * bcx.i + dataj_1.ezs.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.ezc.r * ccx.r - dataj_1.ezc.i * ccx.i, z__6.i = 
		dataj_1.ezc.r * ccx.i + dataj_1.ezc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	hz->r = z__1.r, hz->i = z__1.i;
    }
    if (data_1.m == 0) {
	return 0;
    }
L4:
    jc = data_1.n;
    jl = data_1.ld + 1;
    i__1 = data_1.m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	--jl;
	datap_1.spatj = data_1.bi[jl - 1];
	datap_1.xpatj = data_1.x[jl - 1];
	datap_1.ypatj = data_1.y[jl - 1];
	datap_1.zpatj = data_1.z__[jl - 1];
	datap_1.t1xj = t1x[jl - 1];
	datap_1.t1yj = t1y[jl - 1];
	datap_1.t1zj = t1z[jl - 1];
	datap_1.t2xj = data_1.t2x[jl - 1];
	datap_1.t2yj = data_1.t2y[jl - 1];
	datap_1.t2zj = data_1.t2z[jl - 1];
	hintg_(xob, yob, zob);
	jc += 3;
	i__2 = jc - 3;
	z__3.r = datap_1.t1xj * crnt_1.cur[i__2].r, z__3.i = datap_1.t1xj * 
		crnt_1.cur[i__2].i;
	i__3 = jc - 2;
	z__4.r = datap_1.t1yj * crnt_1.cur[i__3].r, z__4.i = datap_1.t1yj * 
		crnt_1.cur[i__3].i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = jc - 1;
	z__5.r = datap_1.t1zj * crnt_1.cur[i__4].r, z__5.i = datap_1.t1zj * 
		crnt_1.cur[i__4].i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	acx.r = z__1.r, acx.i = z__1.i;
	i__2 = jc - 3;
	z__3.r = datap_1.t2xj * crnt_1.cur[i__2].r, z__3.i = datap_1.t2xj * 
		crnt_1.cur[i__2].i;
	i__3 = jc - 2;
	z__4.r = datap_1.t2yj * crnt_1.cur[i__3].r, z__4.i = datap_1.t2yj * 
		crnt_1.cur[i__3].i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = jc - 1;
	z__5.r = datap_1.t2zj * crnt_1.cur[i__4].r, z__5.i = datap_1.t2zj * 
		crnt_1.cur[i__4].i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	bcx.r = z__1.r, bcx.i = z__1.i;
	z__3.r = acx.r * datap_1.h1x.r - acx.i * datap_1.h1x.i, z__3.i = 
		acx.r * datap_1.h1x.i + acx.i * datap_1.h1x.r;
	z__2.r = hx->r + z__3.r, z__2.i = hx->i + z__3.i;
	z__4.r = bcx.r * datap_1.h2x.r - bcx.i * datap_1.h2x.i, z__4.i = 
		bcx.r * datap_1.h2x.i + bcx.i * datap_1.h2x.r;
	z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	hx->r = z__1.r, hx->i = z__1.i;
	z__3.r = acx.r * datap_1.h1y.r - acx.i * datap_1.h1y.i, z__3.i = 
		acx.r * datap_1.h1y.i + acx.i * datap_1.h1y.r;
	z__2.r = hy->r + z__3.r, z__2.i = hy->i + z__3.i;
	z__4.r = bcx.r * datap_1.h2y.r - bcx.i * datap_1.h2y.i, z__4.i = 
		bcx.r * datap_1.h2y.i + bcx.i * datap_1.h2y.r;
	z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	hy->r = z__1.r, hy->i = z__1.i;
/* L5: */
	z__3.r = acx.r * datap_1.h1z.r - acx.i * datap_1.h1z.i, z__3.i = 
		acx.r * datap_1.h1z.i + acx.i * datap_1.h1z.r;
	z__2.r = hz->r + z__3.r, z__2.i = hz->i + z__3.i;
	z__4.r = bcx.r * datap_1.h2z.r - bcx.i * datap_1.h2z.i, z__4.i = 
		bcx.r * datap_1.h2z.i + bcx.i * datap_1.h2z.r;
	z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	hz->r = z__1.r, hz->i = z__1.i;
    }
    return 0;

/*     GET H BY FINITE DIFFERENCE OF E FOR SOMMERFELD GROUND */
L6:
    if (*zob < 0.f) {
	goto L7;
    }
    z__2.r = gnd_1.xku.r * gnd_1.etau.r - gnd_1.xku.i * gnd_1.etau.i, z__2.i =
	     gnd_1.xku.r * gnd_1.etau.i + gnd_1.xku.i * gnd_1.etau.r;
    z_div(&z__1, &c_b2175, &z__2);
    con.r = z__1.r, con.i = z__1.i;
    delt = .00628318f / z_abs(&gnd_1.xku);
    goto L8;
L7:
    z__2.r = gnd_1.xkl.r * gnd_1.etal.r - gnd_1.xkl.i * gnd_1.etal.i, z__2.i =
	     gnd_1.xkl.r * gnd_1.etal.i + gnd_1.xkl.i * gnd_1.etal.r;
    z_div(&z__1, &c_b2175, &z__2);
    con.r = z__1.r, con.i = z__1.i;
    delt = .00628318f / z_abs(&gnd_1.xkl);
L8:
    glock_1.iglock = 1;
    d__1 = *xob + delt;
    nefld_(&d__1, yob, zob, &expx, &eypx, &ezpx);
    d__1 = *xob - delt;
    nefld_(&d__1, yob, zob, &exmx, &eymx, &ezmx);
    d__1 = *yob + delt;
    nefld_(xob, &d__1, zob, &expy, &eypy, &ezpy);
    d__1 = *yob - delt;
    nefld_(xob, &d__1, zob, &exmy, &eymy, &ezmy);
    d__1 = *zob + delt;
    nefld_(xob, yob, &d__1, &expz, &eypz, &ezpz);
    d__1 = *zob - delt;
    nefld_(xob, yob, &d__1, &exmz, &eymz, &ezmz);
    glock_1.iglock = 0;
    z__5.r = ezpy.r - ezmy.r, z__5.i = ezpy.i - ezmy.i;
    z__4.r = z__5.r - eypz.r, z__4.i = z__5.i - eypz.i;
    z__3.r = z__4.r + eymz.r, z__3.i = z__4.i + eymz.i;
    z__2.r = con.r * z__3.r - con.i * z__3.i, z__2.i = con.r * z__3.i + con.i 
	    * z__3.r;
    d__1 = delt * 2.f;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    hx->r = z__1.r, hx->i = z__1.i;
    z__5.r = expz.r - exmz.r, z__5.i = expz.i - exmz.i;
    z__4.r = z__5.r - ezpx.r, z__4.i = z__5.i - ezpx.i;
    z__3.r = z__4.r + ezmx.r, z__3.i = z__4.i + ezmx.i;
    z__2.r = con.r * z__3.r - con.i * z__3.i, z__2.i = con.r * z__3.i + con.i 
	    * z__3.r;
    d__1 = delt * 2.f;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    hy->r = z__1.r, hy->i = z__1.i;
    z__5.r = eypx.r - eymx.r, z__5.i = eypx.i - eymx.i;
    z__4.r = z__5.r - expy.r, z__4.i = z__5.i - expy.i;
    z__3.r = z__4.r + exmy.r, z__3.i = z__4.i + exmy.i;
    z__2.r = con.r * z__3.r - con.i * z__3.i, z__2.i = con.r * z__3.i + con.i 
	    * z__3.r;
    d__1 = delt * 2.f;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    hz->r = z__1.r, hz->i = z__1.i;
    return 0;
} /* nhfld_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x
#undef zs
#undef ys
#undef xs


/* Subroutine */ int patch_0_(int n__, integer *nx, integer *ny, doublereal *
	x1, doublereal *y1, doublereal *z1, doublereal *x2, doublereal *y2, 
	doublereal *z2, doublereal *x3, doublereal *y3, doublereal *z3, 
	doublereal *x4, doublereal *y4, doublereal *z4)
{
    /* Format strings */
    static char fmt_14[] = "(\002 PATCH: ERROR - CORNERS OF QUADRILATERAL PA"
	    "TCH DO NOT\002,\002 LIE IN A PLANE\002)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    double cos(doublereal), sin(doublereal), sqrt(doublereal);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer mi;
    static doublereal xa;
    static integer ix, iy;
    static doublereal xs, ys, zs, xt, yt, zt, xn2, yn2, zn2, s1x;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    static doublereal s1y, s1z, s2x, s2y, s2z;
    static integer mia, ntp, nxp, nyp;
    static doublereal xnv, ynv, znv, xst, saln, salpn;

    /* Fortran I/O blocks */
    static cilist io___1629 = { 0, 3, 0, fmt_14, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PATCH generates and modifies patch geometry data. */
/*     Entry SUBPH divides a patch at a wire connection. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

/*     NEW PATCHES.  FOR NX=0, NY=1,2,3,4 PATCH IS (RESPECTIVELY) */
/*     ARBITRARY, RECTAGULAR, TRIANGULAR, OR QUADRILATERAL. */
/*     FOR NX AND NY .GT. 0 A RECTANGULAR SURFACE IS PRODUCED WITH */
/*     NX BY NY RECTANGULAR PATCHES. */
    switch(n__) {
	case 1: goto L_subph;
	}

    ++data_1.m;
    mi = data_1.ld + 1 - data_1.m;
    ntp = *ny;
    if (*nx > 0) {
	ntp = 2;
    }
    if (ntp > 1) {
	goto L2;
    }
    data_1.x[mi - 1] = *x1;
    data_1.y[mi - 1] = *y1;
    data_1.z__[mi - 1] = *z1;
    data_1.bi[mi - 1] = *z2;
    znv = cos(*x2);
    xnv = znv * cos(*y2);
    ynv = znv * sin(*y2);
    znv = sin(*x2);
    xa = sqrt(xnv * xnv + ynv * ynv);
    if (xa < 1e-6f) {
	goto L1;
    }
    t1x[mi - 1] = -ynv / xa;
    t1y[mi - 1] = xnv / xa;
    t1z[mi - 1] = 0.f;
    goto L6;
L1:
    t1x[mi - 1] = 1.f;
    t1y[mi - 1] = 0.f;
    t1z[mi - 1] = 0.f;
    goto L6;
L2:
    s1x = *x2 - *x1;
    s1y = *y2 - *y1;
    s1z = *z2 - *z1;
    s2x = *x3 - *x2;
    s2y = *y3 - *y2;
    s2z = *z3 - *z2;
    if (*nx == 0) {
	goto L3;
    }
    s1x /= *nx;
    s1y /= *nx;
    s1z /= *nx;
    s2x /= *ny;
    s2y /= *ny;
    s2z /= *ny;
L3:
    xnv = s1y * s2z - s1z * s2y;
    ynv = s1z * s2x - s1x * s2z;
    znv = s1x * s2y - s1y * s2x;
    xa = sqrt(xnv * xnv + ynv * ynv + znv * znv);
    xnv /= xa;
    ynv /= xa;
    znv /= xa;
    xst = sqrt(s1x * s1x + s1y * s1y + s1z * s1z);
    t1x[mi - 1] = s1x / xst;
    t1y[mi - 1] = s1y / xst;
    t1z[mi - 1] = s1z / xst;
    if (ntp > 2) {
	goto L4;
    }
    data_1.x[mi - 1] = *x1 + (s1x + s2x) * .5f;
    data_1.y[mi - 1] = *y1 + (s1y + s2y) * .5f;
    data_1.z__[mi - 1] = *z1 + (s1z + s2z) * .5f;
    data_1.bi[mi - 1] = xa;
    goto L6;
L4:
    if (ntp == 4) {
	goto L5;
    }
    data_1.x[mi - 1] = (*x1 + *x2 + *x3) / 3.f;
    data_1.y[mi - 1] = (*y1 + *y2 + *y3) / 3.f;
    data_1.z__[mi - 1] = (*z1 + *z2 + *z3) / 3.f;
    data_1.bi[mi - 1] = xa * .5f;
    goto L6;
L5:
    s1x = *x3 - *x1;
    s1y = *y3 - *y1;
    s1z = *z3 - *z1;
    s2x = *x4 - *x1;
    s2y = *y4 - *y1;
    s2z = *z4 - *z1;
    xn2 = s1y * s2z - s1z * s2y;
    yn2 = s1z * s2x - s1x * s2z;
    zn2 = s1x * s2y - s1y * s2x;
    xst = sqrt(xn2 * xn2 + yn2 * yn2 + zn2 * zn2);
    salpn = 1.f / ((xa + xst) * 3.f);
    data_1.x[mi - 1] = (xa * (*x1 + *x2 + *x3) + xst * (*x1 + *x3 + *x4)) * 
	    salpn;
    data_1.y[mi - 1] = (xa * (*y1 + *y2 + *y3) + xst * (*y1 + *y3 + *y4)) * 
	    salpn;
    data_1.z__[mi - 1] = (xa * (*z1 + *z2 + *z3) + xst * (*z1 + *z3 + *z4)) * 
	    salpn;
    data_1.bi[mi - 1] = (xa + xst) * .5f;
    s1x = (xnv * xn2 + ynv * yn2 + znv * zn2) / xst;
    if (s1x > .9998f) {
	goto L6;
    }
    s_wsfe(&io___1629);
    e_wsfe();
    s_stop("", (ftnlen)0);
L6:
    data_1.t2x[mi - 1] = ynv * t1z[mi - 1] - znv * t1y[mi - 1];
    data_1.t2y[mi - 1] = znv * t1x[mi - 1] - xnv * t1z[mi - 1];
    data_1.t2z[mi - 1] = xnv * t1y[mi - 1] - ynv * t1x[mi - 1];
    data_1.salp[mi - 1] = 1.f;
    if (*nx == 0) {
	goto L8;
    }
    data_1.m = data_1.m + *nx * *ny - 1;
    xn2 = data_1.x[mi - 1] - s1x - s2x;
    yn2 = data_1.y[mi - 1] - s1y - s2y;
    zn2 = data_1.z__[mi - 1] - s1z - s2z;
    xs = t1x[mi - 1];
    ys = t1y[mi - 1];
    zs = t1z[mi - 1];
    xt = data_1.t2x[mi - 1];
    yt = data_1.t2y[mi - 1];
    zt = data_1.t2z[mi - 1];
    ++mi;
    i__1 = *ny;
    for (iy = 1; iy <= i__1; ++iy) {
	xn2 += s2x;
	yn2 += s2y;
	zn2 += s2z;
	i__2 = *nx;
	for (ix = 1; ix <= i__2; ++ix) {
	    xst = (doublereal) ix;
	    --mi;
	    data_1.x[mi - 1] = xn2 + xst * s1x;
	    data_1.y[mi - 1] = yn2 + xst * s1y;
	    data_1.z__[mi - 1] = zn2 + xst * s1z;
	    data_1.bi[mi - 1] = xa;
	    data_1.salp[mi - 1] = 1.f;
	    t1x[mi - 1] = xs;
	    t1y[mi - 1] = ys;
	    t1z[mi - 1] = zs;
	    data_1.t2x[mi - 1] = xt;
	    data_1.t2y[mi - 1] = yt;
/* L7: */
	    data_1.t2z[mi - 1] = zt;
	}
    }
L8:
    data_1.ipsym = 0;
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    return 0;
/*     DIVIDE PATCH FOR WIRE CONNECTION */

L_subph:
    if (*ny > 0) {
	goto L10;
    }
    if (*nx == data_1.m) {
	goto L10;
    }
    nxp = *nx + 1;
    ix = data_1.ld - data_1.m;
    i__2 = data_1.m;
    for (iy = nxp; iy <= i__2; ++iy) {
	++ix;
	nyp = ix - 3;
	data_1.x[nyp - 1] = data_1.x[ix - 1];
	data_1.y[nyp - 1] = data_1.y[ix - 1];
	data_1.z__[nyp - 1] = data_1.z__[ix - 1];
	data_1.bi[nyp - 1] = data_1.bi[ix - 1];
	data_1.salp[nyp - 1] = data_1.salp[ix - 1];
	t1x[nyp - 1] = t1x[ix - 1];
	t1y[nyp - 1] = t1y[ix - 1];
	t1z[nyp - 1] = t1z[ix - 1];
	data_1.t2x[nyp - 1] = data_1.t2x[ix - 1];
	data_1.t2y[nyp - 1] = data_1.t2y[ix - 1];
/* L9: */
	data_1.t2z[nyp - 1] = data_1.t2z[ix - 1];
    }
L10:
    mi = data_1.ld + 1 - *nx;
    xs = data_1.x[mi - 1];
    ys = data_1.y[mi - 1];
    zs = data_1.z__[mi - 1];
    xa = data_1.bi[mi - 1] * .25f;
    xst = sqrt(xa) * .5f;
    s1x = t1x[mi - 1];
    s1y = t1y[mi - 1];
    s1z = t1z[mi - 1];
    s2x = data_1.t2x[mi - 1];
    s2y = data_1.t2y[mi - 1];
    s2z = data_1.t2z[mi - 1];
    saln = data_1.salp[mi - 1];
    xt = xst;
    yt = xst;
    if (*ny > 0) {
	goto L11;
    }
    mia = mi;
    goto L12;
L11:
    ++data_1.m;
    ++data_1.mp;
    mia = data_1.ld + 1 - data_1.m;
L12:
    for (ix = 1; ix <= 4; ++ix) {
	data_1.x[mia - 1] = xs + xt * s1x + yt * s2x;
	data_1.y[mia - 1] = ys + xt * s1y + yt * s2y;
	data_1.z__[mia - 1] = zs + xt * s1z + yt * s2z;
	data_1.bi[mia - 1] = xa;
	t1x[mia - 1] = s1x;
	t1y[mia - 1] = s1y;
	t1z[mia - 1] = s1z;
	data_1.t2x[mia - 1] = s2x;
	data_1.t2y[mia - 1] = s2y;
	data_1.t2z[mia - 1] = s2z;
	data_1.salp[mia - 1] = saln;
	if (ix == 2) {
	    yt = -yt;
	}
	if (ix == 1 || ix == 3) {
	    xt = -xt;
	}
	--mia;
/* L13: */
    }
    data_1.m += 3;
    if (*nx <= data_1.mp) {
	data_1.mp += 3;
    }
    if (*ny > 0) {
	data_1.z__[mi - 1] = 1e4f;
    }
    return 0;

} /* patch_ */

#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int patch_(integer *nx, integer *ny, doublereal *x1, 
	doublereal *y1, doublereal *z1, doublereal *x2, doublereal *y2, 
	doublereal *z2, doublereal *x3, doublereal *y3, doublereal *z3, 
	doublereal *x4, doublereal *y4, doublereal *z4)
{
    return patch_0_(0, nx, ny, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
	    ;
    }

/* Subroutine */ int subph_(integer *nx, integer *ny, doublereal *x1, 
	doublereal *y1, doublereal *z1, doublereal *x2, doublereal *y2, 
	doublereal *z2, doublereal *x3, doublereal *y3, doublereal *z3, 
	doublereal *x4, doublereal *y4, doublereal *z4)
{
    return patch_0_(1, nx, ny, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
	    ;
    }

/* Subroutine */ int pcint_(doublereal *xi, doublereal *yi, doublereal *zi, 
	doublereal *cabi, doublereal *sabi, doublereal *salpi, doublecomplex *
	e)
{
    /* Initialized data */

    static doublereal tpi = 6.2831853071796;
    static integer nint = 10;

    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal d__;
    static doublecomplex e1, e2, e3, e4, e5, e6, e7, e8, e9;
    static integer i1, i2;
    static doublereal g1, g2, g3, s1, s2, g4, f2, f1, da, ds, xs, s2x, xxj, 
	    xyj, xzj, xss, yss, zss, fcon, gcon;
    extern /* Subroutine */ int unere_(doublereal *, doublereal *, doublereal 
	    *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PCINT evaluates the E field due to patches at a wire connection */
/*     by integrating over the patches. */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    d__ = sqrt(datap_1.spatj) * .5f;
    ds = d__ * 4.f / (doublereal) nint;
    da = ds * ds;
    gcon = 1.f / datap_1.spatj;
    fcon = 1.f / (tpi * 2.f * d__);
    xxj = datap_1.xpatj;
    xyj = datap_1.ypatj;
    xzj = datap_1.zpatj;
    xs = datap_1.spatj;
    datap_1.spatj = da;
    s1 = d__ + ds * .5f;
    xss = datap_1.xpatj + s1 * (datap_1.t1xj + datap_1.t2xj);
    yss = datap_1.ypatj + s1 * (datap_1.t1yj + datap_1.t2yj);
    zss = datap_1.zpatj + s1 * (datap_1.t1zj + datap_1.t2zj);
    s1 += d__;
    s2x = s1;
    e1.r = 0.f, e1.i = 0.f;
    e2.r = 0.f, e2.i = 0.f;
    e3.r = 0.f, e3.i = 0.f;
    e4.r = 0.f, e4.i = 0.f;
    e5.r = 0.f, e5.i = 0.f;
    e6.r = 0.f, e6.i = 0.f;
    e7.r = 0.f, e7.i = 0.f;
    e8.r = 0.f, e8.i = 0.f;
    e9.r = 0.f, e9.i = 0.f;
    i__1 = nint;
    for (i1 = 1; i1 <= i__1; ++i1) {
	s1 -= ds;
	s2 = s2x;
	xss -= ds * datap_1.t1xj;
	yss -= ds * datap_1.t1yj;
	zss -= ds * datap_1.t1zj;
	datap_1.xpatj = xss;
	datap_1.ypatj = yss;
	datap_1.zpatj = zss;
	i__2 = nint;
	for (i2 = 1; i2 <= i__2; ++i2) {
	    s2 -= ds;
	    datap_1.xpatj -= ds * datap_1.t2xj;
	    datap_1.ypatj -= ds * datap_1.t2yj;
	    datap_1.zpatj -= ds * datap_1.t2zj;
	    unere_(xi, yi, zi);
	    z__3.r = *cabi * datap_1.h1x.r, z__3.i = *cabi * datap_1.h1x.i;
	    z__4.r = *sabi * datap_1.h1y.r, z__4.i = *sabi * datap_1.h1y.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = *salpi * datap_1.h1z.r, z__5.i = *salpi * datap_1.h1z.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    datap_1.h1x.r = z__1.r, datap_1.h1x.i = z__1.i;
	    z__3.r = *cabi * datap_1.h2x.r, z__3.i = *cabi * datap_1.h2x.i;
	    z__4.r = *sabi * datap_1.h2y.r, z__4.i = *sabi * datap_1.h2y.i;
	    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	    z__5.r = *salpi * datap_1.h2z.r, z__5.i = *salpi * datap_1.h2z.i;
	    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	    datap_1.h2x.r = z__1.r, datap_1.h2x.i = z__1.i;
	    g1 = (d__ + s1) * (d__ + s2) * gcon;
	    g2 = (d__ - s1) * (d__ + s2) * gcon;
	    g3 = (d__ - s1) * (d__ - s2) * gcon;
	    g4 = (d__ + s1) * (d__ - s2) * gcon;
	    f2 = (s1 * s1 + s2 * s2) * tpi;
	    f1 = s1 / f2 - (g1 - g2 - g3 + g4) * fcon;
	    f2 = s2 / f2 - (g1 + g2 - g3 - g4) * fcon;
	    z__2.r = g1 * datap_1.h1x.r, z__2.i = g1 * datap_1.h1x.i;
	    z__1.r = e1.r + z__2.r, z__1.i = e1.i + z__2.i;
	    e1.r = z__1.r, e1.i = z__1.i;
	    z__2.r = g2 * datap_1.h1x.r, z__2.i = g2 * datap_1.h1x.i;
	    z__1.r = e2.r + z__2.r, z__1.i = e2.i + z__2.i;
	    e2.r = z__1.r, e2.i = z__1.i;
	    z__2.r = g3 * datap_1.h1x.r, z__2.i = g3 * datap_1.h1x.i;
	    z__1.r = e3.r + z__2.r, z__1.i = e3.i + z__2.i;
	    e3.r = z__1.r, e3.i = z__1.i;
	    z__2.r = g4 * datap_1.h1x.r, z__2.i = g4 * datap_1.h1x.i;
	    z__1.r = e4.r + z__2.r, z__1.i = e4.i + z__2.i;
	    e4.r = z__1.r, e4.i = z__1.i;
	    z__2.r = g1 * datap_1.h2x.r, z__2.i = g1 * datap_1.h2x.i;
	    z__1.r = e5.r + z__2.r, z__1.i = e5.i + z__2.i;
	    e5.r = z__1.r, e5.i = z__1.i;
	    z__2.r = g2 * datap_1.h2x.r, z__2.i = g2 * datap_1.h2x.i;
	    z__1.r = e6.r + z__2.r, z__1.i = e6.i + z__2.i;
	    e6.r = z__1.r, e6.i = z__1.i;
	    z__2.r = g3 * datap_1.h2x.r, z__2.i = g3 * datap_1.h2x.i;
	    z__1.r = e7.r + z__2.r, z__1.i = e7.i + z__2.i;
	    e7.r = z__1.r, e7.i = z__1.i;
	    z__2.r = g4 * datap_1.h2x.r, z__2.i = g4 * datap_1.h2x.i;
	    z__1.r = e8.r + z__2.r, z__1.i = e8.i + z__2.i;
	    e8.r = z__1.r, e8.i = z__1.i;
/* L1: */
	    z__3.r = f1 * datap_1.h1x.r, z__3.i = f1 * datap_1.h1x.i;
	    z__2.r = e9.r + z__3.r, z__2.i = e9.i + z__3.i;
	    z__4.r = f2 * datap_1.h2x.r, z__4.i = f2 * datap_1.h2x.i;
	    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	    e9.r = z__1.r, e9.i = z__1.i;
	}
    }
    e[1].r = e1.r, e[1].i = e1.i;
    e[2].r = e2.r, e[2].i = e2.i;
    e[3].r = e3.r, e[3].i = e3.i;
    e[4].r = e4.r, e[4].i = e4.i;
    e[5].r = e5.r, e[5].i = e5.i;
    e[6].r = e6.r, e[6].i = e6.i;
    e[7].r = e7.r, e[7].i = e7.i;
    e[8].r = e8.r, e[8].i = e8.i;
    e[9].r = e9.r, e[9].i = e9.i;
    datap_1.xpatj = xxj;
    datap_1.ypatj = xyj;
    datap_1.zpatj = xzj;
    datap_1.spatj = xs;
    return 0;
} /* pcint_ */

/* Subroutine */ int prnt_(integer *in1, integer *in2, integer *in3, 
	doublereal *fl1, doublereal *fl2, doublereal *fl3, doublereal *fl4, 
	doublereal *fl5, doublereal *fl6, char *ctype, ftnlen ctype_len)
{
    /* Format strings */
    static char fmt_90[] = "(i5)";
    static char fmt_91[] = "(1pe13.4)";
    static char fmt_92[] = "(/,3x,3a,3x,6a,3x,a)";

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static integer i__;
    static char cflt[13*6], cint[5*3];

    /* Fortran I/O blocks */
    static icilist io___1678 = { 0, cint, 0, fmt_90, 5, 1 };
    static icilist io___1679 = { 0, cint+5, 0, fmt_90, 5, 1 };
    static icilist io___1680 = { 0, cint+10, 0, fmt_90, 5, 1 };
    static icilist io___1682 = { 0, cflt, 0, fmt_91, 13, 1 };
    static icilist io___1683 = { 0, cflt+13, 0, fmt_91, 13, 1 };
    static icilist io___1684 = { 0, cflt+26, 0, fmt_91, 13, 1 };
    static icilist io___1685 = { 0, cflt+39, 0, fmt_91, 13, 1 };
    static icilist io___1686 = { 0, cflt+52, 0, fmt_91, 13, 1 };
    static icilist io___1687 = { 0, cflt+65, 0, fmt_91, 13, 1 };
    static cilist io___1688 = { 0, 3, 0, fmt_92, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     PRNT prints the input data for impedance loading, inserting blanks */
/*     for numbers that are zero. */

/*     INPUT: */
/*     IN1-3 = INTEGER VALUES TO BE PRINTED */
/*     FL1-6 = REAL VALUES TO BE PRINTED */
/*     CTYPE = CHARACTER STRING TO BE PRINTED */

    for (i__ = 1; i__ <= 3; ++i__) {
/* L1: */
	s_copy(cint + (i__ - 1) * 5, "     ", (ftnlen)5, (ftnlen)5);
    }
    if (*in1 == 0 && *in2 == 0 && *in3 == 0) {
	s_copy(cint, "  ALL", (ftnlen)5, (ftnlen)5);
    } else {
	if (*in1 != 0) {
	    s_wsfi(&io___1678);
	    do_fio(&c__1, (char *)&(*in1), (ftnlen)sizeof(integer));
	    e_wsfi();
	}
	if (*in2 != 0) {
	    s_wsfi(&io___1679);
	    do_fio(&c__1, (char *)&(*in2), (ftnlen)sizeof(integer));
	    e_wsfi();
	}
	if (*in3 != 0) {
	    s_wsfi(&io___1680);
	    do_fio(&c__1, (char *)&(*in3), (ftnlen)sizeof(integer));
	    e_wsfi();
	}
    }
    for (i__ = 1; i__ <= 6; ++i__) {
/* L2: */
	s_copy(cflt + (i__ - 1) * 13, "     ", (ftnlen)13, (ftnlen)5);
    }
    if (abs(*fl1) > 1e-30f) {
	s_wsfi(&io___1682);
	do_fio(&c__1, (char *)&(*fl1), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    if (abs(*fl2) > 1e-30f) {
	s_wsfi(&io___1683);
	do_fio(&c__1, (char *)&(*fl2), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    if (abs(*fl3) > 1e-30f) {
	s_wsfi(&io___1684);
	do_fio(&c__1, (char *)&(*fl3), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    if (abs(*fl4) > 1e-30f) {
	s_wsfi(&io___1685);
	do_fio(&c__1, (char *)&(*fl4), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    if (abs(*fl5) > 1e-30f) {
	s_wsfi(&io___1686);
	do_fio(&c__1, (char *)&(*fl5), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    if (abs(*fl6) > 1e-30f) {
	s_wsfi(&io___1687);
	do_fio(&c__1, (char *)&(*fl6), (ftnlen)sizeof(doublereal));
	e_wsfi();
    }
    s_wsfe(&io___1688);
    for (i__ = 1; i__ <= 3; ++i__) {
	do_fio(&c__1, cint + (i__ - 1) * 5, (ftnlen)5);
    }
    for (i__ = 1; i__ <= 6; ++i__) {
	do_fio(&c__1, cflt + (i__ - 1) * 13, (ftnlen)13);
    }
    do_fio(&c__1, ctype, ctype_len);
    e_wsfe();
    return 0;

} /* prnt_ */

/* Subroutine */ int rdpat_(doublereal *pin, doublereal *pnls, doublereal *
	ploss)
{
    /* Initialized data */

    static char igtp[19*3] = "   - POWER GAINS - " "- DIRECTIVE GAINS -" 
	    "  - CROSS SECTION -";
    static char igax[14*2] = " MAJOR   MINOR" " VERT.   HOR. ";
    static char igntp[12*5] = " MAJOR AXIS " " MINOR AXIS " "   VERTICAL " 
	    " HORIZONTAL " "      TOTAL ";

    /* Format strings */
    static char fmt_36[] = "(///,31x,\002- - - FAR FIELD GROUND PARAMETERS -"
	    " - -\002,//)";
    static char fmt_37[] = "(40x,\002RADIAL WIRE GROUND SCREEN\002,/,40x,i5"
	    ",\002 WIRES\002,/,40x,\002WIRE LENGTH=\002,f8.2,\002 METERS\002,"
	    "/,40x,\002WIRE RADIUS=\002,1pe10.3,\002 METERS\002)";
    static char fmt_38[] = "(40x,a6,\002 CLIFF\002,/,40x,\002EDGE DISTANCE"
	    "=\002,f9.2,\002 METERS\002,/,40x,\002HEIGHT=\002,f8.2,\002 METERS"
	    "\002,/,40x,\002SECOND MEDIUM -\002,/,40x,\002RELATIVE DIELECTRIC"
	    " CONST.=\002,f7.3,/,40x,\002CONDUCTIVITY=\002,1pe10.3,\002 MHO"
	    "S\002)";
    static char fmt_49[] = "(\002 RDPAT: WARNING - THE CLIFF OR RADIAL-WIRE "
	    "GROUND SCREEN \002,\002APPROXIMATIONS \002,/,\002 ARE NOT INCLUD"
	    "ED IN CALCULATING GROUND \002,\002WAVE (RP1,...)\002)";
    static char fmt_43[] = "(///,28x,\002 - - - RADIATED FIELDS NEAR GROUND "
	    "- - -\002,//,8x,\002- - - LOCATION - - -\002,10x,\002- - E(THETA"
	    ") - -\002,8x,\002- - E(PHI) - -\002,8x,\002- - E(RADIAL) - -\002"
	    ",/,7x,\002RHO\002,6x,\002PHI\002,9x,\002Z\002,12x,\002MAG\002,6x,"
	    "\002PHASE\002,9x,\002MAG\002,6x,\002PHASE\002,9x,\002MAG\002,6x"
	    ",\002PHASE\002,/,5x,\002METERS\002,3x,\002DEGREES\002,4x,\002MET"
	    "ERS\002,8x,\002VOLTS/M\002,3x,\002DEGREES\002,6x,\002VOLTS/M\002"
	    ",3x,\002DEGREES\002,6x,\002VOLTS/M\002,3x,\002DEGREES\002,/)";
    static char fmt_39[] = "(///,48x,\002- - - RADIATION PATTERNS - - -\002)";
    static char fmt_40[] = "(54x,\002RANGE=\002,1pe13.6,\002 METERS\002,/,54"
	    "x,\002EXP(-JKR)/R=\002,e12.5,\002 AT PHASE\002,0pf7.2,\002 DEGRE"
	    "ES\002,/)";
    static char fmt_41[] = "(39x,\002LOWER MEDIUM - EXP(-JKR)/R=\002,1pe12"
	    ".5,\002 AT PHASE\002,0pf7.2,\002 DEGREES\002)";
    static char fmt_42[] = "(/,2x,\002- - ANGLES - -\002,7x,a19,7x,\002- - -"
	    " POLARIZATION - - -\002,4x,\002- - - E(THETA) - - -\002,4x,\002-"
	    " - - E(PHI) - - -\002,/,2x,\002THETA\002,5x,\002PHI\002,7x,a14,3"
	    "x,\002TOTAL\002,6x,\002AXIAL\002,5x,\002TILT\002,3x,\002SENSE"
	    "\002,2(5x,\002MAGNITUDE\002,4x,\002PHASE \002),/,2(1x,\002DEGREES"
	    "\002,1x),3(6x,\002DB\002),8x,\002RATIO\002,5x,\002DEG.\002,8x,2("
	    "6x,a,4x,\002DEGREES\002))";
    static char fmt_45[] = "(3x,f9.2,2x,f7.2,2x,f9.2,1x,3(3x,1pe11.4,2x,0pf7"
	    ".2))";
    static char fmt_44[] = "(1x,f7.2,f9.2,3x,3f8.2,f11.5,f9.2,2x,a6,2(1pe15."
	    "5,0pf9.2))";
    static char fmt_46[] = "(//,3x,\002AVERAGE POWER GAIN=\002,1pe12.5,7x"
	    ",\002SOLID ANGLE \002,\002USED IN AVERAGING=(\002,0pf7.4,\002)*P"
	    "I STERADIANS.\002,//,3x,\002POWER RADIATED ASSUMING RADIATION IN"
	    "TO 4*PI STERADIANS =\002,1pe12.5,\002 WATTS\002)";
    static char fmt_50[] = "(/)";
    static char fmt_47[] = "(//,37x,\002- - - - NORMALIZED GAIN - - - -\002,"
	    "//,37x,a12,\002GAIN\002,/,38x,\002NORMALIZATION FACTOR =\002,f9."
	    "2,\002 DB\002,//,3(4x,\002- - ANGLES - -\002,6x,\002GAIN\002,7x)"
	    ",/,3(4x,\002THETA\002,5x,\002PHI\002,8x,\002DB\002,8x),/,3(3x"
	    ",\002DEGREES\002,2x,\002DEGREES\002,16x))";
    static char fmt_48[] = "(3(1x,2f9.2,1x,f9.2,6x))";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    void z_exp(doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *), atan(doublereal), sqrt(doublereal);
    void d_cnjg(doublecomplex *, doublecomplex *);
    double cos(doublereal), sin(doublereal);

    /* Local variables */
    static integer i__, j;
    static doublereal da;
    extern doublereal db10_(doublereal *);
    static doublereal pha, eta;
    static doublecomplex erd, eph, eth;
    static doublereal phi;
    static integer kph, kth;
    static doublereal tha, gnv, gnh, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
    extern doublereal cang_(doublecomplex *);
    static doublereal erda;
    extern /* Subroutine */ int gfld_(doublereal *, doublereal *, doublereal *
	    , doublecomplex *, doublecomplex *, doublecomplex *), ffld_(
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *);
    static doublereal epha, etha, prad, gcop, gcon, gmax, erdm, ethm, ephm;
    static integer ipdx;
    static doublereal thet, pint, dfaz, gnmj, gnmn, gtot, dfaz2, ephm2;
    extern doublereal atgn2_(doublereal *, doublereal *);
    static doublereal ethm2, exra1, exra2;
    static integer itmp1;
    static doublereal exrm1, exrm2;
    static integer itmp2, itmp3, itmp4;
    static char hclif[6];
    static doublereal cdfaz, gconn, tilta;
    static char isens[6];
    static doublereal rdist, axrat, pinhz, emajr2, eminr2, tstor1, tstor2, 
	    avgain, stilta;
    static integer normax;
    static char funits[7];

    /* Fortran I/O blocks */
    static cilist io___1693 = { 0, 3, 0, fmt_36, 0 };
    static cilist io___1694 = { 0, 3, 0, fmt_37, 0 };
    static cilist io___1696 = { 0, 3, 0, fmt_38, 0 };
    static cilist io___1697 = { 0, 3, 0, fmt_49, 0 };
    static cilist io___1698 = { 0, 3, 0, fmt_43, 0 };
    static cilist io___1699 = { 0, 3, 0, fmt_39, 0 };
    static cilist io___1704 = { 0, 3, 0, fmt_40, 0 };
    static cilist io___1707 = { 0, 3, 0, fmt_41, 0 };
    static cilist io___1709 = { 0, 3, 0, fmt_42, 0 };
    static cilist io___1738 = { 0, 3, 0, fmt_45, 0 };
    static cilist io___1760 = { 0, 3, 0, fmt_44, 0 };
    static cilist io___1762 = { 0, 3, 0, fmt_46, 0 };
    static cilist io___1763 = { 0, 3, 0, fmt_50, 0 };
    static cilist io___1764 = { 0, 3, 0, fmt_47, 0 };
    static cilist io___1770 = { 0, 3, 0, fmt_48, 0 };
    static cilist io___1771 = { 0, 3, 0, fmt_48, 0 };
    static cilist io___1772 = { 0, 3, 0, fmt_48, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RDPAT calls routines to evaluate the radiation pattern, and prints */
/*     radiated field, gain and normalized gain. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

/* *** */
/* *** */
/* *** */
    normax = 4840;
    if (gnd_1.iclift != 0 || gnd_1.nradl != 0) {
	s_wsfe(&io___1693);
	e_wsfe();
	if (gnd_1.nradl > 0) {
	    s_wsfe(&io___1694);
	    do_fio(&c__1, (char *)&gnd_1.nradl, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&gnd_1.scnrad, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gnd_1.scnwrd, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
	if (gnd_1.iclift != 0) {
	    if (gnd_1.iclift == 1) {
		s_copy(hclif, "LINEAR", (ftnlen)6, (ftnlen)6);
	    }
	    if (gnd_1.iclift == 2) {
		s_copy(hclif, "CIRCLE", (ftnlen)6, (ftnlen)6);
	    }
	    s_wsfe(&io___1696);
	    do_fio(&c__1, hclif, (ftnlen)6);
	    do_fio(&c__1, (char *)&gnd_1.clifl, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gnd_1.clifh, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gnd_1.epsr2, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gnd_1.sig2, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
    }
    if (gnd_1.ifar == 1) {
	if (gnd_1.iclift != 0 || gnd_1.nradl != 0) {
	    s_wsfe(&io___1697);
	    e_wsfe();
	}
	s_wsfe(&io___1698);
	e_wsfe();
    } else {
	s_wsfe(&io___1699);
	e_wsfe();
	s_copy(funits, " VOLTS ", (ftnlen)7, (ftnlen)7);
	if (rpdat_1.rfld > 1e-20f) {
	    s_copy(funits, "VOLTS/M", (ftnlen)7, (ftnlen)7);
	    z__4.r = gnd_1.xku.r * -0.f - gnd_1.xku.i * -1.f, z__4.i = 
		    gnd_1.xku.r * -1.f + gnd_1.xku.i * -0.f;
	    z__3.r = rpdat_1.rfld * z__4.r, z__3.i = rpdat_1.rfld * z__4.i;
	    z_exp(&z__2, &z__3);
	    z__1.r = z__2.r / rpdat_1.rfld, z__1.i = z__2.i / rpdat_1.rfld;
	    eth.r = z__1.r, eth.i = z__1.i;
	    exrm1 = z_abs(&eth);
	    exra1 = cang_(&eth);
	    s_wsfe(&io___1704);
	    do_fio(&c__1, (char *)&rpdat_1.rfld, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&exrm1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&exra1, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	    if (gnd_1.ksymp > 1 && gnd_1.iperf != 1) {
		z__4.r = gnd_1.xkl.r * -0.f - gnd_1.xkl.i * -1.f, z__4.i = 
			gnd_1.xkl.r * -1.f + gnd_1.xkl.i * -0.f;
		z__3.r = rpdat_1.rfld * z__4.r, z__3.i = rpdat_1.rfld * 
			z__4.i;
		z_exp(&z__2, &z__3);
		z__1.r = z__2.r / rpdat_1.rfld, z__1.i = z__2.i / 
			rpdat_1.rfld;
		eth.r = z__1.r, eth.i = z__1.i;
		exrm2 = z_abs(&eth);
		exra2 = cang_(&eth);
		s_wsfe(&io___1707);
		do_fio(&c__1, (char *)&exrm2, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&exra2, (ftnlen)sizeof(doublereal));
		e_wsfe();
	    }
	}
	ipdx = rpdat_1.ipd + 1;
	if (sorces_1.isortp[sorces_1.nsorc - 1] != 1 && sorces_1.isortp[
		sorces_1.nsorc - 1] != 4) {
	    ipdx = 3;
	}
	s_wsfe(&io___1709);
	do_fio(&c__1, igtp + (ipdx - 1) * 19, (ftnlen)19);
	do_fio(&c__1, igax + rpdat_1.iax * 14, (ftnlen)14);
	do_fio(&c__1, funits, (ftnlen)7);
	do_fio(&c__1, funits, (ftnlen)7);
	e_wsfe();
    }
    if (sorces_1.isortp[sorces_1.nsorc - 1] == 1 || sorces_1.isortp[
	    sorces_1.nsorc - 1] == 4) {

/*        VOLTAGE SOURCES */

	prad = *pin - *ploss - *pnls;
	gcop = constn_1.tp / *pin;
	gconn = gcop;
	if (rpdat_1.ipd != 0) {
	    gconn = gconn * *pin / prad;
	}
    } else if (sorces_1.isortp[sorces_1.nsorc - 1] == 3) {

/*        HERTZIAN DIPOLE SOURCE */

	if (sorces_1.psor3[sorces_1.nsorc - 1] >= 0.f) {
	    z__2.r = gnd_1.etau.r * gnd_1.xku.r - gnd_1.etau.i * gnd_1.xku.i, 
		    z__2.i = gnd_1.etau.r * gnd_1.xku.i + gnd_1.etau.i * 
		    gnd_1.xku.r;
	    z__1.r = z__2.r * gnd_1.xku.r - z__2.i * gnd_1.xku.i, z__1.i = 
		    z__2.r * gnd_1.xku.i + z__2.i * gnd_1.xku.r;
	    eth.r = z__1.r, eth.i = z__1.i;
	} else {
	    z__2.r = gnd_1.etal.r * gnd_1.xkl.r - gnd_1.etal.i * gnd_1.xkl.i, 
		    z__2.i = gnd_1.etal.r * gnd_1.xkl.i + gnd_1.etal.i * 
		    gnd_1.xkl.r;
	    z__1.r = z__2.r * gnd_1.xkl.r - z__2.i * gnd_1.xkl.i, z__1.i = 
		    z__2.r * gnd_1.xkl.i + z__2.i * gnd_1.xkl.r;
	    eth.r = z__1.r, eth.i = z__1.i;
	}
/* Computing 2nd power */
	d__2 = sorces_1.psor6[sorces_1.nsorc - 1];
	d__1 = d__2 * d__2;
	z__2.r = d__1 * eth.r, z__2.i = d__1 * eth.i;
	d__3 = constn_1.pi * 12.f;
	z__1.r = z__2.r / d__3, z__1.i = z__2.i / d__3;
	pinhz = z__1.r;
	prad = pinhz - *ploss - *pnls;
	gcop = constn_1.tp / pinhz;
	gconn = gcop;
	if (rpdat_1.ipd != 0) {
	    gconn = gconn * *pin / prad;
	}
    } else {

/*     PLANE-WAVE SOURCE */

	prad = 0.f;
/*     Changed 1/24/06 to correct use of PSOR5 and PSOR4. */
	z__1.r = gnd_1.xku.r * gnd_1.xku.r - gnd_1.xku.i * gnd_1.xku.i, 
		z__1.i = gnd_1.xku.r * gnd_1.xku.i + gnd_1.xku.i * 
		gnd_1.xku.r;
/* Computing 2nd power */
	d__1 = sorces_1.psor5[sorces_1.nsorc - 1];
/* Computing 2nd power */
	d__2 = sorces_1.psor4[sorces_1.nsorc - 1];
	gconn = z_abs(&z__1) / (constn_1.pi * (d__1 * d__1 + 1.f) * (d__2 * 
		d__2));
	gcop = gconn;
    }
    i__ = 0;
    gmax = -1e10f;
    pint = 0.f;
    tmp1 = rpdat_1.dph * constn_1.dtorad;
    tmp2 = rpdat_1.dth * .5f * constn_1.dtorad;
    phi = rpdat_1.phis - rpdat_1.dph;
    i__1 = rpdat_1.nph;
    for (kph = 1; kph <= i__1; ++kph) {
	phi += rpdat_1.dph;
	pha = phi * constn_1.dtorad;
	thet = rpdat_1.thets - rpdat_1.dth;
	i__2 = rpdat_1.nth;
	for (kth = 1; kth <= i__2; ++kth) {
	    thet += rpdat_1.dth;
	    tha = thet * constn_1.dtorad;
	    eta = gnd_1.etau.r;
	    if (abs(thet) > 90.f) {
		eta = gnd_1.etal.r;
	    }
	    if (sorces_1.isortp[sorces_1.nsorc - 1] == 2) {
		eta = 1.f;
	    }
	    gcon = gconn / eta;
	    if (gnd_1.ifar == 1) {
		if (gnd_1.iperf != 1) {
		    gfld_(&rpdat_1.rfld, &pha, &thet, &eth, &eph, &erd);
		    erdm = z_abs(&erd);
		    erda = cang_(&erd);
		} else {
		    if (abs(thet) > 1e-20f) {
			tha = atan(rpdat_1.rfld / thet);
		    } else {
			tha = constn_1.pi * .5f;
		    }
		    ffld_(&tha, &pha, &eth, &eph);
		    rdist = sqrt(rpdat_1.rfld * rpdat_1.rfld + thet * thet);
		    z__5.r = gnd_1.xku.r * -0.f - gnd_1.xku.i * -1.f, z__5.i =
			     gnd_1.xku.r * -1.f + gnd_1.xku.i * -0.f;
		    z__4.r = rdist * z__5.r, z__4.i = rdist * z__5.i;
		    z_exp(&z__3, &z__4);
		    z__2.r = eth.r * z__3.r - eth.i * z__3.i, z__2.i = eth.r *
			     z__3.i + eth.i * z__3.r;
		    z__1.r = z__2.r / rdist, z__1.i = z__2.i / rdist;
		    eth.r = z__1.r, eth.i = z__1.i;
		    z__5.r = gnd_1.xku.r * -0.f - gnd_1.xku.i * -1.f, z__5.i =
			     gnd_1.xku.r * -1.f + gnd_1.xku.i * -0.f;
		    z__4.r = rdist * z__5.r, z__4.i = rdist * z__5.i;
		    z_exp(&z__3, &z__4);
		    z__2.r = eph.r * z__3.r - eph.i * z__3.i, z__2.i = eph.r *
			     z__3.i + eph.i * z__3.r;
		    z__1.r = z__2.r / rdist, z__1.i = z__2.i / rdist;
		    eph.r = z__1.r, eph.i = z__1.i;
		    erdm = 0.f;
		    erda = 0.f;
		}
	    } else {
		ffld_(&tha, &pha, &eth, &eph);
	    }
	    d_cnjg(&z__2, &eth);
	    z__1.r = eth.r * z__2.r - eth.i * z__2.i, z__1.i = eth.r * z__2.i 
		    + eth.i * z__2.r;
	    ethm2 = z__1.r;
	    ethm = sqrt(ethm2);
	    etha = cang_(&eth);
	    d_cnjg(&z__2, &eph);
	    z__1.r = eph.r * z__2.r - eph.i * z__2.i, z__1.i = eph.r * z__2.i 
		    + eph.i * z__2.r;
	    ephm2 = z__1.r;
	    ephm = sqrt(ephm2);
	    epha = cang_(&eph);
	    if (gnd_1.ifar == 1) {
		s_wsfe(&io___1738);
		do_fio(&c__1, (char *)&rpdat_1.rfld, (ftnlen)sizeof(
			doublereal));
		do_fio(&c__1, (char *)&phi, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&thet, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&ethm, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&etha, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&ephm, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&epha, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&erdm, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&erda, (ftnlen)sizeof(doublereal));
		e_wsfe();
		goto L30;
	    }
/*     ELLIPTICAL POLARIZATION CALC. */
	    if (ethm2 < 1e-20f && ephm2 < 1e-20f) {
		tilta = 0.f;
		emajr2 = 0.f;
		eminr2 = 0.f;
		axrat = 0.f;
		s_copy(isens, "      ", (ftnlen)6, (ftnlen)6);
	    } else {
		dfaz = epha - etha;
		if (epha >= 0.f) {
		    dfaz2 = dfaz - 360.f;
		} else {
		    dfaz2 = dfaz + 360.f;
		}
		if (abs(dfaz) > abs(dfaz2)) {
		    dfaz = dfaz2;
		}
		cdfaz = cos(dfaz * constn_1.dtorad);
		tstor1 = ethm2 - ephm2;
		tstor2 = ephm * 2.f * ethm * cdfaz;
		tilta = atgn2_(&tstor2, &tstor1) * .5f;
		stilta = sin(tilta);
		tstor1 = tstor1 * stilta * stilta;
		tstor2 = tstor2 * stilta * cos(tilta);
		emajr2 = -tstor1 + tstor2 + ethm2;
		eminr2 = tstor1 - tstor2 + ephm2;
		if (eminr2 < 0.f) {
		    eminr2 = 0.f;
		}
		axrat = sqrt(eminr2 / emajr2);
		tilta /= constn_1.dtorad;
		if (axrat < 1e-5f) {
		    s_copy(isens, "LINEAR", (ftnlen)6, (ftnlen)6);
		} else {
		    if (dfaz <= 0.f) {
			s_copy(isens, "RIGHT ", (ftnlen)6, (ftnlen)6);
		    } else {
			s_copy(isens, "LEFT  ", (ftnlen)6, (ftnlen)6);
		    }
		}
	    }
	    d__1 = gcon * emajr2;
	    gnmj = db10_(&d__1);
	    d__1 = gcon * eminr2;
	    gnmn = db10_(&d__1);
	    d__1 = gcon * ethm2;
	    gnv = db10_(&d__1);
	    d__1 = gcon * ephm2;
	    gnh = db10_(&d__1);
	    d__1 = gcon * (ethm2 + ephm2);
	    gtot = db10_(&d__1);
	    ++i__;
	    if (rpdat_1.inor > 0 && i__ <= normax) {
		if (rpdat_1.inor == 1) {
		    tstor1 = gnmj;
		} else if (rpdat_1.inor == 2) {
		    tstor1 = gnmn;
		} else if (rpdat_1.inor == 3) {
		    tstor1 = gnv;
		} else if (rpdat_1.inor == 4) {
		    tstor1 = gnh;
		} else if (rpdat_1.inor == 5) {
		    tstor1 = gtot;
		}
		scratm_3.gain[i__ - 1] = tstor1;
		if (tstor1 > gmax) {
		    gmax = tstor1;
		}
	    }
	    if (rpdat_1.iavp != 0) {
		tstor1 = (ethm2 + ephm2) / eta;
		tmp3 = tha - tmp2;
		tmp4 = tha + tmp2;
		if (kth == 1) {
		    tmp3 = tha;
		}
		if (kth == rpdat_1.nth) {
		    tmp4 = tha;
		}
		da = (d__1 = tmp1 * (cos(tmp3) - cos(tmp4)), abs(d__1));
		if (kph == 1 || kph == rpdat_1.nph) {
		    da *= .5f;
		}
		pint += tstor1 * da;
		if (rpdat_1.iavp == 2) {
		    goto L30;
		}
	    }
	    if (rpdat_1.iax == 1) {
		tmp5 = gnv;
		tmp6 = gnh;
	    } else {
		tmp5 = gnmj;
		tmp6 = gnmn;
	    }
	    if (rpdat_1.rfld > 1e-20f) {
		if (gnd_1.ksymp == 1 || abs(thet) <= 90.f) {
		    ethm *= exrm1;
		    etha += exra1;
		    ephm *= exrm1;
		    epha += exra1;
		} else {
		    ethm *= exrm2;
		    etha += exra2;
		    ephm *= exrm2;
		    epha += exra2;
		}
	    }
	    s_wsfe(&io___1760);
	    do_fio(&c__1, (char *)&thet, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&phi, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&tmp5, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&tmp6, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&gtot, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&axrat, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&tilta, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, isens, (ftnlen)6);
	    do_fio(&c__1, (char *)&ethm, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&etha, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ephm, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&epha, (ftnlen)sizeof(doublereal));
	    e_wsfe();
L30:
	    ;
	}
    }
    if (rpdat_1.iavp != 0) {
	tmp3 = rpdat_1.thets * constn_1.dtorad;
	tmp4 = tmp3 + rpdat_1.dth * constn_1.dtorad * (doublereal) (
		rpdat_1.nth - 1);
	tmp3 = (d__1 = rpdat_1.dph * constn_1.dtorad * (doublereal) (
		rpdat_1.nph - 1) * (cos(tmp3) - cos(tmp4)), abs(d__1));
	pint = constn_1.tp * pint / tmp3;
	avgain = gcop * pint / constn_1.tp;
	tmp3 /= constn_1.pi;
	s_wsfe(&io___1762);
	do_fio(&c__1, (char *)&avgain, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&pint, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    s_wsfe(&io___1763);
    e_wsfe();
    if (rpdat_1.inor == 0) {
	return 0;
    }
    if (abs(rpdat_1.gnor) > 1e-20f) {
	gmax = rpdat_1.gnor;
    }
    s_wsfe(&io___1764);
    do_fio(&c__1, igntp + (rpdat_1.inor - 1) * 12, (ftnlen)12);
    do_fio(&c__1, (char *)&gmax, (ftnlen)sizeof(doublereal));
    e_wsfe();
    itmp2 = rpdat_1.nph * rpdat_1.nth;
    if (itmp2 > normax) {
	itmp2 = normax;
    }
    itmp1 = (itmp2 + 2) / 3;
    itmp2 = itmp1 * 3 - itmp2;
    itmp3 = itmp1;
    itmp4 = itmp1 << 1;
    if (itmp2 == 2) {
	--itmp4;
    }
    i__2 = itmp1;
    for (i__ = 1; i__ <= i__2; ++i__) {
	++itmp3;
	++itmp4;
	j = (i__ - 1) / rpdat_1.nth;
	tmp1 = rpdat_1.thets + (doublereal) (i__ - j * rpdat_1.nth - 1) * 
		rpdat_1.dth;
	tmp2 = rpdat_1.phis + (doublereal) j * rpdat_1.dph;
	j = (itmp3 - 1) / rpdat_1.nth;
	tmp3 = rpdat_1.thets + (doublereal) (itmp3 - j * rpdat_1.nth - 1) * 
		rpdat_1.dth;
	tmp4 = rpdat_1.phis + (doublereal) j * rpdat_1.dph;
	j = (itmp4 - 1) / rpdat_1.nth;
	tmp5 = rpdat_1.thets + (doublereal) (itmp4 - j * rpdat_1.nth - 1) * 
		rpdat_1.dth;
	tmp6 = rpdat_1.phis + (doublereal) j * rpdat_1.dph;
	tstor1 = scratm_3.gain[i__ - 1] - gmax;
	if (i__ == itmp1 && itmp2 != 0) {
	    if (itmp2 == 2) {
		s_wsfe(&io___1770);
		do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tstor1, (ftnlen)sizeof(doublereal));
		e_wsfe();
		return 0;
	    } else {
		tstor2 = scratm_3.gain[itmp3 - 1] - gmax;
		s_wsfe(&io___1771);
		do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tstor1, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tmp4, (ftnlen)sizeof(doublereal));
		do_fio(&c__1, (char *)&tstor2, (ftnlen)sizeof(doublereal));
		e_wsfe();
		return 0;
	    }
	}
	tstor2 = scratm_3.gain[itmp3 - 1] - gmax;
	pint = scratm_3.gain[itmp4 - 1] - gmax;
/* L32: */
	s_wsfe(&io___1772);
	do_fio(&c__1, (char *)&tmp1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tstor1, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp3, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp4, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tstor2, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp5, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tmp6, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&pint, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

} /* rdpat_ */

/* Subroutine */ int readgm_(integer *inunit__, char *code, integer *i1, 
	integer *i2, doublereal *r1, doublereal *r2, doublereal *r3, 
	doublereal *r4, doublereal *r5, doublereal *r6, doublereal *r7, 
	doublereal *r8, doublereal *r9, doublereal *r10, char *fname, ftnlen 
	code_len, ftnlen fname_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ieof, icmblk;
    static char recdat[78];
    static doublereal reaval[10];
    static integer intval[2];
    extern /* Subroutine */ int parsit_(integer *, integer *, integer *, char 
	    *, char *, integer *, doublereal *, char *, integer *, ftnlen, 
	    ftnlen, ftnlen), comout_(char *, integer *, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     READGM calls PARSIT to read input commands in the format for */
/*     structure geometry data. */

/*     OUTPUT: */
/*     CODE        two letter mnemonic code */
/*     I1 - I2     integer values from record */
/*     R1 - R10    real values from record */

    icmblk = 0;

/*     Call the routine to read the record and parse it. */

L1:
    parsit_(inunit__, &c__2, &c__10, code, recdat, intval, reaval, fname, &
	    ieof, code_len, (ftnlen)78, fname_len);
    if (ieof < 0) {
	s_copy(code, "GE", code_len, (ftnlen)2);
    }

/*     Process text lines.  Then read next input line. */

    if (s_cmp(code, "CM", code_len, (ftnlen)2) == 0) {
	comout_(recdat, &icmblk, (ftnlen)78);
	goto L1;
    }
    if (icmblk == 1) {
	icmblk = 2;
	comout_(recdat, &icmblk, (ftnlen)78);
    }

/*     Set the return variables to the buffer array elements. */

    *i1 = intval[0];
    *i2 = intval[1];
    *r1 = reaval[0];
    *r2 = reaval[1];
    *r3 = reaval[2];
    *r4 = reaval[3];
    *r5 = reaval[4];
    *r6 = reaval[5];
    *r7 = reaval[6];
    *r8 = reaval[7];
    *r9 = reaval[8];
    *r10 = reaval[9];
    return 0;
} /* readgm_ */

/* Subroutine */ int readmn_(integer *inunit__, char *code, integer *i1, 
	integer *i2, integer *i3, integer *i4, doublereal *f1, doublereal *f2,
	 doublereal *f3, doublereal *f4, doublereal *f5, doublereal *f6, 
	doublereal *f7, char *fname, ftnlen code_len, ftnlen fname_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ieof, icmblk;
    static char recdat[78];
    static doublereal reaval[7];
    static integer intval[4];
    extern /* Subroutine */ int parsit_(integer *, integer *, integer *, char 
	    *, char *, integer *, doublereal *, char *, integer *, ftnlen, 
	    ftnlen, ftnlen), comout_(char *, integer *, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     READMN calls PARSIT to read input commands in the format for */
/*     electrical parameters (after geometry data.) */

    icmblk = 0;

/*     Call the routine to read the record and parse it. */

L1:
    parsit_(inunit__, &c__4, &c__7, code, recdat, intval, reaval, fname, &
	    ieof, code_len, (ftnlen)78, fname_len);
    if (ieof < 0) {
	s_copy(code, "EN", code_len, (ftnlen)2);
    }

/*     Process text lines.  Then read next input line. */

    if (s_cmp(code, "CM", code_len, (ftnlen)2) == 0) {
	comout_(recdat, &icmblk, (ftnlen)78);
	goto L1;
    }
    if (icmblk == 1) {
	icmblk = 2;
	comout_(recdat, &icmblk, (ftnlen)78);
    }

/*     Set the return variables to the buffer array elements. */

    *i1 = intval[0];
    *i2 = intval[1];
    *i3 = intval[2];
    *i4 = intval[3];
    *f1 = reaval[0];
    *f2 = reaval[1];
    *f3 = reaval[2];
    *f4 = reaval[3];
    *f5 = reaval[4];
    *f6 = reaval[5];
    *f7 = reaval[6];
    return 0;
} /* readmn_ */

/* Subroutine */ int parsit_(integer *inlun, integer *maxint, integer *maxre, 
	char *cmnd, char *recdat, integer *intfld, doublereal *refld, char *
	fname, integer *ieof, ftnlen cmnd_len, ftnlen recdat_len, ftnlen 
	fname_len)
{
    /* Format strings */
    static char fmt_8000[] = "(a80)";
    static char fmt_8005[] = "(\002 PARSIT: INVALID ENTRY OF NON-NUMERIC D"
	    "ATA\002)";
    static char fmt_8001[] = "(//,\002 PARSIT: INPUT ERROR - TOO MANY FIELDS"
	    " IN RECORD\002)";
    static char fmt_8002[] = "(//,\002 PARSIT: INPUT ERROR - INVALID NUMBER "
	    "AT INTEGER\002,\002 POSITION \002,i1)";
    static char fmt_8003[] = "(//,\002 PARSIT: INPUT ERROR - INVALID NUMBER "
	    "AT REAL\002,\002 POSITION \002,i1)";
    static char fmt_8004[] = "(\002 ***** TEXT -->  \002,a80)";

    /* System generated locals */
    address a__1[3];
    integer i__1, i__2, i__3[3];
    icilist ici__1;

    /* Builtin functions */
    integer s_rsfe(cilist *), do_fio(integer *, char *, ftnlen), e_rsfe(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void), i_indx(char *, char *, ftnlen, ftnlen), s_rsli(icilist *), 
	    do_lio(integer *, integer *, char *, ftnlen), e_rsli(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, j, k;
    static char rec[80];
    static integer ind, inde, last, bgnfld[17], endfld[17], namfld;
    static char buffer[40];
    extern /* Subroutine */ int upcase_(char *, char *, integer *, ftnlen, 
	    ftnlen);
    static integer length;
    static logical fldtrm;
    static integer totfld, totcol;

    /* Fortran I/O blocks */
    static cilist io___1783 = { 1, 0, 1, fmt_8000, 0 };
    static cilist io___1795 = { 0, 3, 0, fmt_8005, 0 };
    static cilist io___1796 = { 0, 3, 0, fmt_8001, 0 };
    static cilist io___1801 = { 0, 3, 0, fmt_8002, 0 };
    static cilist io___1802 = { 0, 3, 0, fmt_8003, 0 };
    static cilist io___1803 = { 0, 3, 0, fmt_8004, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     PARSIT reads an input record and parses it. */

/*     OUTPUT: */
/*     MAXINT     total number of integers in record */
/*     MAXRE      total number of real values in record */
/*     CMND       two letter mnemonic code */
/*     INTFLD     integer values from record */
/*     REFLD      real values from record */
/*     FNAME      text returned.  Can be used for a file name. */

/*  *****  Internal Variables */
/*     BGNFLD     list of starting indices */
/*     BUFFER     text buffer */
/*     ENDFLD     list of ending indices */
/*     FLDTRM     flag to indicate that pointer is in field position */
/*     REC        input line as read */
/*     TOTCOL     total number of columns in REC */
/*     TOTFLD     number of numeric fields */

    /* Parameter adjustments */
    --intfld;
    --refld;

    /* Function Body */
    io___1783.ciunit = *inlun;
    *ieof = s_rsfe(&io___1783);
    if (*ieof != 0) {
	goto L100001;
    }
    *ieof = do_fio(&c__1, rec, (ftnlen)80);
    if (*ieof != 0) {
	goto L100001;
    }
    *ieof = e_rsfe();
L100001:
    s_copy(recdat, rec + 2, (ftnlen)78, (ftnlen)78);
    upcase_(rec, rec, &totcol, (ftnlen)80, (ftnlen)80);

/*     Store opcode and clear field arrays. */

    s_copy(cmnd, rec, (ftnlen)2, (ftnlen)2);
    s_copy(fname, " ", fname_len, (ftnlen)1);
    i__1 = *maxint;
    for (i__ = 1; i__ <= i__1; ++i__) {
	intfld[i__] = 0;
/* L3000: */
    }
    i__1 = *maxre;
    for (i__ = 1; i__ <= i__1; ++i__) {
	refld[i__] = 0.f;
/* L3010: */
    }
    if (*ieof < 0) {
	return 0;
    }
    if (s_cmp(cmnd, "CM", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(cmnd, "CE", (
	    ftnlen)2, (ftnlen)2) == 0) {
	s_copy(cmnd, "CM", (ftnlen)2, (ftnlen)2);
	return 0;
    }
    for (i__ = 1; i__ <= 17; ++i__) {
	bgnfld[i__ - 1] = 0;
	endfld[i__ - 1] = 0;
/* L3020: */
    }

/*     Find the beginning and ending of each field as well as the total */
/*     number of fields. */

    totfld = 0;
    namfld = 0;
    fldtrm = FALSE_;
    last = *maxre + *maxint;
    i__1 = totcol;
    for (j = 3; j <= i__1; ++j) {
	k = *(unsigned char *)&rec[j - 1];

/*     Check for end of line comment (`!').  This is a new modification */
/*     to allow VAX-like comments at the end of data records, i.e. */
/*       GW 1 7 0 0 0 0 0 .5 .0001 ! DIPOLE WIRE */
/*       GE ! END OF GEOMETRY */

	if (k == 33) {
	    if (fldtrm) {
		endfld[totfld - 1] = j - 1;
	    }
	    goto L5000;

/*     Set the ending index when the character is a comma or space and */
/*     the pointer is in a field position (FLDTRM = .TRUE.). */

	} else if (k == 32 || k == 44) {
	    if (fldtrm) {
		endfld[totfld - 1] = j - 1;
		fldtrm = FALSE_;
	    }

/*     Set beginning index when the character is not a comma or space and */
/*     the pointer is not currently in a field position (FLDTRM= .FALSE.) */

	} else if (! fldtrm) {
	    ++totfld;
	    fldtrm = TRUE_;
	    bgnfld[totfld - 1] = j;
	    if (k > 57) {
		namfld = totfld;
	    }
	}
/* L4000: */
    }
    if (fldtrm) {
	endfld[totfld - 1] = totcol;
    }

/*     Check to see if the total number of value fields is within the */
/*     precribed limits. */

L5000:
    if (namfld > 0) {
	--totfld;
	if (namfld != totfld + 1) {
	    s_wsfe(&io___1795);
	    e_wsfe();
	    goto L9010;
	}
	i__1 = bgnfld[namfld - 1] - 1;
	s_copy(fname, rec + i__1, fname_len, endfld[namfld - 1] - i__1);
    }
    if (totfld == 0) {
	return 0;
    }
    if (totfld > last) {
	s_wsfe(&io___1796);
	e_wsfe();
	goto L9010;
    }
    j = min(totfld,*maxint);

/*     Parse out integer values and store into integer buffer array. */

    i__1 = j;
    for (i__ = 1; i__ <= i__1; ++i__) {
	length = endfld[i__ - 1] - bgnfld[i__ - 1] + 1;
	i__2 = bgnfld[i__ - 1] - 1;
	s_copy(buffer, rec + i__2, (ftnlen)40, endfld[i__ - 1] - i__2);
	ind = i_indx(buffer, ".", length, (ftnlen)1);
	if (ind > 0 && ind < length) {
	    goto L9000;
	}
	if (ind == length) {
	    --length;
	}
	ici__1.icierr = 1;
	ici__1.iciend = 0;
	ici__1.icirnum = 1;
	ici__1.icirlen = length;
	ici__1.iciunit = buffer;
	ici__1.icifmt = 0;
	i__2 = s_rsli(&ici__1);
	if (i__2 != 0) {
	    goto L9000;
	}
	i__2 = do_lio(&c__3, &c__1, (char *)&intfld[i__], (ftnlen)sizeof(
		integer));
	if (i__2 != 0) {
	    goto L9000;
	}
	i__2 = e_rsli();
	if (i__2 != 0) {
	    goto L9000;
	}
/* L5090: */
    }

/*     Parse out real values and store into real buffer array. */

    if (totfld > *maxint) {
	j = *maxint + 1;
	i__1 = totfld;
	for (i__ = j; i__ <= i__1; ++i__) {
	    length = endfld[i__ - 1] - bgnfld[i__ - 1] + 1;
	    i__2 = bgnfld[i__ - 1] - 1;
	    s_copy(buffer, rec + i__2, (ftnlen)40, endfld[i__ - 1] - i__2);
	    ind = i_indx(buffer, ".", length, (ftnlen)1);
	    if (ind == 0) {
		inde = i_indx(buffer, "E", length, (ftnlen)1);
		++length;
		if (inde == 0) {
		    *(unsigned char *)&buffer[length - 1] = '.';
		} else {
/* Writing concatenation */
		    i__3[0] = inde - 1, a__1[0] = buffer;
		    i__3[1] = 1, a__1[1] = ".";
		    i__3[2] = length - 1 - (inde - 1), a__1[2] = buffer + (
			    inde - 1);
		    s_cat(buffer, a__1, i__3, &c__3, (ftnlen)40);
		}
	    }
	    ici__1.icierr = 1;
	    ici__1.iciend = 0;
	    ici__1.icirnum = 1;
	    ici__1.icirlen = length;
	    ici__1.iciunit = buffer;
	    ici__1.icifmt = 0;
	    i__2 = s_rsli(&ici__1);
	    if (i__2 != 0) {
		goto L9000;
	    }
	    i__2 = do_lio(&c__5, &c__1, (char *)&refld[i__ - *maxint], (
		    ftnlen)sizeof(doublereal));
	    if (i__2 != 0) {
		goto L9000;
	    }
	    i__2 = e_rsli();
	    if (i__2 != 0) {
		goto L9000;
	    }
/* L6000: */
	}
    }
    return 0;

/*     Print out text of record line when error occurs. */

L9000:
    if (i__ <= *maxint) {
	s_wsfe(&io___1801);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
    } else {
	i__ -= *maxint;
	s_wsfe(&io___1802);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
    }
L9010:
    s_wsfe(&io___1803);
    do_fio(&c__1, rec, (ftnlen)80);
    e_wsfe();
    s_stop("INPUT ERROR", (ftnlen)11);

/*     Input formats and output messages. */

    return 0;
} /* parsit_ */

/* Subroutine */ int upcase_(char *intext, char *outtxt, integer *length, 
	ftnlen intext_len, ftnlen outtxt_len)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer i_len(char *, ftnlen);

    /* Local variables */
    static integer i__, j;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     UPCASE finds the length of INTEXT and converts it to upper case. */



    *length = i_len(intext, intext_len);
    i__1 = *length;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = *(unsigned char *)&intext[i__ - 1];
	if (j >= 96) {
	    j += -32;
	}
	*(unsigned char *)&outtxt[i__ - 1] = (char) j;
/* L3000: */
    }
    return 0;
} /* upcase_ */

/* Subroutine */ int reblk_(doublecomplex *b, doublecomplex *bx, integer *nb, 
	integer *nbx, integer *n2c, integer *iuin, integer *iuot)
{
    /* System generated locals */
    integer b_dim1, b_offset, bx_dim1, bx_offset, i__1, i__2, i__3, i__4, 
	    i__5, i__6;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *);

    /* Local variables */
    static integer i__, j, ib, ix, nib, npb, ibx, nix, npx;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen), recot_(doublecomplex *, 
	    integer *, integer *, integer *, integer *, char *, ftnlen), 
	    daopen_(integer *, char *, char *, char *, integer *, ftnlen, 
	    ftnlen, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     REBLK reblocks array B, in the N.G.F. solution, from blocks of */
/*     rows on unit IUIN to blocks of columns on unit IUOT. */

    /* Parameter adjustments */
    b_dim1 = *nb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *nbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;

    /* Function Body */
    cl__1.cerr = 1;
    cl__1.cunit = *iuot;
    cl__1.csta = "DELETE";
    i__1 = f_clos(&cl__1);
    if (i__1 != 0) {
	goto L4;
    }
L4:
    i__1 = matpar_1.npbl * *nb;
    daopen_(iuot, "TAPEBB.NEC", "unknown", "DELETE", &i__1, (ftnlen)10, (
	    ftnlen)7, (ftnlen)6);
    nib = 0;
    npb = matpar_1.npbl;
    i__1 = matpar_1.nbbl;
    for (ib = 1; ib <= i__1; ++ib) {
	if (ib == matpar_1.nbbl) {
	    npb = matpar_1.nlbl;
	}
	nix = 0;
	npx = matpar_1.npbx;
	i__2 = matpar_1.nbbx;
	for (ibx = 1; ibx <= i__2; ++ibx) {
	    if (ibx == matpar_1.nbbx) {
		npx = matpar_1.nlbx;
	    }
	    i__3 = matpar_1.npbx * *n2c;
	    recin_(&bx[bx_offset], iuin, &c__1, &i__3, &ibx, " READ BX IN RE"
		    "BLK", (ftnlen)17);
	    i__3 = npx;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		ix = i__ + nix;
		i__4 = npb;
		for (j = 1; j <= i__4; ++j) {
/* L1: */
		    i__5 = ix + j * b_dim1;
		    i__6 = i__ + (j + nib) * bx_dim1;
		    b[i__5].r = bx[i__6].r, b[i__5].i = bx[i__6].i;
		}
	    }
/* L2: */
	    nix += matpar_1.npbx;
	}
	i__2 = *nb * npb;
	recot_(&b[b_offset], iuot, &c__1, &i__2, &ib, " WRITE B IN REBLK", (
		ftnlen)17);
/* L3: */
	nib += matpar_1.npbl;
    }
    cl__1.cerr = 0;
    cl__1.cunit = *iuin;
    cl__1.csta = "DELETE";
    f_clos(&cl__1);
    return 0;
} /* reblk_ */

/* Subroutine */ int reflc_(integer *ix, integer *iy, integer *iz, integer *
	itx, integer *nop)
{
    /* Format strings */
    static char fmt_24[] = "(\002 REFLEC: GEOMETRY DATA ERROR - SEGMENT\002,"
	    "i5,\002 LIES IN\002,\002 PLANE OF SYMMETRY\002)";
    static char fmt_25[] = "(\002 REFLEC: GEOMETRY DATA ERROR - PATCH\002,"
	    "i4,\002 LIES IN PLANE\002,\002 OF SYMMETRY\002)";

    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double cos(doublereal), sin(doublereal);

    /* Local variables */
    static integer i__, j, k;
    static doublereal e1, e2;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static doublereal cs, xk, yk;
    static integer nx;
    static doublereal ss;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    static doublereal sam;
    static integer iti, nxx;
    static doublereal fnop;
    static integer itagi;

    /* Fortran I/O blocks */
    static cilist io___1826 = { 0, 3, 0, fmt_24, 0 };
    static cilist io___1829 = { 0, 3, 0, fmt_25, 0 };
    static cilist io___1830 = { 0, 3, 0, fmt_24, 0 };
    static cilist io___1831 = { 0, 3, 0, fmt_25, 0 };
    static cilist io___1832 = { 0, 3, 0, fmt_24, 0 };
    static cilist io___1833 = { 0, 3, 0, fmt_25, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     REFLC reflects a partial structure along X,Y, or Z axes or rotates */
/*     the structure to complete a symmetric structure. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    iti = *itx;
    if (*ix < 0) {
	goto L19;
    }
    if (*nop == 0) {
	return 0;
    }
    data_1.ipsym = 1;
    if (*iz == 0) {
	goto L6;
    }

/*     REFLECT ALONG Z AXIS */

    data_1.ipsym = 2;
    if (data_1.n < data_1.n2) {
	goto L3;
    }
    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
	nx = i__ + data_1.n - data_1.n1;
	e1 = data_1.z__[i__ - 1];
	e2 = z2[i__ - 1];
	if (abs(e1) + abs(e2) > 1e-5f && e1 * e2 >= -1e-6f) {
	    goto L1;
	}
	s_wsfe(&io___1826);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L1:
	data_1.x[nx - 1] = data_1.x[i__ - 1];
	data_1.y[nx - 1] = data_1.y[i__ - 1];
	data_1.z__[nx - 1] = -e1;
	x2[nx - 1] = x2[i__ - 1];
	y2[nx - 1] = y2[i__ - 1];
	z2[nx - 1] = -e2;
	itagi = data_1.itag[i__ - 1];
	if (itagi == 0) {
	    data_1.itag[nx - 1] = 0;
	}
	if (itagi != 0) {
	    data_1.itag[nx - 1] = itagi + iti;
	}
/* L2: */
	data_1.bi[nx - 1] = data_1.bi[i__ - 1];
    }
    data_1.n = (data_1.n << 1) - data_1.n1;
    iti <<= 1;
L3:
    if (data_1.m < data_1.m2) {
	goto L6;
    }
    nxx = data_1.ld + 1 - data_1.m1;
    i__1 = data_1.m;
    for (i__ = data_1.m2; i__ <= i__1; ++i__) {
	--nxx;
	nx = nxx - data_1.m + data_1.m1;
	if ((d__1 = data_1.z__[nxx - 1], abs(d__1)) > 1e-10f) {
	    goto L4;
	}
	s_wsfe(&io___1829);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L4:
	data_1.x[nx - 1] = data_1.x[nxx - 1];
	data_1.y[nx - 1] = data_1.y[nxx - 1];
	data_1.z__[nx - 1] = -data_1.z__[nxx - 1];
	t1x[nx - 1] = t1x[nxx - 1];
	t1y[nx - 1] = t1y[nxx - 1];
	t1z[nx - 1] = -t1z[nxx - 1];
	data_1.t2x[nx - 1] = data_1.t2x[nxx - 1];
	data_1.t2y[nx - 1] = data_1.t2y[nxx - 1];
	data_1.t2z[nx - 1] = -data_1.t2z[nxx - 1];
	data_1.salp[nx - 1] = -data_1.salp[nxx - 1];
/* L5: */
	data_1.bi[nx - 1] = data_1.bi[nxx - 1];
    }
    data_1.m = (data_1.m << 1) - data_1.m1;
L6:
    if (*iy == 0) {
	goto L12;
    }

/*     REFLECT ALONG Y AXIS */

    if (data_1.n < data_1.n2) {
	goto L9;
    }
    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
	nx = i__ + data_1.n - data_1.n1;
	e1 = data_1.y[i__ - 1];
	e2 = y2[i__ - 1];
	if (abs(e1) + abs(e2) > 1e-5f && e1 * e2 >= -1e-6f) {
	    goto L7;
	}
	s_wsfe(&io___1830);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L7:
	data_1.x[nx - 1] = data_1.x[i__ - 1];
	data_1.y[nx - 1] = -e1;
	data_1.z__[nx - 1] = data_1.z__[i__ - 1];
	x2[nx - 1] = x2[i__ - 1];
	y2[nx - 1] = -e2;
	z2[nx - 1] = z2[i__ - 1];
	itagi = data_1.itag[i__ - 1];
	if (itagi == 0) {
	    data_1.itag[nx - 1] = 0;
	}
	if (itagi != 0) {
	    data_1.itag[nx - 1] = itagi + iti;
	}
/* L8: */
	data_1.bi[nx - 1] = data_1.bi[i__ - 1];
    }
    data_1.n = (data_1.n << 1) - data_1.n1;
    iti <<= 1;
L9:
    if (data_1.m < data_1.m2) {
	goto L12;
    }
    nxx = data_1.ld + 1 - data_1.m1;
    i__1 = data_1.m;
    for (i__ = data_1.m2; i__ <= i__1; ++i__) {
	--nxx;
	nx = nxx - data_1.m + data_1.m1;
	if ((d__1 = data_1.y[nxx - 1], abs(d__1)) > 1e-10f) {
	    goto L10;
	}
	s_wsfe(&io___1831);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L10:
	data_1.x[nx - 1] = data_1.x[nxx - 1];
	data_1.y[nx - 1] = -data_1.y[nxx - 1];
	data_1.z__[nx - 1] = data_1.z__[nxx - 1];
	t1x[nx - 1] = t1x[nxx - 1];
	t1y[nx - 1] = -t1y[nxx - 1];
	t1z[nx - 1] = t1z[nxx - 1];
	data_1.t2x[nx - 1] = data_1.t2x[nxx - 1];
	data_1.t2y[nx - 1] = -data_1.t2y[nxx - 1];
	data_1.t2z[nx - 1] = data_1.t2z[nxx - 1];
	data_1.salp[nx - 1] = -data_1.salp[nxx - 1];
/* L11: */
	data_1.bi[nx - 1] = data_1.bi[nxx - 1];
    }
    data_1.m = (data_1.m << 1) - data_1.m1;
L12:
    if (*ix == 0) {
	goto L18;
    }

/*     REFLECT ALONG X AXIS */

    if (data_1.n < data_1.n2) {
	goto L15;
    }
    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
	nx = i__ + data_1.n - data_1.n1;
	e1 = data_1.x[i__ - 1];
	e2 = x2[i__ - 1];
	if (abs(e1) + abs(e2) > 1e-5f && e1 * e2 >= -1e-6f) {
	    goto L13;
	}
	s_wsfe(&io___1832);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L13:
	data_1.x[nx - 1] = -e1;
	data_1.y[nx - 1] = data_1.y[i__ - 1];
	data_1.z__[nx - 1] = data_1.z__[i__ - 1];
	x2[nx - 1] = -e2;
	y2[nx - 1] = y2[i__ - 1];
	z2[nx - 1] = z2[i__ - 1];
	itagi = data_1.itag[i__ - 1];
	if (itagi == 0) {
	    data_1.itag[nx - 1] = 0;
	}
	if (itagi != 0) {
	    data_1.itag[nx - 1] = itagi + iti;
	}
/* L14: */
	data_1.bi[nx - 1] = data_1.bi[i__ - 1];
    }
    data_1.n = (data_1.n << 1) - data_1.n1;
L15:
    if (data_1.m < data_1.m2) {
	goto L18;
    }
    nxx = data_1.ld + 1 - data_1.m1;
    i__1 = data_1.m;
    for (i__ = data_1.m2; i__ <= i__1; ++i__) {
	--nxx;
	nx = nxx - data_1.m + data_1.m1;
	if ((d__1 = data_1.x[nxx - 1], abs(d__1)) > 1e-10f) {
	    goto L16;
	}
	s_wsfe(&io___1833);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
L16:
	data_1.x[nx - 1] = -data_1.x[nxx - 1];
	data_1.y[nx - 1] = data_1.y[nxx - 1];
	data_1.z__[nx - 1] = data_1.z__[nxx - 1];
	t1x[nx - 1] = -t1x[nxx - 1];
	t1y[nx - 1] = t1y[nxx - 1];
	t1z[nx - 1] = t1z[nxx - 1];
	data_1.t2x[nx - 1] = -data_1.t2x[nxx - 1];
	data_1.t2y[nx - 1] = data_1.t2y[nxx - 1];
	data_1.t2z[nx - 1] = data_1.t2z[nxx - 1];
	data_1.salp[nx - 1] = -data_1.salp[nxx - 1];
/* L17: */
	data_1.bi[nx - 1] = data_1.bi[nxx - 1];
    }
    data_1.m = (data_1.m << 1) - data_1.m1;
L18:
    return 0;

/*     REPRODUCE STRUCTURE WITH ROTATION TO FORM CYLINDRICAL STRUCTURE */

L19:
    fnop = (doublereal) (*nop);
    data_1.ipsym = -1;
    sam = 6.2831853071796 / fnop;
    cs = cos(sam);
    ss = sin(sam);
    if (data_1.n < data_1.n2) {
	goto L21;
    }
    data_1.n = data_1.n1 + (data_1.n - data_1.n1) * *nop;
    nx = data_1.np + 1;
    i__1 = data_1.n;
    for (i__ = nx; i__ <= i__1; ++i__) {
	k = i__ - data_1.np + data_1.n1;
	xk = data_1.x[k - 1];
	yk = data_1.y[k - 1];
	data_1.x[i__ - 1] = xk * cs - yk * ss;
	data_1.y[i__ - 1] = xk * ss + yk * cs;
	data_1.z__[i__ - 1] = data_1.z__[k - 1];
	xk = x2[k - 1];
	yk = y2[k - 1];
	x2[i__ - 1] = xk * cs - yk * ss;
	y2[i__ - 1] = xk * ss + yk * cs;
	z2[i__ - 1] = z2[k - 1];
	itagi = data_1.itag[k - 1];
	if (itagi == 0) {
	    data_1.itag[i__ - 1] = 0;
	}
	if (itagi != 0) {
	    data_1.itag[i__ - 1] = itagi + iti;
	}
/* L20: */
	data_1.bi[i__ - 1] = data_1.bi[k - 1];
    }
L21:
    if (data_1.m < data_1.m2) {
	goto L23;
    }
    data_1.m = data_1.m1 + (data_1.m - data_1.m1) * *nop;
    nx = data_1.mp + 1;
    k = data_1.ld + 1 - data_1.m1;
    i__1 = data_1.m;
    for (i__ = nx; i__ <= i__1; ++i__) {
	--k;
	j = k - data_1.mp + data_1.m1;
	xk = data_1.x[k - 1];
	yk = data_1.y[k - 1];
	data_1.x[j - 1] = xk * cs - yk * ss;
	data_1.y[j - 1] = xk * ss + yk * cs;
	data_1.z__[j - 1] = data_1.z__[k - 1];
	xk = t1x[k - 1];
	yk = t1y[k - 1];
	t1x[j - 1] = xk * cs - yk * ss;
	t1y[j - 1] = xk * ss + yk * cs;
	t1z[j - 1] = t1z[k - 1];
	xk = data_1.t2x[k - 1];
	yk = data_1.t2y[k - 1];
	data_1.t2x[j - 1] = xk * cs - yk * ss;
	data_1.t2y[j - 1] = xk * ss + yk * cs;
	data_1.t2z[j - 1] = data_1.t2z[k - 1];
	data_1.salp[j - 1] = data_1.salp[k - 1];
/* L22: */
	data_1.bi[j - 1] = data_1.bi[k - 1];
    }
L23:
    return 0;

} /* reflc_ */

#undef t1z
#undef t1y
#undef t1x
#undef z2
#undef y2
#undef x2


/* Subroutine */ int rombg_(doublereal *a, doublereal *b, integer *n, S_fp 
	fsub, doublecomplex *sum, doublereal *dmin__, doublereal *rx)
{
    /* Initialized data */

    static integer nm = 65536;
    static integer nts = 4;
    static integer nx = 1;

    /* Format strings */
    static char fmt_20[] = "(\002 ROMBG: ERROR - B LESS THAN A\002)";
    static char fmt_21[] = "(\002 ROMBG: STEP SIZE LIMITED AT Z =\002,1pe12."
	    "5)";
    static char fmt_19[] = "(1p10e12.5)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double d_imag(doublecomplex *), sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal s, z__;
    static doublecomplex g1[9], g2[9], g3[9], g4[9], g5[9], t00, t01[9], t10[
	    9], t02, t11, t20[9];
    static doublereal ep, ti, dz, ze;
    static integer ns, nt;
    static doublereal tr, zend;
    extern /* Subroutine */ int test_(doublereal *, doublereal *, doublereal *
	    , doublereal *, doublereal *, doublereal *, doublereal *);
    static doublereal dzot, tmag1, tmag2;

    /* Fortran I/O blocks */
    static cilist io___1848 = { 0, 3, 0, fmt_20, 0 };
    static cilist io___1871 = { 0, 3, 0, fmt_21, 0 };
    static cilist io___1872 = { 0, 3, 0, fmt_19, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ROMBG performs variable interval width Romberg integration for an */
/*     N element vector function supplied by FSUB. */

    /* Parameter adjustments */
    --sum;

    /* Function Body */
    z__ = *a;
    ze = *b;
    s = *b - *a;
    if (s >= 0.f) {
	goto L1;
    }
    s_wsfe(&io___1848);
    e_wsfe();
    s_stop("", (ftnlen)0);
L1:
    ep = s / (nm * 1e4f);
    zend = ze - ep;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L2: */
	i__2 = i__;
	sum[i__2].r = 0.f, sum[i__2].i = 0.f;
    }
    ns = nx;
    nt = 0;
    (*fsub)(&z__, g1);
L3:
    dz = s / ns;
    if (z__ + dz <= ze) {
	goto L4;
    }
    dz = ze - z__;
    if (dz <= ep) {
	goto L18;
    }
L4:
    dzot = dz * .5f;
    d__1 = z__ + dzot;
    (*fsub)(&d__1, g3);
    d__1 = z__ + dz;
    (*fsub)(&d__1, g5);
L5:
    tmag1 = 0.f;
    tmag2 = 0.f;

/*     EVALUATE 3 POINT ROMBERG RESULT AND TEST CONVERGENCE. */
/*     CONVERGENCE TEST ON FIRST 3 FUNCTIONS ONLY */

    i__2 = *n;
    for (i__ = 1; i__ <= i__2; ++i__) {
	i__1 = i__ - 1;
	i__3 = i__ - 1;
	z__2.r = g1[i__1].r + g5[i__3].r, z__2.i = g1[i__1].i + g5[i__3].i;
	z__1.r = dzot * z__2.r, z__1.i = dzot * z__2.i;
	t00.r = z__1.r, t00.i = z__1.i;
	i__1 = i__ - 1;
	i__3 = i__ - 1;
	z__3.r = dz * g3[i__3].r, z__3.i = dz * g3[i__3].i;
	z__2.r = t00.r + z__3.r, z__2.i = t00.i + z__3.i;
	z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
	t01[i__1].r = z__1.r, t01[i__1].i = z__1.i;
	i__1 = i__ - 1;
	i__3 = i__ - 1;
	z__3.r = t01[i__3].r * 4.f, z__3.i = t01[i__3].i * 4.f;
	z__2.r = z__3.r - t00.r, z__2.i = z__3.i - t00.i;
	z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
	t10[i__1].r = z__1.r, t10[i__1].i = z__1.i;
	if (i__ > 3) {
	    goto L6;
	}
	i__1 = i__ - 1;
	tr = t01[i__1].r;
	ti = d_imag(&t01[i__ - 1]);
	tmag1 = tmag1 + tr * tr + ti * ti;
	i__1 = i__ - 1;
	tr = t10[i__1].r;
	ti = d_imag(&t10[i__ - 1]);
	tmag2 = tmag2 + tr * tr + ti * ti;
L6:
	;
    }
    tmag1 = sqrt(tmag1);
    tmag2 = sqrt(tmag2);
    test_(&tmag1, &tmag2, &tr, &c_b332, &c_b332, &ti, dmin__);
    if (tr > *rx) {
	goto L8;
    }
    i__2 = *n;
    for (i__ = 1; i__ <= i__2; ++i__) {
/* L7: */
	i__1 = i__;
	i__3 = i__;
	i__4 = i__ - 1;
	z__1.r = sum[i__3].r + t10[i__4].r, z__1.i = sum[i__3].i + t10[i__4]
		.i;
	sum[i__1].r = z__1.r, sum[i__1].i = z__1.i;
    }
    nt += 2;
    goto L12;
L8:
    d__1 = z__ + dz * .25f;
    (*fsub)(&d__1, g2);
    d__1 = z__ + dz * .75f;
    (*fsub)(&d__1, g4);
    tmag1 = 0.f;
    tmag2 = 0.f;

/*     EVALUATE 5 POINT ROMBERG RESULT AND TEST CONVERGENCE. */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__3 = i__ - 1;
	i__4 = i__ - 1;
	i__2 = i__ - 1;
	z__4.r = g2[i__4].r + g4[i__2].r, z__4.i = g2[i__4].i + g4[i__2].i;
	z__3.r = dzot * z__4.r, z__3.i = dzot * z__4.i;
	z__2.r = t01[i__3].r + z__3.r, z__2.i = t01[i__3].i + z__3.i;
	z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
	t02.r = z__1.r, t02.i = z__1.i;
	z__3.r = t02.r * 4.f, z__3.i = t02.i * 4.f;
	i__3 = i__ - 1;
	z__2.r = z__3.r - t01[i__3].r, z__2.i = z__3.i - t01[i__3].i;
	z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
	t11.r = z__1.r, t11.i = z__1.i;
	i__3 = i__ - 1;
	z__3.r = t11.r * 16.f, z__3.i = t11.i * 16.f;
	i__4 = i__ - 1;
	z__2.r = z__3.r - t10[i__4].r, z__2.i = z__3.i - t10[i__4].i;
	z__1.r = z__2.r / 15.f, z__1.i = z__2.i / 15.f;
	t20[i__3].r = z__1.r, t20[i__3].i = z__1.i;
	if (i__ > 3) {
	    goto L9;
	}
	tr = t11.r;
	ti = d_imag(&t11);
	tmag1 = tmag1 + tr * tr + ti * ti;
	i__3 = i__ - 1;
	tr = t20[i__3].r;
	ti = d_imag(&t20[i__ - 1]);
	tmag2 = tmag2 + tr * tr + ti * ti;
L9:
	;
    }
    tmag1 = sqrt(tmag1);
    tmag2 = sqrt(tmag2);
    test_(&tmag1, &tmag2, &tr, &c_b332, &c_b332, &ti, dmin__);
    if (tr > *rx) {
	goto L14;
    }
L10:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L11: */
	i__3 = i__;
	i__4 = i__;
	i__2 = i__ - 1;
	z__1.r = sum[i__4].r + t20[i__2].r, z__1.i = sum[i__4].i + t20[i__2]
		.i;
	sum[i__3].r = z__1.r, sum[i__3].i = z__1.i;
    }
    ++nt;
L12:
    z__ += dz;
    if (z__ > zend) {
	goto L18;
    }
    i__3 = *n;
    for (i__ = 1; i__ <= i__3; ++i__) {
/* L13: */
	i__4 = i__ - 1;
	i__2 = i__ - 1;
	g1[i__4].r = g5[i__2].r, g1[i__4].i = g5[i__2].i;
    }
    if (nt < nts || ns <= nx) {
	goto L3;
    }
    ns /= 2;
    nt = 1;
    goto L3;
L14:
    nt = 0;
    if (ns < nm) {
	goto L16;
    }
    s_wsfe(&io___1871);
    do_fio(&c__1, (char *)&z__, (ftnlen)sizeof(doublereal));
    e_wsfe();
    i__4 = *n;
    for (i__ = 1; i__ <= i__4; ++i__) {
/* L15: */
	s_wsfe(&io___1872);
	do_fio(&c__2, (char *)&g1[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g2[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g3[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g4[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g5[i__ - 1], (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    goto L10;
L16:
    ns <<= 1;
    dz = s / ns;
    dzot = dz * .5f;
    i__4 = *n;
    for (i__ = 1; i__ <= i__4; ++i__) {
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	g5[i__2].r = g3[i__3].r, g5[i__2].i = g3[i__3].i;
/* L17: */
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	g3[i__2].r = g2[i__3].r, g3[i__2].i = g2[i__3].i;
    }
    goto L5;
L18:
    return 0;

} /* rombg_ */

/* Subroutine */ int rxfld_(doublereal *rhox, doublereal *zsx, doublereal *
	zox, integer *izs, doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh, integer *
	ireg)
{
    extern /* Subroutine */ int trxfld_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RXFLD determines whether reflected or transmitted field is needed */
/*     and sets ZZ and ZZP for observer above the interface and source */
/*     below. */

    gnrzz_1.rho = *rhox;
    gnrzz_1.zs = *zsx;
    gnrzz_1.zo = *zox;
    if (*izs == 0) {
	goto L1;
    }
    if (*izs > 0 && gnrzz_1.zo >= 0.f) {
	goto L4;
    }
    if (*izs < 0 && gnrzz_1.zo < 0.f) {
	goto L5;
    }
    goto L2;
L1:
    if (gnrzz_1.zs >= 0.f && gnrzz_1.zo >= 0.f) {
	goto L4;
    }
    if (gnrzz_1.zs < 0.f && gnrzz_1.zo < 0.f) {
	goto L5;
    }
L2:
    if (gnrzz_1.zo < 0.f) {
	goto L3;
    }
    gnrzz_1.icase = 3;
    gnrzz_1.zz = gnrzz_1.zo;
    gnrzz_1.zzp = gnrzz_1.zs;
    goto L6;
L3:
    gnrzz_1.icase = 4;
    gnrzz_1.zz = gnrzz_1.zs;
    gnrzz_1.zzp = gnrzz_1.zo;
    goto L6;
L4:
    gnrzz_1.icase = 1;
    gnrzz_1.zz = gnrzz_1.zs + gnrzz_1.zo;
    gnrzz_1.zzp = 0.f;
    goto L6;
L5:
    gnrzz_1.icase = 2;
    gnrzz_1.zz = 0.f;
    gnrzz_1.zzp = gnrzz_1.zs + gnrzz_1.zo;
L6:
    gnrzz_1.azp = -gnrzz_1.zzp;
    trxfld_(erv, ezv, erh, eph, ezh, ireg);
    return 0;
} /* rxfld_ */

/* Subroutine */ int sadpt_(doublereal *rho, doublereal *zz, doublereal *zp, 
	doublecomplex *xls)
{
    /* Initialized data */

    static doublereal ck1r = 0.;
    static doublereal ck1i = 0.;
    static integer ndim = 21;
    static doublereal dr = 0.;
    static doublereal dz = 0.;

    /* Format strings */
    static char fmt_90[] = "(\002 SADPT: ERROR - RHO,ZZ,ZP=\002,1p3e12.5)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    double d_imag(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double sqrt(doublereal);

    /* Local variables */
    static integer ir, iz;
    static doublereal rx, zx;
    static doublecomplex xz1, xz2;
    extern /* Subroutine */ int strac_(integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1878 = { 0, 3, 0, fmt_90, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SADPT obtains coordinates of the saddle point between the origin */
/*     and GCK2 (K+) by interpolation.  STRAC is called the first time */
/*     that SADPT is called for new ground parameters. */

    if (gparm_1.gck1.r != ck1r || d_imag(&gparm_1.gck1) != ck1i) {
	ck1r = gparm_1.gck1.r;
	ck1i = d_imag(&gparm_1.gck1);
	strac_(&ndim, &ndim);
	dr = 1.f / (ndim - 1.f);
	dz = dr;
    }
    if (*zz < 0.f || *zp > 0.f) {
	s_wsfe(&io___1878);
	do_fio(&c__1, (char *)&(*rho), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*zz), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*zp), (ftnlen)sizeof(doublereal));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    gparm_1.zrat = *zz - *zp;
    gparm_1.rhon = sqrt(*rho * *rho + gparm_1.zrat * gparm_1.zrat);
    if (gparm_1.rhon > 1e-20f) {
	gparm_1.rhon = *rho / gparm_1.rhon;
    } else {
	gparm_1.rhon = 0.f;
    }
    if (gparm_1.zrat > 1e-20f) {
	gparm_1.zrat = *zz / gparm_1.zrat;
    } else {
	gparm_1.zrat = 0.f;
    }
    ir = (integer) (gparm_1.rhon / dr + 1);
    if (ir == ndim) {
	--ir;
    }
    rx = gparm_1.rhon - (ir - 1) * dr;
    iz = (integer) (gparm_1.zrat / dz + 1);
    if (iz == ndim) {
	--iz;
    }
    zx = gparm_1.zrat - (iz - 1) * dz;
    i__1 = ir + iz * 21 - 22;
    d__1 = dr - rx;
    z__2.r = d__1 * gparm_1.xla[i__1].r, z__2.i = d__1 * gparm_1.xla[i__1].i;
    i__2 = ir + 1 + iz * 21 - 22;
    z__3.r = rx * gparm_1.xla[i__2].r, z__3.i = rx * gparm_1.xla[i__2].i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    xz1.r = z__1.r, xz1.i = z__1.i;
    i__1 = ir + (iz + 1) * 21 - 22;
    d__1 = dr - rx;
    z__2.r = d__1 * gparm_1.xla[i__1].r, z__2.i = d__1 * gparm_1.xla[i__1].i;
    i__2 = ir + 1 + (iz + 1) * 21 - 22;
    z__3.r = rx * gparm_1.xla[i__2].r, z__3.i = rx * gparm_1.xla[i__2].i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    xz2.r = z__1.r, xz2.i = z__1.i;
    d__1 = dz - zx;
    z__3.r = d__1 * xz1.r, z__3.i = d__1 * xz1.i;
    z__4.r = zx * xz2.r, z__4.i = zx * xz2.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    d__2 = dr * dz;
    z__1.r = z__2.r / d__2, z__1.i = z__2.i / d__2;
    xls->r = z__1.r, xls->i = z__1.i;
    return 0;

} /* sadpt_ */

/* Subroutine */ int sdlpt_(doublecomplex *xl, integer *ierr)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_sqrt(doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublecomplex com;
    static doublereal trm;
    static doublecomplex cjro, term, cgam1, cgam2;
    static doublereal zmzz, zozz;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SDLPT iterates to find the location of the saddle point for param- */
/*     eters ZRAT=ZZ/(ZZ-ZP) and RHON=RHO/SQRT(RHO**2+(ZZ-ZP)**2) */

    zmzz = 1.f - gparm_1.rhon * gparm_1.rhon;
    if (zmzz < 0.f) {
	zmzz = 0.f;
    }
    zmzz = sqrt(zmzz);
    zozz = zmzz * gparm_1.zrat;
    zmzz *= gparm_1.zrat - 1.f;
    z__1.r = 0., z__1.i = gparm_1.rhon;
    cjro.r = z__1.r, cjro.i = z__1.i;
    for (i__ = 1; i__ <= 100; ++i__) {
	z__1.r = xl->r - gparm_1.gck1.r, z__1.i = xl->i - gparm_1.gck1.i;
	com.r = z__1.r, com.i = z__1.i;
	z__3.r = xl->r + gparm_1.gck1.r, z__3.i = xl->i + gparm_1.gck1.i;
	z_sqrt(&z__2, &z__3);
	z_sqrt(&z__4, &com);
	z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i 
		+ z__2.i * z__4.r;
	cgam1.r = z__1.r, cgam1.i = z__1.i;
	if (d_imag(&com) < 0.f) {
	    z__1.r = -cgam1.r, z__1.i = -cgam1.i;
	    cgam1.r = z__1.r, cgam1.i = z__1.i;
	}
	z__1.r = xl->r - gparm_1.gck2.r, z__1.i = xl->i - gparm_1.gck2.i;
	com.r = z__1.r, com.i = z__1.i;
	z__3.r = xl->r + gparm_1.gck2.r, z__3.i = xl->i + gparm_1.gck2.i;
	z_sqrt(&z__2, &z__3);
	z_sqrt(&z__4, &com);
	z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i 
		+ z__2.i * z__4.r;
	cgam2.r = z__1.r, cgam2.i = z__1.i;
	if (d_imag(&com) < 0.f) {
	    z__1.r = -cgam2.r, z__1.i = -cgam2.i;
	    cgam2.r = z__1.r, cgam2.i = z__1.i;
	}
	z__2.r = xl->r * 2.f, z__2.i = xl->i * 2.f;
	z__1.r = z__2.r * xl->r - z__2.i * xl->i, z__1.i = z__2.r * xl->i + 
		z__2.i * xl->r;
	com.r = z__1.r, com.i = z__1.i;
	z__3.r = zozz * cgam2.r, z__3.i = zozz * cgam2.i;
	z__4.r = com.r - gparm_1.gck1sq.r, z__4.i = com.i - gparm_1.gck1sq.i;
	z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i 
		+ z__3.i * z__4.r;
	z__6.r = zmzz * cgam1.r, z__6.i = zmzz * cgam1.i;
	z__7.r = com.r - gparm_1.gck2sq.r, z__7.i = com.i - gparm_1.gck2sq.i;
	z__5.r = z__6.r * z__7.r - z__6.i * z__7.i, z__5.i = z__6.r * z__7.i 
		+ z__6.i * z__7.r;
	z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
	term.r = z__1.r, term.i = z__1.i;
	z__3.r = cjro.r * xl->r - cjro.i * xl->i, z__3.i = cjro.r * xl->i + 
		cjro.i * xl->r;
	z__5.r = com.r - gparm_1.gck1sq.r, z__5.i = com.i - gparm_1.gck1sq.i;
	z__4.r = z__5.r - gparm_1.gck2sq.r, z__4.i = z__5.i - 
		gparm_1.gck2sq.i;
	z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i 
		+ z__3.i * z__4.r;
	z__1.r = term.r + z__2.r, z__1.i = term.i + z__2.i;
	com.r = z__1.r, com.i = z__1.i;
	z__2.r = cgam1.r * cgam2.r - cgam1.i * cgam2.i, z__2.i = cgam1.r * 
		cgam2.i + cgam1.i * cgam2.r;
	z__6.r = zozz * cgam1.r, z__6.i = zozz * cgam1.i;
	z__7.r = zmzz * cgam2.r, z__7.i = zmzz * cgam2.i;
	z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
	z__4.r = xl->r * z__5.r - xl->i * z__5.i, z__4.i = xl->r * z__5.i + 
		xl->i * z__5.r;
	z__9.r = cjro.r * cgam1.r - cjro.i * cgam1.i, z__9.i = cjro.r * 
		cgam1.i + cjro.i * cgam1.r;
	z__8.r = z__9.r * cgam2.r - z__9.i * cgam2.i, z__8.i = z__9.r * 
		cgam2.i + z__9.i * cgam2.r;
	z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
	z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i 
		+ z__2.i * z__3.r;
	term.r = z__1.r, term.i = z__1.i;
	z_div(&z__1, &term, &com);
	term.r = z__1.r, term.i = z__1.i;
	z__1.r = xl->r - term.r, z__1.i = xl->i - term.i;
	xl->r = z__1.r, xl->i = z__1.i;
	trm = z_abs(&term);
	if (trm < 1e-5f) {
	    goto L3;
	}
	if (trm > 1e3f) {
	    goto L2;
	}
/* L1: */
    }
    *ierr = 1;
    goto L4;
L2:
    *ierr = 2;
    goto L4;
L3:
    *ierr = 0;
    if (xl->r > gparm_1.gck2.r) {
	*ierr = 3;
    }
L4:
    return 0;
} /* sdlpt_ */

/* Subroutine */ int second_(doublereal *cpusecd)
{
    static real wallsplt;
    extern /* Subroutine */ int stopwtch_(real *, real *, real *, real *);
    static real cpusecs, walltot, cpusplt;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SECOND returns cpu time in seconds.  Must be customized!!! */

/*     VAX or other (modify subroutine stopwtch): */

    stopwtch_(&cpusecs, &walltot, &cpusplt, &wallsplt);
    *cpusecd = cpusecs * 60.f;
/*     MACINTOSH: */
/*      CPUSECD= LONG(362)/60.0 */
    return 0;
} /* second_ */

/* Subroutine */ int stopwtch_(real *cputot, real *walltot, real *cpusplt, 
	real *wallsplt)
{
    /* Initialized data */

    static logical initiz = FALSE_;

    static integer wallinit, walllast, icpu;
    extern integer mclock_(void);
    static real cpunow, cpuinit, cpulast;
    static integer wallnow;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*       stopwtch operates as a stopwatch for CPU time.  When first */
/*       called, the routine initializes the clock.  On subsequent calls */
/*       the routine returns: */

/*       Outputs: cputot   -- elapsed CPU time since initialization */
/*                walltot  -- elapsed wallclock time since initialization */
/*                cpusplt  -- split (delta) CPU time since previous call */
/*                wallsplt -- split wallclock time since previous call */

/*       These outputs will all be zero (or very close to it) on the */
/*       first (initialization) call. */

/*       Internal times (cpuinit,wallinit,cpunow,wallnow) are stored in */
/*       seconds.  cpuinit  and cpunow  are stored as reals, */
/*                 wallinit and wallnow are stored as integers. */
/*       Output times are converted to real minutes. */

/* History: */
/*   Date       Author            Reason */
/*   ---------  ----------------  ------------------------------------ */
/*    early-90  Scott L. Ray      initial version */
/*      mid-90  Scott L. Ray      support for additional machines */
/*   14-JAN-91                    ---- Version 2.2/release    ---- */
/*   23-MAY-91  Scott L. Ray      UNICOS branch */
/*   29-JAN-92  Scott L. Ray      FPS and NLTSS support dropped */
/*   29-JAN-92  Scott L. Ray      switch to cpp conditional compilation */
/*   18-SEP-92      Conditional compilation disabled for use in NEC */
/* ---------------------------------------------------------------------- */

/* parameter list */


/* locals (non sysdep) */


/* locals (sysdep) */

/* #include "machines.h" */
/* #ifdef VAX_VMS */
/*        integer istatus,iwall,icpu */
/*        real rwall */
/*        dimension iwall(2) */
/* #endif */
/* #ifdef SUN4TIMER */
/*        integer time */
/*        real tarray */
/*        dimension tarray(2) */
/* #endif */
/* #ifdef CONVEX */
/*        real time, secnds, tarray */
/*        dimension tarray(2) */
/*        external secnds */
/* #endif */
/* #ifdef IBM_RISC */
/* #endif */
/* #ifdef IRIS4D */
/*        external time */
/* #endif */
/* #ifdef STARDENT */
/*        integer stime */
/*        real tarray */
/*        dimension tarray(2) */
/* #endif */
/* #ifdef UNICOS */
/*        real rwall */
/* #endif */

/* data initialization */


/* ---------------------------------------------------------------------- */

    if (! initiz) {

/* ...      set the flag showing that the clock has been initialized */

	initiz = TRUE_;

/* ...      set the initial times to default value of zero.  These may */
/*          be changed, depending on how an individual machine handles */
/*          its timer. */

	cpuinit = 0.f;
	wallinit = 0;

/* ...      initialize the timer (may not be necessary on all machines) */

/* #ifdef VAX_VMS */
/*           istatus = lib$init_timer() */
/* #endif */

/* #ifdef SUN4TIMER */
/*          CPU timer on SUN4 initializes automatically on job startup. */
/*          However, we want t=0 to be defined when this routine is first */
/*          called.  Hence, define initial CPU time here. */
/*          Wall clock timer counts in seconds from 1-Jan-70  Thus, */
/*          initial wall clock time is non-zero.  It is obtained here. */

/*           cpuinit  = etime(tarray) */
/*           wallinit = time() */
/* #endif */

/* #ifdef CONVEX */
/*           cpuinit = etime(tarray) */
/*           time = secnds(0.0) */
/*           wallinit = ifix(time) */
/* #endif */

/* #ifdef IBM_RISC */
/*          no known wall clock timer */

	icpu = mclock_();
	cpuinit = (real) icpu / 100.f;
	wallinit = 0;
/* #endif */

/* #ifdef STARDENT */
/*          CPU timer on STARDENT initializes automatically on job */
/*          startup. */
/*          However, we want t=0 to be defined when this routine is first */
/*          called.  Hence, define initial CPU time here. */
/*          Wall clock timer counts in seconds from 1-Jan-70  Thus, */
/*          initial wall clock time is non-zero.  It is obtained here. */

/*           cpuinit  = etime(tarray) */
/*           wallinit = stime() */
/* #endif */

/* #ifdef UNICOS */
/*          I hope that the "second" routine is true UNICOS and not a */
/*          local (LLNL) feature that was added on to keep things */
/*          consistent with NLTSS. */
/*          The "timef" routine returns real milliseconds; first */
/*          call initializes the timer and should return zero (not */
/*          that we care -- this routine works by taking differences). */

/*           call second(cpuinit) */
/*           call timef(rwall) */
/*           wallinit = ifix(rwall*1.0e-03) */
/* #endif */

/* ...      since this is the first call to this routine, */
/*          initialize the previous call times to the initial time. */

	cpulast = cpuinit;
	walllast = wallinit;

    }

/* ...   Find the current cpu and wall times */

/* #ifdef HASTIMER */
/* #ifdef VAX_VMS */

/*       function "lib$stat_timer" is called as: */
/*       error_status = lib$stat_timer(input_code,output_result,junk) */
/*       where, */
/*        input_code = 1 returns elapsed wall clock time in VAX_VMS */
/*           binary internal format.  This format takes 64 bits to store, */
/*           hence output_result should be a 32 bit integer array of */
/*           length 2. */
/*           This internal format is converted to a floating point number */
/*           by calling "lib$cvtf_from_internal_time".  This function */
/*           is poorly documented in the VAX_VMS manuals.  Here are some */
/*           details:  First argument = 28 ==> result in real hours */
/*                                    = 29 ==> result in real minutes */
/*                                    = 30 ==> result in real seconds */
/*           The input to "lib$cvtf_from_internal_time" goes in the 3rd */
/*           argument, the result is returned in the 2nd argument. */
/*           input_code = 2 returns elapsed cpu time as an integer in */
/*           units of 10msec.  This is converted to seconds here. */

/*        istatus = lib$stat_timer(1,iwall,) */
/*        istatus = lib$cvtf_from_internal_time(30,rwall,iwall) */
/*        wallnow = rwall */
/*        istatus = lib$stat_timer(2,icpu,) */
/*        cpunow = icpu*(10.0e-3) */
/* #endif */

/* #ifdef SUN4TIMER */
/*       there is some ambiguity in the manual as to how to use */
/*       etime.  Function returns: */
/*          "elapsed execution time" = tarray(1) + tarray(2) */
/*                                   = user time + system time */
/*       I am uncertain whether to let cpunow = return value or */
/*       else tarray(1). */

/*        cpunow  = etime(tarray) */
/*        wallnow = time() */
/* #endif */

/* #ifdef CONVEX */
/*           cpunow = etime(tarray) */
/*           time = secnds(0.0) */
/*           wallnow = ifix(time) */
/* #endif */

/* #ifdef IBM_RISC */
/*       no known wall clock timer */

    icpu = mclock_();
    cpunow = (real) icpu / 100.f;
    wallnow = 0;
/* #endif */

/* #ifdef STARDENT */
/*       there is some ambiguity in the manual as to how to use */
/*       etime.  Function returns: */
/*          "elapsed execution time" = tarray(1) + tarray(2) */
/*                                   = user time + system time */
/*       I am uncertain whether to let cpunow = return value or */
/*       else tarray(1). */

/*        cpunow  = etime(tarray) */
/*        wallnow = stime() */
/* #endif */

/* #ifdef UNICOS */
/*       I hope that the "second" routine is true UNICOS and not a */
/*       local (LLNL) feature that was added on to keep things */
/*       consistent with NLTSS. */
/*       The "timef" routine returns real milliseconds. */

/*        call second(cpunow) */
/*        call timef(rwall) */
/*        wallnow = ifix(rwall*1.0e-03) */
/* #endif */
/* #else */
/*       for machines without timers or with unknown timers, */
/*       set things to zero now to ensure that something is returned */
/*        cpunow  = 0.0 */
/*        wallnow = 0 */
/* #endif */

/* ...   calculate elapsed and split cpu and wall clock times, */
/*       convert to minutes on output. */

    *cputot = (cpunow - cpuinit) / 60.f;
    *walltot = (real) (wallnow - wallinit) / 60.f;
    *cpusplt = (cpunow - cpulast) / 60.f;
    *wallsplt = (real) (wallnow - walllast) / 60.f;

/* ...   save "now" times in "last" times */

    cpulast = cpunow;
    walllast = wallnow;

    return 0;
/* ********************************************************************** */
} /* stopwtch_ */

/* Subroutine */ int solgf_(doublecomplex *a, doublecomplex *b, doublecomplex 
	*c__, doublecomplex *d__, doublecomplex *xy, integer *ip, integer *np,
	 integer *n1, integer *n, integer *mp, integer *m1, integer *m, 
	integer *n1c, integer *n2c, integer *n2cz)
{
    /* System generated locals */
    integer b_dim1, b_offset, c_dim1, c_offset, d_dim1, d_offset, i__1, i__2, 
	    i__3, i__4, i__5;
    doublecomplex z__1, z__2;

    /* Local variables */
    static integer i__, j, n2, ii, jj, ni, jp, npb, neq, npm;
    static doublecomplex sum;
    static integer neqs;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen), solve_(integer *, 
	    doublecomplex *, integer *, doublecomplex *, integer *), solves_(
	    doublecomplex *, integer *, doublecomplex *, integer *, integer *,
	     integer *, integer *, integer *, integer *, integer *), ltsolv_(
	    doublecomplex *, integer *, integer *, doublecomplex *, integer *,
	     integer *, integer *, integer *, integer *, integer *, integer *)
	    ;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOLGF solves for current in the N.G.F. procedure. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --a;
    --xy;
    --ip;
    c_dim1 = *n1c;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    b_dim1 = *n1c;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    d_dim1 = *n2cz;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    if (*n2c == 0) {

/*        NORMAL SOLUTION.  NOT N.G.F. */

	solves_(&a[1], &ip[1], &xy[1], n1c, &c__1, np, n, mp, m, &c__11);
	return 0;
    }
    if (*n1 != *n && *m1 > 0) {

/*        REORDER EXCITATION ARRAY */
	n2 = *n1 + 1;
	jj = *n + 1;
	npm = *n + (*m1 << 1);
	i__1 = npm;
	for (i__ = n2; i__ <= i__1; ++i__) {
/* L2: */
	    i__2 = i__ - 1;
	    i__3 = i__;
	    scratm_2.y[i__2].r = xy[i__3].r, scratm_2.y[i__2].i = xy[i__3].i;
	}
	j = *n1;
	i__2 = npm;
	for (i__ = jj; i__ <= i__2; ++i__) {
	    ++j;
/* L3: */
	    i__3 = j;
	    i__1 = i__ - 1;
	    xy[i__3].r = scratm_2.y[i__1].r, xy[i__3].i = scratm_2.y[i__1].i;
	}
	i__3 = *n;
	for (i__ = n2; i__ <= i__3; ++i__) {
	    ++j;
/* L4: */
	    i__1 = j;
	    i__2 = i__ - 1;
	    xy[i__1].r = scratm_2.y[i__2].r, xy[i__1].i = scratm_2.y[i__2].i;
	}
    }

/*     COMPUTE INV(A)E1 */

    neqs = segj_1.nscon + (segj_1.npcon << 1);
    if (neqs > 0) {
	neq = *n1c + *n2c;
	neqs = neq - neqs + 1;
	i__1 = neq;
	for (i__ = neqs; i__ <= i__1; ++i__) {
/* L6: */
	    i__2 = i__;
	    xy[i__2].r = 0.f, xy[i__2].i = 0.f;
	}
    }
    solves_(&a[1], &ip[1], &xy[1], n1c, &c__1, np, n1, mp, m1, &c__11);
    ni = 0;

/*     COMPUTE E2-C(INV(A)E1) */

    npb = matpar_1.npbl;
    i__2 = matpar_1.nbbl;
    for (jj = 1; jj <= i__2; ++jj) {
	if (jj == matpar_1.nbbl) {
	    npb = matpar_1.nlbl;
	}
	if (matpar_1.icasx > 1) {
	    i__1 = *n1c * npb;
	    recin_(&c__[c_offset], &c__13, &c__1, &i__1, &jj, " READ C IN SO"
		    "LGF", (ftnlen)16);
	}
	ii = *n1c + ni;
	i__1 = npb;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    sum.r = 0.f, sum.i = 0.f;
	    i__3 = *n1c;
	    for (j = 1; j <= i__3; ++j) {
/* L8: */
		i__4 = j + i__ * c_dim1;
		i__5 = j;
		z__2.r = c__[i__4].r * xy[i__5].r - c__[i__4].i * xy[i__5].i, 
			z__2.i = c__[i__4].r * xy[i__5].i + c__[i__4].i * xy[
			i__5].r;
		z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
		sum.r = z__1.r, sum.i = z__1.i;
	    }
	    j = ii + i__;
/* L9: */
	    i__4 = j;
	    i__5 = j;
	    z__1.r = xy[i__5].r - sum.r, z__1.i = xy[i__5].i - sum.i;
	    xy[i__4].r = z__1.r, xy[i__4].i = z__1.i;
	}
/* L10: */
	ni += matpar_1.npbl;
    }
    jj = *n1c + 1;

/*     COMPUTE INV(D)(E2-C(INV(A)E1)) = I2 */

    if (matpar_1.icasx == 1) {
	solve_(n2c, &d__[d_offset], &ip[jj], &xy[jj], n2c);
    } else if (matpar_1.icasx == 2 || matpar_1.icasx == 3) {
	ni = *n2c * *n2c;
	recin_(&b[b_offset], &c__14, &c__1, &ni, &c__1, " READ B IN SOLGF", (
		ftnlen)16);
	solve_(n2c, &b[b_offset], &ip[jj], &xy[jj], n2c);
    } else if (matpar_1.icasx == 4) {
	ltsolv_(&b[b_offset], n2c, &ip[jj], &xy[jj], n2c, &c__1, &
		matpar_1.nbbl, &matpar_1.npbl, &matpar_1.nlbl, &c__0, &c__14);
    }

/*     COMPUTE INV(A)E1-(INV(A)B)I2 = I1 */

    ni = 0;
    npb = matpar_1.npbl;
    i__2 = matpar_1.nbbl;
    for (jj = 1; jj <= i__2; ++jj) {
	if (jj == matpar_1.nbbl) {
	    npb = matpar_1.nlbl;
	}
	if (matpar_1.icasx > 1) {
	    i__4 = *n1c * npb;
	    recin_(&b[b_offset], &c__12, &c__1, &i__4, &jj, " READ B FROM UN"
		    "IT 12 IN SOLGF", (ftnlen)29);
	}
	ii = *n1c + ni;
	i__4 = *n1c;
	for (i__ = 1; i__ <= i__4; ++i__) {
	    sum.r = 0.f, sum.i = 0.f;
	    i__5 = npb;
	    for (j = 1; j <= i__5; ++j) {
		jp = ii + j;
/* L14: */
		i__1 = i__ + j * b_dim1;
		i__3 = jp;
		z__2.r = b[i__1].r * xy[i__3].r - b[i__1].i * xy[i__3].i, 
			z__2.i = b[i__1].r * xy[i__3].i + b[i__1].i * xy[i__3]
			.r;
		z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
		sum.r = z__1.r, sum.i = z__1.i;
	    }
/* L15: */
	    i__1 = i__;
	    i__3 = i__;
	    z__1.r = xy[i__3].r - sum.r, z__1.i = xy[i__3].i - sum.i;
	    xy[i__1].r = z__1.r, xy[i__1].i = z__1.i;
	}
/* L16: */
	ni += matpar_1.npbl;
    }
    if (*n1 != *n && *m1 > 0) {

/*        REORDER CURRENT ARRAY */
	i__2 = npm;
	for (i__ = n2; i__ <= i__2; ++i__) {
/* L17: */
	    i__1 = i__ - 1;
	    i__3 = i__;
	    scratm_2.y[i__1].r = xy[i__3].r, scratm_2.y[i__1].i = xy[i__3].i;
	}
	jj = *n1c + 1;
	j = *n1;
	i__1 = npm;
	for (i__ = jj; i__ <= i__1; ++i__) {
	    ++j;
/* L18: */
	    i__3 = j;
	    i__2 = i__ - 1;
	    xy[i__3].r = scratm_2.y[i__2].r, xy[i__3].i = scratm_2.y[i__2].i;
	}
	i__3 = *n1c;
	for (i__ = n2; i__ <= i__3; ++i__) {
	    ++j;
/* L19: */
	    i__2 = j;
	    i__1 = i__ - 1;
	    xy[i__2].r = scratm_2.y[i__1].r, xy[i__2].i = scratm_2.y[i__1].i;
	}
    }
    if (segj_1.nscon > 0) {
	j = neqs - 1;
	i__2 = segj_1.nscon;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    ++j;
	    jj = segj_1.iscon[i__ - 1];
/* L21: */
	    i__1 = jj;
	    i__3 = j;
	    xy[i__1].r = xy[i__3].r, xy[i__1].i = xy[i__3].i;
	}
    }
    return 0;
} /* solgf_ */

/* Subroutine */ int solve_(integer *n, doublecomplex *a, integer *ip, 
	doublecomplex *b, integer *ndim)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, j, k, pi, ip1;
    static doublecomplex sum;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOLVE solves the matrix equation LU*X=B where L is a unit */
/*     lower triangular matrix and U is an upper triangular matrix both */
/*     of which are stored in A.  The RHS vector B is input and the */
/*     solution is returned through vector B. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */


/*     FORWARD SUBSTITUTION */

    /* Parameter adjustments */
    --b;
    --ip;
    a_dim1 = *ndim;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	pi = ip[i__];
	i__2 = i__ - 1;
	i__3 = pi;
	scratm_2.y[i__2].r = b[i__3].r, scratm_2.y[i__2].i = b[i__3].i;
	i__2 = pi;
	i__3 = i__;
	b[i__2].r = b[i__3].r, b[i__2].i = b[i__3].i;
	ip1 = i__ + 1;
	if (ip1 > *n) {
	    goto L2;
	}
	i__2 = *n;
	for (j = ip1; j <= i__2; ++j) {
	    i__3 = j;
	    i__4 = j;
	    i__5 = j + i__ * a_dim1;
	    i__6 = i__ - 1;
	    z__2.r = a[i__5].r * scratm_2.y[i__6].r - a[i__5].i * scratm_2.y[
		    i__6].i, z__2.i = a[i__5].r * scratm_2.y[i__6].i + a[i__5]
		    .i * scratm_2.y[i__6].r;
	    z__1.r = b[i__4].r - z__2.r, z__1.i = b[i__4].i - z__2.i;
	    b[i__3].r = z__1.r, b[i__3].i = z__1.i;
/* L1: */
	}
L2:
/* L3: */
	;
    }

/*     BACKWARD SUBSTITUTION */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	i__ = *n - k + 1;
	sum.r = 0.f, sum.i = 0.f;
	ip1 = i__ + 1;
	if (ip1 > *n) {
	    goto L5;
	}
	i__2 = *n;
	for (j = ip1; j <= i__2; ++j) {
	    i__3 = i__ + j * a_dim1;
	    i__4 = j;
	    z__2.r = a[i__3].r * b[i__4].r - a[i__3].i * b[i__4].i, z__2.i = 
		    a[i__3].r * b[i__4].i + a[i__3].i * b[i__4].r;
	    z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
	    sum.r = z__1.r, sum.i = z__1.i;
/* L4: */
	}
L5:
	i__2 = i__;
	i__3 = i__ - 1;
	z__2.r = scratm_2.y[i__3].r - sum.r, z__2.i = scratm_2.y[i__3].i - 
		sum.i;
	z_div(&z__1, &z__2, &a[i__ + i__ * a_dim1]);
	b[i__2].r = z__1.r, b[i__2].i = z__1.i;
/* L6: */
    }
    return 0;
} /* solve_ */

/* Subroutine */ int solves_(doublecomplex *a, integer *ip, doublecomplex *b, 
	integer *neq, integer *nrh, integer *np, integer *n, integer *mp, 
	integer *m, integer *iu1)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, j, k, ia, ib, ic, kk, nop;
    static doublecomplex sum;
    static integer krec;
    static doublereal fnop;
    static integer npeq, nrow;
    extern /* Subroutine */ int recin_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static doublereal fnorm;
    extern /* Subroutine */ int solve_(integer *, doublecomplex *, integer *, 
	    doublecomplex *, integer *), ltsolv_(doublecomplex *, integer *, 
	    integer *, doublecomplex *, integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOLVES performs the transformation of the right-hand side vector */
/*     for symmetric structures, and in any case calls routines to solve */
/*     the matrix equation for in-core or disk storage. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --a;
    --ip;
    b_dim1 = *neq;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    npeq = *np + (*mp << 1);
    nop = *neq / npeq;
    fnop = (doublereal) nop;
    fnorm = 1.f / fnop;
    nrow = *neq;
    if (matpar_1.icase > 3) {
	nrow = npeq;
    }
    if (nop > 1) {
	i__1 = *nrh;
	for (ic = 1; ic <= i__1; ++ic) {
	    if (*n > 0 && *m > 0) {
		i__2 = *neq;
		for (i__ = 1; i__ <= i__2; ++i__) {
/* L1: */
		    i__3 = i__ - 1;
		    i__4 = i__ + ic * b_dim1;
		    scratm_2.y[i__3].r = b[i__4].r, scratm_2.y[i__3].i = b[
			    i__4].i;
		}
		kk = *mp << 1;
		ia = *np;
		ib = *n;
		j = *np;
		i__3 = nop;
		for (k = 1; k <= i__3; ++k) {
		    if (k > 1) {
			i__4 = *np;
			for (i__ = 1; i__ <= i__4; ++i__) {
			    ++ia;
			    ++j;
/* L2: */
			    i__2 = j + ic * b_dim1;
			    i__5 = ia - 1;
			    b[i__2].r = scratm_2.y[i__5].r, b[i__2].i = 
				    scratm_2.y[i__5].i;
			}
		    }
		    if (k < nop) {
			i__2 = kk;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    ++ib;
			    ++j;
/* L4: */
			    i__5 = j + ic * b_dim1;
			    i__4 = ib - 1;
			    b[i__5].r = scratm_2.y[i__4].r, b[i__5].i = 
				    scratm_2.y[i__4].i;
			}
		    }
/* L5: */
		}
	    }

/*        TRANSFORM MATRIX EQ. RHS VECTOR ACCORDING TO SYMMETRY MODES */

	    i__3 = npeq;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		i__5 = nop;
		for (k = 1; k <= i__5; ++k) {
		    ia = i__ + (k - 1) * npeq;
/* L7: */
		    i__4 = k - 1;
		    i__2 = ia + ic * b_dim1;
		    scratm_2.y[i__4].r = b[i__2].r, scratm_2.y[i__4].i = b[
			    i__2].i;
		}
		sum.r = scratm_2.y[0].r, sum.i = scratm_2.y[0].i;
		i__4 = nop;
		for (k = 2; k <= i__4; ++k) {
/* L8: */
		    i__2 = k - 1;
		    z__1.r = sum.r + scratm_2.y[i__2].r, z__1.i = sum.i + 
			    scratm_2.y[i__2].i;
		    sum.r = z__1.r, sum.i = z__1.i;
		}
		i__2 = i__ + ic * b_dim1;
		z__1.r = fnorm * sum.r, z__1.i = fnorm * sum.i;
		b[i__2].r = z__1.r, b[i__2].i = z__1.i;
		i__2 = nop;
		for (k = 2; k <= i__2; ++k) {
		    ia = i__ + (k - 1) * npeq;
		    sum.r = scratm_2.y[0].r, sum.i = scratm_2.y[0].i;
		    i__4 = nop;
		    for (j = 2; j <= i__4; ++j) {
/* L9: */
			i__5 = j - 1;
			d_cnjg(&z__3, &smat_1.ssx[k + j * 20 - 21]);
			z__2.r = scratm_2.y[i__5].r * z__3.r - scratm_2.y[
				i__5].i * z__3.i, z__2.i = scratm_2.y[i__5].r 
				* z__3.i + scratm_2.y[i__5].i * z__3.r;
			z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
			sum.r = z__1.r, sum.i = z__1.i;
		    }
/* L10: */
		    i__5 = ia + ic * b_dim1;
		    z__1.r = fnorm * sum.r, z__1.i = fnorm * sum.i;
		    b[i__5].r = z__1.r, b[i__5].i = z__1.i;
		}
	    }
	}
    }

/*     SOLVE EACH MODE EQUATION */

    i__5 = nop;
    for (kk = 1; kk <= i__5; ++kk) {
	krec = (kk - 1) * matpar_1.nblsym;
	ia = (kk - 1) * npeq + 1;
	ib = ia;
	if (matpar_1.icase == 4) {
	    i__ = npeq * npeq;
	    recin_(&a[1], iu1, &c__1, &i__, &kk, "Read for ICASE=4 in SOLVES",
		     (ftnlen)26);
	    ib = 1;
	}
	if (matpar_1.icase == 1 || matpar_1.icase == 2 || matpar_1.icase == 4)
		 {
	    i__2 = *nrh;
	    for (ic = 1; ic <= i__2; ++ic) {
/* L14: */
		solve_(&npeq, &a[ib], &ip[ia], &b[ia + ic * b_dim1], &nrow);
	    }
	} else {
	    ltsolv_(&a[1], &npeq, &ip[ia], &b[ia + b_dim1], neq, nrh, &
		    matpar_1.nblsym, &matpar_1.npsym, &matpar_1.nlsym, &krec, 
		    iu1);
	}
/* L16: */
    }
    if (nop == 1) {
	return 0;
    }

/*     INVERSE TRANSFORM THE MODE SOLUTIONS */

    i__5 = *nrh;
    for (ic = 1; ic <= i__5; ++ic) {
	i__2 = npeq;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i__3 = nop;
	    for (k = 1; k <= i__3; ++k) {
		ia = i__ + (k - 1) * npeq;
/* L17: */
		i__1 = k - 1;
		i__4 = ia + ic * b_dim1;
		scratm_2.y[i__1].r = b[i__4].r, scratm_2.y[i__1].i = b[i__4]
			.i;
	    }
	    sum.r = scratm_2.y[0].r, sum.i = scratm_2.y[0].i;
	    i__1 = nop;
	    for (k = 2; k <= i__1; ++k) {
/* L18: */
		i__4 = k - 1;
		z__1.r = sum.r + scratm_2.y[i__4].r, z__1.i = sum.i + 
			scratm_2.y[i__4].i;
		sum.r = z__1.r, sum.i = z__1.i;
	    }
	    i__4 = i__ + ic * b_dim1;
	    b[i__4].r = sum.r, b[i__4].i = sum.i;
	    i__4 = nop;
	    for (k = 2; k <= i__4; ++k) {
		ia = i__ + (k - 1) * npeq;
		sum.r = scratm_2.y[0].r, sum.i = scratm_2.y[0].i;
		i__1 = nop;
		for (j = 2; j <= i__1; ++j) {
/* L19: */
		    i__3 = j - 1;
		    i__6 = k + j * 20 - 21;
		    z__2.r = scratm_2.y[i__3].r * smat_1.ssx[i__6].r - 
			    scratm_2.y[i__3].i * smat_1.ssx[i__6].i, z__2.i = 
			    scratm_2.y[i__3].r * smat_1.ssx[i__6].i + 
			    scratm_2.y[i__3].i * smat_1.ssx[i__6].r;
		    z__1.r = sum.r + z__2.r, z__1.i = sum.i + z__2.i;
		    sum.r = z__1.r, sum.i = z__1.i;
		}
/* L20: */
		i__3 = ia + ic * b_dim1;
		b[i__3].r = sum.r, b[i__3].i = sum.i;
	    }
	}
	if (*n == 0 || *m == 0) {
	    goto L26;
	}
	i__3 = *neq;
	for (i__ = 1; i__ <= i__3; ++i__) {
/* L21: */
	    i__4 = i__ - 1;
	    i__2 = i__ + ic * b_dim1;
	    scratm_2.y[i__4].r = b[i__2].r, scratm_2.y[i__4].i = b[i__2].i;
	}
	kk = *mp << 1;
	ia = *np;
	ib = *n;
	j = *np;
	i__4 = nop;
	for (k = 1; k <= i__4; ++k) {
	    if (k > 1) {
		i__2 = *np;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    ++ia;
		    ++j;
/* L22: */
		    i__3 = ia + ic * b_dim1;
		    i__6 = j - 1;
		    b[i__3].r = scratm_2.y[i__6].r, b[i__3].i = scratm_2.y[
			    i__6].i;
		}
	    }
	    if (k < nop) {
		i__3 = kk;
		for (i__ = 1; i__ <= i__3; ++i__) {
		    ++ib;
		    ++j;
/* L24: */
		    i__6 = ib + ic * b_dim1;
		    i__2 = j - 1;
		    b[i__6].r = scratm_2.y[i__2].r, b[i__6].i = scratm_2.y[
			    i__2].i;
		}
	    }
/* L25: */
	}
L26:
	;
    }
    return 0;
} /* solves_ */

/* Subroutine */ int strac_(integer *nz, integer *nr)
{
    /* Format strings */
    static char fmt_11[] = "(\002 STRAC: AN ERROR OCCURRED IN FILLING THE IN"
	    "TERPOLATION\002,\002 TABLES,  IR,IZ=\002,2i7)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublecomplex z__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static doublereal dr;
    static integer ir;
    static doublereal dz;
    static integer ix, iz;
    static doublecomplex xl;
    static integer nrm;
    static doublereal drx;
    static integer irs;
    static doublecomplex xll;
    static integer irx, nrx, ierr;
    static doublereal rozx;
    extern /* Subroutine */ int sdlpt_(doublecomplex *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1950 = { 0, 3, 0, fmt_11, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     STRAC fills the interpolation table (XLA) for locations of the */
/*     saddle-point between 0. and GCK2. */

    dz = 1.f / (*nz - 1.f);
    dr = 1.f / (*nr - 1.f);
    gparm_1.zrat = -dz;
    i__1 = *nz;
    for (iz = 1; iz <= i__1; ++iz) {
	gparm_1.zrat += dz;
	i__2 = iz * 21 - 21;
	gparm_1.xla[i__2].r = 0.f, gparm_1.xla[i__2].i = 0.f;
	i__2 = *nr + iz * 21 - 22;
	gparm_1.xla[i__2].r = gparm_1.gck2.r, gparm_1.xla[i__2].i = 
		gparm_1.gck2.i;
	rozx = 0.f;
	xll.r = 0.f, xll.i = 0.f;
	nrm = *nr - 1;
	i__2 = nrm;
	for (ir = 2; ir <= i__2; ++ir) {
	    rozx += dr;
	    if (iz == 1) {
		z__1.r = rozx * gparm_1.gck1.r, z__1.i = rozx * 
			gparm_1.gck1.i;
		xl.r = z__1.r, xl.i = z__1.i;
		if (xl.r > gparm_1.gck2.r) {
		    xl.r = gparm_1.gck2.r, xl.i = gparm_1.gck2.i;
		}
		i__3 = ir + iz * 21 - 22;
		gparm_1.xla[i__3].r = xl.r, gparm_1.xla[i__3].i = xl.i;
	    } else if (iz == *nz) {
		i__3 = ir + iz * 21 - 22;
		z__1.r = rozx * gparm_1.gck2.r, z__1.i = rozx * 
			gparm_1.gck2.i;
		gparm_1.xla[i__3].r = z__1.r, gparm_1.xla[i__3].i = z__1.i;
	    } else {
		drx = dr;
		nrx = 1;
L3:
		xl.r = xll.r, xl.i = xll.i;
		gparm_1.rhon = rozx - dr;
		i__3 = nrx;
		for (ix = 1; ix <= i__3; ++ix) {
		    gparm_1.rhon += drx;
		    sdlpt_(&xl, &ierr);
		    if (ierr != 0) {
			nrx <<= 1;
			drx *= .5f;
			if (nrx <= 256) {
			    goto L3;
			}
			if (ierr != 3) {
			    s_wsfe(&io___1950);
			    do_fio(&c__1, (char *)&ir, (ftnlen)sizeof(integer)
				    );
			    do_fio(&c__1, (char *)&iz, (ftnlen)sizeof(integer)
				    );
			    e_wsfe();
			    s_stop("", (ftnlen)0);
			}
			irs = ir;
			i__4 = nrm;
			for (irx = irs; irx <= i__4; ++irx) {
/* L8: */
			    i__5 = irx + iz * 21 - 22;
			    gparm_1.xla[i__5].r = gparm_1.gck2.r, gparm_1.xla[
				    i__5].i = gparm_1.gck2.i;
			}
			goto L9;
		    }
/* L4: */
		}
		i__3 = ir + iz * 21 - 22;
		gparm_1.xla[i__3].r = xl.r, gparm_1.xla[i__3].i = xl.i;
		xll.r = xl.r, xll.i = xl.i;
	    }
/* L6: */
	}
L9:
	;
    }
    return 0;

} /* strac_ */

/* Subroutine */ int test_(doublereal *f1r, doublereal *f2r, doublereal *tr, 
	doublereal *f1i, doublereal *f2i, doublereal *ti, doublereal *dmin__)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    static doublereal den;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TEST tests for convergence in the Romberg numerical integration. */

    den = abs(*f2r);
    *tr = abs(*f2i);
    if (den < *tr) {
	den = *tr;
    }
    if (den < *dmin__) {
	den = *dmin__;
    }
    if (den < 1e-37f) {
	goto L1;
    }
    *tr = (d__1 = (*f1r - *f2r) / den, abs(d__1));
    *ti = (d__1 = (*f1i - *f2i) / den, abs(d__1));
    return 0;
L1:
    *tr = 0.f;
    *ti = 0.f;
    return 0;
} /* test_ */

/* Subroutine */ int trxfld_(doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh, integer *
	ireg)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double cos(doublereal);

    /* Local variables */
    static doublereal s;
    static doublecomplex fph, frh, fzh, frv, fzv;
    extern /* Subroutine */ int fitls_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, integer *), 
	    intreg_(doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TRXFLD returns transmitted E field at RHO,ZO due to a source */
/*     at ZS on the Z axis.  Field values are obtained by interpolation */
/*     or L.S. approximation with the transitions smoothed. */

    if (gnrzz_1.rho > gregon_1.elm) {
	goto L3;
    }
    if (gnrzz_1.zz > gregon_1.elm) {
	goto L3;
    }
    intreg_(erv, ezv, erh, eph, ezh);
    if (gnrzz_1.rho < gregon_1.elmx && gnrzz_1.zz < gregon_1.elmx) {
	return 0;
    }
    if (gnrzz_1.azp > gregon_1.zpmx2) {
	return 0;
    }
    if (gnrzz_1.zz > gnrzz_1.rho) {
	goto L1;
    }
    s = (gnrzz_1.rho - gregon_1.elmx) * gregon_1.scfac;
    goto L2;
L1:
    s = (gnrzz_1.zz - gregon_1.elmx) * gregon_1.scfac;
L2:
    s = (cos(s) + 1.f) * .5f;
    fitls_(&frv, &fzv, &frh, &fph, &fzh, ireg);
    z__3.r = erv->r - frv.r, z__3.i = erv->i - frv.i;
    z__2.r = s * z__3.r, z__2.i = s * z__3.i;
    z__1.r = z__2.r + frv.r, z__1.i = z__2.i + frv.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = ezv->r - fzv.r, z__3.i = ezv->i - fzv.i;
    z__2.r = s * z__3.r, z__2.i = s * z__3.i;
    z__1.r = z__2.r + fzv.r, z__1.i = z__2.i + fzv.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__3.r = erh->r - frh.r, z__3.i = erh->i - frh.i;
    z__2.r = s * z__3.r, z__2.i = s * z__3.i;
    z__1.r = z__2.r + frh.r, z__1.i = z__2.i + frh.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__3.r = eph->r - fph.r, z__3.i = eph->i - fph.i;
    z__2.r = s * z__3.r, z__2.i = s * z__3.i;
    z__1.r = z__2.r + fph.r, z__1.i = z__2.i + fph.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__3.r = ezh->r - fzh.r, z__3.i = ezh->i - fzh.i;
    z__2.r = s * z__3.r, z__2.i = s * z__3.i;
    z__1.r = z__2.r + fzh.r, z__1.i = z__2.i + fzh.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L3:
    fitls_(erv, ezv, erh, eph, ezh, ireg);
    return 0;
} /* trxfld_ */

/* Subroutine */ int unere_(doublereal *xob, doublereal *yob, doublereal *zob)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_sqrt(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static doublecomplex q1, q2;
    static doublereal r2;
    static doublecomplex er, xk;
    static doublereal px, py, rx, ry, zr, rz;
    static doublecomplex tt1, tt2, edp;
    static doublereal cth;
    static doublecomplex rkj, rrh, etx, rrv;
    static doublereal t1zr, t2zr, xymag;
    static doublecomplex zrati;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     UNERE calculates the electric field due to unit current in the T1 */
/*     and T2 directions on a patch. */

    if (datap_1.zpatj >= 0.f) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	etx.r = gnd_1.etau.r, etx.i = gnd_1.etau.i;
    } else {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	etx.r = gnd_1.etal.r, etx.i = gnd_1.etal.i;
    }
    zr = datap_1.zpatj;
    t1zr = datap_1.t1zj;
    t2zr = datap_1.t2zj;
    if (datap_1.ipgnd == 2) {
	zr = -zr;
	t1zr = -t1zr;
	t2zr = -t2zr;
    }
    rx = *xob - datap_1.xpatj;
    ry = *yob - datap_1.ypatj;
    rz = *zob - zr;
    r2 = rx * rx + ry * ry + rz * rz;
    if (r2 < 1e-20f) {
	datap_1.h1x.r = 0.f, datap_1.h1x.i = 0.f;
	datap_1.h1y.r = 0.f, datap_1.h1y.i = 0.f;
	datap_1.h1z.r = 0.f, datap_1.h1z.i = 0.f;
	datap_1.h2x.r = 0.f, datap_1.h2x.i = 0.f;
	datap_1.h2y.r = 0.f, datap_1.h2y.i = 0.f;
	datap_1.h2z.r = 0.f, datap_1.h2z.i = 0.f;
	return 0;
    }
    r__ = sqrt(r2);
    z__1.r = r__ * xk.r, z__1.i = r__ * xk.i;
    tt1.r = z__1.r, tt1.i = z__1.i;
    z__1.r = tt1.r * tt1.r - tt1.i * tt1.i, z__1.i = tt1.r * tt1.i + tt1.i * 
	    tt1.r;
    tt2.r = z__1.r, tt2.i = z__1.i;
    z__1.r = tt1.r * 0.f - tt1.i * 1.f, z__1.i = tt1.r * 1.f + tt1.i * 0.f;
    rkj.r = z__1.r, rkj.i = z__1.i;
    z__5.r = -rkj.r, z__5.i = -rkj.i;
    z_exp(&z__4, &z__5);
    z__3.r = datap_1.spatj * z__4.r, z__3.i = datap_1.spatj * z__4.i;
    z__2.r = z__3.r * etx.r - z__3.i * etx.i, z__2.i = z__3.r * etx.i + 
	    z__3.i * etx.r;
    z__6.r = rkj.r * 12.56637062f, z__6.i = rkj.i * 12.56637062f;
    z_div(&z__1, &z__2, &z__6);
    er.r = z__1.r, er.i = z__1.i;
    z__4.r = tt2.r - rkj.r, z__4.i = tt2.i - rkj.i;
    z__3.r = z__4.r - 1.f, z__3.i = z__4.i;
    z__2.r = z__3.r * er.r - z__3.i * er.i, z__2.i = z__3.r * er.i + z__3.i * 
	    er.r;
    z__1.r = z__2.r / r2, z__1.i = z__2.i / r2;
    q1.r = z__1.r, q1.i = z__1.i;
    z__5.r = rkj.r + 1.f, z__5.i = rkj.i;
    z__4.r = z__5.r * 3.f, z__4.i = z__5.i * 3.f;
    z__3.r = z__4.r - tt2.r, z__3.i = z__4.i - tt2.i;
    z__2.r = z__3.r * er.r - z__3.i * er.i, z__2.i = z__3.r * er.i + z__3.i * 
	    er.r;
    d__1 = r2 * r2;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    q2.r = z__1.r, q2.i = z__1.i;
    d__1 = datap_1.t1xj * rx + datap_1.t1yj * ry + t1zr * rz;
    z__1.r = d__1 * q2.r, z__1.i = d__1 * q2.i;
    er.r = z__1.r, er.i = z__1.i;
    z__2.r = datap_1.t1xj * q1.r, z__2.i = datap_1.t1xj * q1.i;
    z__3.r = rx * er.r, z__3.i = rx * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h1x.r = z__1.r, datap_1.h1x.i = z__1.i;
    z__2.r = datap_1.t1yj * q1.r, z__2.i = datap_1.t1yj * q1.i;
    z__3.r = ry * er.r, z__3.i = ry * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h1y.r = z__1.r, datap_1.h1y.i = z__1.i;
    z__2.r = t1zr * q1.r, z__2.i = t1zr * q1.i;
    z__3.r = rz * er.r, z__3.i = rz * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h1z.r = z__1.r, datap_1.h1z.i = z__1.i;
    d__1 = datap_1.t2xj * rx + datap_1.t2yj * ry + t2zr * rz;
    z__1.r = d__1 * q2.r, z__1.i = d__1 * q2.i;
    er.r = z__1.r, er.i = z__1.i;
    z__2.r = datap_1.t2xj * q1.r, z__2.i = datap_1.t2xj * q1.i;
    z__3.r = rx * er.r, z__3.i = rx * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h2x.r = z__1.r, datap_1.h2x.i = z__1.i;
    z__2.r = datap_1.t2yj * q1.r, z__2.i = datap_1.t2yj * q1.i;
    z__3.r = ry * er.r, z__3.i = ry * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h2y.r = z__1.r, datap_1.h2y.i = z__1.i;
    z__2.r = t2zr * q1.r, z__2.i = t2zr * q1.i;
    z__3.r = rz * er.r, z__3.i = rz * er.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h2z.r = z__1.r, datap_1.h2z.i = z__1.i;
    if (datap_1.ipgnd == 1) {
	goto L8;
    }
    if (gnd_1.iperf == 1) {
	z__1.r = -datap_1.h1x.r, z__1.i = -datap_1.h1x.i;
	datap_1.h1x.r = z__1.r, datap_1.h1x.i = z__1.i;
	z__1.r = -datap_1.h1y.r, z__1.i = -datap_1.h1y.i;
	datap_1.h1y.r = z__1.r, datap_1.h1y.i = z__1.i;
	z__1.r = -datap_1.h1z.r, z__1.i = -datap_1.h1z.i;
	datap_1.h1z.r = z__1.r, datap_1.h1z.i = z__1.i;
	z__1.r = -datap_1.h2x.r, z__1.i = -datap_1.h2x.i;
	datap_1.h2x.r = z__1.r, datap_1.h2x.i = z__1.i;
	z__1.r = -datap_1.h2y.r, z__1.i = -datap_1.h2y.i;
	datap_1.h2y.r = z__1.r, datap_1.h2y.i = z__1.i;
	z__1.r = -datap_1.h2z.r, z__1.i = -datap_1.h2z.i;
	datap_1.h2z.r = z__1.r, datap_1.h2z.i = z__1.i;
	goto L8;
    }
    xymag = sqrt(rx * rx + ry * ry);
    z_div(&z__1, &gnd_1.xku, &gnd_1.xkl);
    zrati.r = z__1.r, zrati.i = z__1.i;
    if (datap_1.zpatj < 0.f) {
	z_div(&z__1, &gnd_1.xkl, &gnd_1.xku);
	zrati.r = z__1.r, zrati.i = z__1.i;
    }
    if (xymag < 1e-10f) {
	px = 0.f;
	py = 0.f;
	cth = 1.f;
	rrv.r = 1.f, rrv.i = 0.f;
    } else {
	px = -ry / xymag;
	py = rx / xymag;
	cth = abs(rz) / sqrt(xymag * xymag + rz * rz);
	z__4.r = zrati.r * zrati.r - zrati.i * zrati.i, z__4.i = zrati.r * 
		zrati.i + zrati.i * zrati.r;
	d__1 = 1.f - cth * cth;
	z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
	z_sqrt(&z__1, &z__2);
	rrv.r = z__1.r, rrv.i = z__1.i;
    }
    z__1.r = cth * zrati.r, z__1.i = cth * zrati.i;
    rrh.r = z__1.r, rrh.i = z__1.i;
    z__2.r = rrh.r - rrv.r, z__2.i = rrh.i - rrv.i;
    z__3.r = rrh.r + rrv.r, z__3.i = rrh.i + rrv.i;
    z_div(&z__1, &z__2, &z__3);
    rrh.r = z__1.r, rrh.i = z__1.i;
    z__1.r = zrati.r * rrv.r - zrati.i * rrv.i, z__1.i = zrati.r * rrv.i + 
	    zrati.i * rrv.r;
    rrv.r = z__1.r, rrv.i = z__1.i;
    z__3.r = cth - rrv.r, z__3.i = -rrv.i;
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__4.r = cth + rrv.r, z__4.i = rrv.i;
    z_div(&z__1, &z__2, &z__4);
    rrv.r = z__1.r, rrv.i = z__1.i;
    z__3.r = px * datap_1.h1x.r, z__3.i = px * datap_1.h1x.i;
    z__4.r = py * datap_1.h1y.r, z__4.i = py * datap_1.h1y.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__5.r = rrh.r - rrv.r, z__5.i = rrh.i - rrv.i;
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    edp.r = z__1.r, edp.i = z__1.i;
    z__2.r = datap_1.h1x.r * rrv.r - datap_1.h1x.i * rrv.i, z__2.i = 
	    datap_1.h1x.r * rrv.i + datap_1.h1x.i * rrv.r;
    z__3.r = px * edp.r, z__3.i = px * edp.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h1x.r = z__1.r, datap_1.h1x.i = z__1.i;
    z__2.r = datap_1.h1y.r * rrv.r - datap_1.h1y.i * rrv.i, z__2.i = 
	    datap_1.h1y.r * rrv.i + datap_1.h1y.i * rrv.r;
    z__3.r = py * edp.r, z__3.i = py * edp.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h1y.r = z__1.r, datap_1.h1y.i = z__1.i;
    z__1.r = datap_1.h1z.r * rrv.r - datap_1.h1z.i * rrv.i, z__1.i = 
	    datap_1.h1z.r * rrv.i + datap_1.h1z.i * rrv.r;
    datap_1.h1z.r = z__1.r, datap_1.h1z.i = z__1.i;
    z__3.r = px * datap_1.h2x.r, z__3.i = px * datap_1.h2x.i;
    z__4.r = py * datap_1.h2y.r, z__4.i = py * datap_1.h2y.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__5.r = rrh.r - rrv.r, z__5.i = rrh.i - rrv.i;
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    edp.r = z__1.r, edp.i = z__1.i;
    z__2.r = datap_1.h2x.r * rrv.r - datap_1.h2x.i * rrv.i, z__2.i = 
	    datap_1.h2x.r * rrv.i + datap_1.h2x.i * rrv.r;
    z__3.r = px * edp.r, z__3.i = px * edp.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h2x.r = z__1.r, datap_1.h2x.i = z__1.i;
    z__2.r = datap_1.h2y.r * rrv.r - datap_1.h2y.i * rrv.i, z__2.i = 
	    datap_1.h2y.r * rrv.i + datap_1.h2y.i * rrv.r;
    z__3.r = py * edp.r, z__3.i = py * edp.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    datap_1.h2y.r = z__1.r, datap_1.h2y.i = z__1.i;
    z__1.r = datap_1.h2z.r * rrv.r - datap_1.h2z.i * rrv.i, z__1.i = 
	    datap_1.h2z.r * rrv.i + datap_1.h2z.i * rrv.r;
    datap_1.h2z.r = z__1.r, datap_1.h2z.i = z__1.i;
L8:
    return 0;
} /* unere_ */

/* Subroutine */ int wire_(doublereal *xw1, doublereal *yw1, doublereal *zw1, 
	doublereal *xw2, doublereal *yw2, doublereal *zw2, doublereal *rad, 
	doublereal *rdel, doublereal *rrad, integer *ns, integer *itg)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal), pow_di(doublereal *, integer *);

    /* Local variables */
    static integer i__;
#define x2 ((doublereal *)&data_1 + 3630)
#define y2 ((doublereal *)&data_1 + 6050)
#define z2 ((doublereal *)&data_1 + 7260)
    static doublereal rd, xd, yd, zd, xs1, ys1, zs1, xs2, ys2, zs2, fns;
    static integer ist;
    static doublereal delz, radz;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     WIRE generates segment geometry data for a straight wire of NS */
/*     segments. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ist = data_1.n + 1;
    data_1.n += *ns;
    data_1.np = data_1.n;
    data_1.mp = data_1.m;
    data_1.ipsym = 0;
    if (*ns < 1) {
	return 0;
    }
    xd = *xw2 - *xw1;
    yd = *yw2 - *yw1;
    zd = *zw2 - *zw1;
    if ((d__1 = *rdel - 1.f, abs(d__1)) < 1e-6f) {
	goto L1;
    }
    delz = sqrt(xd * xd + yd * yd + zd * zd);
    xd /= delz;
    yd /= delz;
    zd /= delz;
    delz = delz * (1.f - *rdel) / (1.f - pow_di(rdel, ns));
    rd = *rdel;
    goto L2;
L1:
    fns = (doublereal) (*ns);
    xd /= fns;
    yd /= fns;
    zd /= fns;
    delz = 1.f;
    rd = 1.f;
L2:
    radz = *rad;
    xs1 = *xw1;
    ys1 = *yw1;
    zs1 = *zw1;
    i__1 = data_1.n;
    for (i__ = ist; i__ <= i__1; ++i__) {
	data_1.itag[i__ - 1] = *itg;
	xs2 = xs1 + xd * delz;
	ys2 = ys1 + yd * delz;
	zs2 = zs1 + zd * delz;
	data_1.x[i__ - 1] = xs1;
	data_1.y[i__ - 1] = ys1;
	data_1.z__[i__ - 1] = zs1;
	x2[i__ - 1] = xs2;
	y2[i__ - 1] = ys2;
	z2[i__ - 1] = zs2;
	data_1.bi[i__ - 1] = radz;
	delz *= rd;
	radz *= *rrad;
	xs1 = xs2;
	ys1 = ys2;
/* L3: */
	zs1 = zs2;
    }
    x2[data_1.n - 1] = *xw2;
    y2[data_1.n - 1] = *yw2;
    z2[data_1.n - 1] = *zw2;
    return 0;
} /* wire_ */

#undef z2
#undef y2
#undef x2


/* Subroutine */ int inset_(doublereal *omegin)
{
    /* Format strings */
    static char fmt_90[] = "(//,35x,\002- - - WIRE SHEATH PARAMETERS - - "
	    "-\002,//,27x,\002SEGMENTS\002,9x,\002RELATIVE\002,5x,\002CONDUCT"
	    "IVITY\002,3x,\002SHEATH RAD.\002,/,24x,\002TAG\002,2x,\002FRO"
	    "M\002,2x,\002THRU\002,3x,\002PERMITTIVITY\002,5x,\002(MHOS/M)"
	    "\002,8x,\002(M)\002,/)";
    static char fmt_91[] = "(21x,3i6,2x,1pe12.5,3x,e12.5,3x,e12.5)";
    static char fmt_92[] = "(\002 INSET: ERROR - SHEATH MAY NOT BE ADDED TO "
	    "WIRE IN NGF\002,\002 SECTION\002)";
    static char fmt_95[] = "(\002 INSET: ERROR - SHEATH RADIUS .LE. SEGMENT "
	    "RADIUS FOR\002,\002 SEGMENT\002,i5)";
    static char fmt_93[] = "(\002 INSET: ERROR -- NO SEGMENTS MATCHED THE RA"
	    "NGE ON THE\002,\002 PREVIOUS IS COMMAND\002)";
    static char fmt_94[] = "(\002 INSET: WARNING - OVERLAPPING SHEATH SPECIF"
	    "ICATIONS.\002,\002  LAST ONE WAS USED.\002)";
    static char fmt_96[] = "(//,35x,\002**** WIRE SHEATHS IN NGF SECTION *"
	    "***\002,//)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, l1, l2, is, nop, ichk;
    static doublereal epcon;
    static integer iwarn, icount;

    /* Fortran I/O blocks */
    static cilist io___2003 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___2007 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___2010 = { 0, 3, 0, fmt_92, 0 };
    static cilist io___2013 = { 0, 3, 0, fmt_95, 0 };
    static cilist io___2014 = { 0, 3, 0, fmt_93, 0 };
    static cilist io___2015 = { 0, 3, 0, fmt_94, 0 };
    static cilist io___2017 = { 0, 3, 0, fmt_96, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     INSET FILLS THE ARRAYS CEINS AND BRINS IN COMMON/INSCOM/ */
/*     WITH THE COMPLEX PERMITTIVITY AND RADIUS OF THE WIRE SHEATH */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (inscom_1.nins == 0) {
	goto L9;
    }
    epcon = 1.f / (*omegin * constn_1.epsrz);

/*     PRINT HEADING AND INITIALIZE ARRAYS */

    s_wsfe(&io___2003);
    e_wsfe();
    i__1 = data_1.n;
    for (i__ = data_1.n2; i__ <= i__1; ++i__) {
	inscom_1.brins[i__ - 1] = 0.f;
/* L1: */
	i__2 = i__ - 1;
	inscom_1.ceins[i__2].r = 1.f, inscom_1.ceins[i__2].i = 0.f;
    }
    iwarn = 0;

/*     LOOP OVER INSULATION COMMANDS */

    i__2 = inscom_1.nins;
    for (is = 1; is <= i__2; ++is) {
	s_wsfe(&io___2007);
	do_fio(&c__1, (char *)&inscom_1.intag[is - 1], (ftnlen)sizeof(integer)
		);
	do_fio(&c__1, (char *)&inscom_1.intagf[is - 1], (ftnlen)sizeof(
		integer));
	do_fio(&c__1, (char *)&inscom_1.intagt[is - 1], (ftnlen)sizeof(
		integer));
	do_fio(&c__1, (char *)&inscom_1.epsin[is - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__1, (char *)&inscom_1.sigin[is - 1], (ftnlen)sizeof(
		doublereal));
	do_fio(&c__1, (char *)&inscom_1.radin[is - 1], (ftnlen)sizeof(
		doublereal));
	e_wsfe();

/*     SEARCH FOR SEGMENTS IN THE RANGE SPECIFIED */

	if (inscom_1.intag[is - 1] != 0 || inscom_1.intagf[is - 1] == 0 && 
		inscom_1.intagt[is - 1] == 0) {
	    l1 = data_1.n2;
	    l2 = data_1.n;
	} else {
	    l1 = inscom_1.intagf[is - 1];
	    l2 = inscom_1.intagt[is - 1];
	}
	if (l1 <= data_1.n1) {
	    s_wsfe(&io___2010);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	icount = 0;
	ichk = 0;
	i__1 = l2;
	for (i__ = l1; i__ <= i__1; ++i__) {
	    if (inscom_1.intag[is - 1] != 0) {
		if (inscom_1.intag[is - 1] != data_1.itag[i__ - 1]) {
		    goto L3;
		}
		if (inscom_1.intagf[is - 1] > 0) {
		    ++icount;
		    if (icount < inscom_1.intagf[is - 1] || icount > 
			    inscom_1.intagt[is - 1]) {
			goto L3;
		    }
		}
	    }

/*     FILL ARRAYS CEINS AND BRINS */

	    ichk = 1;
	    if (inscom_1.brins[i__ - 1] > 0.f) {
		iwarn = 1;
	    }
	    if (inscom_1.radin[is - 1] < data_1.bi[i__ - 1]) {
		s_wsfe(&io___2013);
		do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
		e_wsfe();
		s_stop("", (ftnlen)0);
	    }
	    i__3 = i__ - 1;
	    i__4 = is - 1;
	    i__5 = is - 1;
	    z__1.r = inscom_1.epsin[i__4], z__1.i = inscom_1.sigin[i__5];
	    inscom_1.ceins[i__3].r = z__1.r, inscom_1.ceins[i__3].i = z__1.i;
	    if (inscom_1.sigin[is - 1] > 0.f) {
		i__3 = i__ - 1;
		i__4 = is - 1;
		i__5 = is - 1;
		z__3.r = inscom_1.sigin[i__5] * 0.f, z__3.i = inscom_1.sigin[
			i__5] * 1.f;
		z__2.r = epcon * z__3.r, z__2.i = epcon * z__3.i;
		z__1.r = inscom_1.epsin[i__4] - z__2.r, z__1.i = -z__2.i;
		inscom_1.ceins[i__3].r = z__1.r, inscom_1.ceins[i__3].i = 
			z__1.i;
	    }
	    inscom_1.brins[i__ - 1] = inscom_1.radin[is - 1];
L3:
	    ;
	}
	if (ichk == 0) {
	    s_wsfe(&io___2014);
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
/* L10: */
    }
    if (iwarn == 1) {
	s_wsfe(&io___2015);
	e_wsfe();
    }
    nop = data_1.n / data_1.np;
    if (nop > 1 && data_1.n1 + (data_1.m1 << 1) == 0) {
	i__2 = data_1.np;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    l1 = i__;
	    i__1 = nop;
	    for (l2 = 2; l2 <= i__1; ++l2) {
		l1 += data_1.np;
		i__3 = l1 - 1;
		i__4 = i__ - 1;
		inscom_1.ceins[i__3].r = inscom_1.ceins[i__4].r, 
			inscom_1.ceins[i__3].i = inscom_1.ceins[i__4].i;
/* L8: */
		inscom_1.brins[l1 - 1] = inscom_1.brins[i__ - 1];
	    }
	}
    }
L9:
    if (inscom_1.ninsf > 0) {
	s_wsfe(&io___2017);
	e_wsfe();
    }
    return 0;
} /* inset_ */

/* Subroutine */ int xkset_(void)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *), log(doublereal);

    /* Local variables */
    static integer i__;
    static doublecomplex h0, xk, h0p, xki;
    extern /* Subroutine */ int hank12_(doublecomplex *, integer *, 
	    doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     XKSET FILLS XKS WITH VALUES OF K FOR THE CURRENT EXPANSION */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (data_1.n < 1) {
	return 0;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	if (data_1.z__[i__ - 1] < 0.f) {
	    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	}
	i__2 = i__ - 1;
	crnt_1.xks[i__2].r = xk.r, crnt_1.xks[i__2].i = xk.i;
	if (inscom_1.nins == 0 && inscom_1.ninsf == 0) {
	    goto L10;
	}
	if (inscom_1.brins[i__ - 1] < data_1.bi[i__ - 1]) {
	    goto L10;
	}
	d__1 = gnd_1.omegag / 2.998e8f;
	z_sqrt(&z__2, &inscom_1.ceins[i__ - 1]);
	z__1.r = d__1 * z__2.r, z__1.i = d__1 * z__2.i;
	xki.r = z__1.r, xki.i = z__1.i;
	z_div(&z__1, &xk, &xki);
	if (z_abs(&z__1) < 2.f) {
	    goto L10;
	}

/*     COMPUTE MODIFIED K FOR CURRENT EXPANSION ON INSULATED WIRE */

	i__2 = i__ - 1;
	z__1.r = inscom_1.brins[i__2] * xk.r, z__1.i = inscom_1.brins[i__2] * 
		xk.i;
	hank12_(&z__1, &c__2, &h0, &h0p);
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__7.r = inscom_1.brins[i__3] * xk.r, z__7.i = inscom_1.brins[i__3] * 
		xk.i;
	d__1 = log(inscom_1.brins[i__ - 1] / data_1.bi[i__ - 1]);
	z__6.r = d__1 * z__7.r, z__6.i = d__1 * z__7.i;
	z__5.r = z__6.r * h0p.r - z__6.i * h0p.i, z__5.i = z__6.r * h0p.i + 
		z__6.i * h0p.r;
	z_div(&z__4, &h0, &z__5);
	z__3.r = 1.f - z__4.r, z__3.i = -z__4.i;
	z_sqrt(&z__2, &z__3);
	z__1.r = xki.r * z__2.r - xki.i * z__2.i, z__1.i = xki.r * z__2.i + 
		xki.i * z__2.r;
	crnt_1.xks[i__2].r = z__1.r, crnt_1.xks[i__2].i = z__1.i;
L10:
	;
    }
    return 0;
} /* xkset_ */

/* Subroutine */ int ptslen_(void)
{
    /* Format strings */
    static char fmt_90[] = "(///,29x,\002- - - SEGMENT LENGTHS AND RADII - -"
	    " -\002,//,31x,\002K  = WAVE NUMBER IN MEDIUM\002,/,31x,\002KS = "
	    "WAVE NUMBER FOR CURRENT\002,\002 EXPANSION\002,//,33x,\002ELECTR"
	    "ICAL LENGTHS NORMALIZED -\002,13x,\002WAVE NO. FOR CURRENT EXP"
	    ".\002,/,2x,\002SEG.\002,5x,\002- - METERS - -\002,8x,\002BY 2.*P"
	    "I/CABS(K)\002,7x,\002BY 2.*PI/CABS(KS)\002,13x,\002(KS)\002,/2x"
	    ",\002NO.\002,6x,\002LENGTH\002,5x,\002RADIUS\002,6x,\002LENGT"
	    "H\002,5x,\002RADIUS\002,6x,\002LENGTH\002,5x,\002RADIUS\002,7x"
	    ",\002REAL\002,8x,\002IMAG.\002)";
    static char fmt_91[] = "(i6,3(1x,1p2e11.3),1x,2e12.4)";
    static char fmt_92[] = "(///)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double z_abs(doublecomplex *);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublecomplex xk;
    static doublereal bnor, tpok, snor, bnors, tpoks, snors;

    /* Fortran I/O blocks */
    static cilist io___2023 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___2032 = { 0, 3, 0, fmt_91, 0 };
    static cilist io___2033 = { 0, 3, 0, fmt_92, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     PTSLEN prints the effective electrical lengths of segments */
/*     relative to the wavelength 2pi/ks.  ks is the wavenumber used */
/*     in the current expansion, and takes into account the medium sur- */
/*     rounding the wire and whether the wire has an insulating sheath. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    if (data_1.n < 1) {
	return 0;
    }
    s_wsfe(&io___2023);
    e_wsfe();
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	if (data_1.z__[i__ - 1] < 0.f) {
	    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	}
	tpok = z_abs(&xk) / constn_1.tp;
	tpoks = z_abs(&crnt_1.xks[i__ - 1]) / constn_1.tp;
	snor = data_1.si[i__ - 1] * tpok;
	bnor = data_1.bi[i__ - 1] * tpok;
	snors = data_1.si[i__ - 1] * tpoks;
	bnors = data_1.bi[i__ - 1] * tpoks;
/* L1: */
	s_wsfe(&io___2032);
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&data_1.si[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_fio(&c__1, (char *)&data_1.bi[i__ - 1], (ftnlen)sizeof(doublereal))
		;
	do_fio(&c__1, (char *)&snor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&bnor, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&snors, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&bnors, (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&crnt_1.xks[i__ - 1], (ftnlen)sizeof(doublereal)
		);
	e_wsfe();
    }
    s_wsfe(&io___2033);
    e_wsfe();
    return 0;

} /* ptslen_ */

/* Double Complex */ VOID zint_(doublecomplex * ret_val, doublereal *sigl, 
	doublereal *rmu, doublereal *rolam)
{
    /* Initialized data */

    static doublereal pi = 3.1415926;
    static doublereal pot = 1.5707963;
    static doublereal tp = 6.2831853071796;
    static doublereal tpcmu = 2368.705;
    static doublereal cmotp = 60.;
    static doublecomplex fj = {0.,1.};
    static doublecomplex cn = {.70710678,.70710678};
    static struct {
	doublereal e_1[28];
	} equiv_13 = { 6e-7, 1.9e-6, -3.4e-6, 5.1e-6, -2.52e-5, 0., -9.06e-5, 
		-9.01e-5, 0., -9.765e-4, .0110486, -.0110485, 0., -.3926991, 
		1.6e-6, -3.2e-6, 1.17e-5, -2.4e-6, 3.46e-5, 3.38e-5, 5e-7, 
		2.452e-4, -.0013813, .0013811, -.0625001, -1e-7, .7071068, 
		.7071068 };


    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15, z__16, z__17, z__18, z__19, 
	    z__20, z__21, z__22, z__23, z__24, z__25, z__26, z__27, z__28, 
	    z__29, z__30, z__31, z__32, z__33, z__34, z__35, z__36, z__37, 
	    z__38, z__39, z__40, z__41, z__42, z__43;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_exp(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal s, x, y;
#define cc1 ((doublecomplex *)&equiv_13)
#define cc2 ((doublecomplex *)&equiv_13 + 1)
#define cc3 ((doublecomplex *)&equiv_13 + 2)
#define cc4 ((doublecomplex *)&equiv_13 + 3)
#define cc5 ((doublecomplex *)&equiv_13 + 4)
#define cc6 ((doublecomplex *)&equiv_13 + 5)
#define cc7 ((doublecomplex *)&equiv_13 + 6)
#define cc8 ((doublecomplex *)&equiv_13 + 7)
#define cc9 ((doublecomplex *)&equiv_13 + 8)
    static doublecomplex br1, br2;
#define cc10 ((doublecomplex *)&equiv_13 + 9)
#define cc11 ((doublecomplex *)&equiv_13 + 10)
#define cc12 ((doublecomplex *)&equiv_13 + 11)
#define cc13 ((doublecomplex *)&equiv_13 + 12)
#define cc14 ((doublecomplex *)&equiv_13 + 13)
    static doublereal bei;
#define ccn ((doublereal *)&equiv_13)
    static doublereal ber;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ZINT computes the internal impedance of a circular wire. */


/*     STATEMENT FUNCTIONS: */


/*     END OF STATEMENT FUNCTIONS; BEGIN EXECUTABLE STATEMENTS. */

    x = sqrt(tpcmu * *rmu * *sigl) * *rolam;
    if (x > 110.f) {
	goto L2;
    }
    if (x > 8.f) {
	goto L1;
    }
    y = x / 8.f;
    y *= y;
    s = y * y;
    ber = ((((((s * -9.01e-6f + .00122552f) * s - .08349609f) * s + 2.641914f)
	     * s - 32.363456f) * s + 113.77778f) * s - 64.f) * s + 1.f;
    bei = ((((((s * 1.1346e-4f - .01103667f) * s + .52185615f) * s - 
	    10.567658f) * s + 72.817777f) * s - 113.77778f) * s + 16.f) * y;
    z__1.r = ber, z__1.i = bei;
    br1.r = z__1.r, br1.i = z__1.i;
    ber = ((((((s * -3.94e-6f + 4.5957e-4f) * s - .02609253f) * s + 
	    .66047849f) * s - 6.0681481f) * s + 14.222222f) * s - 4.f) * y * 
	    x;
    bei = ((((((s * 4.609e-5f - .00379386f) * s + .14677204f) * s - 
	    2.3116751f) * s + 11.377778f) * s - 10.666667f) * s + .5f) * x;
    z__1.r = ber, z__1.i = bei;
    br2.r = z__1.r, br2.i = z__1.i;
    z_div(&z__1, &br1, &br2);
    br1.r = z__1.r, br1.i = z__1.i;
    goto L3;
L1:
    d__1 = -8.f / x;
    d__2 = sqrt(pot / x);
    z__7.r = -cn.r, z__7.i = -cn.i;
    z__6.r = x * z__7.r, z__6.i = x * z__7.i;
    z__19.r = d__1 * cc1->r, z__19.i = d__1 * cc1->i;
    z__18.r = z__19.r + cc2->r, z__18.i = z__19.i + cc2->i;
    z__17.r = d__1 * z__18.r, z__17.i = d__1 * z__18.i;
    z__16.r = z__17.r + cc3->r, z__16.i = z__17.i + cc3->i;
    z__15.r = d__1 * z__16.r, z__15.i = d__1 * z__16.i;
    z__14.r = z__15.r + cc4->r, z__14.i = z__15.i + cc4->i;
    z__13.r = d__1 * z__14.r, z__13.i = d__1 * z__14.i;
    z__12.r = z__13.r + cc5->r, z__12.i = z__13.i + cc5->i;
    z__11.r = d__1 * z__12.r, z__11.i = d__1 * z__12.i;
    z__10.r = z__11.r + cc6->r, z__10.i = z__11.i + cc6->i;
    z__9.r = d__1 * z__10.r, z__9.i = d__1 * z__10.i;
    z__8.r = z__9.r + cc7->r, z__8.i = z__9.i + cc7->i;
    z__5.r = z__6.r + z__8.r, z__5.i = z__6.i + z__8.i;
    z_exp(&z__4, &z__5);
    z__3.r = d__2 * z__4.r, z__3.i = d__2 * z__4.i;
    z__2.r = fj.r * z__3.r - fj.i * z__3.i, z__2.i = fj.r * z__3.i + fj.i * 
	    z__3.r;
    z__1.r = z__2.r / pi, z__1.i = z__2.i / pi;
    br2.r = z__1.r, br2.i = z__1.i;
    d__1 = 8.f / x;
    z__5.r = x * cn.r, z__5.i = x * cn.i;
    z__17.r = d__1 * cc1->r, z__17.i = d__1 * cc1->i;
    z__16.r = z__17.r + cc2->r, z__16.i = z__17.i + cc2->i;
    z__15.r = d__1 * z__16.r, z__15.i = d__1 * z__16.i;
    z__14.r = z__15.r + cc3->r, z__14.i = z__15.i + cc3->i;
    z__13.r = d__1 * z__14.r, z__13.i = d__1 * z__14.i;
    z__12.r = z__13.r + cc4->r, z__12.i = z__13.i + cc4->i;
    z__11.r = d__1 * z__12.r, z__11.i = d__1 * z__12.i;
    z__10.r = z__11.r + cc5->r, z__10.i = z__11.i + cc5->i;
    z__9.r = d__1 * z__10.r, z__9.i = d__1 * z__10.i;
    z__8.r = z__9.r + cc6->r, z__8.i = z__9.i + cc6->i;
    z__7.r = d__1 * z__8.r, z__7.i = d__1 * z__8.i;
    z__6.r = z__7.r + cc7->r, z__6.i = z__7.i + cc7->i;
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z_exp(&z__3, &z__4);
    d__2 = sqrt(tp * x);
    z__2.r = z__3.r / d__2, z__2.i = z__3.i / d__2;
    z__1.r = z__2.r + br2.r, z__1.i = z__2.i + br2.i;
    br1.r = z__1.r, br1.i = z__1.i;
    d__1 = 8.f / x;
    d__2 = 8.f / x;
    d__3 = -8.f / x;
    z__6.r = x * cn.r, z__6.i = x * cn.i;
    z__18.r = d__1 * cc1->r, z__18.i = d__1 * cc1->i;
    z__17.r = z__18.r + cc2->r, z__17.i = z__18.i + cc2->i;
    z__16.r = d__1 * z__17.r, z__16.i = d__1 * z__17.i;
    z__15.r = z__16.r + cc3->r, z__15.i = z__16.i + cc3->i;
    z__14.r = d__1 * z__15.r, z__14.i = d__1 * z__15.i;
    z__13.r = z__14.r + cc4->r, z__13.i = z__14.i + cc4->i;
    z__12.r = d__1 * z__13.r, z__12.i = d__1 * z__13.i;
    z__11.r = z__12.r + cc5->r, z__11.i = z__12.i + cc5->i;
    z__10.r = d__1 * z__11.r, z__10.i = d__1 * z__11.i;
    z__9.r = z__10.r + cc6->r, z__9.i = z__10.i + cc6->i;
    z__8.r = d__1 * z__9.r, z__8.i = d__1 * z__9.i;
    z__7.r = z__8.r + cc7->r, z__7.i = z__8.i + cc7->i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z_exp(&z__4, &z__5);
    d__4 = sqrt(tp * x);
    z__3.r = z__4.r / d__4, z__3.i = z__4.i / d__4;
    z__30.r = d__2 * cc8->r, z__30.i = d__2 * cc8->i;
    z__29.r = z__30.r + cc9->r, z__29.i = z__30.i + cc9->i;
    z__28.r = d__2 * z__29.r, z__28.i = d__2 * z__29.i;
    z__27.r = z__28.r + cc10->r, z__27.i = z__28.i + cc10->i;
    z__26.r = d__2 * z__27.r, z__26.i = d__2 * z__27.i;
    z__25.r = z__26.r + cc11->r, z__25.i = z__26.i + cc11->i;
    z__24.r = d__2 * z__25.r, z__24.i = d__2 * z__25.i;
    z__23.r = z__24.r + cc12->r, z__23.i = z__24.i + cc12->i;
    z__22.r = d__2 * z__23.r, z__22.i = d__2 * z__23.i;
    z__21.r = z__22.r + cc13->r, z__21.i = z__22.i + cc13->i;
    z__20.r = d__2 * z__21.r, z__20.i = d__2 * z__21.i;
    z__19.r = z__20.r + cc14->r, z__19.i = z__20.i + cc14->i;
    z__2.r = z__3.r * z__19.r - z__3.i * z__19.i, z__2.i = z__3.r * z__19.i + 
	    z__3.i * z__19.r;
    z__43.r = d__3 * cc8->r, z__43.i = d__3 * cc8->i;
    z__42.r = z__43.r + cc9->r, z__42.i = z__43.i + cc9->i;
    z__41.r = d__3 * z__42.r, z__41.i = d__3 * z__42.i;
    z__40.r = z__41.r + cc10->r, z__40.i = z__41.i + cc10->i;
    z__39.r = d__3 * z__40.r, z__39.i = d__3 * z__40.i;
    z__38.r = z__39.r + cc11->r, z__38.i = z__39.i + cc11->i;
    z__37.r = d__3 * z__38.r, z__37.i = d__3 * z__38.i;
    z__36.r = z__37.r + cc12->r, z__36.i = z__37.i + cc12->i;
    z__35.r = d__3 * z__36.r, z__35.i = d__3 * z__36.i;
    z__34.r = z__35.r + cc13->r, z__34.i = z__35.i + cc13->i;
    z__33.r = d__3 * z__34.r, z__33.i = d__3 * z__34.i;
    z__32.r = z__33.r + cc14->r, z__32.i = z__33.i + cc14->i;
    z__31.r = br2.r * z__32.r - br2.i * z__32.i, z__31.i = br2.r * z__32.i + 
	    br2.i * z__32.r;
    z__1.r = z__2.r - z__31.r, z__1.i = z__2.i - z__31.i;
    br2.r = z__1.r, br2.i = z__1.i;
    z_div(&z__1, &br1, &br2);
    br1.r = z__1.r, br1.i = z__1.i;
    goto L3;
L2:
    br1.r = .70710678, br1.i = -.70710678;
L3:
    d__1 = sqrt(cmotp * *rmu / *sigl);
    z__3.r = d__1 * fj.r, z__3.i = d__1 * fj.i;
    z__2.r = z__3.r * br1.r - z__3.i * br1.i, z__2.i = z__3.r * br1.i + 
	    z__3.i * br1.r;
    z__1.r = z__2.r / *rolam, z__1.i = z__2.i / *rolam;
     ret_val->r = z__1.r,  ret_val->i = z__1.i;
    return ;
} /* zint_ */

#undef ccn
#undef cc14
#undef cc13
#undef cc12
#undef cc11
#undef cc10
#undef cc9
#undef cc8
#undef cc7
#undef cc6
#undef cc5
#undef cc4
#undef cc3
#undef cc2
#undef cc1


/* Double Complex */ VOID zzexp_(doublecomplex * ret_val, doublecomplex *z__)
{
    /* System generated locals */
    doublecomplex z__1;

    /* Builtin functions */
    void z_exp(doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ZZEXP (function) evaluates the exponential of a complex number, */
/*     returning 0 for real arguments less than -85. */

    if (z__->r > -85.f) {
	goto L1;
    }
     ret_val->r = 0.f,  ret_val->i = 0.f;
    return ;
L1:
    z_exp(&z__1, z__);
     ret_val->r = z__1.r,  ret_val->i = z__1.i;
    return ;
} /* zzexp_ */

/* Subroutine */ int cmww_(integer *j, integer *i1, integer *i2, 
	doublecomplex *cm, integer *nr, doublecomplex *cw, integer *nw, 
	integer *itrp)
{
    /* System generated locals */
    integer cm_dim1, cm_offset, cw_dim1, cw_offset, i__1, i__2, i__3, i__4, 
	    i__5, i__6, i__7;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double log(doublereal);
    void pow_zi(doublecomplex *, doublecomplex *, integer *);

    /* Local variables */
    static integer i__, ij;
    static doublereal xi, yi, zi;
    static integer jx;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex etc, etk, ets;
    static integer ipr;
    static doublereal cabi;
    extern /* Subroutine */ int efld_(doublereal *, doublereal *, doublereal *
	    );
    static doublereal sabi;
    static doublecomplex cfcon;
    static doublereal salpi;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CMWW computes matrix elements for wire-wire interactions. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

/*     SET SOURCE SEGMENT PARAMETERS */
    /* Parameter adjustments */
    cm_dim1 = *nr;
    cm_offset = 1 + cm_dim1;
    cm -= cm_offset;
    cw_dim1 = *nw;
    cw_offset = 1 + cw_dim1;
    cw -= cw_offset;

    /* Function Body */
    dataj_1.slenj = data_1.si[*j - 1];
    dataj_1.aradj = data_1.bi[*j - 1];
    dataj_1.xj = data_1.x[*j - 1];
    dataj_1.yj = data_1.y[*j - 1];
    dataj_1.zj = data_1.z__[*j - 1];
    dataj_1.dxj = cab[*j - 1];
    dataj_1.dyj = sab[*j - 1];
    dataj_1.dzj = data_1.salp[*j - 1];
    i__1 = *j - 1;
    dataj_1.xksj.r = crnt_1.xks[i__1].r, dataj_1.xksj.i = crnt_1.xks[i__1].i;
    dataj_1.ind1 = data_1.icon1[*j - 1];
    dataj_1.ind2 = data_1.icon2[*j - 1];
    i__1 = *j - 1;
    dataj_1.zpeds.r = zload_1.zarray[i__1].r, dataj_1.zpeds.i = 
	    zload_1.zarray[i__1].i;
    if (jnqcom_1.ipqend[*j - 1] == 1 || jnqcom_1.ipqend[*j - 1] == 3) {
	dataj_1.ind1 = 60000;
    }
    if (jnqcom_1.ipqend[*j - 1] > 1) {
	dataj_1.ind2 = 60000;
    }

/*     OBSERVATION LOOP */

    ipr = 0;
    i__1 = *i2;
    for (i__ = *i1; i__ <= i__1; ++i__) {
	++ipr;
	xi = data_1.x[i__ - 1];
	yi = data_1.y[i__ - 1];
	zi = data_1.z__[i__ - 1];
	cabi = cab[i__ - 1];
	sabi = sab[i__ - 1];
	salpi = data_1.salp[i__ - 1];
	efld_(&xi, &yi, &zi);
	z__4.r = cabi * dataj_1.exk.r, z__4.i = cabi * dataj_1.exk.i;
	z__5.r = sabi * dataj_1.eyk.r, z__5.i = sabi * dataj_1.eyk.i;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__6.r = salpi * dataj_1.ezk.r, z__6.i = salpi * dataj_1.ezk.i;
	z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	etk.r = z__1.r, etk.i = z__1.i;
	z__4.r = cabi * dataj_1.exs.r, z__4.i = cabi * dataj_1.exs.i;
	z__5.r = sabi * dataj_1.eys.r, z__5.i = sabi * dataj_1.eys.i;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__6.r = salpi * dataj_1.ezs.r, z__6.i = salpi * dataj_1.ezs.i;
	z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	ets.r = z__1.r, ets.i = z__1.i;
	z__4.r = cabi * dataj_1.exc.r, z__4.i = cabi * dataj_1.exc.i;
	z__5.r = sabi * dataj_1.eyc.r, z__5.i = sabi * dataj_1.eyc.i;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__6.r = salpi * dataj_1.ezc.r, z__6.i = salpi * dataj_1.ezc.i;
	z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	z_div(&z__1, &z__2, &gnd_1.xku);
	etc.r = z__1.r, etc.i = z__1.i;
	if (i__ == *j) {

/*     ADD TERMS FOR IMPEDANCE LOADING AND AN INSULATING SHEATH */

	    if (zload_1.nload != 0 || zload_1.nlodf != 0) {
		i__2 = *j - 1;
		z__1.r = etk.r - zload_1.zarray[i__2].r, z__1.i = etk.i - 
			zload_1.zarray[i__2].i;
		etk.r = z__1.r, etk.i = z__1.i;
	    }
	    if ((inscom_1.nins != 0 || inscom_1.ninsf != 0) && inscom_1.brins[
		    *j - 1] > 0.f) {
		if (data_1.z__[*j - 1] >= 0.f) {
		    z__3.r = gnd_1.etau.r * 0.f - gnd_1.etau.i * 1.f, z__3.i =
			     gnd_1.etau.r * 1.f + gnd_1.etau.i * 0.f;
		    i__2 = *j - 1;
		    z__4.r = inscom_1.ceins[i__2].r - gnd_1.cepsu.r, z__4.i = 
			    inscom_1.ceins[i__2].i - gnd_1.cepsu.i;
		    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = 
			    z__3.r * z__4.i + z__3.i * z__4.r;
		    z_div(&z__1, &z__2, &gnd_1.xku);
		    cfcon.r = z__1.r, cfcon.i = z__1.i;
		} else {
		    z__3.r = gnd_1.etal.r * 0.f - gnd_1.etal.i * 1.f, z__3.i =
			     gnd_1.etal.r * 1.f + gnd_1.etal.i * 0.f;
		    i__2 = *j - 1;
		    z__4.r = inscom_1.ceins[i__2].r - gnd_1.cepsl.r, z__4.i = 
			    inscom_1.ceins[i__2].i - gnd_1.cepsl.i;
		    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = 
			    z__3.r * z__4.i + z__3.i * z__4.r;
		    z_div(&z__1, &z__2, &gnd_1.xkl);
		    cfcon.r = z__1.r, cfcon.i = z__1.i;
		}
		d__1 = log(inscom_1.brins[*j - 1] / data_1.bi[*j - 1]);
		z__5.r = d__1 * cfcon.r, z__5.i = d__1 * cfcon.i;
		i__2 = *j - 1;
		z__6.r = constn_1.tp * inscom_1.ceins[i__2].r, z__6.i = 
			constn_1.tp * inscom_1.ceins[i__2].i;
		z_div(&z__4, &z__5, &z__6);
		pow_zi(&z__7, &dataj_1.xksj, &c__2);
		z__3.r = z__4.r * z__7.r - z__4.i * z__7.i, z__3.i = z__4.r * 
			z__7.i + z__4.i * z__7.r;
		z_div(&z__2, &z__3, &gnd_1.xku);
		z__1.r = etc.r - z__2.r, z__1.i = etc.i - z__2.i;
		etc.r = z__1.r, etc.i = z__1.i;
	    }
	}

/*     FILL MATRIX ELEMENTS.  ELEMENT LOCATIONS DETERMINED BY CONNECTION */
/*     DATA. */

	if (*itrp != 0) {
	    goto L18;
	}
/*     NORMAL FILL */
	i__2 = segj_1.jsno;
	for (ij = 1; ij <= i__2; ++ij) {
	    jx = segj_1.jco[ij - 1];
/* L17: */
	    i__3 = ipr + jx * cm_dim1;
	    i__4 = ipr + jx * cm_dim1;
	    i__5 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__5].r - etk.i * segj_1.ax[i__5].i, 
		    z__4.i = etk.r * segj_1.ax[i__5].i + etk.i * segj_1.ax[
		    i__5].r;
	    z__3.r = cm[i__4].r + z__4.r, z__3.i = cm[i__4].i + z__4.i;
	    i__6 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__6].r - ets.i * segj_1.bx[i__6].i, 
		    z__5.i = ets.r * segj_1.bx[i__6].i + ets.i * segj_1.bx[
		    i__6].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__7 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__7].r - etc.i * segj_1.cx[i__7].i, 
		    z__6.i = etc.r * segj_1.cx[i__7].i + etc.i * segj_1.cx[
		    i__7].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__3].r = z__1.r, cm[i__3].i = z__1.i;
	}
	goto L23;
L18:
	if (*itrp == 2) {
	    goto L20;
	}
/*     TRANSPOSED FILL */
	i__3 = segj_1.jsno;
	for (ij = 1; ij <= i__3; ++ij) {
	    jx = segj_1.jco[ij - 1];
/* L19: */
	    i__4 = jx + ipr * cm_dim1;
	    i__5 = jx + ipr * cm_dim1;
	    i__6 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__6].r - etk.i * segj_1.ax[i__6].i, 
		    z__4.i = etk.r * segj_1.ax[i__6].i + etk.i * segj_1.ax[
		    i__6].r;
	    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + z__4.i;
	    i__7 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__7].r - ets.i * segj_1.bx[i__7].i, 
		    z__5.i = ets.r * segj_1.bx[i__7].i + ets.i * segj_1.bx[
		    i__7].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__2 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__2].r - etc.i * segj_1.cx[i__2].i, 
		    z__6.i = etc.r * segj_1.cx[i__2].i + etc.i * segj_1.cx[
		    i__2].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
	}
	goto L23;
/*     TRANS. FILL FOR C(WW) - TEST FOR ELEMENTS FOR D(WW)PRIME.  (=CW) */
L20:
	i__4 = segj_1.jsno;
	for (ij = 1; ij <= i__4; ++ij) {
	    jx = segj_1.jco[ij - 1];
	    if (jx > *nr) {
		goto L21;
	    }
	    i__5 = jx + ipr * cm_dim1;
	    i__6 = jx + ipr * cm_dim1;
	    i__7 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__7].r - etk.i * segj_1.ax[i__7].i, 
		    z__4.i = etk.r * segj_1.ax[i__7].i + etk.i * segj_1.ax[
		    i__7].r;
	    z__3.r = cm[i__6].r + z__4.r, z__3.i = cm[i__6].i + z__4.i;
	    i__2 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__2].r - ets.i * segj_1.bx[i__2].i, 
		    z__5.i = ets.r * segj_1.bx[i__2].i + ets.i * segj_1.bx[
		    i__2].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__3 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__3].r - etc.i * segj_1.cx[i__3].i, 
		    z__6.i = etc.r * segj_1.cx[i__3].i + etc.i * segj_1.cx[
		    i__3].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cm[i__5].r = z__1.r, cm[i__5].i = z__1.i;
	    goto L22;
L21:
	    jx -= *nr;
	    i__5 = jx + ipr * cw_dim1;
	    i__6 = jx + ipr * cw_dim1;
	    i__7 = ij - 1;
	    z__4.r = etk.r * segj_1.ax[i__7].r - etk.i * segj_1.ax[i__7].i, 
		    z__4.i = etk.r * segj_1.ax[i__7].i + etk.i * segj_1.ax[
		    i__7].r;
	    z__3.r = cw[i__6].r + z__4.r, z__3.i = cw[i__6].i + z__4.i;
	    i__2 = ij - 1;
	    z__5.r = ets.r * segj_1.bx[i__2].r - ets.i * segj_1.bx[i__2].i, 
		    z__5.i = ets.r * segj_1.bx[i__2].i + ets.i * segj_1.bx[
		    i__2].r;
	    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	    i__3 = ij - 1;
	    z__6.r = etc.r * segj_1.cx[i__3].r - etc.i * segj_1.cx[i__3].i, 
		    z__6.i = etc.r * segj_1.cx[i__3].i + etc.i * segj_1.cx[
		    i__3].r;
	    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	    cw[i__5].r = z__1.r, cw[i__5].i = z__1.i;
L22:
	    ;
	}
L23:
	;
    }
    return 0;
} /* cmww_ */

#undef sab
#undef cab


/* Subroutine */ int nefld_(doublereal *xob, doublereal *yob, doublereal *zob,
	 doublecomplex *ex, doublecomplex *ey, doublecomplex *ez)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Local variables */
    static integer i__, jc, jl, ip;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex acx, bcx, ccx;
    extern /* Subroutine */ int efld_(doublereal *, doublereal *, doublereal *
	    ), unere_(doublereal *, doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     NEFLD computes the near field at specified points in space after */
/*     the structure currents have been computed. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ex->r = 0.f, ex->i = 0.f;
    ey->r = 0.f, ey->i = 0.f;
    ez->r = 0.f, ez->i = 0.f;
    if (data_1.n == 0) {
	goto L20;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	dataj_1.slenj = data_1.si[i__ - 1];
	dataj_1.aradj = data_1.bi[i__ - 1];
	dataj_1.xj = data_1.x[i__ - 1];
	dataj_1.yj = data_1.y[i__ - 1];
	dataj_1.zj = data_1.z__[i__ - 1];
	dataj_1.dxj = cab[i__ - 1];
	dataj_1.dyj = sab[i__ - 1];
	dataj_1.dzj = data_1.salp[i__ - 1];
	i__2 = i__ - 1;
	dataj_1.xksj.r = crnt_1.xks[i__2].r, dataj_1.xksj.i = crnt_1.xks[i__2]
		.i;
	i__2 = i__ - 1;
	dataj_1.zpeds.r = zload_1.zarray[i__2].r, dataj_1.zpeds.i = 
		zload_1.zarray[i__2].i;
	dataj_1.ind1 = data_1.icon1[i__ - 1];
	dataj_1.ind2 = data_1.icon2[i__ - 1];
	if (jnqcom_1.ipqend[i__ - 1] == 1 || jnqcom_1.ipqend[i__ - 1] == 3) {
	    dataj_1.ind1 = 60000;
	}
	if (jnqcom_1.ipqend[i__ - 1] > 1) {
	    dataj_1.ind2 = 60000;
	}
	efld_(xob, yob, zob);
	i__2 = i__ - 1;
	acx.r = crnt_1.aix[i__2].r, acx.i = crnt_1.aix[i__2].i;
	i__2 = i__ - 1;
	bcx.r = crnt_1.bix[i__2].r, bcx.i = crnt_1.bix[i__2].i;
	i__2 = i__ - 1;
	ccx.r = crnt_1.cix[i__2].r, ccx.i = crnt_1.cix[i__2].i;
	z__4.r = dataj_1.exk.r * acx.r - dataj_1.exk.i * acx.i, z__4.i = 
		dataj_1.exk.r * acx.i + dataj_1.exk.i * acx.r;
	z__3.r = ex->r + z__4.r, z__3.i = ex->i + z__4.i;
	z__5.r = dataj_1.exs.r * bcx.r - dataj_1.exs.i * bcx.i, z__5.i = 
		dataj_1.exs.r * bcx.i + dataj_1.exs.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.exc.r * ccx.r - dataj_1.exc.i * ccx.i, z__6.i = 
		dataj_1.exc.r * ccx.i + dataj_1.exc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	ex->r = z__1.r, ex->i = z__1.i;
	z__4.r = dataj_1.eyk.r * acx.r - dataj_1.eyk.i * acx.i, z__4.i = 
		dataj_1.eyk.r * acx.i + dataj_1.eyk.i * acx.r;
	z__3.r = ey->r + z__4.r, z__3.i = ey->i + z__4.i;
	z__5.r = dataj_1.eys.r * bcx.r - dataj_1.eys.i * bcx.i, z__5.i = 
		dataj_1.eys.r * bcx.i + dataj_1.eys.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.eyc.r * ccx.r - dataj_1.eyc.i * ccx.i, z__6.i = 
		dataj_1.eyc.r * ccx.i + dataj_1.eyc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	ey->r = z__1.r, ey->i = z__1.i;
/* L19: */
	z__4.r = dataj_1.ezk.r * acx.r - dataj_1.ezk.i * acx.i, z__4.i = 
		dataj_1.ezk.r * acx.i + dataj_1.ezk.i * acx.r;
	z__3.r = ez->r + z__4.r, z__3.i = ez->i + z__4.i;
	z__5.r = dataj_1.ezs.r * bcx.r - dataj_1.ezs.i * bcx.i, z__5.i = 
		dataj_1.ezs.r * bcx.i + dataj_1.ezs.i * bcx.r;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__6.r = dataj_1.ezc.r * ccx.r - dataj_1.ezc.i * ccx.i, z__6.i = 
		dataj_1.ezc.r * ccx.i + dataj_1.ezc.i * ccx.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	ez->r = z__1.r, ez->i = z__1.i;
    }
    if (data_1.m == 0) {
	return 0;
    }
L20:
    jc = data_1.n;
    jl = data_1.ld + 1;
    i__1 = data_1.m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	--jl;
	datap_1.spatj = data_1.bi[jl - 1];
	datap_1.xpatj = data_1.x[jl - 1];
	datap_1.ypatj = data_1.y[jl - 1];
	datap_1.zpatj = data_1.z__[jl - 1];
	datap_1.t1xj = t1x[jl - 1];
	datap_1.t1yj = t1y[jl - 1];
	datap_1.t1zj = t1z[jl - 1];
	datap_1.t2xj = data_1.t2x[jl - 1];
	datap_1.t2yj = data_1.t2y[jl - 1];
	datap_1.t2zj = data_1.t2z[jl - 1];
	jc += 3;
	i__2 = jc - 3;
	z__3.r = datap_1.t1xj * crnt_1.cur[i__2].r, z__3.i = datap_1.t1xj * 
		crnt_1.cur[i__2].i;
	i__3 = jc - 2;
	z__4.r = datap_1.t1yj * crnt_1.cur[i__3].r, z__4.i = datap_1.t1yj * 
		crnt_1.cur[i__3].i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = jc - 1;
	z__5.r = datap_1.t1zj * crnt_1.cur[i__4].r, z__5.i = datap_1.t1zj * 
		crnt_1.cur[i__4].i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	acx.r = z__1.r, acx.i = z__1.i;
	i__2 = jc - 3;
	z__3.r = datap_1.t2xj * crnt_1.cur[i__2].r, z__3.i = datap_1.t2xj * 
		crnt_1.cur[i__2].i;
	i__3 = jc - 2;
	z__4.r = datap_1.t2yj * crnt_1.cur[i__3].r, z__4.i = datap_1.t2yj * 
		crnt_1.cur[i__3].i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	i__4 = jc - 1;
	z__5.r = datap_1.t2zj * crnt_1.cur[i__4].r, z__5.i = datap_1.t2zj * 
		crnt_1.cur[i__4].i;
	z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
	bcx.r = z__1.r, bcx.i = z__1.i;
	i__2 = gnd_1.ksymp;
	for (ip = 1; ip <= i__2; ++ip) {
	    datap_1.ipgnd = ip;
	    unere_(xob, yob, zob);
	    z__3.r = acx.r * datap_1.h1x.r - acx.i * datap_1.h1x.i, z__3.i = 
		    acx.r * datap_1.h1x.i + acx.i * datap_1.h1x.r;
	    z__2.r = ex->r + z__3.r, z__2.i = ex->i + z__3.i;
	    z__4.r = bcx.r * datap_1.h2x.r - bcx.i * datap_1.h2x.i, z__4.i = 
		    bcx.r * datap_1.h2x.i + bcx.i * datap_1.h2x.r;
	    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	    ex->r = z__1.r, ex->i = z__1.i;
	    z__3.r = acx.r * datap_1.h1y.r - acx.i * datap_1.h1y.i, z__3.i = 
		    acx.r * datap_1.h1y.i + acx.i * datap_1.h1y.r;
	    z__2.r = ey->r + z__3.r, z__2.i = ey->i + z__3.i;
	    z__4.r = bcx.r * datap_1.h2y.r - bcx.i * datap_1.h2y.i, z__4.i = 
		    bcx.r * datap_1.h2y.i + bcx.i * datap_1.h2y.r;
	    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	    ey->r = z__1.r, ey->i = z__1.i;
/* L21: */
	    z__3.r = acx.r * datap_1.h1z.r - acx.i * datap_1.h1z.i, z__3.i = 
		    acx.r * datap_1.h1z.i + acx.i * datap_1.h1z.r;
	    z__2.r = ez->r + z__3.r, z__2.i = ez->i + z__3.i;
	    z__4.r = bcx.r * datap_1.h2z.r - bcx.i * datap_1.h2z.i, z__4.i = 
		    bcx.r * datap_1.h2z.i + bcx.i * datap_1.h2z.r;
	    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
	    ez->r = z__1.r, ez->i = z__1.i;
	}
    }
    return 0;
} /* nefld_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int efld_(doublereal *xi, doublereal *yi, doublereal *zi)
{
    /* Format strings */
    static char fmt_34[] = "(\002 EFLD: ERROR - MUST USE SOMMERFELD FOR INTE"
	    "RACTION\002,\002 ACROSS THE INTERFACE\002,/,1p6e12.5)";

    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double sqrt(doublereal);
    void d_cnjg(doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static doublecomplex xk;
    static doublereal xij;
    static doublecomplex etx, txc, tyc, tzc, txk, tyk, tzk;
    static doublereal yij, zij;
    static doublecomplex txs, tys, tzs;
    static doublereal rho, zup, zdn, dmin__, dzjr, zijs, rhod1, rhod2;
    static integer indx1, indx2;
    static doublereal xdst1, ydst1, zdst1, xdst2, ydst2, zdst2;
    static integer imagf;
    static doublereal slenh;
    static doublecomplex fratx, zrati;
    extern /* Subroutine */ int efldsg_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, integer *, integer *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *), somfld_(doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublereal *, 
	    integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *), rctran_(doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *);

    /* Fortran I/O blocks */
    static cilist io___2123 = { 0, 3, 0, fmt_34, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EFLD evaluates the near E field components of a wire segment with */
/*     constant, sin(ks) and cos(ks)-1 current distributions.  The effect */
/*     of a ground plane is included, with Sommerfeld or reflection */
/*     coefficient options for finitely conducting ground. For perfectly */
/*     conducting ground ZI and ZJ must be positive.  Field transmitted */
/*     across the interface may be computed in the Sommerfeld mode only. */

/*     INPUT: */
/*     XI,YI,ZI = COORDINATES OF THE EVALUATION POINT */
/*     OTHER INPUT FROM COMMON/DATAJ/ AND COMMON/GND/ */

/*     OUTPUT THROUGH COMMON/DATAJ/: */
/*     EXK,EYK,EZK = X,Y,Z COMPONENTS OF E DUE TO CONSTANT CURRENT */
/*     EXS,EYS,EZS = X,Y,Z COMPONENTS OF E DUE TO SIN(KS) CURRENT */
/*     EXC,EYC,EZC = X,Y,Z COMPONENTS OF E DUE TO COS(KS)-1 CURRENT */

    xij = *xi - dataj_1.xj;
    yij = *yi - dataj_1.yj;
    zij = *zi - dataj_1.zj;

/*     TEST IF FIELD IS TRANSMITTED ACROSS AN INTERFACE WITH GROUND */
/*     IF SO, GO TO SOMMERFELD SECTION. */

    if (gnd_1.ksymp > 1 && *zi * dataj_1.zj < 0.f) {
	goto L19;
    }

/*     SOURCE AND EVALUATION POINT ON SAME SIDE OF THE INTERFACE SO */
/*     EVALUATE DIRECT AND REFLECTED FIELD IF GROUND IS PRESENT. */

    if (dataj_1.zj > 0.f) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	etx.r = gnd_1.etau.r, etx.i = gnd_1.etau.i;
	fratx.r = gnd_1.frati.r, fratx.i = gnd_1.frati.i;
	z_div(&z__1, &gnd_1.xku, &gnd_1.xkl);
	zrati.r = z__1.r, zrati.i = z__1.i;
    } else {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	etx.r = gnd_1.etal.r, etx.i = gnd_1.etal.i;
	z__1.r = -gnd_1.frati.r, z__1.i = -gnd_1.frati.i;
	fratx.r = z__1.r, fratx.i = z__1.i;
	z_div(&z__1, &gnd_1.xkl, &gnd_1.xku);
	zrati.r = z__1.r, zrati.i = z__1.i;
    }

/*     EVALUATE DIRECT FIELD FROM SOURCE TO EVALUATION POINT */

    efldsg_(&xij, &yij, &zij, &dataj_1.dxj, &dataj_1.dyj, &dataj_1.dzj, &
	    dataj_1.slenj, &dataj_1.aradj, &dataj_1.zpeds, &xk, &etx, &
	    dataj_1.xksj, &dataj_1.ind1, &dataj_1.ind2, &dataj_1.exk, &
	    dataj_1.eyk, &dataj_1.ezk, &dataj_1.exs, &dataj_1.eys, &
	    dataj_1.ezs, &dataj_1.exc, &dataj_1.eyc, &dataj_1.ezc);
    if (gnd_1.ksymp == 1) {
	return 0;
    }

/*     FOR GROUND, EVALUATE FIELD OF THE IMAGE OF THE SOURCE SEGMENT */

    dzjr = -dataj_1.dzj;
    zij = *zi + dataj_1.zj;
    imagf = 0;

/*     FOR SOMMERFELD GROUND EVALUATION, TEST IF DISTANCE IS GREAT ENOUGH */
/*     TO USE POINT SOURCE APPROXIMATION.  IF SO THE TOTAL REFLECTED */
/*     FIELD IS EVALUATED BY SOMMERFELD-INTERPOLATION CODE. */

    if (gnd_1.iperf == 2) {
	imagf = 1;
	rho = sqrt(xij * xij + yij * yij) * gnd_1.gscal;
	zijs = zij * gnd_1.gscal;
	if (zijs > gregon_1.zzmx1 || -zijs > gregon_1.zpmx1 || rho > 
		gregon_1.rhmx1) {
	    imagf = 2;
	    goto L17;
	}
/*     Include point charges on segment ends within 0.1 of the boundary */
/*     for switching to one-point integration. */
	slenh = dataj_1.slenj * .5f;
	xdst1 = *xi - (dataj_1.xj - dataj_1.dxj * slenh);
	ydst1 = *yi - (dataj_1.yj - dataj_1.dyj * slenh);
	zdst1 = *zi + (dataj_1.zj - dataj_1.dzj * slenh) * gnd_1.gscal;
/* Computing 2nd power */
	d__1 = xdst1;
/* Computing 2nd power */
	d__2 = ydst1;
	rhod1 = sqrt(d__1 * d__1 + d__2 * d__2) * gnd_1.gscal;
	xdst2 = *xi - (dataj_1.xj + dataj_1.dxj * slenh);
	ydst2 = *yi - (dataj_1.yj + dataj_1.dyj * slenh);
	zdst2 = *zi + (dataj_1.zj + dataj_1.dzj * slenh) * gnd_1.gscal;
/* Computing 2nd power */
	d__1 = xdst2;
/* Computing 2nd power */
	d__2 = ydst2;
	rhod2 = sqrt(d__1 * d__1 + d__2 * d__2) * gnd_1.gscal;
	if (zdst1 > gregon_1.zzmx1 - .1f || -zdst1 > gregon_1.zpmx1 - .1f || 
		rhod1 > gregon_1.rhmx1 - .1f) {
	    indx1 = 60000;
	} else {
	    indx1 = dataj_1.ind1;
	}
	if (zdst2 > gregon_1.zzmx1 - .1f || -zdst2 > gregon_1.zpmx1 - .1f || 
		rhod2 > gregon_1.rhmx1 - .1f) {
	    indx2 = 60000;
	} else {
	    indx2 = dataj_1.ind2;
	}
    } else {
	indx1 = dataj_1.ind1;
	indx2 = dataj_1.ind2;
    }

/*     EVALUATE IMAGE FIELD */

    efldsg_(&xij, &yij, &zij, &dataj_1.dxj, &dataj_1.dyj, &dzjr, &
	    dataj_1.slenj, &dataj_1.aradj, &dataj_1.zpeds, &xk, &etx, &
	    dataj_1.xksj, &indx1, &indx2, &txk, &tyk, &tzk, &txs, &tys, &tzs, 
	    &txc, &tyc, &tzc);
    if (imagf == 0) {
/*     RCTRAN TRANSFORMS THE IMAGE FIELD FOR REFLECTION COEF. APPROX. */

	if (gnd_1.iperf == 0) {
	    rctran_(xi, yi, zi, &dataj_1.xj, &dataj_1.yj, &dataj_1.zj, &zrati,
		     &etx, &txk, &tyk, &tzk, &txs, &tys, &tzs, &txc, &tyc, &
		    tzc);
	}

/*     ADD IMAGE FIELD FOR PERFECT GROUND OR REFLECTION COEF. APPROX. */

	z__1.r = dataj_1.exk.r - txk.r, z__1.i = dataj_1.exk.i - txk.i;
	dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
	z__1.r = dataj_1.eyk.r - tyk.r, z__1.i = dataj_1.eyk.i - tyk.i;
	dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
	z__1.r = dataj_1.ezk.r - tzk.r, z__1.i = dataj_1.ezk.i - tzk.i;
	dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
	z__1.r = dataj_1.exs.r - txs.r, z__1.i = dataj_1.exs.i - txs.i;
	dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
	z__1.r = dataj_1.eys.r - tys.r, z__1.i = dataj_1.eys.i - tys.i;
	dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
	z__1.r = dataj_1.ezs.r - tzs.r, z__1.i = dataj_1.ezs.i - tzs.i;
	dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
	z__1.r = dataj_1.exc.r - txc.r, z__1.i = dataj_1.exc.i - txc.i;
	dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
	z__1.r = dataj_1.eyc.r - tyc.r, z__1.i = dataj_1.eyc.i - tyc.i;
	dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
	z__1.r = dataj_1.ezc.r - tzc.r, z__1.i = dataj_1.ezc.i - tzc.i;
	dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
	return 0;
    } else {

/*     FOR SOMMERFELD MODE, ADD IMAGE FIELD WITH STATIC REFLECTION FACTOR */

	z__2.r = txk.r * fratx.r - txk.i * fratx.i, z__2.i = txk.r * fratx.i 
		+ txk.i * fratx.r;
	z__1.r = dataj_1.exk.r - z__2.r, z__1.i = dataj_1.exk.i - z__2.i;
	dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
	z__2.r = tyk.r * fratx.r - tyk.i * fratx.i, z__2.i = tyk.r * fratx.i 
		+ tyk.i * fratx.r;
	z__1.r = dataj_1.eyk.r - z__2.r, z__1.i = dataj_1.eyk.i - z__2.i;
	dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
	z__2.r = tzk.r * fratx.r - tzk.i * fratx.i, z__2.i = tzk.r * fratx.i 
		+ tzk.i * fratx.r;
	z__1.r = dataj_1.ezk.r - z__2.r, z__1.i = dataj_1.ezk.i - z__2.i;
	dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
	z__2.r = txs.r * fratx.r - txs.i * fratx.i, z__2.i = txs.r * fratx.i 
		+ txs.i * fratx.r;
	z__1.r = dataj_1.exs.r - z__2.r, z__1.i = dataj_1.exs.i - z__2.i;
	dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
	z__2.r = tys.r * fratx.r - tys.i * fratx.i, z__2.i = tys.r * fratx.i 
		+ tys.i * fratx.r;
	z__1.r = dataj_1.eys.r - z__2.r, z__1.i = dataj_1.eys.i - z__2.i;
	dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
	z__2.r = tzs.r * fratx.r - tzs.i * fratx.i, z__2.i = tzs.r * fratx.i 
		+ tzs.i * fratx.r;
	z__1.r = dataj_1.ezs.r - z__2.r, z__1.i = dataj_1.ezs.i - z__2.i;
	dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
	z__2.r = txc.r * fratx.r - txc.i * fratx.i, z__2.i = txc.r * fratx.i 
		+ txc.i * fratx.r;
	z__1.r = dataj_1.exc.r - z__2.r, z__1.i = dataj_1.exc.i - z__2.i;
	dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
	z__2.r = tyc.r * fratx.r - tyc.i * fratx.i, z__2.i = tyc.r * fratx.i 
		+ tyc.i * fratx.r;
	z__1.r = dataj_1.eyc.r - z__2.r, z__1.i = dataj_1.eyc.i - z__2.i;
	dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
	z__2.r = tzc.r * fratx.r - tzc.i * fratx.i, z__2.i = tzc.r * fratx.i 
		+ tzc.i * fratx.r;
	z__1.r = dataj_1.ezc.r - z__2.r, z__1.i = dataj_1.ezc.i - z__2.i;
	dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
    }

/*     SOMMERFELD FIELD EVALUATION FOR REFLECTED FIELD */

L17:
    d_cnjg(&z__4, &dataj_1.exk);
    z__3.r = dataj_1.exk.r * z__4.r - dataj_1.exk.i * z__4.i, z__3.i = 
	    dataj_1.exk.r * z__4.i + dataj_1.exk.i * z__4.r;
    d_cnjg(&z__6, &dataj_1.eyk);
    z__5.r = dataj_1.eyk.r * z__6.r - dataj_1.eyk.i * z__6.i, z__5.i = 
	    dataj_1.eyk.r * z__6.i + dataj_1.eyk.i * z__6.r;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    d_cnjg(&z__8, &dataj_1.ezk);
    z__7.r = dataj_1.ezk.r * z__8.r - dataj_1.ezk.i * z__8.i, z__7.i = 
	    dataj_1.ezk.r * z__8.i + dataj_1.ezk.i * z__8.r;
    z__1.r = z__2.r + z__7.r, z__1.i = z__2.i + z__7.i;
    dmin__ = z__1.r;
    dmin__ = sqrt(dmin__) * .01f;
    somfld_(xi, yi, zi, &dataj_1.xj, &dataj_1.yj, &dataj_1.zj, &dataj_1.dxj, &
	    dataj_1.dyj, &dataj_1.dzj, &dataj_1.slenj, &dataj_1.aradj, &
	    dataj_1.xksj, &dmin__, &imagf, &txk, &tyk, &tzk, &txs, &tys, &tzs,
	     &txc, &tyc, &tzc);
    z__1.r = dataj_1.exk.r + txk.r, z__1.i = dataj_1.exk.i + txk.i;
    dataj_1.exk.r = z__1.r, dataj_1.exk.i = z__1.i;
    z__1.r = dataj_1.eyk.r + tyk.r, z__1.i = dataj_1.eyk.i + tyk.i;
    dataj_1.eyk.r = z__1.r, dataj_1.eyk.i = z__1.i;
    z__1.r = dataj_1.ezk.r + tzk.r, z__1.i = dataj_1.ezk.i + tzk.i;
    dataj_1.ezk.r = z__1.r, dataj_1.ezk.i = z__1.i;
    z__1.r = dataj_1.exs.r + txs.r, z__1.i = dataj_1.exs.i + txs.i;
    dataj_1.exs.r = z__1.r, dataj_1.exs.i = z__1.i;
    z__1.r = dataj_1.eys.r + tys.r, z__1.i = dataj_1.eys.i + tys.i;
    dataj_1.eys.r = z__1.r, dataj_1.eys.i = z__1.i;
    z__1.r = dataj_1.ezs.r + tzs.r, z__1.i = dataj_1.ezs.i + tzs.i;
    dataj_1.ezs.r = z__1.r, dataj_1.ezs.i = z__1.i;
    z__1.r = dataj_1.exc.r + txc.r, z__1.i = dataj_1.exc.i + txc.i;
    dataj_1.exc.r = z__1.r, dataj_1.exc.i = z__1.i;
    z__1.r = dataj_1.eyc.r + tyc.r, z__1.i = dataj_1.eyc.i + tyc.i;
    dataj_1.eyc.r = z__1.r, dataj_1.eyc.i = z__1.i;
    z__1.r = dataj_1.ezc.r + tzc.r, z__1.i = dataj_1.ezc.i + tzc.i;
    dataj_1.ezc.r = z__1.r, dataj_1.ezc.i = z__1.i;
    return 0;

/*     SOMMERFELD EVALUATION FOR FIELD TRANSMITTED ACROSS THE INTERFACE */

L19:
    if (gnd_1.iperf != 2) {
	s_wsfe(&io___2123);
	do_fio(&c__1, (char *)&dataj_1.xj, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&dataj_1.yj, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&dataj_1.zj, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*xi), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*yi), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*zi), (ftnlen)sizeof(doublereal));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (dataj_1.zj > 0.f) {
	zup = dataj_1.zj * gnd_1.gscal;
	zdn = *zi * gnd_1.gscal;
    } else {
	zup = *zi * gnd_1.gscal;
	zdn = dataj_1.zj * gnd_1.gscal;
    }

/*     TEST IF DISTANCE IS GREAT ENOUGH TO USE POINT SOURCE APPROXIMATION */

    imagf = -1;
    rho = sqrt(xij * xij + yij * yij) * gnd_1.gscal;
    if (zup > gregon_1.zzmx1 || -zdn > gregon_1.zpmx1 || rho > gregon_1.rhmx1)
	     {
	imagf = -2;
    }
    somfld_(xi, yi, zi, &dataj_1.xj, &dataj_1.yj, &dataj_1.zj, &dataj_1.dxj, &
	    dataj_1.dyj, &dataj_1.dzj, &dataj_1.slenj, &dataj_1.aradj, &
	    dataj_1.xksj, &c_b332, &imagf, &dataj_1.exk, &dataj_1.eyk, &
	    dataj_1.ezk, &dataj_1.exs, &dataj_1.eys, &dataj_1.ezs, &
	    dataj_1.exc, &dataj_1.eyc, &dataj_1.ezc);
    return 0;

} /* efld_ */

/* Subroutine */ int efldsg_(doublereal *xij, doublereal *yij, doublereal *
	zij, doublereal *dxj, doublereal *dyj, doublereal *dzj, doublereal *
	slenj, doublereal *aradj, doublecomplex *zpeds, doublecomplex *xk, 
	doublecomplex *etx, doublecomplex *xks, integer *ind1, integer *ind2, 
	doublecomplex *exk, doublecomplex *eyk, doublecomplex *ezk, 
	doublecomplex *exs, doublecomplex *eys, doublecomplex *ezs, 
	doublecomplex *exc, doublecomplex *eyc, doublecomplex *ezc)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal rh, zp;
    static doublecomplex terc, tezc, terk, tezk, ters;
    static doublereal rhox, rhoy, rhoz;
    static doublecomplex tezs;
    extern /* Subroutine */ int ekscsz_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, integer *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EFLDSG evaluates the E field due to an arbitrarily oriented */
/*     segment in an infinite medium.  This routine transforms */
/*     coordinates and then calls subroutine EKSCSZ to evaluate the */
/*     field of the segment on the Z axis of a cylindrical coordinate */
/*     system centered at the origin. */

/*     INPUT: */
/*     XIJ,YIJ,ZIJ = COMPONENTS OF VECTOR FROM SOURCE TO EVALUATON POINT */
/*     DXJ,DYJ,DZJ = UNIT VECTOR IN DIRECTION OF THE SOURCE SEGMENT */
/*     SLENJ = LENGTH OF THE SOURCE SEGMENT */
/*     ARADJ = RADIUS OF THE SOURCE SEGMENT */
/*     ZPEDS = IMPEDANCE LOAD ON SEGMENT */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE SOURCE */
/*     ETX = INTRINSIC IMPEDANCE IN THE MEDIUM CONTAINING THE SOURCE */
/*     XKS = WAVENUMBER FOR THE CURRENT EXPANSION ON THE SEGMENT */
/*     IND1 = CONNECTION NUMBER (ICON1) FOR END ONE OF THE SOURCE SEG. */
/*          = 60000 FOR A JUNCTION THROUGH THE AIR-GROUND INTERFACE */
/*     IND2 = CONNECTION NUMBER (ICON2) FOR END TWO OF THE SOURCE SEG. */
/*          = 60000 FOR A JUNCTION THROUGH THE AIR-GROUND INTERFACE */

/*     OUTPUT: */
/*     EXK,EYK,EZK = X,Y,Z COMPONENTS OF E DUE TO CONSTANT CURRENT */
/*     EXS,EYS,EZS = X,Y,Z COMPONENTS OF E DUE TO SIN(KS) CURRENT */
/*     EXC,EYC,EZC = X,Y,Z COMPONENTS OF E DUE TO COS(KS)-1 CURRENT */

    zp = *xij * *dxj + *yij * *dyj + *zij * *dzj;
    rhox = *xij - *dxj * zp;
    rhoy = *yij - *dyj * zp;
    rhoz = *zij - *dzj * zp;
    rh = sqrt(rhox * rhox + rhoy * rhoy + rhoz * rhoz);
    if (rh > 1e-12f) {
	rhox /= rh;
	rhoy /= rh;
	rhoz /= rh;
    } else {
	rhox = 0.f;
	rhoy = 0.f;
	rhoz = 0.f;
    }

/*     EKSCSZ EVALUATES THIN WIRE APPROX. OF FIELD OF SEGMENT ON Z AXIS */

    ekscsz_(&rh, &zp, slenj, aradj, zpeds, xk, etx, xks, &tezk, &tezs, &tezc, 
	    &terk, &ters, &terc, ind1, ind2);
    z__2.r = *dxj * tezk.r, z__2.i = *dxj * tezk.i;
    z__3.r = rhox * terk.r, z__3.i = rhox * terk.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    exk->r = z__1.r, exk->i = z__1.i;
    z__2.r = *dyj * tezk.r, z__2.i = *dyj * tezk.i;
    z__3.r = rhoy * terk.r, z__3.i = rhoy * terk.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    eyk->r = z__1.r, eyk->i = z__1.i;
    z__2.r = *dzj * tezk.r, z__2.i = *dzj * tezk.i;
    z__3.r = rhoz * terk.r, z__3.i = rhoz * terk.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ezk->r = z__1.r, ezk->i = z__1.i;
    z__2.r = *dxj * tezs.r, z__2.i = *dxj * tezs.i;
    z__3.r = rhox * ters.r, z__3.i = rhox * ters.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    exs->r = z__1.r, exs->i = z__1.i;
    z__2.r = *dyj * tezs.r, z__2.i = *dyj * tezs.i;
    z__3.r = rhoy * ters.r, z__3.i = rhoy * ters.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    eys->r = z__1.r, eys->i = z__1.i;
    z__2.r = *dzj * tezs.r, z__2.i = *dzj * tezs.i;
    z__3.r = rhoz * ters.r, z__3.i = rhoz * ters.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__2.r = *dxj * tezc.r, z__2.i = *dxj * tezc.i;
    z__3.r = rhox * terc.r, z__3.i = rhox * terc.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    exc->r = z__1.r, exc->i = z__1.i;
    z__2.r = *dyj * tezc.r, z__2.i = *dyj * tezc.i;
    z__3.r = rhoy * terc.r, z__3.i = rhoy * terc.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    eyc->r = z__1.r, eyc->i = z__1.i;
    z__2.r = *dzj * tezc.r, z__2.i = *dzj * tezc.i;
    z__3.r = rhoz * terc.r, z__3.i = rhoz * terc.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ezc->r = z__1.r, ezc->i = z__1.i;
    return 0;
} /* efldsg_ */

/* Subroutine */ int rctran_(doublereal *xi, doublereal *yi, doublereal *zi, 
	doublereal *xj, doublereal *yj, doublereal *zj, doublecomplex *zrati, 
	doublecomplex *etx, doublecomplex *txk, doublecomplex *tyk, 
	doublecomplex *tzk, doublecomplex *txs, doublecomplex *tys, 
	doublecomplex *tzs, doublecomplex *txc, doublecomplex *tyc, 
	doublecomplex *tzc)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    double sqrt(doublereal), log(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_sqrt(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal px, py, cth, xij, yij;
    static doublecomplex epx, epy;
    static doublereal zij;
    static doublecomplex refs, refps;
    static doublereal xspec, yspec, xymag;
    static doublecomplex zscrn, zrsin, zratx;
    static doublereal rhospc;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     RCTRAN applies the plane-wave reflection formulas to the field of */
/*     the image of a source above or below the interface with ground. */

/*     INPUT: */
/*     XI,YI,ZI = COORDINATES OF THE EVALUATION POINT */
/*     XJ,YJ,ZJ = COORDINATES OF THE SOURCE POINT */
/*     ZRATI = RATIO OF INTRINSIC IMPEDANCE OF LOWER MEDIUM TO THAT OF */
/*             UPPER MEDIUM */
/*     ETX = INTRINSIC IMPEDANCE IN THE MEDIUM CONTAINING THE SOURCE */

/*     INPUT AND TRANSFORMED AS OUTPUT: */
/*     TXK,TYK,TZK = X,Y,Z COMPONENTS OF E DUE TO A CONSTANT CURRENT */
/*     TXS,TYS,TZS = X,Y,Z COMPONENTS OF E DUE TO A SIN(KS) CURRENT */
/*     TXC,TYC,TZC = X,Y,Z COMPONENTS OF E DUE TO A COS(KS)-1 CURRENT */

    zratx.r = zrati->r, zratx.i = zrati->i;
    xij = *xi - *xj;
    yij = *yi - *yj;
    zij = *zi + *zj;

/*     SET PARAMETERS IF RADIAL WIRE GROUND SCREEN IS USED. */

    if (gnd_1.nradl != 0) {
	xspec = (*xi * *zj + *zi * *xj) / (*zi + *zj);
	yspec = (*yi * *zj + *zi * *yj) / (*zi + *zj);
/* Computing 2nd power */
	d__1 = gnd_1.nradl * gnd_1.scnwrd;
	rhospc = sqrt(xspec * xspec + yspec * yspec + d__1 * d__1);
	if (rhospc <= gnd_1.scnrad) {
	    z__5.r = constn_1.rmuz * 0.f, z__5.i = constn_1.rmuz * 1.f;
	    z__4.r = gnd_1.omegag * z__5.r, z__4.i = gnd_1.omegag * z__5.i;
	    z__3.r = rhospc * z__4.r, z__3.i = rhospc * z__4.i;
	    d__1 = (doublereal) gnd_1.nradl;
	    z__2.r = z__3.r / d__1, z__2.i = z__3.i / d__1;
	    d__2 = log(rhospc / (gnd_1.nradl * gnd_1.scnwrd));
	    z__1.r = d__2 * z__2.r, z__1.i = d__2 * z__2.i;
	    zscrn.r = z__1.r, zscrn.i = z__1.i;
	    z__2.r = zscrn.r * zrati->r - zscrn.i * zrati->i, z__2.i = 
		    zscrn.r * zrati->i + zscrn.i * zrati->r;
	    z__4.r = etx->r * zrati->r - etx->i * zrati->i, z__4.i = etx->r * 
		    zrati->i + etx->i * zrati->r;
	    z__3.r = z__4.r + zscrn.r, z__3.i = z__4.i + zscrn.i;
	    z_div(&z__1, &z__2, &z__3);
	    zratx.r = z__1.r, zratx.i = z__1.i;
	}
    }

/*     CALCULATION OF REFLECTION COEFFICIENTS */

    xymag = sqrt(xij * xij + yij * yij);
    if (xymag < 1e-10f) {
	px = 0.f;
	py = 0.f;
	cth = 1.f;
	zrsin.r = 1.f, zrsin.i = 0.f;
    } else {
	px = -yij / xymag;
	py = xij / xymag;
	cth = abs(zij) / sqrt(xymag * xymag + zij * zij);
	z__4.r = zratx.r * zratx.r - zratx.i * zratx.i, z__4.i = zratx.r * 
		zratx.i + zratx.i * zratx.r;
	d__1 = 1.f - cth * cth;
	z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	z__2.r = 1.f - z__3.r, z__2.i = -z__3.i;
	z_sqrt(&z__1, &z__2);
	zrsin.r = z__1.r, zrsin.i = z__1.i;
    }
    z__3.r = zratx.r * zrsin.r - zratx.i * zrsin.i, z__3.i = zratx.r * 
	    zrsin.i + zratx.i * zrsin.r;
    z__2.r = cth - z__3.r, z__2.i = -z__3.i;
    z__5.r = zratx.r * zrsin.r - zratx.i * zrsin.i, z__5.i = zratx.r * 
	    zrsin.i + zratx.i * zrsin.r;
    z__4.r = cth + z__5.r, z__4.i = z__5.i;
    z_div(&z__1, &z__2, &z__4);
    refs.r = z__1.r, refs.i = z__1.i;
    z__4.r = cth * zratx.r, z__4.i = cth * zratx.i;
    z__3.r = z__4.r - zrsin.r, z__3.i = z__4.i - zrsin.i;
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__6.r = cth * zratx.r, z__6.i = cth * zratx.i;
    z__5.r = z__6.r + zrsin.r, z__5.i = z__6.i + zrsin.i;
    z_div(&z__1, &z__2, &z__5);
    refps.r = z__1.r, refps.i = z__1.i;
    z__1.r = refps.r - refs.r, z__1.i = refps.i - refs.i;
    refps.r = z__1.r, refps.i = z__1.i;

/*     DECOMPOSE FIELDS INTO TE AND TM COMPONENTS, MULTIPLY BY REFLECTION */
/*     COEFFICIENTS AND RECOMBINE. */

    z__2.r = px * txk->r, z__2.i = px * txk->i;
    z__3.r = py * tyk->r, z__3.i = py * tyk->i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__1.r = px * epy.r, z__1.i = px * epy.i;
    epx.r = z__1.r, epx.i = z__1.i;
    z__1.r = py * epy.r, z__1.i = py * epy.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__2.r = refs.r * txk->r - refs.i * txk->i, z__2.i = refs.r * txk->i + 
	    refs.i * txk->r;
    z__3.r = refps.r * epx.r - refps.i * epx.i, z__3.i = refps.r * epx.i + 
	    refps.i * epx.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    txk->r = z__1.r, txk->i = z__1.i;
    z__2.r = refs.r * tyk->r - refs.i * tyk->i, z__2.i = refs.r * tyk->i + 
	    refs.i * tyk->r;
    z__3.r = refps.r * epy.r - refps.i * epy.i, z__3.i = refps.r * epy.i + 
	    refps.i * epy.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    tyk->r = z__1.r, tyk->i = z__1.i;
    z__1.r = refs.r * tzk->r - refs.i * tzk->i, z__1.i = refs.r * tzk->i + 
	    refs.i * tzk->r;
    tzk->r = z__1.r, tzk->i = z__1.i;
    z__2.r = px * txs->r, z__2.i = px * txs->i;
    z__3.r = py * tys->r, z__3.i = py * tys->i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__1.r = px * epy.r, z__1.i = px * epy.i;
    epx.r = z__1.r, epx.i = z__1.i;
    z__1.r = py * epy.r, z__1.i = py * epy.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__2.r = refs.r * txs->r - refs.i * txs->i, z__2.i = refs.r * txs->i + 
	    refs.i * txs->r;
    z__3.r = refps.r * epx.r - refps.i * epx.i, z__3.i = refps.r * epx.i + 
	    refps.i * epx.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    txs->r = z__1.r, txs->i = z__1.i;
    z__2.r = refs.r * tys->r - refs.i * tys->i, z__2.i = refs.r * tys->i + 
	    refs.i * tys->r;
    z__3.r = refps.r * epy.r - refps.i * epy.i, z__3.i = refps.r * epy.i + 
	    refps.i * epy.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    tys->r = z__1.r, tys->i = z__1.i;
    z__1.r = refs.r * tzs->r - refs.i * tzs->i, z__1.i = refs.r * tzs->i + 
	    refs.i * tzs->r;
    tzs->r = z__1.r, tzs->i = z__1.i;
    z__2.r = px * txc->r, z__2.i = px * txc->i;
    z__3.r = py * tyc->r, z__3.i = py * tyc->i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__1.r = px * epy.r, z__1.i = px * epy.i;
    epx.r = z__1.r, epx.i = z__1.i;
    z__1.r = py * epy.r, z__1.i = py * epy.i;
    epy.r = z__1.r, epy.i = z__1.i;
    z__2.r = refs.r * txc->r - refs.i * txc->i, z__2.i = refs.r * txc->i + 
	    refs.i * txc->r;
    z__3.r = refps.r * epx.r - refps.i * epx.i, z__3.i = refps.r * epx.i + 
	    refps.i * epx.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    txc->r = z__1.r, txc->i = z__1.i;
    z__2.r = refs.r * tyc->r - refs.i * tyc->i, z__2.i = refs.r * tyc->i + 
	    refs.i * tyc->r;
    z__3.r = refps.r * epy.r - refps.i * epy.i, z__3.i = refps.r * epy.i + 
	    refps.i * epy.r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    tyc->r = z__1.r, tyc->i = z__1.i;
    z__1.r = refs.r * tzc->r - refs.i * tzc->i, z__1.i = refs.r * tzc->i + 
	    refs.i * tzc->r;
    tzc->r = z__1.r, tzc->i = z__1.i;
    return 0;
} /* rctran_ */

/* Subroutine */ int ekscsz_(doublereal *rh, doublereal *zp, doublereal *slen,
	 doublereal *arad, doublecomplex *zpeds, doublecomplex *xk, 
	doublecomplex *eta, doublecomplex *xks, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezcm, doublecomplex *erk, 
	doublecomplex *ers, doublecomplex *erc, integer *ind1, integer *ind2)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex ecr1, ecr2, ecz1, ecz2;
    static doublereal rhoa;
    extern /* Subroutine */ int efcap_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *);
    static doublereal shalf;
    extern /* Subroutine */ int endcap_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *);
    static doublereal rhofac;
    extern /* Subroutine */ int ekscmn_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    ), ekscks_(doublereal *, doublereal *, doublereal *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *), ekscpq_(doublereal *, doublereal *, doublereal *
	    , doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCSZ evaluates the E field due to a segment on the Z axis of a */
/*     cylindrical coordinate system using the thin wire approximation. */
/*     This routine calls subroutine EKSCMN to get the field due to a */
/*     filament of current after transforming the RHO coordinate for the */
/*     thin wire approximation. */

/*     INPUT: */
/*     RH = RHO COORDINATE OF THE EVALUATION POINT */
/*     ZP = Z COORDINATE OF THE EVALUATION POINT */
/*     SLEN = LENGTH OF THE SOURCE SEGMENT */
/*     ARAD = RADIUS OF THE SOURCE SEGMENT */
/*     ZPEDS = IMPEDANCE LOAD ON THE SEGMENT */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE SOURCE */
/*     ETA = INTRINSIC IMPEDANCE IN THE MEDIUM CONTAINING THE SOURCE */
/*     XKS = WAVENUMBER FOR THE CURRENT EXPANSION ON THE SEGMENT */
/*     IND1 = CONNECTION NUMBER (ICON1) FOR END ONE OF THE SOURCE SEG. */
/*          = 60000 FOR A JUNCTION THROUGH THE AIR-GROUND INTERFACE */
/*     IND2 = CONNECTION NUMBER (ICON2) FOR END TWO OF THE SOURCE SEG. */
/*          = 60000 FOR A JUNCTION THROUGH THE AIR-GROUND INTERFACE */

/*     OUTPUT: */
/*     EZK,ERK = Z AND RHO COMPONENTS OF E DUE TO CONSTANT CURRENT */
/*     EZS,ERS = Z AND RHO COMPONENTS OF E DUE TO SIN(KS) CURRENT */
/*     EZCM,ERC = Z AND RHO COMPONENTS OF E DUE TO COS(KS)-1 CURRENT */

    shalf = *slen * .5f;
    rhoa = sqrt(*rh * *rh + *arad * *arad);
    z__2.r = xks->r - xk->r, z__2.i = xks->i - xk->i;
    z_div(&z__1, &z__2, xk);
    if (z_abs(&z__1) > 1e-5f) {
	ekscks_(slen, zp, &rhoa, xk, eta, xks, ezk, ezs, ezcm, ers, erc);
    } else {
	ekscmn_(slen, zp, &rhoa, xk, eta, ezk, ezs, ezcm, ers, erc);
    }
    erk->r = 0.f, erk->i = 0.f;

/*     IF A SEGMENT CONNECTS TO A MFIE PATCH OR FORMS A JUNCTION CROSSING */
/*     THE AIR-GROUND INTERFACE THE FIELD DUE TO THE POINT CHARGE ON THE */
/*     CONNECTED END IS ADDED BY SUBROUTINE EKSCPQ */

    if (*ind1 > 30000) {
	d__1 = -shalf;
	ekscpq_(&d__1, zp, &rhoa, xk, eta, xks, ezk, ezs, ezcm, erk, ers, erc)
		;
    }
    if (*ind2 > 30000) {
	ekscpq_(&shalf, zp, &rhoa, xk, eta, xks, ezk, ezs, ezcm, erk, ers, 
		erc);
    }

/*     ADJUST RADIAL FIELD TO USE 1/RH FACTOR RATHER THAN 1/RHOA. */

    if (*rh > *arad * .999f) {
	rhofac = rhoa / *rh;
	z__1.r = rhofac * erk->r, z__1.i = rhofac * erk->i;
	erk->r = z__1.r, erk->i = z__1.i;
	z__1.r = rhofac * ers->r, z__1.i = rhofac * ers->i;
	ers->r = z__1.r, ers->i = z__1.i;
	z__1.r = rhofac * erc->r, z__1.i = rhofac * erc->i;
	erc->r = z__1.r, erc->i = z__1.i;
    } else if (abs(*zp) - shalf > *arad * .1f) {
	erk->r = 0.f, erk->i = 0.f;
	ers->r = 0.f, ers->i = 0.f;
	erc->r = 0.f, erc->i = 0.f;
    } else if (*rh < *arad * .001f) {
	ers->r = 0.f, ers->i = 0.f;
	erc->r = 0.f, erc->i = 0.f;
    }

/*     ADD END CAP FIELDS TO SEGMENTS ON FREE ENDS */

    if (*ind1 == 0) {
	endcap_(&c_n1, slen, arad, rh, zp, xk, eta, xks, ezk, ezs, ezcm, erk, 
		ers, erc);
    }
    if (*ind2 == 0) {
	endcap_(&c__1, slen, arad, rh, zp, xk, eta, xks, ezk, ezs, ezcm, erk, 
		ers, erc);
    }

/*     ADD FIELD DUE TO END CAPS ON SEGMENTS WITH IMPEDANCE LOADS. */

    if (vlcapc_1.ivcap == 1 && z_abs(zpeds) > 1e-10f) {
	d__1 = *zp + shalf;
	efcap_(arad, rh, &d__1, xk, &ecr1, &ecz1);
	d__1 = *zp - shalf;
	efcap_(arad, rh, &d__1, xk, &ecr2, &ecz2);
	z__4.r = ecz1.r - ecz2.r, z__4.i = ecz1.i - ecz2.i;
	z__3.r = z__4.r * zpeds->r - z__4.i * zpeds->i, z__3.i = z__4.r * 
		zpeds->i + z__4.i * zpeds->r;
	z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
		z__3.i * xk->r;
	z__1.r = ezk->r + z__2.r, z__1.i = ezk->i + z__2.i;
	ezk->r = z__1.r, ezk->i = z__1.i;
	z__4.r = ecr1.r - ecr2.r, z__4.i = ecr1.i - ecr2.i;
	z__3.r = z__4.r * zpeds->r - z__4.i * zpeds->i, z__3.i = z__4.r * 
		zpeds->i + z__4.i * zpeds->r;
	z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
		z__3.i * xk->r;
	z__1.r = erk->r + z__2.r, z__1.i = erk->i + z__2.i;
	erk->r = z__1.r, erk->i = z__1.i;
    }
    return 0;
} /* ekscsz_ */

/* Subroutine */ int endcap_(integer *iend, doublereal *slen, doublereal *
	caprad, doublereal *rho, doublereal *zob, doublecomplex *xk, 
	doublecomplex *eta, doublecomplex *xks, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezc, doublecomplex *erk, 
	doublecomplex *ers, doublecomplex *erc)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_sin(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex er, ez;
    extern /* Subroutine */ int efcap_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *);
    static doublereal shalf;
    static doublecomplex comks, sinks;
    static doublereal zdist;
    extern /* Double Complex */ VOID ccosm1_(doublecomplex *, doublecomplex *)
	    ;
    static doublecomplex rhoend;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ENDCAP evaluates the E field due to charge on an end cap of an */
/*     arbitrarily oriented segment in an infinite medium.  This routine */
/*     transforms coordinates and then calls subroutine EFCAP to evaluate */
/*     the field of the end cap of the segment on the Z axis of a */
/*     cylindrical coordinate system. */

/*     INPUT: */
/*     IEND = -1 IF CAP IS ON (-) END OF THE SEGMENT */
/*          = +1 IF CAP IS ON (+) END OF THE SEGMENT */
/*     SLEN = LENGTH OF THE SOURCE SEGMENT */
/*     CAPRAD = RADIUS OF THE SOURCE SEGMENT */
/*     RHO,ZOB = RHO AND Z COORDINATES OF THE EVALUATION POINT */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE SOURCE */
/*     ETA = INTRINSIC IMPEDANCE IN THE MEDIUM CONTAINING THE SOURCE */
/*     XKS = WAVENUMBER FOR THE CURRENT EXPANSION */

/*     INPUT AND OUTPUT: */
/*     EZK,ERK = Z AND RHO COMPONENTS OF E DUE TO CONSTANT CURRENT */
/*     EZS,ERS = Z AND RHO COMPONENTS OF E DUE TO SIN(KS) CURRENT */
/*     EZCM,ERC = Z AND RHO COMPONENTS OF E DUE TO COS(KS)-1 CURRENT */

    shalf = *slen * .5f;
    if (*iend > 0) {
	zdist = *zob - shalf;
    } else {
	zdist = *zob + shalf;
    }
    efcap_(caprad, rho, &zdist, xk, &er, &ez);
    z__2.r = eta->r * -0.f - eta->i * -1.f, z__2.i = eta->r * -1.f + eta->i * 
	    -0.f;
/* Computing 2nd power */
    d__2 = *caprad;
    d__1 = constn_1.pi * (d__2 * d__2);
    z__3.r = d__1 * xk->r, z__3.i = d__1 * xk->i;
    z_div(&z__1, &z__2, &z__3);
    rhoend.r = z__1.r, rhoend.i = z__1.i;
    z__1.r = er.r * rhoend.r - er.i * rhoend.i, z__1.i = er.r * rhoend.i + 
	    er.i * rhoend.r;
    er.r = z__1.r, er.i = z__1.i;
    z__1.r = ez.r * rhoend.r - ez.i * rhoend.i, z__1.i = ez.r * rhoend.i + 
	    ez.i * rhoend.r;
    ez.r = z__1.r, ez.i = z__1.i;
    z__2.r = shalf * xks->r, z__2.i = shalf * xks->i;
    z_sin(&z__1, &z__2);
    sinks.r = z__1.r, sinks.i = z__1.i;
    z__2.r = shalf * xks->r, z__2.i = shalf * xks->i;
    ccosm1_(&z__1, &z__2);
    comks.r = z__1.r, comks.i = z__1.i;
    z__2.r = ez.r * sinks.r - ez.i * sinks.i, z__2.i = ez.r * sinks.i + ez.i *
	     sinks.r;
    z__1.r = ezs->r + z__2.r, z__1.i = ezs->i + z__2.i;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__2.r = er.r * sinks.r - er.i * sinks.i, z__2.i = er.r * sinks.i + er.i *
	     sinks.r;
    z__1.r = ers->r + z__2.r, z__1.i = ers->i + z__2.i;
    ers->r = z__1.r, ers->i = z__1.i;
    if (*iend > 0) {
	z__1.r = ezk->r + ez.r, z__1.i = ezk->i + ez.i;
	ezk->r = z__1.r, ezk->i = z__1.i;
	z__2.r = ez.r * comks.r - ez.i * comks.i, z__2.i = ez.r * comks.i + 
		ez.i * comks.r;
	z__1.r = ezc->r + z__2.r, z__1.i = ezc->i + z__2.i;
	ezc->r = z__1.r, ezc->i = z__1.i;
	z__1.r = erk->r + er.r, z__1.i = erk->i + er.i;
	erk->r = z__1.r, erk->i = z__1.i;
	z__2.r = er.r * comks.r - er.i * comks.i, z__2.i = er.r * comks.i + 
		er.i * comks.r;
	z__1.r = erc->r + z__2.r, z__1.i = erc->i + z__2.i;
	erc->r = z__1.r, erc->i = z__1.i;
    } else {
	z__1.r = ezk->r - ez.r, z__1.i = ezk->i - ez.i;
	ezk->r = z__1.r, ezk->i = z__1.i;
	z__2.r = ez.r * comks.r - ez.i * comks.i, z__2.i = ez.r * comks.i + 
		ez.i * comks.r;
	z__1.r = ezc->r - z__2.r, z__1.i = ezc->i - z__2.i;
	ezc->r = z__1.r, ezc->i = z__1.i;
	z__1.r = erk->r - er.r, z__1.i = erk->i - er.i;
	erk->r = z__1.r, erk->i = z__1.i;
	z__2.r = er.r * comks.r - er.i * comks.i, z__2.i = er.r * comks.i + 
		er.i * comks.r;
	z__1.r = erc->r - z__2.r, z__1.i = erc->i - z__2.i;
	erc->r = z__1.r, erc->i = z__1.i;
    }
    return 0;
} /* endcap_ */

/* Subroutine */ int efcap_(doublereal *caprad, doublereal *rho, doublereal *
	zdist, doublecomplex *xk, doublecomplex *er, doublecomplex *ez)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9;

    /* Builtin functions */
    double sqrt(doublereal), z_abs(doublecomplex *);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal ra, rz;
    static doublecomplex xkr, rzk;
    static doublereal absz, aors;
    static doublecomplex exkr, xjkr, xjkz, term1, term2;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EFCAP evaluates the E field due to charge on a circular disk */
/*     representing the end cap of a wire.  Constant charge density is */
/*     assumed on the disk with the value determined for unit current */
/*     onto the disk. NOTE: A factor of 1/permittivty has been omitted */
/*     from the returned field since it cancels later. */

/*     INPUT: */
/*     CAPRAD = RADIUS OF THE WIRE AND CAP */
/*     RHO,ZDIST = RHO AND Z COORDINATES OF THE EVALUATION POINT */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE CAP */

/*     OUTPUT: */
/*     ER,EZ = RHO AND Z COMPONENTS OF E DUE TO THE CHARGE ON THE CAP */

    absz = abs(*zdist);

/*     EXACT EVALUATION FOR POINTS ON THE AXIS OF THE DISK */

    if (*rho < absz * .1f && absz < *caprad * 10.f) {
	ra = sqrt(*zdist * *zdist + *caprad * *caprad);
	z__2.r = xk->r * 0.f - xk->i * 1.f, z__2.i = xk->r * 1.f + xk->i * 
		0.f;
	z__1.r = absz * z__2.r, z__1.i = absz * z__2.i;
	xjkz.r = z__1.r, xjkz.i = z__1.i;
	d__1 = ra - absz;
	z__1.r = d__1 * xk->r, z__1.i = d__1 * xk->i;
	rzk.r = z__1.r, rzk.i = z__1.i;
	if (z_abs(&rzk) > .001f) {
	    z__4.r = -xjkz.r, z__4.i = -xjkz.i;
	    z_exp(&z__3, &z__4);
	    z__2.r = z__3.r * -.5f, z__2.i = z__3.i * -.5f;
	    z__9.r = rzk.r * -0.f - rzk.i * -1.f, z__9.i = rzk.r * -1.f + 
		    rzk.i * -0.f;
	    z_exp(&z__8, &z__9);
	    z__7.r = absz * z__8.r, z__7.i = absz * z__8.i;
	    z__6.r = z__7.r / ra, z__6.i = z__7.i / ra;
	    z__5.r = z__6.r - 1.f, z__5.i = z__6.i;
	    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * 
		    z__5.i + z__2.i * z__5.r;
	    ez->r = z__1.r, ez->i = z__1.i;
	} else {
	    z__6.r = -xjkz.r, z__6.i = -xjkz.i;
	    z_exp(&z__5, &z__6);
	    z__4.r = z__5.r * -.5f, z__4.i = z__5.i * -.5f;
	    z__3.r = z__4.r / ra, z__3.i = z__4.i / ra;
	    d__1 = absz - ra;
	    z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
	    z__7.r = xjkz.r + 1.f, z__7.i = xjkz.i;
	    z__1.r = z__2.r * z__7.r - z__2.i * z__7.i, z__1.i = z__2.r * 
		    z__7.i + z__2.i * z__7.r;
	    ez->r = z__1.r, ez->i = z__1.i;
	}
	if (*zdist < 0.f) {
	    z__1.r = -ez->r, z__1.i = -ez->i;
	    ez->r = z__1.r, ez->i = z__1.i;
	}
	er->r = 0.f, er->i = 0.f;
    } else {

/*     APPROXIMATION FOR RZ MUCH GREATER THAN CAPRAD */

	rz = sqrt(*rho * *rho + *zdist * *zdist);
	z__1.r = rz * xk->r, z__1.i = rz * xk->i;
	xkr.r = z__1.r, xkr.i = z__1.i;
	z__1.r = xkr.r * 0.f - xkr.i * 1.f, z__1.i = xkr.r * 1.f + xkr.i * 
		0.f;
	xjkr.r = z__1.r, xjkr.i = z__1.i;
/* Computing 2nd power */
	d__1 = *caprad / rz;
	aors = d__1 * d__1;
	d__1 = aors * .25f;
	z__4.r = -xjkr.r, z__4.i = -xjkr.i;
	z_exp(&z__3, &z__4);
	z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
	z__1.r = z__2.r / rz, z__1.i = z__2.i / rz;
	exkr.r = z__1.r, exkr.i = z__1.i;
	if (rz < *caprad * 10.f) {
	    z__2.r = xjkr.r + 1.f, z__2.i = xjkr.i;
/* Computing 2nd power */
	    d__2 = *rho / rz;
	    d__1 = aors * .125f * (d__2 * d__2);
	    z__8.r = xjkr.r + 6.f, z__8.i = xjkr.i;
	    z__7.r = z__8.r * xkr.r - z__8.i * xkr.i, z__7.i = z__8.r * xkr.i 
		    + z__8.i * xkr.r;
	    z__6.r = z__7.r - 0.f, z__6.i = z__7.i - 15.f;
	    z__5.r = z__6.r * xkr.r - z__6.i * xkr.i, z__5.i = z__6.r * xkr.i 
		    + z__6.i * xkr.r;
	    z__4.r = z__5.r - 15.f, z__4.i = z__5.i;
	    z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
	    term1.r = z__1.r, term1.i = z__1.i;
	    d__1 = aors * .5f;
	    z__4.r = xkr.r - 0.f, z__4.i = xkr.i - 3.f;
	    z__3.r = z__4.r * xkr.r - z__4.i * xkr.i, z__3.i = z__4.r * xkr.i 
		    + z__4.i * xkr.r;
	    z__2.r = 3.f - z__3.r, z__2.i = -z__3.i;
	    z__1.r = d__1 * z__2.r, z__1.i = d__1 * z__2.i;
	    term2.r = z__1.r, term2.i = z__1.i;
	    z__2.r = *zdist * exkr.r, z__2.i = *zdist * exkr.i;
	    z__4.r = term2.r * .5f, z__4.i = term2.i * .5f;
	    z__3.r = term1.r - z__4.r, z__3.i = term1.i - z__4.i;
	    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * 
		    z__3.i + z__2.i * z__3.r;
	    ez->r = z__1.r, ez->i = z__1.i;
	    z__2.r = *rho * exkr.r, z__2.i = *rho * exkr.i;
	    z__3.r = term1.r - term2.r, z__3.i = term1.i - term2.i;
	    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * 
		    z__3.i + z__2.i * z__3.r;
	    er->r = z__1.r, er->i = z__1.i;
	} else {
	    z__1.r = xjkr.r + 1.f, z__1.i = xjkr.i;
	    term1.r = z__1.r, term1.i = z__1.i;
	    z__2.r = *zdist * exkr.r, z__2.i = *zdist * exkr.i;
	    z__1.r = z__2.r * term1.r - z__2.i * term1.i, z__1.i = z__2.r * 
		    term1.i + z__2.i * term1.r;
	    ez->r = z__1.r, ez->i = z__1.i;
	    z__2.r = *rho * exkr.r, z__2.i = *rho * exkr.i;
	    z__1.r = z__2.r * term1.r - z__2.i * term1.i, z__1.i = z__2.r * 
		    term1.i + z__2.i * term1.r;
	    er->r = z__1.r, er->i = z__1.i;
	}
    }
    return 0;
} /* efcap_ */

/* Subroutine */ int ekscmn_(doublereal *slen, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezcm, doublecomplex *ers, 
	doublecomplex *erc)
{
    /* System generated locals */
    doublereal d__1;

    /* Builtin functions */
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublereal shs, shaf, rzsq;
    extern /* Subroutine */ int eksmr_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    );
    static doublereal rwlam, zdist;
    extern /* Subroutine */ int ekscex_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    ), eksclr_(doublereal *, doublereal *, doublereal *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , doublecomplex *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCMN calls a routine to compute the electric field due to a */
/*     segment with constant, SIN(KS), and COS(KS)-1 current */
/*     distributions.  The routine EKSCEX uses the exact field equations */
/*     but is subject to numerical errors for some RHO, ZOB, and segment */
/*     lengths.  The other routines use series approximations for */
/*     particular cases that are difficult for subroutine EKSCEX.  The */
/*     tests here are set for single precision code. */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM= Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */

    shaf = *slen * .5f;
    shs = shaf * shaf;
    zdist = abs(*zob) + shaf;
    rzsq = zdist * zdist + *rho * *rho;
    if (rzsq > shs * 100.f) {

/*     SERIES FOR R MUCH LARGER THAN SEGMENT LENGTH. */

	eksclr_(slen, zob, rho, xk, eta, ezk, ezs, ezcm, ers, erc);
    } else {
	rwlam = 6.283185f / z_abs(xk);
/* Computing 2nd power */
	d__1 = rwlam * .01f;
	if (rzsq > d__1 * d__1) {

/*     GENERAL FIELD EVALUATION. */

	    ekscex_(slen, zob, rho, xk, eta, ezk, ezs, ezcm, ers, erc);
	} else {

/*     SERIES FOR SMALL KR. */

	    eksmr_(slen, zob, rho, xk, eta, ezk, ezs, ezcm, ers, erc);
	}
    }
    return 0;
} /* ekscmn_ */

/* Subroutine */ int somfld_(doublereal *xi, doublereal *yi, doublereal *zi, 
	doublereal *xj, doublereal *yj, doublereal *zj, doublereal *dxj, 
	doublereal *dyj, doublereal *dzj, doublereal *slenj, doublereal *
	aradj, doublecomplex *xksx, doublereal *dmin__, integer *imagf, 
	doublecomplex *exk, doublecomplex *eyk, doublecomplex *ezk, 
	doublecomplex *exs, doublecomplex *eys, doublecomplex *ezs, 
	doublecomplex *exc, doublecomplex *eyc, doublecomplex *ezc)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3;
    doublecomplex z__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal zr, xij, yij, zij, rhs, dzr;
    static doublecomplex egnd[9];
    static doublereal shaf, rijs, rhox, rhoy, rhoz;
    extern /* Subroutine */ int rombg_(doublereal *, doublereal *, integer *, 
	    S_fp, doublecomplex *, doublereal *, doublereal *), sflds_(
	    doublereal *, doublecomplex *), gausi3_(doublereal *, doublereal *
	    , integer *, S_fp, doublecomplex *);
    static doublereal twshif;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SOMFLD evaluates the field due to a wire segment in the presence */
/*     of an air-ground interface.  If the source and evaluation points */
/*     are on opposite sides of the interface the total field is */
/*     returned.  If source and evaluation points are on the same side of */
/*     the interface only the component of E due to the Sommerfeld */
/*     integrals is evaluated, and must be combined with the direct field */
/*     and the quasistatic image field. */

/*     INPUT: */
/*     XI,YI,ZI = COORDINATES OF THE EVALUATION POINT */
/*     XJ,YJ,ZJ = COORDINATES OF THE CENTER OF THE SOURCE SEGMENT */
/*     DXJ,DYJ,DZJ = UNIT VECTOR IN THE DIRECTION OF THE SOURCE SEGMENT */
/*     SLENJ = LENGTH OF THE SOURCE SEGMENT */
/*     ARADJ = RADIUS OF THE SOURCE SEGMENT */
/*     XKSX = WAVE NUMBER FOR THE CURRENT EXPANSION ON THE SOURCE SEGMENT */
/*     DMIN = LIMIT TO THE DENOMINATOR IN THE RELATIVE ERROR TEST FOR */
/*            NUMERICAL INTEGRATION BY SUBROUTINE ROMBG */
/*     IMAGF = FLAG TO CONTROL EVALUATION MODE */
/*             IMAGF.GT.0 FOR REFLECTED FIELD, OTHERWISE TRANSMITTED. */
/*             IABS(IMAGF).EQ.2 FOR POINT SOURCE APPROXIMATON OTHERWISE */
/*             USE NUMERICAL INTEGRATION. */

/*     OUTPUT: */
/*     EXK,EYK,EZK = X,Y,Z COMPONENTS OF E DUE TO CONSTANT CURRENT */
/*     EXS,EYS,EZS = X,Y,Z COMPONENTS OF E DUE TO SIN(KS) CURRENT */
/*     EXC,EYC,EZC = X,Y,Z COMPONENTS OF E DUE TO COS(KS)-1 CURRENT */

    incom_1.segl = *slenj;
    incom_1.dirx = *dxj;
    incom_1.diry = *dyj;
    incom_1.dirz = *dzj;
    incom_1.xo = *xi;
    incom_1.yo = *yi;
    incom_1.zo = *zi;
    incom_1.xkseg.r = xksx->r, incom_1.xkseg.i = xksx->i;
    incom_1.sn = sqrt(*dxj * *dxj + *dyj * *dyj);
    if (incom_1.sn > 1e-5f) {
	incom_1.xsn = *dxj / incom_1.sn;
	incom_1.ysn = *dyj / incom_1.sn;
    } else {
	incom_1.sn = 0.f;
	incom_1.xsn = 1.f;
	incom_1.ysn = 0.f;
    }

/*     DISPLACE SOURCE POINT TO THE SURFACE OF THE SOURCE SEGMENT IN A */
/*     DIRECTION NORMAL TO THE DIRECTION TO THE EVALUATION POINT.  IF THE */
/*     SOURCE AND EVALUATION POINTS ARE ON THE SAME SIDE OF THE INTERFACE */
/*     THE IMAGE OF THE SOURCE SEGMENT IS USED IN DETERMINING THE */
/*     DIRECTON FOR DISPLACEMENT. */

    if (*imagf > 0) {
	zr = -(*zj);
	dzr = -(*dzj);
    } else {
	zr = *zj;
	dzr = *dzj;
    }
    xij = *xi - *xj;
    yij = *yi - *yj;
    zij = *zi - zr;
    rhox = *dyj * zij - dzr * yij;
    rhoy = dzr * xij - *dxj * zij;
    rhoz = *dxj * yij - *dyj * xij;
    rhs = rhox * rhox + rhoy * rhoy + rhoz * rhoz;
    if (rhs > 1e-20f) {
	twshif = *aradj / sqrt(rhs);
	if (rhoz < 0.f) {
	    twshif = -twshif;
	}
	if (zr < 0.f) {
	    twshif = -twshif;
	}
	incom_1.xsj = *xj + twshif * rhox;
	incom_1.ysj = *yj + twshif * rhoy;
	incom_1.zsj = zr + twshif * rhoz;
	if (*imagf > 0) {
	    incom_1.zsj = -incom_1.zsj;
	}
    } else {
	incom_1.xsj = *xj - *aradj * incom_1.ysn;
	incom_1.ysj = *yj + *aradj * incom_1.xsn;
	incom_1.zsj = *zj;
    }
    if (abs(*imagf) == 2) {

/*     POINT SOURCE APPROXIMATION */

	incom_1.isnor = 2;
	incom_1.idirx = 1;
	sflds_(&c_b332, egnd);
    } else {

/*     FIELD FROM INTERPOLATION IS INTEGRATED OVER SEGMENT */

	incom_1.isnor = 1;
	incom_1.ireg = 0;
	shaf = *slenj * .5f;
/* Computing 2nd power */
	d__1 = xij;
/* Computing 2nd power */
	d__2 = yij;
/* Computing 2nd power */
	d__3 = zij;
	rijs = d__1 * d__1 + d__2 * d__2 + d__3 * d__3;
/* Computing 2nd power */
	d__1 = *slenj;
	if (rijs < d__1 * d__1 * 2.f) {
	    d__1 = -shaf;
	    rombg_(&d__1, &shaf, &c__9, (S_fp)sflds_, egnd, dmin__, &c_b2721);
	} else {
	    d__1 = -shaf;
	    gausi3_(&d__1, &shaf, &c__9, (S_fp)sflds_, egnd);
	}
    }
    exk->r = egnd[0].r, exk->i = egnd[0].i;
    eyk->r = egnd[1].r, eyk->i = egnd[1].i;
    ezk->r = egnd[2].r, ezk->i = egnd[2].i;
    exs->r = egnd[3].r, exs->i = egnd[3].i;
    eys->r = egnd[4].r, eys->i = egnd[4].i;
    ezs->r = egnd[5].r, ezs->i = egnd[5].i;
    z__1.r = egnd[6].r - exk->r, z__1.i = egnd[6].i - exk->i;
    exc->r = z__1.r, exc->i = z__1.i;
    z__1.r = egnd[7].r - eyk->r, z__1.i = egnd[7].i - eyk->i;
    eyc->r = z__1.r, eyc->i = z__1.i;
    z__1.r = egnd[8].r - ezk->r, z__1.i = egnd[8].i - ezk->i;
    ezc->r = z__1.r, ezc->i = z__1.i;
    return 0;
} /* somfld_ */

/* Subroutine */ int gausi3_(doublereal *a, doublereal *b, integer *nfun, 
	S_fp fsub, doublecomplex *ans)
{
    /* Initialized data */

    static doublereal wcen = .4444444;
    static doublereal wout = .2777778;

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Local variables */
    static integer i__;
    static doublecomplex g1[9], g2[9], g3[9];
    static doublereal ba, abcen, about;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GAUSI3 INTEGRATES FUNCTIONS USING THREE-POINT GAUSSIAN INTEGRATION */

/*     INPUT: */
/*     A = LOWER LIMIT OF INTEGRATION */
/*     B = UPPER LIMIT OF INTEGRATION */
/*     NFUN = NUMBER OF FUNCTIONS TO INTEGRATE */
/*     FSUB = SUBROUTINE SUPPLYING THE INTEGRAND VALUES */

/*     OUTPUT: */
/*     ANS = ARRAY OF INTEGRAL VALUES FOR THE FUNCTIONS (COMPLEX) */

    /* Parameter adjustments */
    --ans;

    /* Function Body */
    abcen = .5f * (*a + *b);
    ba = *b - *a;
    about = ba * .3872983f;
    d__1 = abcen - about;
    (*fsub)(&d__1, g1);
    (*fsub)(&abcen, g2);
    d__1 = abcen + about;
    (*fsub)(&d__1, g3);
    i__1 = *nfun;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__;
	i__3 = i__ - 1;
	z__3.r = wcen * g2[i__3].r, z__3.i = wcen * g2[i__3].i;
	i__4 = i__ - 1;
	i__5 = i__ - 1;
	z__5.r = g1[i__4].r + g3[i__5].r, z__5.i = g1[i__4].i + g3[i__5].i;
	z__4.r = wout * z__5.r, z__4.i = wout * z__5.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__1.r = ba * z__2.r, z__1.i = ba * z__2.i;
	ans[i__2].r = z__1.r, ans[i__2].i = z__1.i;
/* L1: */
    }
    return 0;
} /* gausi3_ */

/* Subroutine */ int sflds_(doublereal *t, doublecomplex *e)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_sin(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static doublecomplex rk;
    static doublereal xt, yt, zt, cph;
    static doublecomplex eph, erh, ezh;
    static doublereal rho, sph;
    static doublecomplex erv;
    static doublereal rhs, phx, phy, rhx, rhy;
    static doublecomplex ezv;
    static doublereal zos;
    static integer izs;
    static doublereal zts;
    static doublecomplex sfac;
    static doublereal sfax, rhos;
    extern /* Subroutine */ int gndef_(doublereal *, doublereal *, doublereal 
	    *, integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *), rxfld_(doublereal *, 
	    doublereal *, doublereal *, integer *, doublecomplex *, 
	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
	    , integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SFLDS returns the field due to a current element in the presence */
/*     of ground.  The current element is on a filament defined in */
/*     COMMON /INCOM/ at a distance T from the center of the filament. */
/*     The main function of SFLDS is to transform coordinates and combine */
/*     field components. */

/*     INPUT (ARGUMENT): */
/*     T = DISTANCE OF THE CURRENT ELEMENT FROM THE CENTER OF THE */

/*     INPUT (COMMON/INCOM/): */
/*     SEGL = LENGTH OF THE CURRENT FILAMENT */
/*     XJ,YJ,ZJ = COORDINATES OF THE CENTER OF THE FILAMENT */
/*     DIRX,DIRY,DIRZ = UNIT VECTOR ALONG THE FILAMENT */
/*     SN = LENGTH OF THE PROJECTION OF THE FILAMENT ONTO THE XY PLANE */
/*     XSN,YSN = UNIT VECTOR ALONG THE PROJECTION OF THE FILAMENT ONTO */
/*               THE XY PLANE */
/*     XO,YO,ZO = COORDINATES OF THE FIELD EVALUATION POINT */
/*     XKSEG = WAVENUMBER FOR THE CURRENT EXPANSION ON THE SOURCE SEGMENT */
/*     ISNOR = 1 TO EVALUATE SOMMERFELD INTEGRAL FIELD, GRID TRANSITIONS */
/*               SMOOTHED */
/*           = 2 TO EVALUATE SOMMERFELD INTEGRAL FIELD, NO SMOOTHING */
/*     IREG = GRID REGION */
/*     IDIRX = 1 TO SUPPRESS THE DIRECT FIELD AND COMPUTE ONLY FIELD */
/*             DUE TO GROUND.  OTHERWISE DIRECT FIELD IS INCLUDED. */

/*     OUTPUT: */
/*     E = ARRAY OF FIELD COMPONENTS */

    /* Parameter adjustments */
    --e;

    /* Function Body */
    xt = incom_1.xsj + *t * incom_1.dirx;
    yt = incom_1.ysj + *t * incom_1.diry;
    zt = incom_1.zsj + *t * incom_1.dirz;
    if (zt * incom_1.zsj < 0.f) {
	zt = 0.f;
    }
    rhx = incom_1.xo - xt;
    rhy = incom_1.yo - yt;
    rhs = rhx * rhx + rhy * rhy;
    rho = sqrt(rhs);
    if (rho == 0.f) {
	rhx = 1.f;
	rhy = 0.f;
	phx = 0.f;
	phy = 1.f;
    } else {
	rhx /= rho;
	rhy /= rho;
	phx = -rhy;
	phy = rhx;
    }
    cph = rhx * incom_1.xsn + rhy * incom_1.ysn;
    sph = rhy * incom_1.xsn - rhx * incom_1.ysn;
    if (abs(cph) < 1e-10f) {
	cph = 0.f;
    }
    if (abs(sph) < 1e-10f) {
	sph = 0.f;
    }
    rhos = rho * gnd_1.gscal;
    zts = zt * gnd_1.gscal;
    zos = incom_1.zo * gnd_1.gscal;
    if (incom_1.isnor == 1) {
	goto L5;
    }

/*     ISNOR.EQ.2 - FIELD FROM INTERPOLATION/L.S. APPROX. OR ASYMPTOTIC */
/*     APPROXIMATION. (NOT INTENDED FOR INTEGRATING BY ROMBG) */

    gndef_(&rhos, &zts, &zos, &incom_1.idirx, &erv, &ezv, &erh, &eph, &ezh);
    sfax = gnd_1.gscal * gnd_1.gscal;
    z__4.r = incom_1.sn * erh.r, z__4.i = incom_1.sn * erh.i;
    z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
    z__5.r = incom_1.dirz * erv.r, z__5.i = incom_1.dirz * erv.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    erh.r = z__1.r, erh.i = z__1.i;
    z__3.r = incom_1.sn * eph.r, z__3.i = incom_1.sn * eph.i;
    z__2.r = sph * z__3.r, z__2.i = sph * z__3.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    eph.r = z__1.r, eph.i = z__1.i;
    z__4.r = incom_1.sn * ezh.r, z__4.i = incom_1.sn * ezh.i;
    z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
    z__5.r = incom_1.dirz * ezv.r, z__5.i = incom_1.dirz * ezv.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    ezh.r = z__1.r, ezh.i = z__1.i;
    z__3.r = rhx * erh.r, z__3.i = rhx * erh.i;
    z__4.r = phx * eph.r, z__4.i = phx * eph.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = incom_1.segl * z__2.r, z__1.i = incom_1.segl * z__2.i;
    e[1].r = z__1.r, e[1].i = z__1.i;
    z__3.r = rhy * erh.r, z__3.i = rhy * erh.i;
    z__4.r = phy * eph.r, z__4.i = phy * eph.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = incom_1.segl * z__2.r, z__1.i = incom_1.segl * z__2.i;
    e[2].r = z__1.r, e[2].i = z__1.i;
    z__1.r = incom_1.segl * ezh.r, z__1.i = incom_1.segl * ezh.i;
    e[3].r = z__1.r, e[3].i = z__1.i;
    e[4].r = 0.f, e[4].i = 0.f;
    e[5].r = 0.f, e[5].i = 0.f;
    e[6].r = 0.f, e[6].i = 0.f;
    z__2.r = incom_1.xkseg.r * .5f, z__2.i = incom_1.xkseg.i * .5f;
    z__1.r = incom_1.segl * z__2.r, z__1.i = incom_1.segl * z__2.i;
    sfac.r = z__1.r, sfac.i = z__1.i;
    z_sin(&z__2, &sfac);
    z_div(&z__1, &z__2, &sfac);
    sfac.r = z__1.r, sfac.i = z__1.i;
    z__1.r = e[1].r * sfac.r - e[1].i * sfac.i, z__1.i = e[1].r * sfac.i + e[
	    1].i * sfac.r;
    e[7].r = z__1.r, e[7].i = z__1.i;
    z__1.r = e[2].r * sfac.r - e[2].i * sfac.i, z__1.i = e[2].r * sfac.i + e[
	    2].i * sfac.r;
    e[8].r = z__1.r, e[8].i = z__1.i;
    z__1.r = e[3].r * sfac.r - e[3].i * sfac.i, z__1.i = e[3].r * sfac.i + e[
	    3].i * sfac.r;
    e[9].r = z__1.r, e[9].i = z__1.i;
    return 0;

/*     ISNOR.EQ.1 - FIELD FROM INTERPOLATION OR L.S. APPROX. FOR */
/*     INTEGRATION OVER SEGMENT.  TRANSITION REGIONS SMOOTHED. */

L5:
    izs = 1;
    if (incom_1.zsj < 0.f) {
	izs = -1;
    }
    rxfld_(&rhos, &zts, &zos, &izs, &erv, &ezv, &erh, &eph, &ezh, &
	    incom_1.ireg);
    sfax = gnd_1.gscal * gnd_1.gscal;
    z__4.r = incom_1.sn * erh.r, z__4.i = incom_1.sn * erh.i;
    z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
    z__5.r = incom_1.dirz * erv.r, z__5.i = incom_1.dirz * erv.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    erh.r = z__1.r, erh.i = z__1.i;
    z__3.r = incom_1.sn * eph.r, z__3.i = incom_1.sn * eph.i;
    z__2.r = sph * z__3.r, z__2.i = sph * z__3.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    eph.r = z__1.r, eph.i = z__1.i;
    z__4.r = incom_1.sn * ezh.r, z__4.i = incom_1.sn * ezh.i;
    z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
    z__5.r = incom_1.dirz * ezv.r, z__5.i = incom_1.dirz * ezv.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = sfax * z__2.r, z__1.i = sfax * z__2.i;
    ezh.r = z__1.r, ezh.i = z__1.i;
/*     X,Y,Z FIELDS FOR CONSTANT CURRENT */
    z__2.r = rhx * erh.r, z__2.i = rhx * erh.i;
    z__3.r = phx * eph.r, z__3.i = phx * eph.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    e[1].r = z__1.r, e[1].i = z__1.i;
    z__2.r = rhy * erh.r, z__2.i = rhy * erh.i;
    z__3.r = phy * eph.r, z__3.i = phy * eph.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    e[2].r = z__1.r, e[2].i = z__1.i;
    e[3].r = ezh.r, e[3].i = ezh.i;
    z__1.r = *t * incom_1.xkseg.r, z__1.i = *t * incom_1.xkseg.i;
    rk.r = z__1.r, rk.i = z__1.i;
/*     X,Y,Z FIELDS FOR SINE CURRENT */
    z_sin(&z__1, &rk);
    sfac.r = z__1.r, sfac.i = z__1.i;
    z__1.r = e[1].r * sfac.r - e[1].i * sfac.i, z__1.i = e[1].r * sfac.i + e[
	    1].i * sfac.r;
    e[4].r = z__1.r, e[4].i = z__1.i;
    z__1.r = e[2].r * sfac.r - e[2].i * sfac.i, z__1.i = e[2].r * sfac.i + e[
	    2].i * sfac.r;
    e[5].r = z__1.r, e[5].i = z__1.i;
    z__1.r = e[3].r * sfac.r - e[3].i * sfac.i, z__1.i = e[3].r * sfac.i + e[
	    3].i * sfac.r;
    e[6].r = z__1.r, e[6].i = z__1.i;
/*     X,Y,Z FIELDS FOR COSINE CURRENT */
    z_cos(&z__1, &rk);
    sfac.r = z__1.r, sfac.i = z__1.i;
    z__1.r = e[1].r * sfac.r - e[1].i * sfac.i, z__1.i = e[1].r * sfac.i + e[
	    1].i * sfac.r;
    e[7].r = z__1.r, e[7].i = z__1.i;
    z__1.r = e[2].r * sfac.r - e[2].i * sfac.i, z__1.i = e[2].r * sfac.i + e[
	    2].i * sfac.r;
    e[8].r = z__1.r, e[8].i = z__1.i;
    z__1.r = e[3].r * sfac.r - e[3].i * sfac.i, z__1.i = e[3].r * sfac.i + e[
	    3].i * sfac.r;
    e[9].r = z__1.r, e[9].i = z__1.i;
    return 0;
} /* sflds_ */

/* Subroutine */ int ekscex_(doublereal *slen, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezcm, doublecomplex *ers, 
	doublecomplex *erc)
{
    /* Initialized data */

    static doublecomplex con = {0.,.07957747151};

    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13;

    /* Builtin functions */
    void z_sin(doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *);
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r1, r2, z1, z2;
    static doublecomplex cs;
    static doublereal sh;
    static doublecomplex ss, gz1, gz2, shk, conk, exri;
    extern /* Subroutine */ int esmlrh_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *), exrint_(doublereal *, doublereal *, doublereal *
	    , doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCEX computes the components of electric field for a segment */
/*     with constant, SIN(KS) and COS(KS)-1 current distributions. The */
/*     exact field equations are evaluated. */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM= Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */
/*     (CONSTANT CURRENT PRODUCES ZERO RHO COMPONENT OF E) */

    z__1.r = con.r * eta->r - con.i * eta->i, z__1.i = con.r * eta->i + con.i 
	    * eta->r;
    conk.r = z__1.r, conk.i = z__1.i;
    sh = *slen * .5f;
    z__1.r = sh * xk->r, z__1.i = sh * xk->i;
    shk.r = z__1.r, shk.i = z__1.i;
    z_sin(&z__1, &shk);
    ss.r = z__1.r, ss.i = z__1.i;
    z_cos(&z__1, &shk);
    cs.r = z__1.r, cs.i = z__1.i;
    z2 = sh - *zob;
    z1 = -(sh + *zob);

/*     EXRINT EVALUATES THE INTEGRAL OF EXP(-J*XK*R)/R. */

    exrint_(rho, zob, slen, xk, &exri);
    z__3.r = -conk.r, z__3.i = -conk.i;
    z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
	    z__3.i * xk->r;
    z__1.r = z__2.r * exri.r - z__2.i * exri.i, z__1.i = z__2.r * exri.i + 
	    z__2.i * exri.r;
    ezk->r = z__1.r, ezk->i = z__1.i;
    r1 = sqrt(z1 * z1 + *rho * *rho);
    r2 = sqrt(z2 * z2 + *rho * *rho);
    z__4.r = xk->r * -0. - xk->i * -1., z__4.i = xk->r * -1. + xk->i * -0.;
    z__3.r = r1 * z__4.r, z__3.i = r1 * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / r1, z__1.i = z__2.i / r1;
    gz1.r = z__1.r, gz1.i = z__1.i;
    z__4.r = xk->r * -0. - xk->i * -1., z__4.i = xk->r * -1. + xk->i * -0.;
    z__3.r = r2 * z__4.r, z__3.i = r2 * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / r2, z__1.i = z__2.i / r2;
    gz2.r = z__1.r, gz2.i = z__1.i;
    z__3.r = gz2.r - gz1.r, z__3.i = gz2.i - gz1.i;
    z__2.r = conk.r * z__3.r - conk.i * z__3.i, z__2.i = conk.r * z__3.i + 
	    conk.i * z__3.r;
    z__1.r = z__2.r * cs.r - z__2.i * cs.i, z__1.i = z__2.r * cs.i + z__2.i * 
	    cs.r;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__4.r = -conk.r, z__4.i = -conk.i;
    z__5.r = gz2.r + gz1.r, z__5.i = gz2.i + gz1.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    z__2.r = z__3.r * ss.r - z__3.i * ss.i, z__2.i = z__3.r * ss.i + z__3.i * 
	    ss.r;
    z__1.r = z__2.r - ezk->r, z__1.i = z__2.i - ezk->i;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    if (*rho > min(r1,r2) * .01f || z2 > 0.f && z1 < 0.f) {
	z__6.r = z2 * gz2.r, z__6.i = z2 * gz2.i;
	z__7.r = z1 * gz1.r, z__7.i = z1 * gz1.i;
	z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
	z__4.r = z__5.r * cs.r - z__5.i * cs.i, z__4.i = z__5.r * cs.i + 
		z__5.i * cs.r;
	z__11.r = r2 * gz2.r, z__11.i = r2 * gz2.i;
	z__12.r = r1 * gz1.r, z__12.i = r1 * gz1.i;
	z__10.r = z__11.r + z__12.r, z__10.i = z__11.i + z__12.i;
	z__9.r = z__10.r * 0.f - z__10.i * 1.f, z__9.i = z__10.r * 1.f + 
		z__10.i * 0.f;
	z__8.r = z__9.r * ss.r - z__9.i * ss.i, z__8.i = z__9.r * ss.i + 
		z__9.i * ss.r;
	z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
	z__2.r = conk.r * z__3.r - conk.i * z__3.i, z__2.i = conk.r * z__3.i 
		+ conk.i * z__3.r;
	z__1.r = z__2.r / *rho, z__1.i = z__2.i / *rho;
	ers->r = z__1.r, ers->i = z__1.i;
	z__3.r = -conk.r, z__3.i = -conk.i;
	z__7.r = z2 * gz2.r, z__7.i = z2 * gz2.i;
	z__8.r = z1 * gz1.r, z__8.i = z1 * gz1.i;
	z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
	z__5.r = z__6.r * ss.r - z__6.i * ss.i, z__5.i = z__6.r * ss.i + 
		z__6.i * ss.r;
	z__12.r = r2 * gz2.r, z__12.i = r2 * gz2.i;
	z__13.r = r1 * gz1.r, z__13.i = r1 * gz1.i;
	z__11.r = z__12.r - z__13.r, z__11.i = z__12.i - z__13.i;
	z__10.r = z__11.r * 0.f - z__11.i * 1.f, z__10.i = z__11.r * 1.f + 
		z__11.i * 0.f;
	z__9.r = z__10.r * cs.r - z__10.i * cs.i, z__9.i = z__10.r * cs.i + 
		z__10.i * cs.r;
	z__4.r = z__5.r - z__9.r, z__4.i = z__5.i - z__9.i;
	z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i 
		+ z__3.i * z__4.r;
	z__1.r = z__2.r / *rho, z__1.i = z__2.i / *rho;
	erc->r = z__1.r, erc->i = z__1.i;
    } else {

/*     ESMLRH EVALUATES THE RHO COMPONENTS OF E FOR SMALL RHO/R. */

	esmlrh_(slen, zob, rho, xk, eta, ers, erc);
    }
    return 0;
} /* ekscex_ */

/* Subroutine */ int ekscks_(doublereal *slen, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *xks, 
	doublecomplex *ezk, doublecomplex *ezs, doublecomplex *ezcm, 
	doublecomplex *ers, doublecomplex *erc)
{
    /* Initialized data */

    static doublecomplex con = {0.,.07957747151};

    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15, z__16, z__17;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_sin(
	    doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *);
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r1, r2, z1, z2;
    static doublecomplex cs;
    static doublereal sh;
    static doublecomplex ss, gz1, gz2, exi[5], shk, conk, xkdif;
    extern /* Subroutine */ int efint_(doublereal *, doublereal *, doublereal 
	    *, doublecomplex *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCKS computes the components of electric field for a segment */
/*     with constant, SIN(KS) and COS(KS)-1 current distributions. The */
/*     exact field equations are evaluated in the form allowing the */
/*     wavenumber on in the current expansion to be different from that */
/*     in the medium. */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */
/*     XKS = WAVENUMBER FOR THE CURRENT EXPANSION */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM= Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */
/*     (CONSTANT CURRENT PRODUCES ZERO RHO COMPONENT OF E) */

    z__2.r = con.r * eta->r - con.i * eta->i, z__2.i = con.r * eta->i + con.i 
	    * eta->r;
    z_div(&z__1, &z__2, xk);
    conk.r = z__1.r, conk.i = z__1.i;
    z__2.r = xk->r * xk->r - xk->i * xk->i, z__2.i = xk->r * xk->i + xk->i * 
	    xk->r;
    z__3.r = xks->r * xks->r - xks->i * xks->i, z__3.i = xks->r * xks->i + 
	    xks->i * xks->r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    xkdif.r = z__1.r, xkdif.i = z__1.i;
    sh = *slen * .5f;
    z__1.r = sh * xks->r, z__1.i = sh * xks->i;
    shk.r = z__1.r, shk.i = z__1.i;
    z_sin(&z__1, &shk);
    ss.r = z__1.r, ss.i = z__1.i;
    z_cos(&z__1, &shk);
    cs.r = z__1.r, cs.i = z__1.i;
    z2 = sh - *zob;
    z1 = -(sh + *zob);

/*     EFINT EVALUATES THE INTEGRALS INVOLVING SIN/COS * EXP(-J*XK*R)/R. */

    efint_(slen, rho, zob, xk, xks, exi);
    z__4.r = -conk.r, z__4.i = -conk.i;
    z__3.r = z__4.r * xk->r - z__4.i * xk->i, z__3.i = z__4.r * xk->i + 
	    z__4.i * xk->r;
    z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
	    z__3.i * xk->r;
    z__1.r = z__2.r * exi[0].r - z__2.i * exi[0].i, z__1.i = z__2.r * exi[0]
	    .i + z__2.i * exi[0].r;
    ezk->r = z__1.r, ezk->i = z__1.i;
    r1 = sqrt(z1 * z1 + *rho * *rho);
    r2 = sqrt(z2 * z2 + *rho * *rho);
    z__4.r = xk->r * -0. - xk->i * -1., z__4.i = xk->r * -1. + xk->i * -0.;
    z__3.r = r1 * z__4.r, z__3.i = r1 * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / r1, z__1.i = z__2.i / r1;
    gz1.r = z__1.r, gz1.i = z__1.i;
    z__4.r = xk->r * -0. - xk->i * -1., z__4.i = xk->r * -1. + xk->i * -0.;
    z__3.r = r2 * z__4.r, z__3.i = r2 * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r / r2, z__1.i = z__2.i / r2;
    gz2.r = z__1.r, gz2.i = z__1.i;
    z__5.r = gz2.r - gz1.r, z__5.i = gz2.i - gz1.i;
    z__4.r = xks->r * z__5.r - xks->i * z__5.i, z__4.i = xks->r * z__5.i + 
	    xks->i * z__5.r;
    z__3.r = z__4.r * cs.r - z__4.i * cs.i, z__3.i = z__4.r * cs.i + z__4.i * 
	    cs.r;
    z__6.r = xkdif.r * exi[1].r - xkdif.i * exi[1].i, z__6.i = xkdif.r * exi[
	    1].i + xkdif.i * exi[1].r;
    z__2.r = z__3.r - z__6.r, z__2.i = z__3.i - z__6.i;
    z__1.r = conk.r * z__2.r - conk.i * z__2.i, z__1.i = conk.r * z__2.i + 
	    conk.i * z__2.r;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__3.r = -conk.r, z__3.i = -conk.i;
    z__7.r = gz2.r + gz1.r, z__7.i = gz2.i + gz1.i;
    z__6.r = xks->r * z__7.r - xks->i * z__7.i, z__6.i = xks->r * z__7.i + 
	    xks->i * z__7.r;
    z__5.r = z__6.r * ss.r - z__6.i * ss.i, z__5.i = z__6.r * ss.i + z__6.i * 
	    ss.r;
    z__8.r = xkdif.r * exi[2].r - xkdif.i * exi[2].i, z__8.i = xkdif.r * exi[
	    2].i + xkdif.i * exi[2].r;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__1.r = z__2.r - ezk->r, z__1.i = z__2.i - ezk->i;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    z__8.r = z2 * gz2.r, z__8.i = z2 * gz2.i;
    z__9.r = z1 * gz1.r, z__9.i = z1 * gz1.i;
    z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
    z__6.r = xks->r * z__7.r - xks->i * z__7.i, z__6.i = xks->r * z__7.i + 
	    xks->i * z__7.r;
    z__5.r = z__6.r * cs.r - z__6.i * cs.i, z__5.i = z__6.r * cs.i + z__6.i * 
	    cs.r;
    z__12.r = xk->r * 0.f - xk->i * 1.f, z__12.i = xk->r * 1.f + xk->i * 0.f;
    z__14.r = r2 * gz2.r, z__14.i = r2 * gz2.i;
    z__15.r = r1 * gz1.r, z__15.i = r1 * gz1.i;
    z__13.r = z__14.r + z__15.r, z__13.i = z__14.i + z__15.i;
    z__11.r = z__12.r * z__13.r - z__12.i * z__13.i, z__11.i = z__12.r * 
	    z__13.i + z__12.i * z__13.r;
    z__10.r = z__11.r * ss.r - z__11.i * ss.i, z__10.i = z__11.r * ss.i + 
	    z__11.i * ss.r;
    z__4.r = z__5.r + z__10.r, z__4.i = z__5.i + z__10.i;
    z__16.r = xkdif.r * exi[3].r - xkdif.i * exi[3].i, z__16.i = xkdif.r * 
	    exi[3].i + xkdif.i * exi[3].r;
    z__3.r = z__4.r + z__16.r, z__3.i = z__4.i + z__16.i;
    z__2.r = conk.r * z__3.r - conk.i * z__3.i, z__2.i = conk.r * z__3.i + 
	    conk.i * z__3.r;
    z__1.r = z__2.r / *rho, z__1.i = z__2.i / *rho;
    ers->r = z__1.r, ers->i = z__1.i;
    z__3.r = -conk.r, z__3.i = -conk.i;
    z__9.r = z2 * gz2.r, z__9.i = z2 * gz2.i;
    z__10.r = z1 * gz1.r, z__10.i = z1 * gz1.i;
    z__8.r = z__9.r + z__10.r, z__8.i = z__9.i + z__10.i;
    z__7.r = xks->r * z__8.r - xks->i * z__8.i, z__7.i = xks->r * z__8.i + 
	    xks->i * z__8.r;
    z__6.r = z__7.r * ss.r - z__7.i * ss.i, z__6.i = z__7.r * ss.i + z__7.i * 
	    ss.r;
    z__13.r = xk->r * 0.f - xk->i * 1.f, z__13.i = xk->r * 1.f + xk->i * 0.f;
    z__15.r = r2 * gz2.r, z__15.i = r2 * gz2.i;
    z__16.r = r1 * gz1.r, z__16.i = r1 * gz1.i;
    z__14.r = z__15.r - z__16.r, z__14.i = z__15.i - z__16.i;
    z__12.r = z__13.r * z__14.r - z__13.i * z__14.i, z__12.i = z__13.r * 
	    z__14.i + z__13.i * z__14.r;
    z__11.r = z__12.r * cs.r - z__12.i * cs.i, z__11.i = z__12.r * cs.i + 
	    z__12.i * cs.r;
    z__5.r = z__6.r - z__11.r, z__5.i = z__6.i - z__11.i;
    z__17.r = xkdif.r * exi[4].r - xkdif.i * exi[4].i, z__17.i = xkdif.r * 
	    exi[4].i + xkdif.i * exi[4].r;
    z__4.r = z__5.r - z__17.r, z__4.i = z__5.i - z__17.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__1.r = z__2.r / *rho, z__1.i = z__2.i / *rho;
    erc->r = z__1.r, erc->i = z__1.i;
    return 0;
} /* ekscks_ */

/* Subroutine */ int efint_(doublereal *s, doublereal *rho, doublereal *zzx, 
	doublecomplex *xk, doublecomplex *xks, doublecomplex *exi)
{
    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    double z_abs(doublecomplex *), sqrt(doublereal), log(doublereal);
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r1, r2, z1, z2;
    extern /* Subroutine */ int gf_();
    static doublecomplex ri2;
    static doublereal ri1;
    static doublecomplex ri4, ri5;
    static doublereal zd1, zd2, ri3, rkm;
    static doublecomplex exx;
    static doublereal dmin__;
    static integer icent;
    extern /* Subroutine */ int rombg_(doublereal *, doublereal *, integer *, 
	    S_fp, doublecomplex *, doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     EFINT RETURNS EXI(1)= INTEGRAL OF CEXP(-J*KR)/R */
/*     EXI(2),EXI(3)= INTEGRALS OF (SIN (KS),COS(KS))*CEXP(-J*KR)/R */
/*     EXI(4),EXI(5)= INT. OF (ZP-ZZ)*(SIN(KS),COS(KS))*CEXP(-J*KR)/R */
/*     WHERE KS=XKS*(ZP-ZZ) AND KR=XK*R */

    /* Parameter adjustments */
    --exi;

    /* Function Body */
    tmi_1.zz = *zzx;
    tmi_1.rh2 = *rho * *rho;
    z__1.r = xk->r * 0.f - xk->i * 1.f, z__1.i = xk->r * 1.f + xk->i * 0.f;
    tmi_1.xkj.r = z__1.r, tmi_1.xkj.i = z__1.i;
    z__1.r = xks->r * 0.f - xks->i * 1.f, z__1.i = xks->r * 1.f + xks->i * 
	    0.f;
    tmi_1.xksj.r = z__1.r, tmi_1.xksj.i = z__1.i;
    z2 = *s * .5f;
    z1 = -z2;
    icent = 0;
    if (abs(tmi_1.zz) / *s < 1e-6f) {
	icent = 1;
	z1 = 0.f;
    }
    zd1 = z1 - tmi_1.zz;
    zd2 = z2 - tmi_1.zz;
    rkm = 1.f / z_abs(xk);
    tmi_1.ij = 0;
    if (*rho > rkm) {
	tmi_1.ij = 1;
    }
    if (zd2 < -rkm) {
	tmi_1.ij = 1;
    }
    if (zd1 > rkm) {
	tmi_1.ij = 1;
    }
    dmin__ = 0.f;
    if (tmi_1.ij == 0) {

/*     EVALUATE INT. OF TERMS SUBTRACTED FROM INTEGRAND TO SMOOTH PEAKS */

	r1 = sqrt(zd1 * zd1 + tmi_1.rh2);
	r2 = sqrt(zd2 * zd2 + tmi_1.rh2);
	if (zd2 > 0.f) {
	    ri1 = log((r2 + zd2) / (r1 + zd1));
	} else {
	    ri1 = -log((r2 - zd2) / (r1 - zd1));
	}
	d__1 = z2 - z1;
	z__2.r = d__1 * tmi_1.xkj.r, z__2.i = d__1 * tmi_1.xkj.i;
	z__1.r = ri1 - z__2.r, z__1.i = -z__2.i;
	ri2.r = z__1.r, ri2.i = z__1.i;
	ri3 = r2 - r1;
	z__3.r = tmi_1.xkj.r * .5f, z__3.i = tmi_1.xkj.i * .5f;
	d__1 = zd2 * zd2 - zd1 * zd1;
	z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
	z__1.r = z__2.r - ri3, z__1.i = z__2.i;
	ri4.r = z__1.r, ri4.i = z__1.i;
	d__1 = (zd2 * r2 - zd1 * r1 - tmi_1.rh2 * ri1) * .5f;
	z__1.r = d__1 * tmi_1.xksj.r, z__1.i = d__1 * tmi_1.xksj.i;
	ri5.r = z__1.r, ri5.i = z__1.i;
	dmin__ = ri1 * .01f;
    }

/*     NUMERICAL INTEGRATION */

    rombg_(&z1, &z2, &c__5, (S_fp)gf_, &exi[1], &dmin__, &c_b2744);

/*     ADD INTEGRALS REMOVED TO SMOOTH PEAKS. */

    if (tmi_1.ij == 0) {
	z__2.r = tmi_1.zz * tmi_1.xksj.r, z__2.i = tmi_1.zz * tmi_1.xksj.i;
	z_exp(&z__1, &z__2);
	exx.r = z__1.r, exx.i = z__1.i;
	z__1.r = exi[1].r + ri1, z__1.i = exi[1].i;
	exi[1].r = z__1.r, exi[1].i = z__1.i;
	z__3.r = exi[2].r + ri2.r, z__3.i = exi[2].i + ri2.i;
	z__4.r = ri3 * tmi_1.xksj.r, z__4.i = ri3 * tmi_1.xksj.i;
	z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
	z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
		z__2.i * exx.r;
	exi[2].r = z__1.r, exi[2].i = z__1.i;
	z__3.r = exi[3].r + ri2.r, z__3.i = exi[3].i + ri2.i;
	z__4.r = ri3 * tmi_1.xksj.r, z__4.i = ri3 * tmi_1.xksj.i;
	z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	z_div(&z__1, &z__2, &exx);
	exi[3].r = z__1.r, exi[3].i = z__1.i;
	z__3.r = exi[4].r + ri4.r, z__3.i = exi[4].i + ri4.i;
	z__2.r = z__3.r - ri5.r, z__2.i = z__3.i - ri5.i;
	z__1.r = z__2.r * exx.r - z__2.i * exx.i, z__1.i = z__2.r * exx.i + 
		z__2.i * exx.r;
	exi[4].r = z__1.r, exi[4].i = z__1.i;
	z__3.r = exi[5].r + ri4.r, z__3.i = exi[5].i + ri4.i;
	z__2.r = z__3.r + ri5.r, z__2.i = z__3.i + ri5.i;
	z_div(&z__1, &z__2, &exx);
	exi[5].r = z__1.r, exi[5].i = z__1.i;
    }

/*     CONVERT FROM EXP(+-KZ) TO SIN(KZ), COS(KZ) */

    z__2.r = exi[2].r - exi[3].r, z__2.i = exi[2].i - exi[3].i;
    z__1.r = z__2.r * 0.f - z__2.i * -.5f, z__1.i = z__2.r * -.5f + z__2.i * 
	    0.f;
    exx.r = z__1.r, exx.i = z__1.i;
    z__2.r = exi[2].r + exi[3].r, z__2.i = exi[2].i + exi[3].i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    exi[3].r = z__1.r, exi[3].i = z__1.i;
    exi[2].r = exx.r, exi[2].i = exx.i;
    z__2.r = exi[4].r - exi[5].r, z__2.i = exi[4].i - exi[5].i;
    z__1.r = z__2.r * 0.f - z__2.i * -.5f, z__1.i = z__2.r * -.5f + z__2.i * 
	    0.f;
    exx.r = z__1.r, exx.i = z__1.i;
    z__2.r = exi[4].r + exi[5].r, z__2.i = exi[4].i + exi[5].i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    exi[5].r = z__1.r, exi[5].i = z__1.i;
    exi[4].r = exx.r, exi[4].i = exx.i;
    if (icent == 1) {
	z__1.r = exi[1].r * 2.f, z__1.i = exi[1].i * 2.f;
	exi[1].r = z__1.r, exi[1].i = z__1.i;
	exi[2].r = 0.f, exi[2].i = 0.f;
	z__1.r = exi[3].r * 2.f, z__1.i = exi[3].i * 2.f;
	exi[3].r = z__1.r, exi[3].i = z__1.i;
	z__1.r = exi[4].r * 2.f, z__1.i = exi[4].i * 2.f;
	exi[4].r = z__1.r, exi[4].i = z__1.i;
	exi[5].r = 0.f, exi[5].i = 0.f;
    }
    return 0;
} /* efint_ */

/* Subroutine */ int gf_(doublereal *z__, doublecomplex *ex)
{
    /* Initialized data */

    static doublereal c1 = 1.;
    static doublereal c2 = .5;
    static doublereal c3 = .166666666667;
    static doublereal c4 = .041666666667;
    static doublereal c5 = .00833333333;
    static doublereal c6 = .001388888889;
    static doublereal c7 = 1.98412698e-4;
    static doublereal c8 = 2.48015873e-5;

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static doublecomplex za, rkj;
    static doublereal zdm;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     GF COMPUTES THE INTEGRAND EXP(-JKR)/(KR) FOR NUMERICAL INTEGRATION */

    /* Parameter adjustments */
    --ex;

    /* Function Body */
    zdm = *z__ - tmi_1.zz;
    r__ = sqrt(tmi_1.rh2 + zdm * zdm);
    z__2.r = -tmi_1.xkj.r, z__2.i = -tmi_1.xkj.i;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    rkj.r = z__1.r, rkj.i = z__1.i;
    if (tmi_1.ij != 0) {

/*     COMPLETE INTEGRAND */

	z_exp(&z__2, &rkj);
	z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	ex[1].r = z__1.r, ex[1].i = z__1.i;
	z__4.r = *z__ * tmi_1.xksj.r, z__4.i = *z__ * tmi_1.xksj.i;
	z__3.r = rkj.r + z__4.r, z__3.i = rkj.i + z__4.i;
	z_exp(&z__2, &z__3);
	z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	ex[2].r = z__1.r, ex[2].i = z__1.i;
	z__4.r = *z__ * tmi_1.xksj.r, z__4.i = *z__ * tmi_1.xksj.i;
	z__3.r = rkj.r - z__4.r, z__3.i = rkj.i - z__4.i;
	z_exp(&z__2, &z__3);
	z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	ex[3].r = z__1.r, ex[3].i = z__1.i;
    } else {

/*     INTEGRAND WITH TERMS REMOVED TO SMOOTH PEAKS */

	if (z_abs(&rkj) > .2f) {
	    z_exp(&z__3, &rkj);
	    z__2.r = z__3.r - 1.f, z__2.i = z__3.i;
	    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	    ex[1].r = z__1.r, ex[1].i = z__1.i;
	    z__2.r = zdm * tmi_1.xksj.r, z__2.i = zdm * tmi_1.xksj.i;
	    z__1.r = rkj.r + z__2.r, z__1.i = rkj.i + z__2.i;
	    za.r = z__1.r, za.i = z__1.i;
	    z_exp(&z__3, &za);
	    z__4.r = za.r + 1.f, z__4.i = za.i;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	    ex[2].r = z__1.r, ex[2].i = z__1.i;
	    z__2.r = zdm * tmi_1.xksj.r, z__2.i = zdm * tmi_1.xksj.i;
	    z__1.r = rkj.r - z__2.r, z__1.i = rkj.i - z__2.i;
	    za.r = z__1.r, za.i = z__1.i;
	    z_exp(&z__3, &za);
	    z__4.r = za.r + 1.f, z__4.i = za.i;
	    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	    ex[3].r = z__1.r, ex[3].i = z__1.i;
	} else {

/*     INTEGRAND WITH TERMS REMOVED TO SMOOTH PEAKS (SMALL ARGUMENT) */

	    za.r = rkj.r, za.i = rkj.i;
	    z__14.r = c7 * za.r, z__14.i = c7 * za.i;
	    z__13.r = z__14.r + c6, z__13.i = z__14.i;
	    z__12.r = z__13.r * za.r - z__13.i * za.i, z__12.i = z__13.r * 
		    za.i + z__13.i * za.r;
	    z__11.r = z__12.r + c5, z__11.i = z__12.i;
	    z__10.r = z__11.r * za.r - z__11.i * za.i, z__10.i = z__11.r * 
		    za.i + z__11.i * za.r;
	    z__9.r = z__10.r + c4, z__9.i = z__10.i;
	    z__8.r = z__9.r * za.r - z__9.i * za.i, z__8.i = z__9.r * za.i + 
		    z__9.i * za.r;
	    z__7.r = z__8.r + c3, z__7.i = z__8.i;
	    z__6.r = z__7.r * za.r - z__7.i * za.i, z__6.i = z__7.r * za.i + 
		    z__7.i * za.r;
	    z__5.r = z__6.r + c2, z__5.i = z__6.i;
	    z__4.r = z__5.r * za.r - z__5.i * za.i, z__4.i = z__5.r * za.i + 
		    z__5.i * za.r;
	    z__3.r = z__4.r + c1, z__3.i = z__4.i;
	    z__2.r = -z__3.r, z__2.i = -z__3.i;
	    z__1.r = z__2.r * tmi_1.xkj.r - z__2.i * tmi_1.xkj.i, z__1.i = 
		    z__2.r * tmi_1.xkj.i + z__2.i * tmi_1.xkj.r;
	    ex[1].r = z__1.r, ex[1].i = z__1.i;
	    z__2.r = zdm * tmi_1.xksj.r, z__2.i = zdm * tmi_1.xksj.i;
	    z__1.r = rkj.r + z__2.r, z__1.i = rkj.i + z__2.i;
	    za.r = z__1.r, za.i = z__1.i;
	    z__15.r = c8 * za.r, z__15.i = c8 * za.i;
	    z__14.r = z__15.r + c7, z__14.i = z__15.i;
	    z__13.r = z__14.r * za.r - z__14.i * za.i, z__13.i = z__14.r * 
		    za.i + z__14.i * za.r;
	    z__12.r = z__13.r + c6, z__12.i = z__13.i;
	    z__11.r = z__12.r * za.r - z__12.i * za.i, z__11.i = z__12.r * 
		    za.i + z__12.i * za.r;
	    z__10.r = z__11.r + c5, z__10.i = z__11.i;
	    z__9.r = z__10.r * za.r - z__10.i * za.i, z__9.i = z__10.r * za.i 
		    + z__10.i * za.r;
	    z__8.r = z__9.r + c4, z__8.i = z__9.i;
	    z__7.r = z__8.r * za.r - z__8.i * za.i, z__7.i = z__8.r * za.i + 
		    z__8.i * za.r;
	    z__6.r = z__7.r + c3, z__6.i = z__7.i;
	    z__5.r = z__6.r * za.r - z__6.i * za.i, z__5.i = z__6.r * za.i + 
		    z__6.i * za.r;
	    z__4.r = z__5.r + c2, z__4.i = z__5.i;
	    z__3.r = z__4.r * za.r - z__4.i * za.i, z__3.i = z__4.r * za.i + 
		    z__4.i * za.r;
	    z__2.r = z__3.r * za.r - z__3.i * za.i, z__2.i = z__3.r * za.i + 
		    z__3.i * za.r;
	    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	    ex[2].r = z__1.r, ex[2].i = z__1.i;
	    z__2.r = zdm * tmi_1.xksj.r, z__2.i = zdm * tmi_1.xksj.i;
	    z__1.r = rkj.r - z__2.r, z__1.i = rkj.i - z__2.i;
	    za.r = z__1.r, za.i = z__1.i;
	    z__15.r = c8 * za.r, z__15.i = c8 * za.i;
	    z__14.r = z__15.r + c7, z__14.i = z__15.i;
	    z__13.r = z__14.r * za.r - z__14.i * za.i, z__13.i = z__14.r * 
		    za.i + z__14.i * za.r;
	    z__12.r = z__13.r + c6, z__12.i = z__13.i;
	    z__11.r = z__12.r * za.r - z__12.i * za.i, z__11.i = z__12.r * 
		    za.i + z__12.i * za.r;
	    z__10.r = z__11.r + c5, z__10.i = z__11.i;
	    z__9.r = z__10.r * za.r - z__10.i * za.i, z__9.i = z__10.r * za.i 
		    + z__10.i * za.r;
	    z__8.r = z__9.r + c4, z__8.i = z__9.i;
	    z__7.r = z__8.r * za.r - z__8.i * za.i, z__7.i = z__8.r * za.i + 
		    z__8.i * za.r;
	    z__6.r = z__7.r + c3, z__6.i = z__7.i;
	    z__5.r = z__6.r * za.r - z__6.i * za.i, z__5.i = z__6.r * za.i + 
		    z__6.i * za.r;
	    z__4.r = z__5.r + c2, z__4.i = z__5.i;
	    z__3.r = z__4.r * za.r - z__4.i * za.i, z__3.i = z__4.r * za.i + 
		    z__4.i * za.r;
	    z__2.r = z__3.r * za.r - z__3.i * za.i, z__2.i = z__3.r * za.i + 
		    z__3.i * za.r;
	    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
	    ex[3].r = z__1.r, ex[3].i = z__1.i;
	}
    }
    d__1 = -zdm;
    z__1.r = d__1 * ex[2].r, z__1.i = d__1 * ex[2].i;
    ex[4].r = z__1.r, ex[4].i = z__1.i;
    d__1 = -zdm;
    z__1.r = d__1 * ex[3].r, z__1.i = d__1 * ex[3].i;
    ex[5].r = z__1.r, ex[5].i = z__1.i;
    return 0;
} /* gf_ */

/* Subroutine */ int eksclr_(doublereal *slen, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezcm, doublecomplex *ers, 
	doublecomplex *erc)
{
    /* Initialized data */

    static doublecomplex con = {0.,.07957747151};
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15, z__16, z__17;

    /* Builtin functions */
    double sqrt(doublereal), z_abs(doublecomplex *);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex a1, a2, d1, d2, d3;
    static doublereal sh, rz, zs;
    static doublecomplex ar1, ar2;
    static doublereal rhs, shs, rrz, rzs, trm1, trm2, trm3, trm4, trm5;
    static doublecomplex conr;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCLR computes the components of electric field for a segment */
/*     with constant, SIN(KS) and COS(KS)-1 current distributions. */
/*     Series approximations for R large relative to segment length are */
/*     used. */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM= Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */
/*     (CONSTANT CURRENT PRODUCES ZERO RHO COMPONENT OF E) */


/*     SERIES FOR R LARGE RELATIVE TO SEGMENT LENGTH AND SEGMENT LENGTH */
/*     LESS THAN APPROXIMATELY 0.2 WAVELENGTHS. */

    sh = .5f * *slen;
    shs = sh * sh;
    rhs = *rho * *rho;
    zs = *zob * *zob;
    rzs = rhs + zs;
    rz = sqrt(rzs);
    rrz = 1.f / rz;
    z__2.r = -fj.r, z__2.i = -fj.i;
    z__1.r = z__2.r * xk->r - z__2.i * xk->i, z__1.i = z__2.r * xk->i + 
	    z__2.i * xk->r;
    a1.r = z__1.r, a1.i = z__1.i;
    z__1.r = rz * a1.r, z__1.i = rz * a1.i;
    ar1.r = z__1.r, ar1.i = z__1.i;
    if (z_abs(xk) * rz < .062831f) {
	goto L1;
    }
    z__1.r = a1.r * a1.r - a1.i * a1.i, z__1.i = a1.r * a1.i + a1.i * a1.r;
    a2.r = z__1.r, a2.i = z__1.i;
    z__3.r = *slen * con.r, z__3.i = *slen * con.i;
    z__2.r = z__3.r * eta->r - z__3.i * eta->i, z__2.i = z__3.r * eta->i + 
	    z__3.i * eta->r;
    z_exp(&z__4, &ar1);
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    conr.r = z__1.r, conr.i = z__1.i;
    z__3.r = rrz - a1.r, z__3.i = -a1.i;
    z__2.r = *zob * z__3.r, z__2.i = *zob * z__3.i;
    z__1.r = z__2.r / rzs, z__1.i = z__2.i / rzs;
    d1.r = z__1.r, d1.i = z__1.i;
    d__1 = rrz * .5f;
    d__2 = zs * 2.f - rhs;
    z__6.r = rrz - a1.r, z__6.i = -a1.i;
    z__5.r = d__2 * z__6.r, z__5.i = d__2 * z__6.i;
    z__4.r = rrz * z__5.r, z__4.i = rrz * z__5.i;
    z__7.r = zs * a2.r, z__7.i = zs * a2.i;
    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
    z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
    z__1.r = z__2.r / rzs, z__1.i = z__2.i / rzs;
    d2.r = z__1.r, d2.i = z__1.i;
    d__1 = *zob * .5f / rzs;
    d__2 = zs * 2.f - rhs * 3.f;
    z__8.r = rrz - a1.r, z__8.i = -a1.i;
    z__7.r = d__2 * z__8.r, z__7.i = d__2 * z__8.i;
    z__6.r = rrz * z__7.r, z__6.i = rrz * z__7.i;
    d__3 = zs - rhs;
    z__9.r = d__3 * a2.r, z__9.i = d__3 * a2.i;
    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
    z__4.r = rrz * z__5.r, z__4.i = rrz * z__5.i;
    z__12.r = a2.r * .3333333f, z__12.i = a2.i * .3333333f;
    z__11.r = zs * z__12.r, z__11.i = zs * z__12.i;
    z__10.r = z__11.r * a1.r - z__11.i * a1.i, z__10.i = z__11.r * a1.i + 
	    z__11.i * a1.r;
    z__3.r = z__4.r - z__10.r, z__3.i = z__4.i - z__10.i;
    z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
    z__1.r = z__2.r / rzs, z__1.i = z__2.i / rzs;
    d3.r = z__1.r, d3.i = z__1.i;
    z__9.r = -conr.r, z__9.i = -conr.i;
    z__8.r = z__9.r * xk->r - z__9.i * xk->i, z__8.i = z__9.r * xk->i + 
	    z__9.i * xk->r;
    z__7.r = *zob * z__8.r, z__7.i = *zob * z__8.i;
    z__6.r = *rho * z__7.r, z__6.i = *rho * z__7.i;
    z__5.r = z__6.r / rzs, z__5.i = z__6.i / rzs;
    z__4.r = shs * z__5.r, z__4.i = shs * z__5.i;
    z__3.r = z__4.r / rzs, z__3.i = z__4.i / rzs;
    z__13.r = ar1.r * .33333333f, z__13.i = ar1.i * .33333333f;
    z__12.r = z__13.r - 1.f, z__12.i = z__13.i;
    z__11.r = z__12.r * ar1.r - z__12.i * ar1.i, z__11.i = z__12.r * ar1.i + 
	    z__12.i * ar1.r;
    z__10.r = z__11.r + 1.f, z__10.i = z__11.i;
    z__2.r = z__3.r * z__10.r - z__3.i * z__10.i, z__2.i = z__3.r * z__10.i + 
	    z__3.i * z__10.r;
    z__1.r = rrz * z__2.r, z__1.i = rrz * z__2.i;
    erc->r = z__1.r, erc->i = z__1.i;
    z__5.r = -conr.r, z__5.i = -conr.i;
    z__4.r = *rho * z__5.r, z__4.i = *rho * z__5.i;
    z__3.r = z__4.r / rzs, z__3.i = z__4.i / rzs;
    z__7.r = ar1.r - 1.f, z__7.i = ar1.i;
    d__1 = shs / rzs;
    d__2 = (rhs - zs * 4.f) * .5f;
    z__13.r = rrz - a1.r, z__13.i = -a1.i;
    z__12.r = d__2 * z__13.r, z__12.i = d__2 * z__13.i;
    z__11.r = rrz * z__12.r, z__11.i = rrz * z__12.i;
    z__14.r = zs * a2.r, z__14.i = zs * a2.i;
    z__10.r = z__11.r - z__14.r, z__10.i = z__11.i - z__14.i;
    z__17.r = a2.r * .16666667f, z__17.i = a2.i * .16666667f;
    d__3 = rhs + zs * 2.f;
    z__16.r = d__3 * z__17.r, z__16.i = d__3 * z__17.i;
    z__15.r = z__16.r * ar1.r - z__16.i * ar1.i, z__15.i = z__16.r * ar1.i + 
	    z__16.i * ar1.r;
    z__9.r = z__10.r + z__15.r, z__9.i = z__10.i + z__15.i;
    z__8.r = d__1 * z__9.r, z__8.i = d__1 * z__9.i;
    z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
    z__2.r = z__3.r * z__6.r - z__3.i * z__6.i, z__2.i = z__3.r * z__6.i + 
	    z__3.i * z__6.r;
    z__1.r = rrz * z__2.r, z__1.i = rrz * z__2.i;
    ers->r = z__1.r, ers->i = z__1.i;
    z__3.r = -conr.r, z__3.i = -conr.i;
    z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
	    z__3.i * xk->r;
    z__6.r = d2.r * .3333333f, z__6.i = d2.i * .3333333f;
    z__5.r = shs * z__6.r, z__5.i = shs * z__6.i;
    z__4.r = rrz + z__5.r, z__4.i = z__5.i;
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    ezk->r = z__1.r, ezk->i = z__1.i;
    z__6.r = a2.r * .5f, z__6.i = a2.i * .5f;
    z__5.r = z__6.r * d1.r - z__6.i * d1.i, z__5.i = z__6.r * d1.i + z__6.i * 
	    d1.r;
    z__4.r = d3.r + z__5.r, z__4.i = d3.i + z__5.i;
    z__3.r = shs * z__4.r, z__3.i = shs * z__4.i;
    z__2.r = d1.r + z__3.r, z__2.i = d1.i + z__3.i;
    z__1.r = conr.r * z__2.r - conr.i * z__2.i, z__1.i = conr.r * z__2.i + 
	    conr.i * z__2.r;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__5.r = -conr.r, z__5.i = -conr.i;
    z__4.r = z__5.r * xk->r - z__5.i * xk->i, z__4.i = z__5.r * xk->i + 
	    z__5.i * xk->r;
    z__3.r = shs * z__4.r, z__3.i = shs * z__4.i;
    z__2.r = z__3.r * .16666667f, z__2.i = z__3.i * .16666667f;
    z__7.r = d2.r * 4.f, z__7.i = d2.i * 4.f;
    z__8.r = rrz * a2.r, z__8.i = rrz * a2.i;
    z__6.r = z__7.r + z__8.r, z__6.i = z__7.i + z__8.i;
    z__1.r = z__2.r * z__6.r - z__2.i * z__6.i, z__1.i = z__2.r * z__6.i + 
	    z__2.i * z__6.r;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    return 0;

/*     SERIES FOR R LARGE RELATIVE TO SEGMENT LENGTH AND FOR KR AND */
/*     K*SLEN SMALL. */

L1:
    z__1.r = ar1.r * ar1.r - ar1.i * ar1.i, z__1.i = ar1.r * ar1.i + ar1.i * 
	    ar1.r;
    ar2.r = z__1.r, ar2.i = z__1.i;
    d__1 = sh / rzs;
    z__2.r = d__1 * con.r, z__2.i = d__1 * con.i;
    z__1.r = z__2.r * eta->r - z__2.i * eta->i, z__1.i = z__2.r * eta->i + 
	    z__2.i * eta->r;
    conr.r = z__1.r, conr.i = z__1.i;
    z__3.r = -conr.r, z__3.i = -conr.i;
    z__2.r = z__3.r * 2.f, z__2.i = z__3.i * 2.f;
    z__11.r = ar1.r * .03333333f, z__11.i = ar1.i * .03333333f;
    z__10.r = z__11.r + .125f, z__10.i = z__11.i;
    z__9.r = z__10.r * ar1.r - z__10.i * ar1.i, z__9.i = z__10.r * ar1.i + 
	    z__10.i * ar1.r;
    z__8.r = z__9.r + .33333333f, z__8.i = z__9.i;
    z__7.r = z__8.r * ar1.r - z__8.i * ar1.i, z__7.i = z__8.r * ar1.i + 
	    z__8.i * ar1.r;
    z__6.r = z__7.r + .5f, z__6.i = z__7.i;
    z__5.r = z__6.r * ar2.r - z__6.i * ar2.i, z__5.i = z__6.r * ar2.i + 
	    z__6.i * ar2.r;
    z__4.r = z__5.r - 1.f, z__4.i = z__5.i;
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    ezs->r = z__1.r, ezs->i = z__1.i;
    d__1 = *rho * rrz;
    z__1.r = d__1 * ezs->r, z__1.i = d__1 * ezs->i;
    ers->r = z__1.r, ers->i = z__1.i;
    d__1 = *zob * rrz;
    z__1.r = d__1 * ezs->r, z__1.i = d__1 * ezs->i;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__8.r = conr.r * -.66666666666666663f, z__8.i = conr.i * 
	    -.66666666666666663f;
    z__7.r = z__8.r * xk->r - z__8.i * xk->i, z__7.i = z__8.r * xk->i + 
	    z__8.i * xk->r;
    z__6.r = *rho * z__7.r, z__6.i = *rho * z__7.i;
    z__5.r = *zob * z__6.r, z__5.i = *zob * z__6.i;
    z__4.r = z__5.r / rzs, z__4.i = z__5.i / rzs;
    z__3.r = shs * z__4.r, z__3.i = shs * z__4.i;
    z__2.r = rrz * z__3.r, z__2.i = rrz * z__3.i;
    z__14.r = ar1.r * .066666667f, z__14.i = ar1.i * .066666667f;
    z__13.r = z__14.r + .125f, z__13.i = z__14.i;
    z__12.r = z__13.r * ar2.r - z__13.i * ar2.i, z__12.i = z__13.r * ar2.i + 
	    z__13.i * ar2.r;
    z__11.r = z__12.r - .5f, z__11.i = z__12.i;
    z__10.r = z__11.r * ar2.r - z__11.i * ar2.i, z__10.i = z__11.r * ar2.i + 
	    z__11.i * ar2.r;
    z__9.r = z__10.r + 3.f, z__9.i = z__10.i;
    z__1.r = z__2.r * z__9.r - z__2.i * z__9.i, z__1.i = z__2.r * z__9.i + 
	    z__2.i * z__9.r;
    erc->r = z__1.r, erc->i = z__1.i;
    trm1 = (zs * 2.f - rhs) * 2.f;
    trm2 = zs + rhs * 2.f;
    trm3 = rzs * 1.6666667f;
    trm4 = (zs * 4.f + rhs * 3.f) * .25f;
    trm5 = (rhs * 9.f - zs * 13.f) * .008333333f;
    z__6.r = -conr.r, z__6.i = -conr.i;
    z__5.r = z__6.r * xk->r - z__6.i * xk->i, z__5.i = z__6.r * xk->i + 
	    z__6.i * xk->r;
    z__4.r = shs * z__5.r, z__4.i = shs * z__5.i;
    d__1 = rz * 3.f;
    z__3.r = z__4.r / d__1, z__3.i = z__4.i / d__1;
    z__14.r = trm5 * ar1.r, z__14.i = trm5 * ar1.i;
    z__13.r = z__14.r + trm4, z__13.i = z__14.i;
    z__12.r = z__13.r * ar1.r - z__13.i * ar1.i, z__12.i = z__13.r * ar1.i + 
	    z__13.i * ar1.r;
    z__11.r = z__12.r + trm3, z__11.i = z__12.i;
    z__10.r = z__11.r * ar1.r - z__11.i * ar1.i, z__10.i = z__11.r * ar1.i + 
	    z__11.i * ar1.r;
    z__9.r = z__10.r + trm2, z__9.i = z__10.i;
    z__8.r = z__9.r * ar2.r - z__9.i * ar2.i, z__8.i = z__9.r * ar2.i + 
	    z__9.i * ar2.r;
    z__7.r = z__8.r + trm1, z__7.i = z__8.i;
    z__2.r = z__3.r * z__7.r - z__3.i * z__7.i, z__2.i = z__3.r * z__7.i + 
	    z__3.i * z__7.r;
    z__1.r = z__2.r / rzs, z__1.i = z__2.i / rzs;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    trm1 = rzs * 6.f + (zs * 2.f - rhs) / rzs * shs;
    trm2 = rzs * 6.f;
    trm3 = rzs * 3.f + shs * .5f / rzs * rhs;
    trm4 = rzs + shs;
    z__4.r = -conr.r, z__4.i = -conr.i;
    z__3.r = z__4.r * xk->r - z__4.i * xk->i, z__3.i = z__4.r * xk->i + 
	    z__4.i * xk->r;
    d__1 = rz * 3.f;
    z__2.r = z__3.r / d__1, z__2.i = z__3.i / d__1;
    z__10.r = trm4 * ar1.r, z__10.i = trm4 * ar1.i;
    z__9.r = z__10.r + trm3, z__9.i = z__10.i;
    z__8.r = z__9.r * ar1.r - z__9.i * ar1.i, z__8.i = z__9.r * ar1.i + 
	    z__9.i * ar1.r;
    z__7.r = z__8.r + trm2, z__7.i = z__8.i;
    z__6.r = z__7.r * ar1.r - z__7.i * ar1.i, z__6.i = z__7.r * ar1.i + 
	    z__7.i * ar1.r;
    z__5.r = z__6.r + trm1, z__5.i = z__6.i;
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    ezk->r = z__1.r, ezk->i = z__1.i;
    return 0;
} /* eksclr_ */

/* Subroutine */ int esmlrh_(doublereal *segl, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *ers, 
	doublecomplex *erc)
{
    /* Initialized data */

    static doublecomplex con = {0.,.079577471};
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14;

    /* Builtin functions */
    void z_exp(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublereal sh;
    static doublecomplex xk2, xk3;
    static doublereal den, abz;
    static doublecomplex xkj;
    static doublereal zsq, shsq;
    static doublecomplex exkz, term1, term2, term3, term4, coskd, exmkd, 
	    sinkd, expkd;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     ESMLRH computes the RHO component of the E field of SIN(K*S) and */
/*     COS(K*S) current filaments by an approximation for small RHO. */
/*     The relative error in the approximation is of order (RHO/ZMIN)**2 */
/*     where ZMIN=ABS(ZOB)-.5*ABS(SEGL). */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */

/*     OUTPUT: */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */
/*     (CONSTANT CURRENT PRODUCES ZERO RHO COMPONENT OF E) */

    sh = .5f * *segl;
    z__1.r = fj.r * xk->r - fj.i * xk->i, z__1.i = fj.r * xk->i + fj.i * 
	    xk->r;
    xkj.r = z__1.r, xkj.i = z__1.i;
    abz = abs(*zob);
    z__3.r = -xkj.r, z__3.i = -xkj.i;
    z__2.r = abz * z__3.r, z__2.i = abz * z__3.i;
    z_exp(&z__1, &z__2);
    exkz.r = z__1.r, exkz.i = z__1.i;
    z__3.r = -xkj.r, z__3.i = -xkj.i;
    z__2.r = sh * z__3.r, z__2.i = sh * z__3.i;
    z_exp(&z__1, &z__2);
    exmkd.r = z__1.r, exmkd.i = z__1.i;
    z_div(&z__1, &c_b336, &exmkd);
    expkd.r = z__1.r, expkd.i = z__1.i;
    z__2.r = expkd.r + exmkd.r, z__2.i = expkd.i + exmkd.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    coskd.r = z__1.r, coskd.i = z__1.i;
    z__2.r = exmkd.r - expkd.r, z__2.i = exmkd.i - expkd.i;
    z__1.r = z__2.r * 0.f - z__2.i * .5f, z__1.i = z__2.r * .5f + z__2.i * 
	    0.f;
    sinkd.r = z__1.r, sinkd.i = z__1.i;
/* Computing 2nd power */
    d__2 = abz + sh;
    d__1 = d__2 * d__2;
    z__1.r = exmkd.r / d__1, z__1.i = exmkd.i / d__1;
    term1.r = z__1.r, term1.i = z__1.i;
/* Computing 2nd power */
    d__2 = abz - sh;
    d__1 = d__2 * d__2;
    z__1.r = expkd.r / d__1, z__1.i = expkd.i / d__1;
    term2.r = z__1.r, term2.i = z__1.i;
    z__2.r = sh * xk->r, z__2.i = sh * xk->i;
/* Computing 2nd power */
    d__2 = abz;
/* Computing 2nd power */
    d__3 = sh;
    d__1 = d__2 * d__2 - d__3 * d__3;
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    term3.r = z__1.r, term3.i = z__1.i;
    z__1.r = *zob * xk->r, z__1.i = *zob * xk->i;
    if (z_abs(&z__1) > .125f) {
	z__4.r = -con.r, z__4.i = -con.i;
	z__3.r = z__4.r * eta->r - z__4.i * eta->i, z__3.i = z__4.r * eta->i 
		+ z__4.i * eta->r;
	z__2.r = *rho * z__3.r, z__2.i = *rho * z__3.i;
	z__1.r = z__2.r * exkz.r - z__2.i * exkz.i, z__1.i = z__2.r * exkz.i 
		+ z__2.i * exkz.r;
	term4.r = z__1.r, term4.i = z__1.i;
	z__5.r = term1.r - term2.r, z__5.i = term1.i - term2.i;
	z__4.r = z__5.r * .5f, z__4.i = z__5.i * .5f;
	z__3.r = z__4.r * coskd.r - z__4.i * coskd.i, z__3.i = z__4.r * 
		coskd.i + z__4.i * coskd.r;
	z__6.r = fj.r * term3.r - fj.i * term3.i, z__6.i = fj.r * term3.i + 
		fj.i * term3.r;
	z__2.r = z__3.r - z__6.r, z__2.i = z__3.i - z__6.i;
	z__1.r = term4.r * z__2.r - term4.i * z__2.i, z__1.i = term4.r * 
		z__2.i + term4.i * z__2.r;
	ers->r = z__1.r, ers->i = z__1.i;
	z__5.r = term1.r + term2.r, z__5.i = term1.i + term2.i;
	z__4.r = z__5.r * .5f, z__4.i = z__5.i * .5f;
	z__3.r = z__4.r * sinkd.r - z__4.i * sinkd.i, z__3.i = z__4.r * 
		sinkd.i + z__4.i * sinkd.r;
	z__2.r = z__3.r - term3.r, z__2.i = z__3.i - term3.i;
	z__1.r = term4.r * z__2.r - term4.i * z__2.i, z__1.i = term4.r * 
		z__2.i + term4.i * z__2.r;
	erc->r = z__1.r, erc->i = z__1.i;
    } else {
	zsq = *zob * *zob;
	shsq = sh * sh;
	den = 1.f / (zsq - shsq);
	z__1.r = xk->r * xk->r - xk->i * xk->i, z__1.i = xk->r * xk->i + 
		xk->i * xk->r;
	xk2.r = z__1.r, xk2.i = z__1.i;
	z__1.r = xk2.r * xk->r - xk2.i * xk->i, z__1.i = xk2.r * xk->i + 
		xk2.i * xk->r;
	xk3.r = z__1.r, xk3.i = z__1.i;
	d__1 = zsq - shsq * 2.f;
	z__1.r = d__1 * xk2.r, z__1.i = d__1 * xk2.i;
	term1.r = z__1.r, term1.i = z__1.i;
	z__3.r = con.r * eta->r - con.i * eta->i, z__3.i = con.r * eta->i + 
		con.i * eta->r;
	z__2.r = *rho * z__3.r, z__2.i = *rho * z__3.i;
	z__1.r = sh * z__2.r, z__1.i = sh * z__2.i;
	term4.r = z__1.r, term4.i = z__1.i;
	d__1 = abz * den;
	z__5.r = term1.r + 2.f, z__5.i = term1.i;
	z__4.r = d__1 * z__5.r, z__4.i = d__1 * z__5.i;
	z__3.r = den * z__4.r, z__3.i = den * z__4.i;
	z__8.r = fj.r * xk3.r - fj.i * xk3.i, z__8.i = fj.r * xk3.i + fj.i * 
		xk3.r;
	z__7.r = z__8.r * 2.f, z__7.i = z__8.i * 2.f;
	z__6.r = z__7.r / 3.f, z__6.i = z__7.i / 3.f;
	z__2.r = z__3.r - z__6.r, z__2.i = z__3.i - z__6.i;
	z__1.r = term4.r * z__2.r - term4.i * z__2.i, z__1.i = term4.r * 
		z__2.i + term4.i * z__2.r;
	ers->r = z__1.r, ers->i = z__1.i;
	z__3.r = -term4.r, z__3.i = -term4.i;
	z__2.r = z__3.r * xk->r - z__3.i * xk->i, z__2.i = z__3.r * xk->i + 
		z__3.i * xk->r;
	d__1 = shsq * den;
	z__8.r = term1.r / 3.f, z__8.i = term1.i / 3.f;
	z__7.r = z__8.r + 2.f, z__7.i = z__8.i;
	z__6.r = d__1 * z__7.r, z__6.i = d__1 * z__7.i;
	z__5.r = den * z__6.r, z__5.i = den * z__6.i;
	z__14.r = fj.r * xk3.r - fj.i * xk3.i, z__14.i = fj.r * xk3.i + fj.i *
		 xk3.r;
	z__13.r = shsq * z__14.r, z__13.i = shsq * z__14.i;
	z__12.r = z__13.r * xk2.r - z__13.i * xk2.i, z__12.i = z__13.r * 
		xk2.i + z__13.i * xk2.r;
	z__11.r = abz * z__12.r, z__11.i = abz * z__12.i;
	z__10.r = z__11.r * 2.f, z__10.i = z__11.i * 2.f;
	z__9.r = z__10.r / 45.f, z__9.i = z__10.i / 45.f;
	z__4.r = z__5.r - z__9.r, z__4.i = z__5.i - z__9.i;
	z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i 
		+ z__2.i * z__4.r;
	erc->r = z__1.r, erc->i = z__1.i;
    }
    if (*zob < 0.f) {
	z__1.r = -erc->r, z__1.i = -erc->i;
	erc->r = z__1.r, erc->i = z__1.i;
    }
    return 0;
} /* esmlrh_ */

/* Subroutine */ int exrint_(doublereal *rho, doublereal *zob, doublereal *
	slen, doublecomplex *xk, doublecomplex *exri)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11;

    /* Builtin functions */
    double sqrt(doublereal), log(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r0, r1, s1, s2, r2, sh;
    static doublecomplex rx;
    static doublereal rz, ri1, ri2, ri3, ri4, ri5;
    static doublecomplex tm1, tm2, tm3, tm4, tm5;
    static doublereal ss1, rs1, ss2, rs2, r0s;
    static doublecomplex xkj;
    static doublereal rhs;
    static doublecomplex xjs;
    static doublereal difr;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EXRINT evaluates the integral of EXP(-J*K*R)/R integrated over a */
/*     segment. */

/*     INPUT: */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     SLEN = SEGMENT LENGTH (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */

/*     OUTPUT: */
/*     EXRI = INTEGRAL OF EXP(-J*K*R)/R */

    z__1.r = xk->r * -0.f - xk->i * -1.f, z__1.i = xk->r * -1.f + xk->i * 
	    -0.f;
    xkj.r = z__1.r, xkj.i = z__1.i;
    rhs = *rho * *rho;
    sh = *slen * .5f;
    if (rhs + *zob * *zob > *slen * 36.f * *slen) {
	goto L1;
    }

/*     SERIES APPROXIMATION FOR INTEGRAL OF EXP(-J*K*R)/R. */

    s1 = -sh - *zob;
    ss1 = s1 * s1;
    rs1 = rhs + ss1;
    r1 = sqrt(rs1);
    s2 = sh - *zob;
    ss2 = s2 * s2;
    rs2 = rhs + ss2;
    r2 = sqrt(rs2);

/*     RIN IS THE INTEGRAL OF R**(N-2) FROM -SH TO SH */

    if (s1 > 0.f) {
	ri1 = log((r2 + s2) / (r1 + s1));
    } else {
	difr = r2 - s2;
	if (s2 > 0.f && *rho < r2 * .05f) {
	    difr = rhs * .5f / s2 * (1.f - rhs * .25f / ss2);
	}
	ri1 = log((r1 - s1) / difr);
    }
    ri2 = s2 - s1;
    ri3 = (rhs * ri1 + s2 * r2 - s1 * r1) * .5f;
    ri4 = rhs * ri2 + (ss2 * s2 - ss1 * s1) / 3.f;
    ri5 = rhs * .75f * ri3 + (s2 * rs2 * r2 - s1 * rs1 * r1) * .25f;
    z__1.r = xkj.r * xkj.r - xkj.i * xkj.i, z__1.i = xkj.r * xkj.i + xkj.i * 
	    xkj.r;
    xjs.r = z__1.r, xjs.i = z__1.i;
    rz = sqrt(rhs + *zob * *zob);
    z__1.r = rz * xkj.r, z__1.i = rz * xkj.i;
    rx.r = z__1.r, rx.i = z__1.i;
    z__8.r = rx.r * .0416666666667f, z__8.i = rx.i * .0416666666667f;
    z__7.r = z__8.r - .166666666667f, z__7.i = z__8.i;
    z__6.r = z__7.r * rx.r - z__7.i * rx.i, z__6.i = z__7.r * rx.i + z__7.i * 
	    rx.r;
    z__5.r = z__6.r + .5f, z__5.i = z__6.i;
    z__4.r = z__5.r * rx.r - z__5.i * rx.i, z__4.i = z__5.r * rx.i + z__5.i * 
	    rx.r;
    z__3.r = z__4.r - 1.f, z__3.i = z__4.i;
    z__2.r = z__3.r * rx.r - z__3.i * rx.i, z__2.i = z__3.r * rx.i + z__3.i * 
	    rx.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    tm1.r = z__1.r, tm1.i = z__1.i;
    z__2.r = -xkj.r, z__2.i = -xkj.i;
    z__8.r = rx.r * .166666666667f, z__8.i = rx.i * .166666666667f;
    z__7.r = z__8.r - .5f, z__7.i = z__8.i;
    z__6.r = z__7.r * rx.r - z__7.i * rx.i, z__6.i = z__7.r * rx.i + z__7.i * 
	    rx.r;
    z__5.r = z__6.r + 1.f, z__5.i = z__6.i;
    z__4.r = z__5.r * rx.r - z__5.i * rx.i, z__4.i = z__5.r * rx.i + z__5.i * 
	    rx.r;
    z__3.r = z__4.r - 1.f, z__3.i = z__4.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    tm2.r = z__1.r, tm2.i = z__1.i;
    z__5.r = rx.r * .25f, z__5.i = rx.i * .25f;
    z__4.r = z__5.r - .5f, z__4.i = z__5.i;
    z__3.r = z__4.r * rx.r - z__4.i * rx.i, z__3.i = z__4.r * rx.i + z__4.i * 
	    rx.r;
    z__2.r = z__3.r + .5f, z__2.i = z__3.i;
    z__1.r = xjs.r * z__2.r - xjs.i * z__2.i, z__1.i = xjs.r * z__2.i + xjs.i 
	    * z__2.r;
    tm3.r = z__1.r, tm3.i = z__1.i;
    z__3.r = xkj.r * .166666666667f, z__3.i = xkj.i * .166666666667f;
    z__2.r = z__3.r * xjs.r - z__3.i * xjs.i, z__2.i = z__3.r * xjs.i + 
	    z__3.i * xjs.r;
    z__4.r = 1.f - rx.r, z__4.i = -rx.i;
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    tm4.r = z__1.r, tm4.i = z__1.i;
    z__2.r = xjs.r * .0416666666667f, z__2.i = xjs.i * .0416666666667f;
    z__1.r = z__2.r * xjs.r - z__2.i * xjs.i, z__1.i = z__2.r * xjs.i + 
	    z__2.i * xjs.r;
    tm5.r = z__1.r, tm5.i = z__1.i;
    z__6.r = ri1 * tm1.r, z__6.i = ri1 * tm1.i;
    z__7.r = ri2 * tm2.r, z__7.i = ri2 * tm2.i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__8.r = ri3 * tm3.r, z__8.i = ri3 * tm3.i;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__9.r = ri4 * tm4.r, z__9.i = ri4 * tm4.i;
    z__3.r = z__4.r + z__9.r, z__3.i = z__4.i + z__9.i;
    z__10.r = ri5 * tm5.r, z__10.i = ri5 * tm5.i;
    z__2.r = z__3.r + z__10.r, z__2.i = z__3.i + z__10.i;
    z_exp(&z__11, &rx);
    z__1.r = z__2.r * z__11.r - z__2.i * z__11.i, z__1.i = z__2.r * z__11.i + 
	    z__2.i * z__11.r;
    exri->r = z__1.r, exri->i = z__1.i;
    return 0;

/*     Approximation for distance large compared to segment length */

L1:
/* Computing 2nd power */
    d__1 = *zob;
    r0s = rhs + d__1 * d__1;
    r0 = sqrt(r0s);
    z__1.r = r0 * xkj.r, z__1.i = r0 * xkj.i;
    rx.r = z__1.r, rx.i = z__1.i;
    d__1 = 2.f / r0;
    tm1.r = d__1, tm1.i = 0.;
    z__4.r = rx.r - 1.f, z__4.i = rx.i;
    z__3.r = r0s * z__4.r, z__3.i = r0s * z__4.i;
/* Computing 2nd power */
    d__2 = *zob;
    d__1 = d__2 * d__2;
    z__8.r = rx.r - 3.f, z__8.i = rx.i;
    z__7.r = z__8.r * rx.r - z__8.i * rx.i, z__7.i = z__8.r * rx.i + z__8.i * 
	    rx.r;
    z__6.r = z__7.r + 3.f, z__6.i = z__7.i;
    z__5.r = d__1 * z__6.r, z__5.i = d__1 * z__6.i;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    d__3 = r0s * 3.f * r0s * r0;
    z__1.r = z__2.r / d__3, z__1.i = z__2.i / d__3;
    tm2.r = z__1.r, tm2.i = z__1.i;
/* Computing 2nd power */
    d__2 = sh;
    d__1 = d__2 * d__2;
    z__4.r = d__1 * tm2.r, z__4.i = d__1 * tm2.i;
    z__3.r = z__4.r + tm1.r, z__3.i = z__4.i + tm1.i;
    z__2.r = sh * z__3.r, z__2.i = sh * z__3.i;
    z_exp(&z__5, &rx);
    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * z__5.i + 
	    z__2.i * z__5.r;
    exri->r = z__1.r, exri->i = z__1.i;
    return 0;
} /* exrint_ */

/* Subroutine */ int eksmr_(doublereal *slen, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *ezk, 
	doublecomplex *ezs, doublecomplex *ezcm, doublecomplex *ers, 
	doublecomplex *erc)
{
    /* Initialized data */

    static doublecomplex con = {0.,.07957747151};
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14, z__15, z__16;

    /* Builtin functions */
    double sqrt(doublereal), log(doublereal);
    void pow_zi(doublecomplex *, doublecomplex *, integer *);

    /* Local variables */
    static doublecomplex a1, a2, a3, a4;
    static doublereal r1, s1, s2, r2, sh, rc1, rc2, ri1, ri2;
    static doublecomplex ex1, ex2;
    static doublereal ri3, ri4, ri5;
    static doublecomplex xk2, xk3;
    static doublereal ss1, rs1, ss2, rs2, den, abz, rhs, zsq;
    static doublecomplex txk3, edif, conk, eint, esum, shxk;
    static doublereal shsq;
    static doublecomplex term1, shxk3, coskd;
    static doublereal rsdif;
    static doublecomplex sinkd, eordif, eordfx, eorsum, eorsmx;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSSMR computes the components of electric field for a segment */
/*     with constant, SIN(KS) and COS(KS)-1 current distributions. Series */
/*     for small KR are used. */

/*     !!!NOTE!!! THE CONTRIBUTIONS TO THE ELECTRIC FIELD DUE TO POINT */
/*     CHARGES (CURRENT DISCONTINUITIES) AT THE SEGMENT ENDS HAVE BEEN */
/*     DROPPED TO IMPROVE NUMERICAL ACCURACY.  HENCE THE FIELD IS CORRECT */
/*     ONLY WHEN COMBINED WITH THE FIELD OF OTHER SEGMENTS TO PRODUCE A */
/*     CONTINUOUS CURRENT THAT GOES TO ZERO AT FREE ENDS. */

/*     INPUT: */
/*     SLEN = SEGMENT LENGTH (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM= Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERC = RHO COMPONENT OF E DUE TO COS(KS) CURRENT */
/*     (CONSTANT CURRENT PRODUCES ZERO RHO COMPONENT OF E) */

    z__1.r = con.r * eta->r - con.i * eta->i, z__1.i = con.r * eta->i + con.i 
	    * eta->r;
    conk.r = z__1.r, conk.i = z__1.i;
    sh = *slen * .5f;
    rhs = *rho * *rho;
    s1 = -sh - *zob;
    ss1 = s1 * s1;
    rs1 = rhs + ss1;
    r1 = sqrt(rs1);
    rc1 = rs1 * r1;
    s2 = sh - *zob;
    ss2 = s2 * s2;
    rs2 = rhs + ss2;
    r2 = sqrt(rs2);
    rc2 = rs2 * r2;

/*     RIN IS THE INTEGRAL OF R**(N-2) FROM -SH TO SH */

    if (s1 > 0.f) {
	ri1 = log((r2 + s2) / (r1 + s1));
    } else {
	rsdif = r2 - s2;
	if (s2 > 0.f && *rho < r2 * .05f) {
	    rsdif = rhs * .5f / s2 * (1.f - rhs * .25f / ss2);
	}
	ri1 = log((r1 - s1) / rsdif);
    }
    ri2 = s2 - s1;
    ri3 = (rhs * ri1 + s2 * r2 - s1 * r1) * .5f;
    ri4 = rhs * ri2 + (ss2 * s2 - ss1 * s1) / 3.f;
    ri5 = rhs * .75f * ri3 + (s2 * rc2 - s1 * rc1) * .25f;

/*     SERIES EVALUATION FOR E FIELD COMPONENTS FOR SMALL R */

    z__2.r = -fj.r, z__2.i = -fj.i;
    z__1.r = z__2.r * xk->r - z__2.i * xk->i, z__1.i = z__2.r * xk->i + 
	    z__2.i * xk->r;
    a1.r = z__1.r, a1.i = z__1.i;
    z__2.r = a1.r * a1.r - a1.i * a1.i, z__2.i = a1.r * a1.i + a1.i * a1.r;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    a2.r = z__1.r, a2.i = z__1.i;
    z__2.r = a1.r * a2.r - a1.i * a2.i, z__2.i = a1.r * a2.i + a1.i * a2.r;
    z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
    a3.r = z__1.r, a3.i = z__1.i;
    z__2.r = a1.r * a3.r - a1.i * a3.i, z__2.i = a1.r * a3.i + a1.i * a3.r;
    z__1.r = z__2.r * .25f, z__1.i = z__2.i * .25f;
    a4.r = z__1.r, a4.i = z__1.i;
    z__5.r = ri3 * a2.r, z__5.i = ri3 * a2.i;
    z__4.r = ri1 + z__5.r, z__4.i = z__5.i;
    z__6.r = ri4 * a3.r, z__6.i = ri4 * a3.i;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__7.r = ri5 * a4.r, z__7.i = ri5 * a4.i;
    z__2.r = z__3.r + z__7.r, z__2.i = z__3.i + z__7.i;
    z__1.r = xk->r * z__2.r - xk->i * z__2.i, z__1.i = xk->r * z__2.i + xk->i 
	    * z__2.r;
    eint.r = z__1.r, eint.i = z__1.i;
    z__2.r = r1 * a1.r, z__2.i = r1 * a1.i;
    z__3.r = rc1 * a3.r, z__3.i = rc1 * a3.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ex1.r = z__1.r, ex1.i = z__1.i;
    z__2.r = r2 * a1.r, z__2.i = r2 * a1.i;
    z__3.r = rc2 * a3.r, z__3.i = rc2 * a3.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    ex2.r = z__1.r, ex2.i = z__1.i;
    z__1.r = ex2.r + ex1.r, z__1.i = ex2.i + ex1.i;
    esum.r = z__1.r, esum.i = z__1.i;
    z__1.r = ex2.r - ex1.r, z__1.i = ex2.i - ex1.i;
    edif.r = z__1.r, edif.i = z__1.i;
    d__1 = 1.f / r2 + 1.f / r1;
    d__2 = r2 + r1;
    z__3.r = d__2 * a2.r, z__3.i = d__2 * a2.i;
    z__2.r = d__1 + z__3.r, z__2.i = z__3.i;
    d__3 = rc2 + rc1;
    z__4.r = d__3 * a4.r, z__4.i = d__3 * a4.i;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    eorsmx.r = z__1.r, eorsmx.i = z__1.i;
    d__1 = 1.f / r2 - 1.f / r1;
    d__2 = r2 - r1;
    z__3.r = d__2 * a2.r, z__3.i = d__2 * a2.i;
    z__2.r = d__1 + z__3.r, z__2.i = z__3.i;
    d__3 = rc2 - rc1;
    z__4.r = d__3 * a4.r, z__4.i = d__3 * a4.i;
    z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
    eordfx.r = z__1.r, eordfx.i = z__1.i;
    d__1 = rs2 + rs1;
    z__2.r = d__1 * a3.r, z__2.i = d__1 * a3.i;
    z__1.r = eorsmx.r + z__2.r, z__1.i = eorsmx.i + z__2.i;
    eorsum.r = z__1.r, eorsum.i = z__1.i;
    d__1 = rs2 - rs1;
    z__2.r = d__1 * a3.r, z__2.i = d__1 * a3.i;
    z__1.r = eordfx.r + z__2.r, z__1.i = eordfx.i + z__2.i;
    eordif.r = z__1.r, eordif.i = z__1.i;
    z__1.r = sh * xk->r, z__1.i = sh * xk->i;
    shxk.r = z__1.r, shxk.i = z__1.i;
    pow_zi(&z__2, &shxk, &c__3);
    z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
    shxk3.r = z__1.r, shxk3.i = z__1.i;
    z__4.r = fj.r * 2.f, z__4.i = fj.i * 2.f;
    pow_zi(&z__5, xk, &c__3);
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    z__2.r = *rho * z__3.r, z__2.i = *rho * z__3.i;
    z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
    txk3.r = z__1.r, txk3.i = z__1.i;
    z__3.r = shxk.r * .5f, z__3.i = shxk.i * .5f;
    z__2.r = z__3.r * shxk.r - z__3.i * shxk.i, z__2.i = z__3.r * shxk.i + 
	    z__3.i * shxk.r;
    z__1.r = 1.f - z__2.r, z__1.i = -z__2.i;
    coskd.r = z__1.r, coskd.i = z__1.i;
    z__2.r = shxk3.r * .5f, z__2.i = shxk3.i * .5f;
    z__1.r = shxk.r - z__2.r, z__1.i = shxk.i - z__2.i;
    sinkd.r = z__1.r, sinkd.i = z__1.i;
    z__2.r = conk.r * eordif.r - conk.i * eordif.i, z__2.i = conk.r * 
	    eordif.i + conk.i * eordif.r;
    z__1.r = z__2.r * coskd.r - z__2.i * coskd.i, z__1.i = z__2.r * coskd.i + 
	    z__2.i * coskd.r;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__2.r = -conk.r, z__2.i = -conk.i;
    z__5.r = eorsum.r * sinkd.r - eorsum.i * sinkd.i, z__5.i = eorsum.r * 
	    sinkd.i + eorsum.i * sinkd.r;
    z__4.r = z__5.r - eint.r, z__4.i = z__5.i - eint.i;
    z__6.r = a1.r * shxk3.r - a1.i * shxk3.i, z__6.i = a1.r * shxk3.i + a1.i *
	     shxk3.r;
    z__3.r = z__4.r - z__6.r, z__3.i = z__4.i - z__6.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    z__2.r = -conk.r, z__2.i = -conk.i;
    z__5.r = xk->r * a1.r - xk->i * a1.i, z__5.i = xk->r * a1.i + xk->i * 
	    a1.r;
    z__4.r = ri2 * z__5.r, z__4.i = ri2 * z__5.i;
    z__3.r = eint.r + z__4.r, z__3.i = eint.i + z__4.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    ezk->r = z__1.r, ezk->i = z__1.i;
    if (*rho > min(r1,r2) * .04f || s1 < 0. && s2 > 0.f) {
	z__2.r = -conk.r, z__2.i = -conk.i;
	z__8.r = *zob * eordfx.r, z__8.i = *zob * eordfx.i;
	z__9.r = sh * eorsmx.r, z__9.i = sh * eorsmx.i;
	z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
	z__6.r = z__7.r * coskd.r - z__7.i * coskd.i, z__6.i = z__7.r * 
		coskd.i + z__7.i * coskd.r;
	z__11.r = fj.r * esum.r - fj.i * esum.i, z__11.i = fj.r * esum.i + 
		fj.i * esum.r;
	z__10.r = z__11.r * sinkd.r - z__11.i * sinkd.i, z__10.i = z__11.r * 
		sinkd.i + z__11.i * sinkd.r;
	z__5.r = z__6.r - z__10.r, z__5.i = z__6.i - z__10.i;
	z__4.r = z__5.r / *rho, z__4.i = z__5.i / *rho;
	z__12.r = sh * txk3.r, z__12.i = sh * txk3.i;
	z__3.r = z__4.r + z__12.r, z__3.i = z__4.i + z__12.i;
	z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i 
		+ z__2.i * z__3.r;
	ers->r = z__1.r, ers->i = z__1.i;
	z__7.r = *zob * eorsmx.r, z__7.i = *zob * eorsmx.i;
	z__8.r = sh * eordfx.r, z__8.i = sh * eordfx.i;
	z__6.r = z__7.r - z__8.r, z__6.i = z__7.i - z__8.i;
	z__5.r = z__6.r * sinkd.r - z__6.i * sinkd.i, z__5.i = z__6.r * 
		sinkd.i + z__6.i * sinkd.r;
	z__10.r = fj.r * edif.r - fj.i * edif.i, z__10.i = fj.r * edif.i + 
		fj.i * edif.r;
	z__9.r = z__10.r * coskd.r - z__10.i * coskd.i, z__9.i = z__10.r * 
		coskd.i + z__10.i * coskd.r;
	z__4.r = z__5.r + z__9.r, z__4.i = z__5.i + z__9.i;
	z__3.r = z__4.r / *rho, z__3.i = z__4.i / *rho;
	z__13.r = txk3.r * shxk3.r - txk3.i * shxk3.i, z__13.i = txk3.r * 
		shxk3.i + txk3.i * shxk3.r;
	z__12.r = *zob * z__13.r, z__12.i = *zob * z__13.i;
	z__11.r = z__12.r / 5.f, z__11.i = z__12.i / 5.f;
	z__2.r = z__3.r + z__11.r, z__2.i = z__3.i + z__11.i;
	z__1.r = conk.r * z__2.r - conk.i * z__2.i, z__1.i = conk.r * z__2.i 
		+ conk.i * z__2.r;
	erc->r = z__1.r, erc->i = z__1.i;
    } else {

/*     SMALL RHO APPROXIMATION FOR RADIAL E FIELD */

	abz = abs(*zob);
	zsq = *zob * *zob;
	shsq = sh * sh;
	den = 1.f / (zsq - shsq);
	z__1.r = xk->r * xk->r - xk->i * xk->i, z__1.i = xk->r * xk->i + 
		xk->i * xk->r;
	xk2.r = z__1.r, xk2.i = z__1.i;
	z__1.r = xk2.r * xk->r - xk2.i * xk->i, z__1.i = xk2.r * xk->i + 
		xk2.i * xk->r;
	xk3.r = z__1.r, xk3.i = z__1.i;
	d__1 = zsq - shsq * 2.f;
	z__1.r = d__1 * xk2.r, z__1.i = d__1 * xk2.i;
	term1.r = z__1.r, term1.i = z__1.i;
	z__2.r = *rho * conk.r, z__2.i = *rho * conk.i;
	d__1 = abz * sh * den;
	z__6.r = term1.r + 2.f, z__6.i = term1.i;
	z__5.r = d__1 * z__6.r, z__5.i = d__1 * z__6.i;
	z__4.r = den * z__5.r, z__4.i = den * z__5.i;
	z__10.r = fj.r * xk3.r - fj.i * xk3.i, z__10.i = fj.r * xk3.i + fj.i *
		 xk3.r;
	z__9.r = sh * z__10.r, z__9.i = sh * z__10.i;
	z__8.r = z__9.r * 2.f, z__8.i = z__9.i * 2.f;
	z__7.r = z__8.r / 3.f, z__7.i = z__8.i / 3.f;
	z__3.r = z__4.r - z__7.r, z__3.i = z__4.i - z__7.i;
	z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i 
		+ z__2.i * z__3.r;
	ers->r = z__1.r, ers->i = z__1.i;
	z__5.r = -conk.r, z__5.i = -conk.i;
	z__4.r = z__5.r * xk->r - z__5.i * xk->i, z__4.i = z__5.r * xk->i + 
		z__5.i * xk->r;
	z__3.r = *rho * z__4.r, z__3.i = *rho * z__4.i;
	z__2.r = sh * z__3.r, z__2.i = sh * z__3.i;
	d__1 = shsq * den;
	z__10.r = term1.r / 3.f, z__10.i = term1.i / 3.f;
	z__9.r = z__10.r + 2.f, z__9.i = z__10.i;
	z__8.r = d__1 * z__9.r, z__8.i = d__1 * z__9.i;
	z__7.r = den * z__8.r, z__7.i = den * z__8.i;
	z__16.r = fj.r * xk3.r - fj.i * xk3.i, z__16.i = fj.r * xk3.i + fj.i *
		 xk3.r;
	z__15.r = shsq * z__16.r, z__15.i = shsq * z__16.i;
	z__14.r = z__15.r * xk2.r - z__15.i * xk2.i, z__14.i = z__15.r * 
		xk2.i + z__15.i * xk2.r;
	z__13.r = abz * z__14.r, z__13.i = abz * z__14.i;
	z__12.r = z__13.r * 2.f, z__12.i = z__13.i * 2.f;
	z__11.r = z__12.r / 45.f, z__11.i = z__12.i / 45.f;
	z__6.r = z__7.r - z__11.r, z__6.i = z__7.i - z__11.i;
	z__1.r = z__2.r * z__6.r - z__2.i * z__6.i, z__1.i = z__2.r * z__6.i 
		+ z__2.i * z__6.r;
	erc->r = z__1.r, erc->i = z__1.i;
	if (*zob < 0.f) {
	    z__1.r = -erc->r, z__1.i = -erc->i;
	    erc->r = z__1.r, erc->i = z__1.i;
	}
    }
    return 0;
} /* eksmr_ */

/* Subroutine */ int ekscpq_(doublereal *zptq, doublereal *zob, doublereal *
	rho, doublecomplex *xk, doublecomplex *eta, doublecomplex *xks, 
	doublecomplex *ezk, doublecomplex *ezs, doublecomplex *ezcm, 
	doublecomplex *erk, doublecomplex *ers, doublecomplex *ercm)
{
    /* Initialized data */

    static doublecomplex con = {0.,.07957747151};
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);
    double d_sign(doublereal *, doublereal *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_sin(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r__;
    static doublecomplex xkr;
    static doublereal rsq, zdif;
    static doublecomplex eptq, eptr, eptz, sinks;
    extern /* Double Complex */ VOID ccosm1_(doublecomplex *, doublecomplex *)
	    ;
    static doublecomplex cosksm;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     EKSCPQ adds the field of the delta function charge at the end of */
/*     a segment to the previously computed field values. */

/*     INPUT: */
/*     ZPTQ = Z COORDINATE OF THE POINT CHARGE AT UPPER OR LOWER END OF */
/*            THE SEGMENT (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */
/*     ETA = INTRINSIC IMPEDANCE OF THE MEDIUM (OHMS) */
/*     XKS = WAVENUMBER FOR THE CURRENT EXPANSION */

/*     OUTPUT: */
/*     EZK = Z COMPONENT OF E DUE TO CONSTANT CURRENT (V/M) */
/*     EZS = Z COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     EZCM = Z COMPONENT OF E DUE TO COS(KS)-1 CURRENT */
/*     ERK = RHO COMPONENT OF E DUE TO CONSTANT CURRENT */
/*     ERS = RHO COMPONENT OF E DUE TO SIN(KS) CURRENT */
/*     ERCM = RHO COMPONENT OF E DUE TO COS(KS)-1 CURRENT */

    zdif = *zob - *zptq;
    rsq = *rho * *rho + zdif * zdif;
    r__ = sqrt(rsq);
    z__2.r = fj.r * xk->r - fj.i * xk->i, z__2.i = fj.r * xk->i + fj.i * 
	    xk->r;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    xkr.r = z__1.r, xkr.i = z__1.i;
    z__7.r = -con.r, z__7.i = -con.i;
    z__6.r = z__7.r * eta->r - z__7.i * eta->i, z__6.i = z__7.r * eta->i + 
	    z__7.i * eta->r;
    z_div(&z__5, &z__6, xk);
    z__8.r = xkr.r + 1.f, z__8.i = xkr.i;
    z__4.r = z__5.r * z__8.r - z__5.i * z__8.i, z__4.i = z__5.r * z__8.i + 
	    z__5.i * z__8.r;
    z__10.r = -xkr.r, z__10.i = -xkr.i;
    z_exp(&z__9, &z__10);
    z__3.r = z__4.r * z__9.r - z__4.i * z__9.i, z__3.i = z__4.r * z__9.i + 
	    z__4.i * z__9.r;
    z__2.r = z__3.r / rsq, z__2.i = z__3.i / rsq;
    d__1 = d_sign(&c_b2760, zptq);
    z__1.r = d__1 * z__2.r, z__1.i = d__1 * z__2.i;
    eptq.r = z__1.r, eptq.i = z__1.i;
    z__2.r = zdif * eptq.r, z__2.i = zdif * eptq.i;
    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
    eptz.r = z__1.r, eptz.i = z__1.i;
    z__2.r = *rho * eptq.r, z__2.i = *rho * eptq.i;
    z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
    eptr.r = z__1.r, eptr.i = z__1.i;
    z__2.r = *zptq * xks->r, z__2.i = *zptq * xks->i;
    z_sin(&z__1, &z__2);
    sinks.r = z__1.r, sinks.i = z__1.i;
    z__2.r = *zptq * xks->r, z__2.i = *zptq * xks->i;
    ccosm1_(&z__1, &z__2);
    cosksm.r = z__1.r, cosksm.i = z__1.i;
    z__1.r = ezk->r + eptz.r, z__1.i = ezk->i + eptz.i;
    ezk->r = z__1.r, ezk->i = z__1.i;
    z__1.r = erk->r + eptr.r, z__1.i = erk->i + eptr.i;
    erk->r = z__1.r, erk->i = z__1.i;
    z__2.r = eptz.r * sinks.r - eptz.i * sinks.i, z__2.i = eptz.r * sinks.i + 
	    eptz.i * sinks.r;
    z__1.r = ezs->r + z__2.r, z__1.i = ezs->i + z__2.i;
    ezs->r = z__1.r, ezs->i = z__1.i;
    z__2.r = eptr.r * sinks.r - eptr.i * sinks.i, z__2.i = eptr.r * sinks.i + 
	    eptr.i * sinks.r;
    z__1.r = ers->r + z__2.r, z__1.i = ers->i + z__2.i;
    ers->r = z__1.r, ers->i = z__1.i;
    z__2.r = eptz.r * cosksm.r - eptz.i * cosksm.i, z__2.i = eptz.r * 
	    cosksm.i + eptz.i * cosksm.r;
    z__1.r = ezcm->r + z__2.r, z__1.i = ezcm->i + z__2.i;
    ezcm->r = z__1.r, ezcm->i = z__1.i;
    z__2.r = eptr.r * cosksm.r - eptr.i * cosksm.i, z__2.i = eptr.r * 
	    cosksm.i + eptr.i * cosksm.r;
    z__1.r = ercm->r + z__2.r, z__1.i = ercm->i + z__2.i;
    ercm->r = z__1.r, ercm->i = z__1.i;
    return 0;
} /* ekscpq_ */

/* Subroutine */ int cabc_(doublecomplex *curx)
{
    /* Initialized data */

    static doublecomplex ccj = {0.,-.01666666667};

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double log(doublereal);
    void z_cos(doublecomplex *, doublecomplex *), z_sin(doublecomplex *, 
	    doublecomplex *);

    /* Local variables */
    static integer i__, j, k, is;
    static doublereal sh;
    static integer jx;
    static doublecomplex cs1, cs2;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
    extern /* Subroutine */ int tbf_(integer *, integer *);
    static integer jco1, jco2;
    static doublecomplex curd, volts;
    extern integer iround_(doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CABC computes coefficients of the constant (A), SIN(K*S) (B), and */
/*     COS(K*S)-1 (C) terms in the current interpolation functions for */
/*     the current vector CUR. */

/*     THIS VERSION WAS MODIFIED ON 7/9/86 TO ACCOUNT FOR THE USE OF */
/*     COS(K*S)-1 TO IMPROVE ACCURACY AT LOW FREQUENCY IN THE CURRENT */
/*     EXPANSION. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --curx;

    /* Function Body */
    if (data_1.n == 0) {
	goto L6;
    }
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__;
	z_div(&z__1, &curx[i__], &gnd_1.xku);
	curx[i__2].r = z__1.r, curx[i__2].i = z__1.i;
	i__2 = i__ - 1;
	crnt_1.aix[i__2].r = 0.f, crnt_1.aix[i__2].i = 0.f;
	i__2 = i__ - 1;
	crnt_1.bix[i__2].r = 0.f, crnt_1.bix[i__2].i = 0.f;
/* L1: */
	i__2 = i__ - 1;
	crnt_1.cix[i__2].r = 0.f, crnt_1.cix[i__2].i = 0.f;
    }
    i__2 = data_1.n;
    for (i__ = 1; i__ <= i__2; ++i__) {
	i__1 = i__;
	curd.r = curx[i__1].r, curd.i = curx[i__1].i;
	tbf_(&i__, &c__1);
	i__1 = segj_1.jsno;
	for (jx = 1; jx <= i__1; ++jx) {
	    j = segj_1.jco[jx - 1];
	    i__3 = j - 1;
	    i__4 = j - 1;
	    i__5 = jx - 1;
	    z__2.r = segj_1.ax[i__5].r * curd.r - segj_1.ax[i__5].i * curd.i, 
		    z__2.i = segj_1.ax[i__5].r * curd.i + segj_1.ax[i__5].i * 
		    curd.r;
	    z__1.r = crnt_1.aix[i__4].r + z__2.r, z__1.i = crnt_1.aix[i__4].i 
		    + z__2.i;
	    crnt_1.aix[i__3].r = z__1.r, crnt_1.aix[i__3].i = z__1.i;
	    i__3 = j - 1;
	    i__4 = j - 1;
	    i__5 = jx - 1;
	    z__2.r = segj_1.bx[i__5].r * curd.r - segj_1.bx[i__5].i * curd.i, 
		    z__2.i = segj_1.bx[i__5].r * curd.i + segj_1.bx[i__5].i * 
		    curd.r;
	    z__1.r = crnt_1.bix[i__4].r + z__2.r, z__1.i = crnt_1.bix[i__4].i 
		    + z__2.i;
	    crnt_1.bix[i__3].r = z__1.r, crnt_1.bix[i__3].i = z__1.i;
/* L2: */
	    i__3 = j - 1;
	    i__4 = j - 1;
	    i__5 = jx - 1;
	    z__2.r = segj_1.cx[i__5].r * curd.r - segj_1.cx[i__5].i * curd.i, 
		    z__2.i = segj_1.cx[i__5].r * curd.i + segj_1.cx[i__5].i * 
		    curd.r;
	    z__1.r = crnt_1.cix[i__4].r + z__2.r, z__1.i = crnt_1.cix[i__4].i 
		    + z__2.i;
	    crnt_1.cix[i__3].r = z__1.r, crnt_1.cix[i__3].i = z__1.i;
	}
    }
    if (sorces_1.nsorc > 0) {
	i__3 = sorces_1.nsorc;
	for (is = 1; is <= i__3; ++is) {
	    if (sorces_1.isortp[is - 1] != 4) {
		goto L8;
	    }
	    i__ = iround_(&sorces_1.psor1[is - 1]);
	    jx = data_1.icon1[i__ - 1];
	    data_1.icon1[i__ - 1] = 0;
	    tbf_(&i__, &c__0);
	    data_1.icon1[i__ - 1] = jx;
	    sh = data_1.si[i__ - 1] * .5f;
	    i__4 = is - 1;
	    i__5 = is - 1;
	    z__1.r = sorces_1.psor2[i__4], z__1.i = sorces_1.psor3[i__5];
	    volts.r = z__1.r, volts.i = z__1.i;
	    i__4 = i__ - 1;
	    z__1.r = sh * crnt_1.xks[i__4].r, z__1.i = sh * crnt_1.xks[i__4]
		    .i;
	    curd.r = z__1.r, curd.i = z__1.i;
	    z__2.r = ccj.r * volts.r - ccj.i * volts.i, z__2.i = ccj.r * 
		    volts.i + ccj.i * volts.r;
	    d__1 = log(sh * 2.f / data_1.bi[i__ - 1]) - 1.f;
	    i__4 = segj_1.jsno - 1;
	    z_cos(&z__6, &curd);
	    z__5.r = segj_1.bx[i__4].r * z__6.r - segj_1.bx[i__4].i * z__6.i, 
		    z__5.i = segj_1.bx[i__4].r * z__6.i + segj_1.bx[i__4].i * 
		    z__6.r;
	    i__5 = segj_1.jsno - 1;
	    z_sin(&z__8, &curd);
	    z__7.r = segj_1.cx[i__5].r * z__8.r - segj_1.cx[i__5].i * z__8.i, 
		    z__7.i = segj_1.cx[i__5].r * z__8.i + segj_1.cx[i__5].i * 
		    z__8.r;
	    z__4.r = z__5.r + z__7.r, z__4.i = z__5.i + z__7.i;
	    z__3.r = d__1 * z__4.r, z__3.i = d__1 * z__4.i;
	    z_div(&z__1, &z__2, &z__3);
	    curd.r = z__1.r, curd.i = z__1.i;
	    i__4 = segj_1.jsno;
	    for (jx = 1; jx <= i__4; ++jx) {
		j = segj_1.jco[jx - 1];
		i__5 = j - 1;
		i__1 = j - 1;
		i__2 = jx - 1;
		z__2.r = segj_1.ax[i__2].r * curd.r - segj_1.ax[i__2].i * 
			curd.i, z__2.i = segj_1.ax[i__2].r * curd.i + 
			segj_1.ax[i__2].i * curd.r;
		z__1.r = crnt_1.aix[i__1].r + z__2.r, z__1.i = crnt_1.aix[
			i__1].i + z__2.i;
		crnt_1.aix[i__5].r = z__1.r, crnt_1.aix[i__5].i = z__1.i;
		i__5 = j - 1;
		i__1 = j - 1;
		i__2 = jx - 1;
		z__2.r = segj_1.bx[i__2].r * curd.r - segj_1.bx[i__2].i * 
			curd.i, z__2.i = segj_1.bx[i__2].r * curd.i + 
			segj_1.bx[i__2].i * curd.r;
		z__1.r = crnt_1.bix[i__1].r + z__2.r, z__1.i = crnt_1.bix[
			i__1].i + z__2.i;
		crnt_1.bix[i__5].r = z__1.r, crnt_1.bix[i__5].i = z__1.i;
/* L3: */
		i__5 = j - 1;
		i__1 = j - 1;
		i__2 = jx - 1;
		z__2.r = segj_1.cx[i__2].r * curd.r - segj_1.cx[i__2].i * 
			curd.i, z__2.i = segj_1.cx[i__2].r * curd.i + 
			segj_1.cx[i__2].i * curd.r;
		z__1.r = crnt_1.cix[i__1].r + z__2.r, z__1.i = crnt_1.cix[
			i__1].i + z__2.i;
		crnt_1.cix[i__5].r = z__1.r, crnt_1.cix[i__5].i = z__1.i;
	    }
L8:
	    ;
	}
    }
    i__3 = data_1.n;
    for (i__ = 1; i__ <= i__3; ++i__) {
/* L5: */
	i__5 = i__;
	i__1 = i__ - 1;
	curx[i__5].r = crnt_1.aix[i__1].r, curx[i__5].i = crnt_1.aix[i__1].i;
    }
L6:
    if (data_1.m == 0) {
	return 0;
    }
/*     CONVERT SURFACE CURRENTS FROM T1,T2 COMPONENTS TO X,Y,Z COMPONENTS */
    k = data_1.ld - data_1.m;
    jco1 = data_1.n + (data_1.m << 1) + 1;
    jco2 = jco1 + data_1.m;
    i__5 = data_1.m;
    for (i__ = 1; i__ <= i__5; ++i__) {
	++k;
	jco1 += -2;
	jco2 += -3;
	i__1 = jco1;
	cs1.r = curx[i__1].r, cs1.i = curx[i__1].i;
	i__1 = jco1 + 1;
	cs2.r = curx[i__1].r, cs2.i = curx[i__1].i;
	i__1 = jco2;
	i__3 = k - 1;
	z__2.r = t1x[i__3] * cs1.r, z__2.i = t1x[i__3] * cs1.i;
	i__2 = k - 1;
	z__3.r = data_1.t2x[i__2] * cs2.r, z__3.i = data_1.t2x[i__2] * cs2.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	curx[i__1].r = z__1.r, curx[i__1].i = z__1.i;
	i__1 = jco2 + 1;
	i__3 = k - 1;
	z__2.r = t1y[i__3] * cs1.r, z__2.i = t1y[i__3] * cs1.i;
	i__2 = k - 1;
	z__3.r = data_1.t2y[i__2] * cs2.r, z__3.i = data_1.t2y[i__2] * cs2.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	curx[i__1].r = z__1.r, curx[i__1].i = z__1.i;
/* L7: */
	i__1 = jco2 + 2;
	i__3 = k - 1;
	z__2.r = t1z[i__3] * cs1.r, z__2.i = t1z[i__3] * cs1.i;
	i__2 = k - 1;
	z__3.r = data_1.t2z[i__2] * cs2.r, z__3.i = data_1.t2z[i__2] * cs2.i;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	curx[i__1].r = z__1.r, curx[i__1].i = z__1.i;
    }
    return 0;
} /* cabc_ */

#undef t1z
#undef t1y
#undef t1x


/* Subroutine */ int gfld_(doublereal *rhoo, doublereal *phio, doublereal *zo,
	 doublecomplex *eth, doublecomplex *epi, doublecomplex *erd)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9;

    /* Builtin functions */
    double cos(doublereal), sin(doublereal), sqrt(doublereal);
    void z_sin(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublecomplex ex, ey, ez;
    static doublereal sn;
    static doublecomplex xk;
    static doublereal xo, yo;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex eph, erh;
    static doublereal cph;
    static doublecomplex ezh;
    static doublereal rho, sph;
    static doublecomplex erv;
    static doublereal rhs, phx, phy, rhx, rhy, thx;
    static doublecomplex ezv;
    static doublereal thy, xsn, ysn, rnx, zos, rny, rnz, thz, zts, sfac;
    static doublecomplex dipm;
    static doublereal cpho, ctho, spho, rhos, stho;
    extern /* Subroutine */ int gndef_(doublereal *, doublereal *, doublereal 
	    *, integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     GFLD computes the distant field including surface wave. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    sfac = gnd_1.gscal * gnd_1.gscal;
    cpho = cos(*phio);
    spho = sin(*phio);
    xo = *rhoo * cpho;
    yo = *rhoo * spho;
    ex.r = 0.f, ex.i = 0.f;
    ey.r = 0.f, ey.i = 0.f;
    ez.r = 0.f, ez.i = 0.f;
    i__1 = data_1.n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	if (data_1.z__[i__ - 1] < 0.f) {
	    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	}
	rhx = xo - data_1.x[i__ - 1];
	rhy = yo - data_1.y[i__ - 1];
	rhs = rhx * rhx + rhy * rhy;
	rho = sqrt(rhs);
	if (rho > 0.f) {
	    goto L1;
	}
	rhx = 1.f;
	rhy = 0.f;
	phx = 0.f;
	phy = 1.f;
	goto L2;
L1:
	rhx /= rho;
	rhy /= rho;
	phx = -rhy;
	phy = rhx;
L2:
	sn = sqrt(cab[i__ - 1] * cab[i__ - 1] + sab[i__ - 1] * sab[i__ - 1]);
	if (sn < 1e-5f) {
	    goto L3;
	}
	xsn = cab[i__ - 1] / sn;
	ysn = sab[i__ - 1] / sn;
	goto L4;
L3:
	sn = 0.f;
	xsn = 1.f;
	ysn = 0.f;
L4:
	cph = rhx * xsn + rhy * ysn;
	sph = rhy * xsn - rhx * ysn;
	if (abs(cph) < 1e-10f) {
	    cph = 0.f;
	}
	if (abs(sph) < 1e-10f) {
	    sph = 0.f;
	}
	rhos = rho * gnd_1.gscal;
	zts = data_1.z__[i__ - 1] * gnd_1.gscal;
	zos = *zo * gnd_1.gscal;
	gndef_(&rhos, &zts, &zos, &c_n1, &erv, &ezv, &erh, &eph, &ezh);
	z__4.r = sn * erh.r, z__4.i = sn * erh.i;
	z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
	i__2 = i__ - 1;
	z__5.r = data_1.salp[i__2] * erv.r, z__5.i = data_1.salp[i__2] * 
		erv.i;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__1.r = sfac * z__2.r, z__1.i = sfac * z__2.i;
	erh.r = z__1.r, erh.i = z__1.i;
	z__3.r = sn * eph.r, z__3.i = sn * eph.i;
	z__2.r = sph * z__3.r, z__2.i = sph * z__3.i;
	z__1.r = sfac * z__2.r, z__1.i = sfac * z__2.i;
	eph.r = z__1.r, eph.i = z__1.i;
	z__4.r = sn * ezh.r, z__4.i = sn * ezh.i;
	z__3.r = cph * z__4.r, z__3.i = cph * z__4.i;
	i__2 = i__ - 1;
	z__5.r = data_1.salp[i__2] * ezv.r, z__5.i = data_1.salp[i__2] * 
		ezv.i;
	z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
	z__1.r = sfac * z__2.r, z__1.i = sfac * z__2.i;
	ezh.r = z__1.r, ezh.i = z__1.i;
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__2.r = data_1.si[i__3] * crnt_1.aix[i__2].r, z__2.i = data_1.si[
		i__3] * crnt_1.aix[i__2].i;
	i__4 = i__ - 1;
	i__5 = i__ - 1;
	z__9.r = data_1.si[i__5] * xk.r, z__9.i = data_1.si[i__5] * xk.i;
	z__8.r = z__9.r * .5f, z__8.i = z__9.i * .5f;
	z_sin(&z__7, &z__8);
	z__6.r = z__7.r * 2.f, z__6.i = z__7.i * 2.f;
	z_div(&z__5, &z__6, &xk);
	i__6 = i__ - 1;
	z__4.r = z__5.r - data_1.si[i__6], z__4.i = z__5.i;
	z__3.r = crnt_1.cix[i__4].r * z__4.r - crnt_1.cix[i__4].i * z__4.i, 
		z__3.i = crnt_1.cix[i__4].r * z__4.i + crnt_1.cix[i__4].i * 
		z__4.r;
	z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	dipm.r = z__1.r, dipm.i = z__1.i;
	z__4.r = rhx * erh.r, z__4.i = rhx * erh.i;
	z__5.r = phx * eph.r, z__5.i = phx * eph.i;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = z__3.r * dipm.r - z__3.i * dipm.i, z__2.i = z__3.r * dipm.i 
		+ z__3.i * dipm.r;
	z__1.r = ex.r + z__2.r, z__1.i = ex.i + z__2.i;
	ex.r = z__1.r, ex.i = z__1.i;
	z__4.r = rhy * erh.r, z__4.i = rhy * erh.i;
	z__5.r = phy * eph.r, z__5.i = phy * eph.i;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = z__3.r * dipm.r - z__3.i * dipm.i, z__2.i = z__3.r * dipm.i 
		+ z__3.i * dipm.r;
	z__1.r = ey.r + z__2.r, z__1.i = ey.i + z__2.i;
	ey.r = z__1.r, ey.i = z__1.i;
	z__2.r = ezh.r * dipm.r - ezh.i * dipm.i, z__2.i = ezh.r * dipm.i + 
		ezh.i * dipm.r;
	z__1.r = ez.r + z__2.r, z__1.i = ez.i + z__2.i;
	ez.r = z__1.r, ez.i = z__1.i;
/* L5: */
    }
    stho = sqrt(*rhoo * *rhoo + *zo * *zo);
    ctho = *zo / stho;
    stho = *rhoo / stho;
    rnx = stho * cpho;
    rny = stho * spho;
    rnz = ctho;
    thx = ctho * cpho;
    thy = ctho * spho;
    thz = -stho;
    phx = -spho;
    phy = cpho;
    z__3.r = thx * ex.r, z__3.i = thx * ex.i;
    z__4.r = thy * ey.r, z__4.i = thy * ey.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__5.r = thz * ez.r, z__5.i = thz * ez.i;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    eth->r = z__1.r, eth->i = z__1.i;
    z__2.r = phx * ex.r, z__2.i = phx * ex.i;
    z__3.r = phy * ey.r, z__3.i = phy * ey.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    epi->r = z__1.r, epi->i = z__1.i;
    z__3.r = rnx * ex.r, z__3.i = rnx * ex.i;
    z__4.r = rny * ey.r, z__4.i = rny * ey.i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__5.r = rnz * ez.r, z__5.i = rnz * ez.i;
    z__1.r = z__2.r + z__5.r, z__1.i = z__2.i + z__5.i;
    erd->r = z__1.r, erd->i = z__1.i;
    return 0;
} /* gfld_ */

#undef sab
#undef cab


/* Subroutine */ int jnqset_(void)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_log(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer j;
    static doublecomplex xk;
    static integer iend, iseg, jseg, ichek, igndc, ipatc, iendx, jncno, iradx,
	     igndx, jncend[30];
    extern /* Subroutine */ int jnfind_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *);
    static integer jncseg[30];
    static doublecomplex qjrati[30];
    extern /* Subroutine */ int qsolve_(integer *, integer *, integer *, 
	    doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     JNQSET sets the proportionality constants for the linear charge */
/*     density on each end of each segment. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    ichek = 1;
    if (gnd_1.ksymp == 2) {
	ichek = 2;
    }
    i__1 = data_1.n;
    for (iseg = 1; iseg <= i__1; ++iseg) {
	jnqcom_1.ipqend[iseg - 1] = 0;
	i__2 = iseg - 1;
	jnqcom_1.qsege1[i__2].r = 0.f, jnqcom_1.qsege1[i__2].i = 0.f;
/* L1: */
	i__2 = iseg - 1;
	jnqcom_1.qsege2[i__2].r = 0.f, jnqcom_1.qsege2[i__2].i = 0.f;
    }
    i__2 = data_1.n;
    for (iseg = 1; iseg <= i__2; ++iseg) {
	for (iend = 1; iend <= 2; ++iend) {
	    if (iend == 1) {
		i__1 = iseg - 1;
		if (jnqcom_1.qsege1[i__1].r != 0.f) {
		    goto L2;
		}
		iendx = -1;
	    } else {
		i__1 = iseg - 1;
		if (jnqcom_1.qsege2[i__1].r != 0.f) {
		    goto L2;
		}
		iendx = 1;
	    }

/*     FIND SEGMENTS CONNECTED TO END IENDX OF SEGMENT ISEG */

	    jnfind_(&iseg, &iendx, &ichek, jncseg, jncend, &jncno, &iradx, &
		    igndx, &igndc, &ipatc);

/*     INCLUDE SEGMENT ISEG */

	    ++jncno;
	    jncseg[jncno - 1] = iseg;
	    jncend[jncno - 1] = iendx;
	    if (igndx != 0) {

/*     SET CHARGE RATIO FOR A JUNCTION CROSSING FROM AIR INTO GROUND */

		i__1 = jncno;
		for (j = 1; j <= i__1; ++j) {
		    jseg = jncseg[j - 1];
		    if (jncend[j - 1] > 0) {
			jnqcom_1.ipqend[jseg - 1] += 2;
			if (data_1.z__[jseg - 1] >= 0.f) {
			    i__3 = jseg - 1;
			    jnqcom_1.qsege2[i__3].r = gnd_1.xku.r, 
				    jnqcom_1.qsege2[i__3].i = gnd_1.xku.i;
			} else {
			    i__3 = jseg - 1;
			    jnqcom_1.qsege2[i__3].r = gnd_1.xkl.r, 
				    jnqcom_1.qsege2[i__3].i = gnd_1.xkl.i;
			}
		    } else {
			++jnqcom_1.ipqend[jseg - 1];
			if (data_1.z__[jseg - 1] > 0.) {
			    i__3 = jseg - 1;
			    jnqcom_1.qsege1[i__3].r = gnd_1.xku.r, 
				    jnqcom_1.qsege1[i__3].i = gnd_1.xku.i;
			} else {
			    i__3 = jseg - 1;
			    jnqcom_1.qsege1[i__3].r = gnd_1.xkl.r, 
				    jnqcom_1.qsege1[i__3].i = gnd_1.xkl.i;
			}
		    }
/* L3: */
		}
	    } else if (iradx != 0 || jncno > 2) {

/*     SET CHARGE RATIO FOR A JUNCTION WITH A CHANGE IN WIRE RADIUS OR */
/*     A MULTIPLE WIRE JUNCTION */

		jseg = jncseg[0];
		xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
		if (data_1.z__[jseg - 1] < 0.f) {
		    xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
		}
		qsolve_(&jncno, jncseg, jncend, &xk, qjrati);
		i__1 = jncno;
		for (j = 1; j <= i__1; ++j) {
		    jseg = jncseg[j - 1];
		    if (jncend[j - 1] > 0) {
			if (setjn_1.isetjn == 1) {
			    i__3 = jseg - 1;
			    i__4 = j - 1;
			    d__1 = qjrati[i__4].r;
			    jnqcom_1.qsege2[i__3].r = d__1, jnqcom_1.qsege2[
				    i__3].i = 0.;
			} else {
			    i__3 = jseg - 1;
			    i__4 = jseg - 1;
			    z__5.r = data_1.bi[i__4] * xk.r, z__5.i = 
				    data_1.bi[i__4] * xk.i;
			    z_div(&z__4, &c_b1407, &z__5);
			    z_log(&z__3, &z__4);
			    z__2.r = z__3.r - .577215664f, z__2.i = z__3.i;
			    z_div(&z__1, &c_b336, &z__2);
			    jnqcom_1.qsege2[i__3].r = z__1.r, jnqcom_1.qsege2[
				    i__3].i = z__1.i;
			}
		    } else {
			if (setjn_1.isetjn == 1) {
			    i__3 = jseg - 1;
			    i__4 = j - 1;
			    d__1 = qjrati[i__4].r;
			    jnqcom_1.qsege1[i__3].r = d__1, jnqcom_1.qsege1[
				    i__3].i = 0.;
			} else {
			    i__3 = jseg - 1;
			    i__4 = jseg - 1;
			    z__5.r = data_1.bi[i__4] * xk.r, z__5.i = 
				    data_1.bi[i__4] * xk.i;
			    z_div(&z__4, &c_b1407, &z__5);
			    z_log(&z__3, &z__4);
			    z__2.r = z__3.r - .577215664f, z__2.i = z__3.i;
			    z_div(&z__1, &c_b336, &z__2);
			    jnqcom_1.qsege1[i__3].r = z__1.r, jnqcom_1.qsege1[
				    i__3].i = z__1.i;
			}
		    }
/* L4: */
		}
	    } else {

/*     SET CHARGE RATIO FOR A CONTINUOUS WIRE JUNCTION */

		i__1 = jncno;
		for (j = 1; j <= i__1; ++j) {
		    jseg = jncseg[j - 1];
		    if (jncend[j - 1] > 0) {
			i__3 = jseg - 1;
			jnqcom_1.qsege2[i__3].r = 1.f, jnqcom_1.qsege2[i__3]
				.i = 0.f;
		    } else {
			i__3 = jseg - 1;
			jnqcom_1.qsege1[i__3].r = 1.f, jnqcom_1.qsege1[i__3]
				.i = 0.f;
		    }
/* L5: */
		}
	    }
L2:
	    ;
	}
/* L6: */
    }
    return 0;
} /* jnqset_ */

/* Subroutine */ int jnfind_(integer *jxseg, integer *jxend, integer *ichek, 
	integer *jncseg, integer *jncend, integer *jncno, integer *iradx, 
	integer *igndx, integer *igndc, integer *ipatc)
{
    /* Format strings */
    static char fmt_90[] = "(\002 JNFIND: ERROR AT\002,i3,\002 END OF SEGM"
	    "ENT\002,i5,/,\002 MULTIPLE WIRE JUNCTION AT CONNECTION TO SURFAC"
	    "E PATCH IS NOT\002,\002 ALLOWED\002)";
    static char fmt_91[] = "(\002 JNFIND: ERROR AT\002,i3,\002 END OF SEGM"
	    "ENT\002,i5,/,\002 NUMBER OF CONNECTED SEGMENTS EXCEEDS LIMIT O"
	    "F\002,i4)";

    /* System generated locals */
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer jend, jseg, icon;
    static doublereal zseg, radseg;

    /* Fortran I/O blocks */
    static cilist io___2484 = { 0, 3, 0, fmt_90, 0 };
    static cilist io___2485 = { 0, 3, 0, fmt_91, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     JNFIND locates all segments connected to a given segment and */
/*     determines the conditions at the junction. */

/*     INPUT: */
/*     JXSEG = NUMBER OF THE SEGMENT TO WHICH CONNECTIONS ARE NEEDED */
/*     JXEND = -1 TO FIND CONNECTIONS TO (-) END OF SEGMENT JXSEG */
/*             +1 TO FIND CONNECTIONS TO (+) END OF SEGMENT JXSEG */
/*     ICHEK = 1 TO CHECK FOR JUNCTIONS CROSSING THE AIR-GROUND INTERFACE */

/*     OUTPUT: */
/*     JNCSEG(I) = NUMBER OF THE I TH SEGMENT CONNECTING TO SEGMENT JXSEG */
/*     JNCEND(I) = -1 IF (-) END OF SEGMENT JNCSEG(I) CONNECTS TO JXSEG */
/*                 +1 IF (+) END OF SEGMENT JNCSEG(I) CONNECTS TO JXSEG */
/*     JNCNO = NUMBER OF SEGMENTS CONNECTING TO SEGMENT JXSEG */
/*     IRADX = 1 IF A RADIUS CHANGE OCCURS AT THE JUNCTION, = 0 OTHERWISE */
/*     IGNDX = 1 IF THE JUNCTION INCLUDES SEGMENTS ON BOTH SIDES OF AN */
/*             AIR-GROUND INTERFACE, = 0 OTHERWISE */
/*     IGNDC = 1 IF SEG. JXSEG CONNECTS TO A GROUND PLANE, = 0 OTHERWISE */
/*     IPATC = 1 IF SEGMENT JXSEG CONNECTS TO A PATCH, = 0 OTHERWISE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --jncend;
    --jncseg;

    /* Function Body */
    jseg = *jxseg;
    jend = *jxend;
    *iradx = 0;
    *igndx = 0;
    *igndc = 0;
    *ipatc = 0;
    *jncno = 0;
    radseg = data_1.bi[*jxseg - 1];
    zseg = data_1.z__[*jxseg - 1];
L1:
    if (jend < 0) {
	icon = data_1.icon1[jseg - 1];
    } else {
	icon = data_1.icon2[jseg - 1];
    }
    jseg = abs(icon);
    if (icon > 0) {
	jend = -jend;
    }
    if (jseg == *jxseg) {
	if (*jncno == 0) {
	    *igndc = 1;
	}
	goto L2;
    } else if (jseg == 0) {
	goto L2;

/*     SEGMENT CONNECTION TO A SURFACE PATCH */

    } else if (jseg > 30000) {
	if (*jncno > 0) {
	    s_wsfe(&io___2484);
	    do_fio(&c__1, (char *)&(*jxend), (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&(*jxseg), (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_stop("", (ftnlen)0);
	}
	*ipatc = 1;
	goto L2;
    }

/*     ENTER CONNECTED SEGMENT IN ARRAY JNCSEG */

    ++(*jncno);
    if (*jncno >= 30) {
	s_wsfe(&io___2485);
	do_fio(&c__1, (char *)&(*jxend), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&(*jxseg), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&c__30, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    jncseg[*jncno] = jseg;
    jncend[*jncno] = jend;
    if (*ichek != 0) {
	if ((d__1 = data_1.bi[jseg - 1] - radseg, abs(d__1)) > radseg * .01f) 
		{
	    *iradx = 1;
	}
    }
    if (*ichek > 1) {
	if (data_1.z__[jseg - 1] * zseg < 0.f) {
	    *igndx = 1;
	}
    }
    goto L1;
L2:
    return 0;

} /* jnfind_ */

/* Subroutine */ int tbf_(integer *i__, integer *icap)
{
    /* Initialized data */

    static doublereal alim = .08;

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11;

    /* Builtin functions */
    void z_sin(doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *);
    double z_abs(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex d__, cd, aj, ap, sd, pm, qm, pp, qp, xk, cdh, den, 
	    sdh, omc;
    static integer jno;
    static doublecomplex dsq;
    static integer igx, irx;
    static doublecomplex xxi;
    static integer igc1, igc2, ipc1, ipc2, iend, june, jcox, jnop;
    static doublecomplex term;
    static integer juns, njun1, njun2, njnxt, image1, image2, jncend[30];
    extern /* Subroutine */ int jnfind_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TBF computes the basis function associated with segment I. The */
/*     components of basis function I are stored in COMMON /SEGJ/.  The */
/*     component of basis function I that extends onto segment J is */
/*     AX(L)+BX(L)*SIN(K*S)+CX(L)*(COS(K*S)-1.) where JCO(L)=J and S is */
/*     measured from the center of segment J.  L runs from 1 through JSNO */
/*     where JSNO is the number of segments in the support of the basis */
/*     function. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    image1 = 0;
    image2 = 0;
    jnfind_(i__, &c_n1, &c__0, segj_1.jco, jncend, &njun1, &irx, &igx, &igc1, 
	    &ipc1);
    if (ipc1 != 0 || igc1 != 0) {
	njun1 = 1;
	segj_1.jco[0] = *i__;
	jncend[0] = -1;
	image1 = 1;
    }
    njnxt = njun1 + 1;
    jnfind_(i__, &c__1, &c__0, &segj_1.jco[njnxt - 1], &jncend[njnxt - 1], &
	    njun2, &irx, &igx, &igc2, &ipc2);
    if (ipc2 != 0 || igc2 != 0) {
	njun2 = 1;
	segj_1.jco[njnxt - 1] = *i__;
	jncend[njnxt - 1] = 1;
	image2 = 1;
    }
    segj_1.jsno = njun1 + njun2 + 1;
    segj_1.jco[segj_1.jsno - 1] = *i__;

/*     EVALUATE A,B,C FOR SEGMENTS CONNECTED TO -1 END OF SEGMENT J */

    pm.r = 0.f, pm.i = 0.f;
    if (njun1 == 0) {
	goto L2;
    }
    i__1 = njun1;
    for (jno = 1; jno <= i__1; ++jno) {
	jcox = segj_1.jco[jno - 1];
	i__2 = jcox - 1;
	xk.r = crnt_1.xks[i__2].r, xk.i = crnt_1.xks[i__2].i;
	if (jncend[jno - 1] < 0) {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege1[i__2].r, aj.i = jnqcom_1.qsege1[i__2].i;
	} else {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege2[i__2].r, aj.i = jnqcom_1.qsege2[i__2].i;
	}
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__2 = jcox - 1;
	z__1.r = data_1.si[i__2] * z__2.r, z__1.i = data_1.si[i__2] * z__2.i;
	d__.r = z__1.r, d__.i = z__1.i;
	z_sin(&z__1, &d__);
	sdh.r = z__1.r, sdh.i = z__1.i;
	z_cos(&z__1, &d__);
	cdh.r = z__1.r, cdh.i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__2 = jno - 1;
	    z_div(&z__4, &c_b1298, &cdh);
	    z__3.r = z__4.r - .5f, z__3.i = z__4.i;
	    z__2.r = aj.r * z__3.r - aj.i * z__3.i, z__2.i = aj.r * z__3.i + 
		    aj.i * z__3.r;
	    z_div(&z__1, &z__2, &sdh);
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	} else {
	    i__2 = jno - 1;
	    z__3.r = aj.r * .25f, z__3.i = aj.i * .25f;
	    z__2.r = z__3.r * d__.r - z__3.i * d__.i, z__2.i = z__3.r * d__.i 
		    + z__3.i * d__.r;
	    z__6.r = d__.r * .58333333333f, z__6.i = d__.i * .58333333333f;
	    z__5.r = z__6.r * d__.r - z__6.i * d__.i, z__5.i = z__6.r * d__.i 
		    + z__6.i * d__.r;
	    z__4.r = z__5.r + 1.f, z__4.i = z__5.i;
	    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * 
		    z__4.i + z__2.i * z__4.r;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	}
	i__2 = jno - 1;
	z__2.r = cdh.r * 2.f, z__2.i = cdh.i * 2.f;
	z_div(&z__1, &aj, &z__2);
	segj_1.bx[i__2].r = z__1.r, segj_1.bx[i__2].i = z__1.i;
	i__2 = jno - 1;
	z__2.r = -aj.r, z__2.i = -aj.i;
	z__3.r = sdh.r * 2.f, z__3.i = sdh.i * 2.f;
	z_div(&z__1, &z__2, &z__3);
	segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	z_div(&z__3, &sdh, &cdh);
	z__2.r = z__3.r * aj.r - z__3.i * aj.i, z__2.i = z__3.r * aj.i + 
		z__3.i * aj.r;
	z__1.r = pm.r + z__2.r, z__1.i = pm.i + z__2.i;
	pm.r = z__1.r, pm.i = z__1.i;
	if (jncend[jno - 1] < 0 && image1 == 0) {
	    i__2 = jno - 1;
	    i__3 = jno - 1;
	    z__1.r = -segj_1.ax[i__3].r, z__1.i = -segj_1.ax[i__3].i;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	    i__2 = jno - 1;
	    i__3 = jno - 1;
	    z__1.r = -segj_1.cx[i__3].r, z__1.i = -segj_1.cx[i__3].i;
	    segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	}
/* L1: */
    }
    if (image1 != 0) {
	i__1 = njun1 - 1;
	i__2 = njun1 - 1;
	z__1.r = -segj_1.bx[i__2].r, z__1.i = -segj_1.bx[i__2].i;
	segj_1.bx[i__1].r = z__1.r, segj_1.bx[i__1].i = z__1.i;
    }

/*     EVALUATE A,B,C FOR SEGMENTS CONNECTED TO +1 END OF SEGMENT J */

L2:
    pp.r = 0.f, pp.i = 0.f;
    if (njun2 == 0) {
	goto L4;
    }
    i__1 = njun2;
    for (jno = 1; jno <= i__1; ++jno) {
	jnop = jno + njun1;
	jcox = segj_1.jco[jnop - 1];
	i__2 = jcox - 1;
	xk.r = crnt_1.xks[i__2].r, xk.i = crnt_1.xks[i__2].i;
	if (jncend[jnop - 1] < 0) {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege1[i__2].r, aj.i = jnqcom_1.qsege1[i__2].i;
	} else {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege2[i__2].r, aj.i = jnqcom_1.qsege2[i__2].i;
	}
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__2 = jcox - 1;
	z__1.r = data_1.si[i__2] * z__2.r, z__1.i = data_1.si[i__2] * z__2.i;
	d__.r = z__1.r, d__.i = z__1.i;
	z_sin(&z__1, &d__);
	sdh.r = z__1.r, sdh.i = z__1.i;
	z_cos(&z__1, &d__);
	cdh.r = z__1.r, cdh.i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__2 = jnop - 1;
	    z__3.r = -aj.r, z__3.i = -aj.i;
	    z_div(&z__5, &c_b1298, &cdh);
	    z__4.r = z__5.r - .5f, z__4.i = z__5.i;
	    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * 
		    z__4.i + z__3.i * z__4.r;
	    z_div(&z__1, &z__2, &sdh);
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	} else {
	    i__2 = jnop - 1;
	    z__4.r = -aj.r, z__4.i = -aj.i;
	    z__3.r = z__4.r * .25f, z__3.i = z__4.i * .25f;
	    z__2.r = z__3.r * d__.r - z__3.i * d__.i, z__2.i = z__3.r * d__.i 
		    + z__3.i * d__.r;
	    z__7.r = d__.r * .58333333333f, z__7.i = d__.i * .58333333333f;
	    z__6.r = z__7.r * d__.r - z__7.i * d__.i, z__6.i = z__7.r * d__.i 
		    + z__7.i * d__.r;
	    z__5.r = z__6.r + 1.f, z__5.i = z__6.i;
	    z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * 
		    z__5.i + z__2.i * z__5.r;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	}
	i__2 = jnop - 1;
	z__2.r = cdh.r * 2.f, z__2.i = cdh.i * 2.f;
	z_div(&z__1, &aj, &z__2);
	segj_1.bx[i__2].r = z__1.r, segj_1.bx[i__2].i = z__1.i;
	i__2 = jnop - 1;
	z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
	z_div(&z__1, &aj, &z__2);
	segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	z_div(&z__3, &sdh, &cdh);
	z__2.r = z__3.r * aj.r - z__3.i * aj.i, z__2.i = z__3.r * aj.i + 
		z__3.i * aj.r;
	z__1.r = pp.r - z__2.r, z__1.i = pp.i - z__2.i;
	pp.r = z__1.r, pp.i = z__1.i;
	if (jncend[jnop - 1] > 0 && image2 == 0) {
	    i__2 = jnop - 1;
	    i__3 = jnop - 1;
	    z__1.r = -segj_1.ax[i__3].r, z__1.i = -segj_1.ax[i__3].i;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	    i__2 = jnop - 1;
	    i__3 = jnop - 1;
	    z__1.r = -segj_1.cx[i__3].r, z__1.i = -segj_1.cx[i__3].i;
	    segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	}
/* L3: */
    }
    if (image2 != 0) {
	i__1 = jnop - 1;
	i__2 = jnop - 1;
	z__1.r = -segj_1.bx[i__2].r, z__1.i = -segj_1.bx[i__2].i;
	segj_1.bx[i__1].r = z__1.r, segj_1.bx[i__1].i = z__1.i;
    }
L4:
    i__1 = *i__ - 1;
    xk.r = crnt_1.xks[i__1].r, xk.i = crnt_1.xks[i__1].i;
    z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
    i__1 = *i__ - 1;
    z__1.r = data_1.si[i__1] * z__2.r, z__1.i = data_1.si[i__1] * z__2.i;
    d__.r = z__1.r, d__.i = z__1.i;
    z__1.r = d__.r * d__.r - d__.i * d__.i, z__1.i = d__.r * d__.i + d__.i * 
	    d__.r;
    dsq.r = z__1.r, dsq.i = z__1.i;
    z_sin(&z__1, &d__);
    sdh.r = z__1.r, sdh.i = z__1.i;
    z_cos(&z__1, &d__);
    cdh.r = z__1.r, cdh.i = z__1.i;
    z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
    z__1.r = z__2.r * cdh.r - z__2.i * cdh.i, z__1.i = z__2.r * cdh.i + 
	    z__2.i * cdh.r;
    sd.r = z__1.r, sd.i = z__1.i;
    z__2.r = cdh.r * cdh.r - cdh.i * cdh.i, z__2.i = cdh.r * cdh.i + cdh.i * 
	    cdh.r;
    z__3.r = sdh.r * sdh.r - sdh.i * sdh.i, z__3.i = sdh.r * sdh.i + sdh.i * 
	    sdh.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    cd.r = z__1.r, cd.i = z__1.i;
    z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
    z__1.r = z__2.r * sdh.r - z__2.i * sdh.i, z__1.i = z__2.r * sdh.i + 
	    z__2.i * sdh.r;
    omc.r = z__1.r, omc.i = z__1.i;
    i__1 = *i__ - 1;
    aj.r = jnqcom_1.qsege1[i__1].r, aj.i = jnqcom_1.qsege1[i__1].i;
    i__1 = *i__ - 1;
    ap.r = jnqcom_1.qsege2[i__1].r, ap.i = jnqcom_1.qsege2[i__1].i;
    if (njun1 > 0 && njun2 > 0) {
	z__4.r = pm.r * pp.r - pm.i * pp.i, z__4.i = pm.r * pp.i + pm.i * 
		pp.r;
	z__5.r = aj.r * ap.r - aj.i * ap.i, z__5.i = aj.r * ap.i + aj.i * 
		ap.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = sd.r * z__3.r - sd.i * z__3.i, z__2.i = sd.r * z__3.i + sd.i 
		* z__3.r;
	z__8.r = pm.r * ap.r - pm.i * ap.i, z__8.i = pm.r * ap.i + pm.i * 
		ap.r;
	z__9.r = pp.r * aj.r - pp.i * aj.i, z__9.i = pp.r * aj.i + pp.i * 
		aj.r;
	z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
	z__6.r = cd.r * z__7.r - cd.i * z__7.i, z__6.i = cd.r * z__7.i + cd.i 
		* z__7.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	den.r = z__1.r, den.i = z__1.i;
	z__3.r = ap.r * omc.r - ap.i * omc.i, z__3.i = ap.r * omc.i + ap.i * 
		omc.r;
	z__4.r = pp.r * sd.r - pp.i * sd.i, z__4.i = pp.r * sd.i + pp.i * 
		sd.r;
	z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	z_div(&z__1, &z__2, &den);
	qm.r = z__1.r, qm.i = z__1.i;
	z__4.r = aj.r * omc.r - aj.i * omc.i, z__4.i = aj.r * omc.i + aj.i * 
		omc.r;
	z__5.r = pm.r * sd.r - pm.i * sd.i, z__5.i = pm.r * sd.i + pm.i * 
		sd.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &den);
	qp.r = z__1.r, qp.i = z__1.i;
	i__1 = segj_1.jsno - 1;
	z__4.r = aj.r * qm.r - aj.i * qm.i, z__4.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__5.r = ap.r * qp.r - ap.i * qp.i, z__5.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = z__3.r * sdh.r - z__3.i * sdh.i, z__2.i = z__3.r * sdh.i + 
		z__3.i * sdh.r;
	z_div(&z__1, &z__2, &sd);
	segj_1.bx[i__1].r = z__1.r, segj_1.bx[i__1].i = z__1.i;
	i__1 = segj_1.jsno - 1;
	z__4.r = aj.r * qm.r - aj.i * qm.i, z__4.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__5.r = ap.r * qp.r - ap.i * qp.i, z__5.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
	z__2.r = z__3.r * cdh.r - z__3.i * cdh.i, z__2.i = z__3.r * cdh.i + 
		z__3.i * cdh.r;
	z_div(&z__1, &z__2, &sd);
	segj_1.cx[i__1].r = z__1.r, segj_1.cx[i__1].i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__1 = segj_1.jsno - 1;
	    i__2 = segj_1.jsno - 1;
	    z__1.r = segj_1.cx[i__2].r - 1.f, z__1.i = segj_1.cx[i__2].i;
	    segj_1.ax[i__1].r = z__1.r, segj_1.ax[i__1].i = z__1.i;
	} else {
	    z_div(&z__5, &pm, &d__);
	    z__4.r = -z__5.r, z__4.i = -z__5.i;
	    z_div(&z__6, &pp, &d__);
	    z__3.r = z__4.r * z__6.r - z__4.i * z__6.i, z__3.i = z__4.r * 
		    z__6.i + z__4.i * z__6.r;
	    z__2.r = z__3.r * sd.r - z__3.i * sd.i, z__2.i = z__3.r * sd.i + 
		    z__3.i * sd.r;
	    z__9.r = aj.r * ap.r - aj.i * ap.i, z__9.i = aj.r * ap.i + aj.i * 
		    ap.r;
	    z__8.r = z__9.r * d__.r - z__9.i * d__.i, z__8.i = z__9.r * d__.i 
		    + z__9.i * d__.r;
	    z__11.r = dsq.r * .25f, z__11.i = dsq.i * .25f;
	    z__10.r = 1.f - z__11.r, z__10.i = -z__11.i;
	    z__7.r = z__8.r * z__10.r - z__8.i * z__10.i, z__7.i = z__8.r * 
		    z__10.i + z__8.i * z__10.r;
	    z__1.r = z__2.r + z__7.r, z__1.i = z__2.i + z__7.i;
	    term.r = z__1.r, term.i = z__1.i;
	    i__1 = segj_1.jsno - 1;
	    z__6.r = pm.r * ap.r - pm.i * ap.i, z__6.i = pm.r * ap.i + pm.i * 
		    ap.r;
	    z__7.r = pp.r * aj.r - pp.i * aj.i, z__7.i = pp.r * aj.i + pp.i * 
		    aj.r;
	    z__5.r = z__6.r - z__7.r, z__5.i = z__6.i - z__7.i;
	    z__9.r = dsq.r * .625f, z__9.i = dsq.i * .625f;
	    z__8.r = 1.5f - z__9.r, z__8.i = -z__9.i;
	    z__4.r = z__5.r * z__8.r - z__5.i * z__8.i, z__4.i = z__5.r * 
		    z__8.i + z__5.i * z__8.r;
	    z__3.r = term.r + z__4.r, z__3.i = term.i + z__4.i;
	    z_div(&z__2, &z__3, &den);
	    z__1.r = z__2.r * dsq.r - z__2.i * dsq.i, z__1.i = z__2.r * dsq.i 
		    + z__2.i * dsq.r;
	    segj_1.ax[i__1].r = z__1.r, segj_1.ax[i__1].i = z__1.i;
	}
	i__1 = njun1;
	for (iend = 1; iend <= i__1; ++iend) {
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.ax[i__3].r * qm.r - segj_1.ax[i__3].i * qm.i, 
		    z__1.i = segj_1.ax[i__3].r * qm.i + segj_1.ax[i__3].i * 
		    qm.r;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.bx[i__3].r * qm.r - segj_1.bx[i__3].i * qm.i, 
		    z__1.i = segj_1.bx[i__3].r * qm.i + segj_1.bx[i__3].i * 
		    qm.r;
	    segj_1.bx[i__2].r = z__1.r, segj_1.bx[i__2].i = z__1.i;
/* L17: */
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.cx[i__3].r * qm.r - segj_1.cx[i__3].i * qm.i, 
		    z__1.i = segj_1.cx[i__3].r * qm.i + segj_1.cx[i__3].i * 
		    qm.r;
	    segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	}
	juns = njun1 + 1;
	june = njun1 + njun2;
	i__2 = june;
	for (iend = juns; iend <= i__2; ++iend) {
	    i__3 = iend - 1;
	    i__1 = iend - 1;
	    z__1.r = segj_1.ax[i__1].r * qp.r - segj_1.ax[i__1].i * qp.i, 
		    z__1.i = segj_1.ax[i__1].r * qp.i + segj_1.ax[i__1].i * 
		    qp.r;
	    segj_1.ax[i__3].r = z__1.r, segj_1.ax[i__3].i = z__1.i;
	    i__3 = iend - 1;
	    i__1 = iend - 1;
	    z__1.r = segj_1.bx[i__1].r * qp.r - segj_1.bx[i__1].i * qp.i, 
		    z__1.i = segj_1.bx[i__1].r * qp.i + segj_1.bx[i__1].i * 
		    qp.r;
	    segj_1.bx[i__3].r = z__1.r, segj_1.bx[i__3].i = z__1.i;
/* L18: */
	    i__3 = iend - 1;
	    i__1 = iend - 1;
	    z__1.r = segj_1.cx[i__1].r * qp.r - segj_1.cx[i__1].i * qp.i, 
		    z__1.i = segj_1.cx[i__1].r * qp.i + segj_1.cx[i__1].i * 
		    qp.r;
	    segj_1.cx[i__3].r = z__1.r, segj_1.cx[i__3].i = z__1.i;
	}
    } else if (njun2 > 0) {
	if (*icap == 0) {
	    xxi.r = 0.f, xxi.i = 0.f;
	} else {
	    z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	    i__3 = *i__ - 1;
	    z__1.r = data_1.bi[i__3] * z__2.r, z__1.i = data_1.bi[i__3] * 
		    z__2.i;
	    xxi.r = z__1.r, xxi.i = z__1.i;
	}
	z__4.r = xxi.r * sd.r - xxi.i * sd.i, z__4.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__3.r = omc.r + z__4.r, z__3.i = omc.i + z__4.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z__8.r = xxi.r * pp.r - xxi.i * pp.i, z__8.i = xxi.r * pp.i + xxi.i * 
		pp.r;
	z__7.r = ap.r + z__8.r, z__7.i = ap.i + z__8.i;
	z__6.r = sd.r * z__7.r - sd.i * z__7.i, z__6.i = sd.r * z__7.i + sd.i 
		* z__7.r;
	z__11.r = xxi.r * ap.r - xxi.i * ap.i, z__11.i = xxi.r * ap.i + xxi.i 
		* ap.r;
	z__10.r = z__11.r - pp.r, z__10.i = z__11.i - pp.i;
	z__9.r = cd.r * z__10.r - cd.i * z__10.i, z__9.i = cd.r * z__10.i + 
		cd.i * z__10.r;
	z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
	z_div(&z__1, &z__2, &z__5);
	qp.r = z__1.r, qp.i = z__1.i;
	z__2.r = xxi.r * sd.r - xxi.i * sd.i, z__2.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__1.r = cd.r - z__2.r, z__1.i = cd.i - z__2.i;
	den.r = z__1.r, den.i = z__1.i;
	i__3 = segj_1.jsno - 1;
	z__4.r = ap.r * qp.r - ap.i * qp.i, z__4.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__6.r = xxi.r * sdh.r - xxi.i * sdh.i, z__6.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__5.r = cdh.r - z__6.r, z__5.i = cdh.i - z__6.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z__2.r = sdh.r + z__3.r, z__2.i = sdh.i + z__3.i;
	z_div(&z__1, &z__2, &den);
	segj_1.bx[i__3].r = z__1.r, segj_1.bx[i__3].i = z__1.i;
	i__3 = segj_1.jsno - 1;
	z__4.r = ap.r * qp.r - ap.i * qp.i, z__4.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__6.r = xxi.r * cdh.r - xxi.i * cdh.i, z__6.i = xxi.r * cdh.i + 
		xxi.i * cdh.r;
	z__5.r = sdh.r + z__6.r, z__5.i = sdh.i + z__6.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z__2.r = cdh.r + z__3.r, z__2.i = cdh.i + z__3.i;
	z_div(&z__1, &z__2, &den);
	segj_1.cx[i__3].r = z__1.r, segj_1.cx[i__3].i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__3 = segj_1.jsno - 1;
	    i__1 = segj_1.jsno - 1;
	    z__1.r = segj_1.cx[i__1].r - 1.f, z__1.i = segj_1.cx[i__1].i;
	    segj_1.ax[i__3].r = z__1.r, segj_1.ax[i__3].i = z__1.i;
	} else {
	    i__3 = segj_1.jsno - 1;
	    z__6.r = dsq.r * .625f, z__6.i = dsq.i * .625f;
	    z__5.r = 1.5f - z__6.r, z__5.i = -z__6.i;
	    z__4.r = dsq.r * z__5.r - dsq.i * z__5.i, z__4.i = dsq.r * z__5.i 
		    + dsq.i * z__5.r;
	    z__7.r = xxi.r * sd.r - xxi.i * sd.i, z__7.i = xxi.r * sd.i + 
		    xxi.i * sd.r;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__9.r = ap.r * qp.r - ap.i * qp.i, z__9.i = ap.r * qp.i + ap.i * 
		    qp.r;
	    z__11.r = xxi.r * cdh.r - xxi.i * cdh.i, z__11.i = xxi.r * cdh.i 
		    + xxi.i * cdh.r;
	    z__10.r = sdh.r + z__11.r, z__10.i = sdh.i + z__11.i;
	    z__8.r = z__9.r * z__10.r - z__9.i * z__10.i, z__8.i = z__9.r * 
		    z__10.i + z__9.i * z__10.r;
	    z__2.r = z__3.r + z__8.r, z__2.i = z__3.i + z__8.i;
	    z_div(&z__1, &z__2, &den);
	    segj_1.ax[i__3].r = z__1.r, segj_1.ax[i__3].i = z__1.i;
	}
	i__3 = njun2;
	for (iend = 1; iend <= i__3; ++iend) {
	    i__1 = iend - 1;
	    i__2 = iend - 1;
	    z__1.r = segj_1.ax[i__2].r * qp.r - segj_1.ax[i__2].i * qp.i, 
		    z__1.i = segj_1.ax[i__2].r * qp.i + segj_1.ax[i__2].i * 
		    qp.r;
	    segj_1.ax[i__1].r = z__1.r, segj_1.ax[i__1].i = z__1.i;
	    i__1 = iend - 1;
	    i__2 = iend - 1;
	    z__1.r = segj_1.bx[i__2].r * qp.r - segj_1.bx[i__2].i * qp.i, 
		    z__1.i = segj_1.bx[i__2].r * qp.i + segj_1.bx[i__2].i * 
		    qp.r;
	    segj_1.bx[i__1].r = z__1.r, segj_1.bx[i__1].i = z__1.i;
/* L22: */
	    i__1 = iend - 1;
	    i__2 = iend - 1;
	    z__1.r = segj_1.cx[i__2].r * qp.r - segj_1.cx[i__2].i * qp.i, 
		    z__1.i = segj_1.cx[i__2].r * qp.i + segj_1.cx[i__2].i * 
		    qp.r;
	    segj_1.cx[i__1].r = z__1.r, segj_1.cx[i__1].i = z__1.i;
	}
    } else if (njun1 > 0) {
	if (*icap == 0) {
	    xxi.r = 0.f, xxi.i = 0.f;
	} else {
	    z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	    i__1 = *i__ - 1;
	    z__1.r = data_1.bi[i__1] * z__2.r, z__1.i = data_1.bi[i__1] * 
		    z__2.i;
	    xxi.r = z__1.r, xxi.i = z__1.i;
	}
	z__3.r = xxi.r * sd.r - xxi.i * sd.i, z__3.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__2.r = omc.r + z__3.r, z__2.i = omc.i + z__3.i;
	z__7.r = xxi.r * pm.r - xxi.i * pm.i, z__7.i = xxi.r * pm.i + xxi.i * 
		pm.r;
	z__6.r = aj.r - z__7.r, z__6.i = aj.i - z__7.i;
	z__5.r = sd.r * z__6.r - sd.i * z__6.i, z__5.i = sd.r * z__6.i + sd.i 
		* z__6.r;
	z__10.r = xxi.r * aj.r - xxi.i * aj.i, z__10.i = xxi.r * aj.i + xxi.i 
		* aj.r;
	z__9.r = pm.r + z__10.r, z__9.i = pm.i + z__10.i;
	z__8.r = cd.r * z__9.r - cd.i * z__9.i, z__8.i = cd.r * z__9.i + cd.i 
		* z__9.r;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z_div(&z__1, &z__2, &z__4);
	qm.r = z__1.r, qm.i = z__1.i;
	z__2.r = xxi.r * sd.r - xxi.i * sd.i, z__2.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__1.r = cd.r - z__2.r, z__1.i = cd.i - z__2.i;
	den.r = z__1.r, den.i = z__1.i;
	i__1 = segj_1.jsno - 1;
	z__4.r = aj.r * qm.r - aj.i * qm.i, z__4.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__6.r = xxi.r * sdh.r - xxi.i * sdh.i, z__6.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__5.r = cdh.r - z__6.r, z__5.i = cdh.i - z__6.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z__2.r = z__3.r - sdh.r, z__2.i = z__3.i - sdh.i;
	z_div(&z__1, &z__2, &den);
	segj_1.bx[i__1].r = z__1.r, segj_1.bx[i__1].i = z__1.i;
	i__1 = segj_1.jsno - 1;
	z__4.r = aj.r * qm.r - aj.i * qm.i, z__4.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__6.r = xxi.r * cdh.r - xxi.i * cdh.i, z__6.i = xxi.r * cdh.i + 
		xxi.i * cdh.r;
	z__5.r = sdh.r + z__6.r, z__5.i = sdh.i + z__6.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z__2.r = cdh.r - z__3.r, z__2.i = cdh.i - z__3.i;
	z_div(&z__1, &z__2, &den);
	segj_1.cx[i__1].r = z__1.r, segj_1.cx[i__1].i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__1 = segj_1.jsno - 1;
	    i__2 = segj_1.jsno - 1;
	    z__1.r = segj_1.cx[i__2].r - 1.f, z__1.i = segj_1.cx[i__2].i;
	    segj_1.ax[i__1].r = z__1.r, segj_1.ax[i__1].i = z__1.i;
	} else {
	    i__1 = segj_1.jsno - 1;
	    z__6.r = dsq.r * .625f, z__6.i = dsq.i * .625f;
	    z__5.r = 1.5f - z__6.r, z__5.i = -z__6.i;
	    z__4.r = dsq.r * z__5.r - dsq.i * z__5.i, z__4.i = dsq.r * z__5.i 
		    + dsq.i * z__5.r;
	    z__7.r = xxi.r * sd.r - xxi.i * sd.i, z__7.i = xxi.r * sd.i + 
		    xxi.i * sd.r;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__9.r = aj.r * qm.r - aj.i * qm.i, z__9.i = aj.r * qm.i + aj.i * 
		    qm.r;
	    z__11.r = xxi.r * cdh.r - xxi.i * cdh.i, z__11.i = xxi.r * cdh.i 
		    + xxi.i * cdh.r;
	    z__10.r = sdh.r + z__11.r, z__10.i = sdh.i + z__11.i;
	    z__8.r = z__9.r * z__10.r - z__9.i * z__10.i, z__8.i = z__9.r * 
		    z__10.i + z__9.i * z__10.r;
	    z__2.r = z__3.r - z__8.r, z__2.i = z__3.i - z__8.i;
	    z_div(&z__1, &z__2, &den);
	    segj_1.ax[i__1].r = z__1.r, segj_1.ax[i__1].i = z__1.i;
	}
	i__1 = njun1;
	for (iend = 1; iend <= i__1; ++iend) {
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.ax[i__3].r * qm.r - segj_1.ax[i__3].i * qm.i, 
		    z__1.i = segj_1.ax[i__3].r * qm.i + segj_1.ax[i__3].i * 
		    qm.r;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.bx[i__3].r * qm.r - segj_1.bx[i__3].i * qm.i, 
		    z__1.i = segj_1.bx[i__3].r * qm.i + segj_1.bx[i__3].i * 
		    qm.r;
	    segj_1.bx[i__2].r = z__1.r, segj_1.bx[i__2].i = z__1.i;
/* L26: */
	    i__2 = iend - 1;
	    i__3 = iend - 1;
	    z__1.r = segj_1.cx[i__3].r * qm.r - segj_1.cx[i__3].i * qm.i, 
		    z__1.i = segj_1.cx[i__3].r * qm.i + segj_1.cx[i__3].i * 
		    qm.r;
	    segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	}
    } else {
	i__2 = segj_1.jsno - 1;
	segj_1.bx[i__2].r = 0.f, segj_1.bx[i__2].i = 0.f;
	if (*icap == 0) {
	    xxi.r = 0.f, xxi.i = 0.f;
	} else {
	    z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	    i__2 = *i__ - 1;
	    z__1.r = data_1.bi[i__2] * z__2.r, z__1.i = data_1.bi[i__2] * 
		    z__2.i;
	    xxi.r = z__1.r, xxi.i = z__1.i;
	}
	i__2 = segj_1.jsno - 1;
	z__3.r = xxi.r * sdh.r - xxi.i * sdh.i, z__3.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__2.r = cdh.r - z__3.r, z__2.i = cdh.i - z__3.i;
	z_div(&z__1, &c_b336, &z__2);
	segj_1.cx[i__2].r = z__1.r, segj_1.cx[i__2].i = z__1.i;
	if (z_abs(&d__) > alim) {
	    i__2 = segj_1.jsno - 1;
	    i__3 = segj_1.jsno - 1;
	    z__1.r = segj_1.cx[i__3].r - 1.f, z__1.i = segj_1.cx[i__3].i;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	} else {
	    i__2 = segj_1.jsno - 1;
	    z__5.r = dsq.r * .04166666667f, z__5.i = dsq.i * .04166666667f;
	    z__4.r = .5f - z__5.r, z__4.i = -z__5.i;
	    z__3.r = dsq.r * z__4.r - dsq.i * z__4.i, z__3.i = dsq.r * z__4.i 
		    + dsq.i * z__4.r;
	    z__6.r = xxi.r * sdh.r - xxi.i * sdh.i, z__6.i = xxi.r * sdh.i + 
		    xxi.i * sdh.r;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    i__3 = segj_1.jsno - 1;
	    z__1.r = z__2.r * segj_1.cx[i__3].r - z__2.i * segj_1.cx[i__3].i, 
		    z__1.i = z__2.r * segj_1.cx[i__3].i + z__2.i * segj_1.cx[
		    i__3].r;
	    segj_1.ax[i__2].r = z__1.r, segj_1.ax[i__2].i = z__1.i;
	}
    }
    return 0;
} /* tbf_ */

/* Subroutine */ int trio_(integer *jseg)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    extern /* Subroutine */ int sbf_(integer *, integer *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    static integer igx, irx, igc1, igc2, ipc1, ipc2, jbas, jbno, njun1, njun2,
	     njnxt, jncend[30];
    extern /* Subroutine */ int jnfind_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     TRIO computes the components of all basis functions on segment */
/*     JSEG. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    jnfind_(jseg, &c_n1, &c__0, segj_1.jco, jncend, &njun1, &irx, &igx, &igc1,
	     &ipc1);
    njnxt = njun1 + 1;
    jnfind_(jseg, &c__1, &c__0, &segj_1.jco[njnxt - 1], &jncend[njnxt - 1], &
	    njun2, &irx, &igx, &igc2, &ipc2);
    segj_1.jsno = njun1 + njun2 + 1;
    segj_1.jco[segj_1.jsno - 1] = *jseg;
    i__1 = segj_1.jsno;
    for (jbno = 1; jbno <= i__1; ++jbno) {
	jbas = segj_1.jco[jbno - 1];
/* L1: */
	sbf_(&jbas, jseg, &segj_1.ax[jbno - 1], &segj_1.bx[jbno - 1], &
		segj_1.cx[jbno - 1]);
    }
    return 0;
} /* trio_ */

/* Subroutine */ int sbf_(integer *ibas, integer *iseg, doublecomplex *aa, 
	doublecomplex *bb, doublecomplex *cc)
{
    /* Initialized data */

    static doublereal alim = .08;

    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12;

    /* Builtin functions */
    void z_sin(doublecomplex *, doublecomplex *), z_cos(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex d__, cd, aj, ap, sd, pm, qm, pp, qp, xk, cdh, den, 
	    ccx, sdh, omc;
    static integer jno;
    static doublecomplex dsq;
    static integer igx, irx;
    static doublecomplex xxi;
    static integer igc1, igc2, ipc1, ipc2, june, jcox, jnop;
    static doublecomplex term;
    static integer jsno, njun1, njun2, njnxt, image1, image2, jncend[30];
    extern /* Subroutine */ int jnfind_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *);
    static integer jncseg[30];

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SBF computes the component of basis function IBAS that extends */
/*     onto segment ISEG. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    image1 = 0;
    image2 = 0;
    jnfind_(ibas, &c_n1, &c__0, jncseg, jncend, &njun1, &irx, &igx, &igc1, &
	    ipc1);
    if (ipc1 != 0 || igc1 != 0) {
	njun1 = 1;
	jncseg[0] = *ibas;
	jncend[0] = -1;
	image1 = 1;
    }
    njnxt = njun1 + 1;
    jnfind_(ibas, &c__1, &c__0, &jncseg[njnxt - 1], &jncend[njnxt - 1], &
	    njun2, &irx, &igx, &igc2, &ipc2);
    if (ipc2 != 0 || igc2 != 0) {
	njun2 = 1;
	jncseg[njnxt - 1] = *ibas;
	jncend[njnxt - 1] = 1;
	image2 = 1;
    }
    jsno = njun1 + njun2 + 1;
    jncseg[jsno - 1] = *ibas;

/*     EVALUATE A,B,C FOR SEGMENTS CONNECTED TO -1 END OF SEGMENT J */

    aa->r = 0.f, aa->i = 0.f;
    bb->r = 0.f, bb->i = 0.f;
    cc->r = 0.f, cc->i = 0.f;
    june = 0;
    pm.r = 0.f, pm.i = 0.f;
    if (njun1 == 0) {
	goto L2;
    }
    i__1 = njun1;
    for (jno = 1; jno <= i__1; ++jno) {
	jcox = jncseg[jno - 1];
	i__2 = jcox - 1;
	xk.r = crnt_1.xks[i__2].r, xk.i = crnt_1.xks[i__2].i;
	if (jncend[jno - 1] < 0) {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege1[i__2].r, aj.i = jnqcom_1.qsege1[i__2].i;
	} else {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege2[i__2].r, aj.i = jnqcom_1.qsege2[i__2].i;
	}
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__2 = jcox - 1;
	z__1.r = data_1.si[i__2] * z__2.r, z__1.i = data_1.si[i__2] * z__2.i;
	d__.r = z__1.r, d__.i = z__1.i;
	z_sin(&z__1, &d__);
	sdh.r = z__1.r, sdh.i = z__1.i;
	z_cos(&z__1, &d__);
	cdh.r = z__1.r, cdh.i = z__1.i;
	z_div(&z__3, &sdh, &cdh);
	z__2.r = z__3.r * aj.r - z__3.i * aj.i, z__2.i = z__3.r * aj.i + 
		z__3.i * aj.r;
	z__1.r = pm.r + z__2.r, z__1.i = pm.i + z__2.i;
	pm.r = z__1.r, pm.i = z__1.i;
	if (jcox == *iseg) {
	    june = -1;
	    if (z_abs(&d__) > alim) {
		z_div(&z__4, &c_b1298, &cdh);
		z__3.r = z__4.r - .5f, z__3.i = z__4.i;
		z__2.r = aj.r * z__3.r - aj.i * z__3.i, z__2.i = aj.r * 
			z__3.i + aj.i * z__3.r;
		z_div(&z__1, &z__2, &sdh);
		aa->r = z__1.r, aa->i = z__1.i;
	    } else {
		z__3.r = aj.r * .25f, z__3.i = aj.i * .25f;
		z__2.r = z__3.r * d__.r - z__3.i * d__.i, z__2.i = z__3.r * 
			d__.i + z__3.i * d__.r;
		z__6.r = d__.r * .58333333333f, z__6.i = d__.i * 
			.58333333333f;
		z__5.r = z__6.r * d__.r - z__6.i * d__.i, z__5.i = z__6.r * 
			d__.i + z__6.i * d__.r;
		z__4.r = z__5.r + 1.f, z__4.i = z__5.i;
		z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * 
			z__4.i + z__2.i * z__4.r;
		aa->r = z__1.r, aa->i = z__1.i;
	    }
	    z__2.r = cdh.r * 2.f, z__2.i = cdh.i * 2.f;
	    z_div(&z__1, &aj, &z__2);
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__2.r = -aj.r, z__2.i = -aj.i;
	    z__3.r = sdh.r * 2.f, z__3.i = sdh.i * 2.f;
	    z_div(&z__1, &z__2, &z__3);
	    cc->r = z__1.r, cc->i = z__1.i;
	    if (jncend[jno - 1] < 0 && image1 == 0) {
		z__1.r = -aa->r, z__1.i = -aa->i;
		aa->r = z__1.r, aa->i = z__1.i;
		z__1.r = -cc->r, z__1.i = -cc->i;
		cc->r = z__1.r, cc->i = z__1.i;
	    }
	    if (image1 != 0) {
		z__1.r = -bb->r, z__1.i = -bb->i;
		bb->r = z__1.r, bb->i = z__1.i;
	    }
	}
/* L1: */
    }

/*     EVALUATE A,B,C FOR SEGMENTS CONNECTED TO +1 END OF SEGMENT J */

L2:
    pp.r = 0.f, pp.i = 0.f;
    if (njun2 == 0) {
	goto L4;
    }
    i__1 = njun2;
    for (jno = 1; jno <= i__1; ++jno) {
	jnop = jno + njun1;
	jcox = jncseg[jnop - 1];
	i__2 = jcox - 1;
	xk.r = crnt_1.xks[i__2].r, xk.i = crnt_1.xks[i__2].i;
	if (jncend[jnop - 1] < 0) {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege1[i__2].r, aj.i = jnqcom_1.qsege1[i__2].i;
	} else {
	    i__2 = jcox - 1;
	    aj.r = jnqcom_1.qsege2[i__2].r, aj.i = jnqcom_1.qsege2[i__2].i;
	}
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__2 = jcox - 1;
	z__1.r = data_1.si[i__2] * z__2.r, z__1.i = data_1.si[i__2] * z__2.i;
	d__.r = z__1.r, d__.i = z__1.i;
	z_sin(&z__1, &d__);
	sdh.r = z__1.r, sdh.i = z__1.i;
	z_cos(&z__1, &d__);
	cdh.r = z__1.r, cdh.i = z__1.i;
	z_div(&z__3, &sdh, &cdh);
	z__2.r = z__3.r * aj.r - z__3.i * aj.i, z__2.i = z__3.r * aj.i + 
		z__3.i * aj.r;
	z__1.r = pp.r - z__2.r, z__1.i = pp.i - z__2.i;
	pp.r = z__1.r, pp.i = z__1.i;
	if (jcox == *iseg) {
	    june = 1;
	    if (z_abs(&d__) > alim) {
		z__3.r = -aj.r, z__3.i = -aj.i;
		z_div(&z__5, &c_b1298, &cdh);
		z__4.r = z__5.r - .5f, z__4.i = z__5.i;
		z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * 
			z__4.i + z__3.i * z__4.r;
		z_div(&z__1, &z__2, &sdh);
		aa->r = z__1.r, aa->i = z__1.i;
	    } else {
		z__4.r = -aj.r, z__4.i = -aj.i;
		z__3.r = z__4.r * .25f, z__3.i = z__4.i * .25f;
		z__2.r = z__3.r * d__.r - z__3.i * d__.i, z__2.i = z__3.r * 
			d__.i + z__3.i * d__.r;
		z__7.r = d__.r * .58333333333f, z__7.i = d__.i * 
			.58333333333f;
		z__6.r = z__7.r * d__.r - z__7.i * d__.i, z__6.i = z__7.r * 
			d__.i + z__7.i * d__.r;
		z__5.r = z__6.r + 1.f, z__5.i = z__6.i;
		z__1.r = z__2.r * z__5.r - z__2.i * z__5.i, z__1.i = z__2.r * 
			z__5.i + z__2.i * z__5.r;
		aa->r = z__1.r, aa->i = z__1.i;
	    }
	    z__2.r = cdh.r * 2.f, z__2.i = cdh.i * 2.f;
	    z_div(&z__1, &aj, &z__2);
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
	    z_div(&z__1, &aj, &z__2);
	    cc->r = z__1.r, cc->i = z__1.i;
	    if (jncend[jnop - 1] > 0 && image2 == 0) {
		z__1.r = -aa->r, z__1.i = -aa->i;
		aa->r = z__1.r, aa->i = z__1.i;
		z__1.r = -cc->r, z__1.i = -cc->i;
		cc->r = z__1.r, cc->i = z__1.i;
	    }
	    if (image2 != 0) {
		z__1.r = -bb->r, z__1.i = -bb->i;
		bb->r = z__1.r, bb->i = z__1.i;
	    }
	}
/* L3: */
    }
L4:
    i__1 = *ibas - 1;
    xk.r = crnt_1.xks[i__1].r, xk.i = crnt_1.xks[i__1].i;
    z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
    i__1 = *ibas - 1;
    z__1.r = data_1.si[i__1] * z__2.r, z__1.i = data_1.si[i__1] * z__2.i;
    d__.r = z__1.r, d__.i = z__1.i;
    z__1.r = d__.r * d__.r - d__.i * d__.i, z__1.i = d__.r * d__.i + d__.i * 
	    d__.r;
    dsq.r = z__1.r, dsq.i = z__1.i;
    z_sin(&z__1, &d__);
    sdh.r = z__1.r, sdh.i = z__1.i;
    z_cos(&z__1, &d__);
    cdh.r = z__1.r, cdh.i = z__1.i;
    z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
    z__1.r = z__2.r * cdh.r - z__2.i * cdh.i, z__1.i = z__2.r * cdh.i + 
	    z__2.i * cdh.r;
    sd.r = z__1.r, sd.i = z__1.i;
    z__2.r = cdh.r * cdh.r - cdh.i * cdh.i, z__2.i = cdh.r * cdh.i + cdh.i * 
	    cdh.r;
    z__3.r = sdh.r * sdh.r - sdh.i * sdh.i, z__3.i = sdh.r * sdh.i + sdh.i * 
	    sdh.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    cd.r = z__1.r, cd.i = z__1.i;
    z__2.r = sdh.r * 2.f, z__2.i = sdh.i * 2.f;
    z__1.r = z__2.r * sdh.r - z__2.i * sdh.i, z__1.i = z__2.r * sdh.i + 
	    z__2.i * sdh.r;
    omc.r = z__1.r, omc.i = z__1.i;
    i__1 = *ibas - 1;
    aj.r = jnqcom_1.qsege1[i__1].r, aj.i = jnqcom_1.qsege1[i__1].i;
    i__1 = *ibas - 1;
    ap.r = jnqcom_1.qsege2[i__1].r, ap.i = jnqcom_1.qsege2[i__1].i;
    if (njun1 > 0 && njun2 > 0) {
	z__4.r = pm.r * pp.r - pm.i * pp.i, z__4.i = pm.r * pp.i + pm.i * 
		pp.r;
	z__5.r = aj.r * ap.r - aj.i * ap.i, z__5.i = aj.r * ap.i + aj.i * 
		ap.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = sd.r * z__3.r - sd.i * z__3.i, z__2.i = sd.r * z__3.i + sd.i 
		* z__3.r;
	z__8.r = pm.r * ap.r - pm.i * ap.i, z__8.i = pm.r * ap.i + pm.i * 
		ap.r;
	z__9.r = pp.r * aj.r - pp.i * aj.i, z__9.i = pp.r * aj.i + pp.i * 
		aj.r;
	z__7.r = z__8.r - z__9.r, z__7.i = z__8.i - z__9.i;
	z__6.r = cd.r * z__7.r - cd.i * z__7.i, z__6.i = cd.r * z__7.i + cd.i 
		* z__7.r;
	z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
	den.r = z__1.r, den.i = z__1.i;
	z__3.r = ap.r * omc.r - ap.i * omc.i, z__3.i = ap.r * omc.i + ap.i * 
		omc.r;
	z__4.r = pp.r * sd.r - pp.i * sd.i, z__4.i = pp.r * sd.i + pp.i * 
		sd.r;
	z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
	z_div(&z__1, &z__2, &den);
	qm.r = z__1.r, qm.i = z__1.i;
	z__4.r = aj.r * omc.r - aj.i * omc.i, z__4.i = aj.r * omc.i + aj.i * 
		omc.r;
	z__5.r = pm.r * sd.r - pm.i * sd.i, z__5.i = pm.r * sd.i + pm.i * 
		sd.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &den);
	qp.r = z__1.r, qp.i = z__1.i;
	if (june == -1) {
	    z__1.r = aa->r * qm.r - aa->i * qm.i, z__1.i = aa->r * qm.i + 
		    aa->i * qm.r;
	    aa->r = z__1.r, aa->i = z__1.i;
	    z__1.r = bb->r * qm.r - bb->i * qm.i, z__1.i = bb->r * qm.i + 
		    bb->i * qm.r;
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__1.r = cc->r * qm.r - cc->i * qm.i, z__1.i = cc->r * qm.i + 
		    cc->i * qm.r;
	    cc->r = z__1.r, cc->i = z__1.i;
	} else if (june == 1) {
	    z__1.r = aa->r * qp.r - aa->i * qp.i, z__1.i = aa->r * qp.i + 
		    aa->i * qp.r;
	    aa->r = z__1.r, aa->i = z__1.i;
	    z__1.r = bb->r * qp.r - bb->i * qp.i, z__1.i = bb->r * qp.i + 
		    bb->i * qp.r;
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__1.r = cc->r * qp.r - cc->i * qp.i, z__1.i = cc->r * qp.i + 
		    cc->i * qp.r;
	    cc->r = z__1.r, cc->i = z__1.i;
	}
	if (*ibas != *iseg) {
	    return 0;
	}
	z__5.r = aj.r * qm.r - aj.i * qm.i, z__5.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__6.r = ap.r * qp.r - ap.i * qp.i, z__6.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
	z__3.r = z__4.r * sdh.r - z__4.i * sdh.i, z__3.i = z__4.r * sdh.i + 
		z__4.i * sdh.r;
	z_div(&z__2, &z__3, &sd);
	z__1.r = bb->r + z__2.r, z__1.i = bb->i + z__2.i;
	bb->r = z__1.r, bb->i = z__1.i;
	z__4.r = aj.r * qm.r - aj.i * qm.i, z__4.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__5.r = ap.r * qp.r - ap.i * qp.i, z__5.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__3.r = z__4.r - z__5.r, z__3.i = z__4.i - z__5.i;
	z__2.r = z__3.r * cdh.r - z__3.i * cdh.i, z__2.i = z__3.r * cdh.i + 
		z__3.i * cdh.r;
	z_div(&z__1, &z__2, &sd);
	ccx.r = z__1.r, ccx.i = z__1.i;
	z__1.r = cc->r + ccx.r, z__1.i = cc->i + ccx.i;
	cc->r = z__1.r, cc->i = z__1.i;
	if (z_abs(&d__) > alim) {
	    z__2.r = aa->r + ccx.r, z__2.i = aa->i + ccx.i;
	    z__1.r = z__2.r - 1.f, z__1.i = z__2.i;
	    aa->r = z__1.r, aa->i = z__1.i;
	} else {
	    z_div(&z__5, &pm, &d__);
	    z__4.r = -z__5.r, z__4.i = -z__5.i;
	    z_div(&z__6, &pp, &d__);
	    z__3.r = z__4.r * z__6.r - z__4.i * z__6.i, z__3.i = z__4.r * 
		    z__6.i + z__4.i * z__6.r;
	    z__2.r = z__3.r * sd.r - z__3.i * sd.i, z__2.i = z__3.r * sd.i + 
		    z__3.i * sd.r;
	    z__9.r = aj.r * ap.r - aj.i * ap.i, z__9.i = aj.r * ap.i + aj.i * 
		    ap.r;
	    z__8.r = z__9.r * d__.r - z__9.i * d__.i, z__8.i = z__9.r * d__.i 
		    + z__9.i * d__.r;
	    z__11.r = dsq.r * .25f, z__11.i = dsq.i * .25f;
	    z__10.r = 1.f - z__11.r, z__10.i = -z__11.i;
	    z__7.r = z__8.r * z__10.r - z__8.i * z__10.i, z__7.i = z__8.r * 
		    z__10.i + z__8.i * z__10.r;
	    z__1.r = z__2.r + z__7.r, z__1.i = z__2.i + z__7.i;
	    term.r = z__1.r, term.i = z__1.i;
	    z__7.r = pm.r * ap.r - pm.i * ap.i, z__7.i = pm.r * ap.i + pm.i * 
		    ap.r;
	    z__8.r = pp.r * aj.r - pp.i * aj.i, z__8.i = pp.r * aj.i + pp.i * 
		    aj.r;
	    z__6.r = z__7.r - z__8.r, z__6.i = z__7.i - z__8.i;
	    z__10.r = dsq.r * .625f, z__10.i = dsq.i * .625f;
	    z__9.r = 1.5f - z__10.r, z__9.i = -z__10.i;
	    z__5.r = z__6.r * z__9.r - z__6.i * z__9.i, z__5.i = z__6.r * 
		    z__9.i + z__6.i * z__9.r;
	    z__4.r = term.r + z__5.r, z__4.i = term.i + z__5.i;
	    z_div(&z__3, &z__4, &den);
	    z__2.r = z__3.r * dsq.r - z__3.i * dsq.i, z__2.i = z__3.r * dsq.i 
		    + z__3.i * dsq.r;
	    z__1.r = aa->r + z__2.r, z__1.i = aa->i + z__2.i;
	    aa->r = z__1.r, aa->i = z__1.i;
	}
	return 0;
    } else if (njun2 > 0) {
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__1 = *ibas - 1;
	z__1.r = data_1.bi[i__1] * z__2.r, z__1.i = data_1.bi[i__1] * z__2.i;
	xxi.r = z__1.r, xxi.i = z__1.i;
	z__4.r = xxi.r * sd.r - xxi.i * sd.i, z__4.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__3.r = omc.r + z__4.r, z__3.i = omc.i + z__4.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z__8.r = xxi.r * pp.r - xxi.i * pp.i, z__8.i = xxi.r * pp.i + xxi.i * 
		pp.r;
	z__7.r = ap.r + z__8.r, z__7.i = ap.i + z__8.i;
	z__6.r = sd.r * z__7.r - sd.i * z__7.i, z__6.i = sd.r * z__7.i + sd.i 
		* z__7.r;
	z__11.r = xxi.r * ap.r - xxi.i * ap.i, z__11.i = xxi.r * ap.i + xxi.i 
		* ap.r;
	z__10.r = z__11.r - pp.r, z__10.i = z__11.i - pp.i;
	z__9.r = cd.r * z__10.r - cd.i * z__10.i, z__9.i = cd.r * z__10.i + 
		cd.i * z__10.r;
	z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
	z_div(&z__1, &z__2, &z__5);
	qp.r = z__1.r, qp.i = z__1.i;
	if (june == 1) {
	    z__1.r = aa->r * qp.r - aa->i * qp.i, z__1.i = aa->r * qp.i + 
		    aa->i * qp.r;
	    aa->r = z__1.r, aa->i = z__1.i;
	    z__1.r = bb->r * qp.r - bb->i * qp.i, z__1.i = bb->r * qp.i + 
		    bb->i * qp.r;
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__1.r = cc->r * qp.r - cc->i * qp.i, z__1.i = cc->r * qp.i + 
		    cc->i * qp.r;
	    cc->r = z__1.r, cc->i = z__1.i;
	}
	if (*ibas != *iseg) {
	    return 0;
	}
	z__2.r = xxi.r * sd.r - xxi.i * sd.i, z__2.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__1.r = cd.r - z__2.r, z__1.i = cd.i - z__2.i;
	den.r = z__1.r, den.i = z__1.i;
	z__5.r = ap.r * qp.r - ap.i * qp.i, z__5.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__7.r = xxi.r * sdh.r - xxi.i * sdh.i, z__7.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__6.r = cdh.r - z__7.r, z__6.i = cdh.i - z__7.i;
	z__4.r = z__5.r * z__6.r - z__5.i * z__6.i, z__4.i = z__5.r * z__6.i 
		+ z__5.i * z__6.r;
	z__3.r = sdh.r + z__4.r, z__3.i = sdh.i + z__4.i;
	z_div(&z__2, &z__3, &den);
	z__1.r = bb->r + z__2.r, z__1.i = bb->i + z__2.i;
	bb->r = z__1.r, bb->i = z__1.i;
	z__4.r = ap.r * qp.r - ap.i * qp.i, z__4.i = ap.r * qp.i + ap.i * 
		qp.r;
	z__6.r = xxi.r * cdh.r - xxi.i * cdh.i, z__6.i = xxi.r * cdh.i + 
		xxi.i * cdh.r;
	z__5.r = sdh.r + z__6.r, z__5.i = sdh.i + z__6.i;
	z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i 
		+ z__4.i * z__5.r;
	z__2.r = cdh.r + z__3.r, z__2.i = cdh.i + z__3.i;
	z_div(&z__1, &z__2, &den);
	ccx.r = z__1.r, ccx.i = z__1.i;
	z__1.r = cc->r + ccx.r, z__1.i = cc->i + ccx.i;
	cc->r = z__1.r, cc->i = z__1.i;
	if (z_abs(&d__) > alim) {
	    z__2.r = aa->r + ccx.r, z__2.i = aa->i + ccx.i;
	    z__1.r = z__2.r - 1.f, z__1.i = z__2.i;
	    aa->r = z__1.r, aa->i = z__1.i;
	} else {
	    z__7.r = dsq.r * .625f, z__7.i = dsq.i * .625f;
	    z__6.r = 1.5f - z__7.r, z__6.i = -z__7.i;
	    z__5.r = dsq.r * z__6.r - dsq.i * z__6.i, z__5.i = dsq.r * z__6.i 
		    + dsq.i * z__6.r;
	    z__8.r = xxi.r * sd.r - xxi.i * sd.i, z__8.i = xxi.r * sd.i + 
		    xxi.i * sd.r;
	    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	    z__10.r = ap.r * qp.r - ap.i * qp.i, z__10.i = ap.r * qp.i + ap.i 
		    * qp.r;
	    z__12.r = xxi.r * cdh.r - xxi.i * cdh.i, z__12.i = xxi.r * cdh.i 
		    + xxi.i * cdh.r;
	    z__11.r = sdh.r + z__12.r, z__11.i = sdh.i + z__12.i;
	    z__9.r = z__10.r * z__11.r - z__10.i * z__11.i, z__9.i = z__10.r *
		     z__11.i + z__10.i * z__11.r;
	    z__3.r = z__4.r + z__9.r, z__3.i = z__4.i + z__9.i;
	    z_div(&z__2, &z__3, &den);
	    z__1.r = aa->r + z__2.r, z__1.i = aa->i + z__2.i;
	    aa->r = z__1.r, aa->i = z__1.i;
	}
	return 0;
    } else if (njun1 > 0) {
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__1 = *ibas - 1;
	z__1.r = data_1.bi[i__1] * z__2.r, z__1.i = data_1.bi[i__1] * z__2.i;
	xxi.r = z__1.r, xxi.i = z__1.i;
	z__3.r = xxi.r * sd.r - xxi.i * sd.i, z__3.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__2.r = omc.r + z__3.r, z__2.i = omc.i + z__3.i;
	z__7.r = xxi.r * pm.r - xxi.i * pm.i, z__7.i = xxi.r * pm.i + xxi.i * 
		pm.r;
	z__6.r = aj.r - z__7.r, z__6.i = aj.i - z__7.i;
	z__5.r = sd.r * z__6.r - sd.i * z__6.i, z__5.i = sd.r * z__6.i + sd.i 
		* z__6.r;
	z__10.r = xxi.r * aj.r - xxi.i * aj.i, z__10.i = xxi.r * aj.i + xxi.i 
		* aj.r;
	z__9.r = pm.r + z__10.r, z__9.i = pm.i + z__10.i;
	z__8.r = cd.r * z__9.r - cd.i * z__9.i, z__8.i = cd.r * z__9.i + cd.i 
		* z__9.r;
	z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
	z_div(&z__1, &z__2, &z__4);
	qm.r = z__1.r, qm.i = z__1.i;
	if (june == -1) {
	    z__1.r = aa->r * qm.r - aa->i * qm.i, z__1.i = aa->r * qm.i + 
		    aa->i * qm.r;
	    aa->r = z__1.r, aa->i = z__1.i;
	    z__1.r = bb->r * qm.r - bb->i * qm.i, z__1.i = bb->r * qm.i + 
		    bb->i * qm.r;
	    bb->r = z__1.r, bb->i = z__1.i;
	    z__1.r = cc->r * qm.r - cc->i * qm.i, z__1.i = cc->r * qm.i + 
		    cc->i * qm.r;
	    cc->r = z__1.r, cc->i = z__1.i;
	}
	if (*ibas != *iseg) {
	    return 0;
	}
	z__2.r = xxi.r * sd.r - xxi.i * sd.i, z__2.i = xxi.r * sd.i + xxi.i * 
		sd.r;
	z__1.r = cd.r - z__2.r, z__1.i = cd.i - z__2.i;
	den.r = z__1.r, den.i = z__1.i;
	z__5.r = aj.r * qm.r - aj.i * qm.i, z__5.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__7.r = xxi.r * sdh.r - xxi.i * sdh.i, z__7.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__6.r = cdh.r - z__7.r, z__6.i = cdh.i - z__7.i;
	z__4.r = z__5.r * z__6.r - z__5.i * z__6.i, z__4.i = z__5.r * z__6.i 
		+ z__5.i * z__6.r;
	z__3.r = z__4.r - sdh.r, z__3.i = z__4.i - sdh.i;
	z_div(&z__2, &z__3, &den);
	z__1.r = bb->r + z__2.r, z__1.i = bb->i + z__2.i;
	bb->r = z__1.r, bb->i = z__1.i;
	z__5.r = aj.r * qm.r - aj.i * qm.i, z__5.i = aj.r * qm.i + aj.i * 
		qm.r;
	z__7.r = xxi.r * cdh.r - xxi.i * cdh.i, z__7.i = xxi.r * cdh.i + 
		xxi.i * cdh.r;
	z__6.r = sdh.r + z__7.r, z__6.i = sdh.i + z__7.i;
	z__4.r = z__5.r * z__6.r - z__5.i * z__6.i, z__4.i = z__5.r * z__6.i 
		+ z__5.i * z__6.r;
	z__3.r = cdh.r - z__4.r, z__3.i = cdh.i - z__4.i;
	z_div(&z__2, &z__3, &den);
	z__1.r = cc->r + z__2.r, z__1.i = cc->i + z__2.i;
	cc->r = z__1.r, cc->i = z__1.i;
	if (z_abs(&d__) > alim) {
	    z__1.r = cc->r - 1.f, z__1.i = cc->i;
	    aa->r = z__1.r, aa->i = z__1.i;
	} else {
	    z__6.r = dsq.r * .625f, z__6.i = dsq.i * .625f;
	    z__5.r = 1.5f - z__6.r, z__5.i = -z__6.i;
	    z__4.r = dsq.r * z__5.r - dsq.i * z__5.i, z__4.i = dsq.r * z__5.i 
		    + dsq.i * z__5.r;
	    z__7.r = xxi.r * sd.r - xxi.i * sd.i, z__7.i = xxi.r * sd.i + 
		    xxi.i * sd.r;
	    z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
	    z__9.r = aj.r * qm.r - aj.i * qm.i, z__9.i = aj.r * qm.i + aj.i * 
		    qm.r;
	    z__11.r = xxi.r * cdh.r - xxi.i * cdh.i, z__11.i = xxi.r * cdh.i 
		    + xxi.i * cdh.r;
	    z__10.r = sdh.r + z__11.r, z__10.i = sdh.i + z__11.i;
	    z__8.r = z__9.r * z__10.r - z__9.i * z__10.i, z__8.i = z__9.r * 
		    z__10.i + z__9.i * z__10.r;
	    z__2.r = z__3.r - z__8.r, z__2.i = z__3.i - z__8.i;
	    z_div(&z__1, &z__2, &den);
	    aa->r = z__1.r, aa->i = z__1.i;
	}
	return 0;
    } else {
	z__2.r = xk.r * .5f, z__2.i = xk.i * .5f;
	i__1 = *ibas - 1;
	z__1.r = data_1.bi[i__1] * z__2.r, z__1.i = data_1.bi[i__1] * z__2.i;
	xxi.r = z__1.r, xxi.i = z__1.i;
	z__3.r = xxi.r * sdh.r - xxi.i * sdh.i, z__3.i = xxi.r * sdh.i + 
		xxi.i * sdh.r;
	z__2.r = cdh.r - z__3.r, z__2.i = cdh.i - z__3.i;
	z_div(&z__1, &c_b336, &z__2);
	cc->r = z__1.r, cc->i = z__1.i;
	if (z_abs(&d__) > alim) {
	    z__1.r = cc->r - 1.f, z__1.i = cc->i;
	    aa->r = z__1.r, aa->i = z__1.i;
	} else {
	    z__5.r = dsq.r * .04166666667f, z__5.i = dsq.i * .04166666667f;
	    z__4.r = .5f - z__5.r, z__4.i = -z__5.i;
	    z__3.r = dsq.r * z__4.r - dsq.i * z__4.i, z__3.i = dsq.r * z__4.i 
		    + dsq.i * z__4.r;
	    z__6.r = xxi.r * sdh.r - xxi.i * sdh.i, z__6.i = xxi.r * sdh.i + 
		    xxi.i * sdh.r;
	    z__2.r = z__3.r + z__6.r, z__2.i = z__3.i + z__6.i;
	    z__1.r = z__2.r * cc->r - z__2.i * cc->i, z__1.i = z__2.r * cc->i 
		    + z__2.i * cc->r;
	    aa->r = z__1.r, aa->i = z__1.i;
	}
    }
    return 0;
} /* sbf_ */

/* Subroutine */ int qsolve_(integer *njwire, integer *jncseg, integer *
	jncend, doublecomplex *xk, doublecomplex *qjrati)
{
    static integer ip[90];
    static doublecomplex rhs[90];
    static integer ntot;
    extern /* Subroutine */ int factr_(integer *, doublecomplex *, integer *, 
	    integer *);
    static doublereal slena;
    extern /* Subroutine */ int qmfil_(integer *, integer *, integer *, 
	    integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    integer *, doublereal *), solve_(integer *, doublecomplex *, 
	    integer *, doublecomplex *, integer *);
    static doublecomplex pmatx[8100]	/* was [90][90] */;
    extern /* Subroutine */ int qjratv_(integer *, integer *, integer *, 
	    doublereal *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     QSOLVE controls the solution for the charge distribution at a */
/*     junction to produce a continuous scalar potential. */

/*     INPUT: */
/*     NJWIRE = NUMBER OF WIRES AT THE JUNCTION */
/*     JNCSEG(I) = NEC SEGMENT NUMBER FOR THE I'TH WIRE */
/*     JNCEND(I) = -1 IF MINUS END OF SEGMENT IS CONNECTED TO JUNCTION */
/*                 +1 IF PLUS END OF SEGMENT IS CONNECTED TO JUNCTION */

/*     OUTPUT: */
/*     QJRATI(I) = RELATIVE CHARGE DENSITY ON WIRE I AT THE JUNCTION */

/*     NSEGPW = NUMBER OF SEGMENTS TO BE USED IN THE SOLUTION FOR EACH */
/*              WIRE */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --qjrati;
    --jncend;
    --jncseg;

    /* Function Body */
    ntot = *njwire * 3;
    qmfil_(njwire, &c__3, &jncseg[1], &jncend[1], xk, pmatx, rhs, &c__90, &
	    slena);
    factr_(&ntot, pmatx, ip, &c__90);
    solve_(&ntot, pmatx, ip, rhs, &c__90);
    qjratv_(njwire, &c__3, &jncseg[1], &slena, rhs, &qjrati[1]);
    return 0;
} /* qsolve_ */

/* Subroutine */ int qjratv_(integer *njwire, integer *nsegpw, integer *
	jncseg, doublereal *slena, doublecomplex *rhs, doublecomplex *qjrati)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer iw, ijnc, iseg;
    static doublecomplex qval;
    static doublereal sval;
    static doublecomplex qnorm;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     QJRATV determines the relative charge densities on each wire at */
/*     a junction from the solution for continuity of scalar potential. */
/*     The charge density at the junction end of each wire is the sum of */
/*     half-triangle basis function a the junction and the semi-infinite */
/*     basis function on that wire. */

/*     INPUT: */
/*     NJWIRE = NUMBER OF WIRES AT THE JUNCTION */
/*     NSEGPW = NUMBER OF SEGMENTS TO BE USED IN THE SOLUTION FOR EACH */
/*              WIRE */
/*     JNCSEG(I) = NEC SEGMENT NUMBER FOR THE I'TH WIRE */
/*     SLENA = AVERAGE LENGTH OF SEGMENTS AT THE JUNCTION */
/*     RHS(I) = AMPLITUDE OF CHARGE BASIS FUNCTION NUMBER I */

/*     OUTPUT: */
/*     QJRATI(I) = RELATIVE CHARGE DENSITY ON WIRE I AT THE JUNCTION */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --qjrati;
    --rhs;
    --jncseg;

    /* Function Body */
    ijnc = 1;
    i__1 = *njwire;
    for (iw = 1; iw <= i__1; ++iw) {
	if (iw > 1) {
	    ijnc += *nsegpw;
	}
	iseg = jncseg[iw];
	if (*njwire > 2) {
	    sval = data_1.si[iseg - 1] * .5f;
	    if (sval < data_1.bi[iseg - 1]) {
		sval = data_1.bi[iseg - 1];
	    }
	    if (sval > *slena) {
		sval = *slena;
	    }
	    d__1 = *slena - sval;
	    i__2 = ijnc;
	    z__2.r = d__1 * rhs[i__2].r, z__2.i = d__1 * rhs[i__2].i;
	    i__3 = ijnc - 1 + *nsegpw;
	    z__3.r = *slena * rhs[i__3].r, z__3.i = *slena * rhs[i__3].i;
	    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
	    qval.r = z__1.r, qval.i = z__1.i;
	    if (*nsegpw > 2) {
		i__2 = ijnc + 1;
		z__2.r = sval * rhs[i__2].r, z__2.i = sval * rhs[i__2].i;
		z__1.r = qval.r + z__2.r, z__1.i = qval.i + z__2.i;
		qval.r = z__1.r, qval.i = z__1.i;
	    }
	} else {
	    i__2 = ijnc;
	    i__3 = ijnc - 1 + *nsegpw;
	    z__2.r = rhs[i__2].r + rhs[i__3].r, z__2.i = rhs[i__2].i + rhs[
		    i__3].i;
	    z__1.r = *slena * z__2.r, z__1.i = *slena * z__2.i;
	    qval.r = z__1.r, qval.i = z__1.i;
	}
	if (iw == 1) {
	    qnorm.r = qval.r, qnorm.i = qval.i;
	    qjrati[1].r = 1.f, qjrati[1].i = 0.f;
	} else {
	    i__2 = iw;
	    z_div(&z__1, &qval, &qnorm);
	    qjrati[i__2].r = z__1.r, qjrati[i__2].i = z__1.i;
	}
/* L1: */
    }
    return 0;
} /* qjratv_ */

/* Subroutine */ int qmfil_(integer *njwire, integer *nsegpw, integer *jncseg,
	 integer *jncend, doublecomplex *xk, doublecomplex *pmatx, 
	doublecomplex *rhs, integer *jndim, doublereal *sleni)
{
    /* System generated locals */
    integer pmatx_dim1, pmatx_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1;

    /* Builtin functions */
    double z_abs(doublecomplex *);

    /* Local variables */
    static integer is, iw, jw;
    static doublereal xi, yi, zi, xj, yj, zj;
    static integer js;
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static integer ieq, jeq;
    static doublecomplex spm, spp;
    static integer iseg, jseg, ntot;
    static doublereal bifac, aradj, bimax, slend, xjend, slenj, yjend, zjend, 
	    xidir, yidir, zidir, xjdir, yjdir, zjdir;
    static integer nspwm;
    static doublecomplex seminf;
    extern /* Subroutine */ int scapot_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *), 
	    scapox_(doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     QMFIL fills the scalar potential interaction matrix for triangular */
/*     charge basis functions. */

/*     INPUT: */
/*     NJWIRE = NUMBER OF WIRES AT THE JUNCTION */
/*     NSEGPW = NUMBER OF SEGMENTS TO BE USED IN THE SOLUTION FOR EACH */
/*              WIRE */
/*     JNCSEG(I) = NEC SEGMENT NUMBER FOR THE I'TH WIRE */
/*     JNCEND(I) = -1 IF MINUS END OF SEGMENT IS CONNECTED TO JUNCTION */
/*                 +1 IF PLUS END OF SEGMENT IS CONNECTED TO JUNCTION */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE WIRES */
/*     JNDIM = DIMENSIONED SIZE OF ARRAY PMATX */

/*     OUTPUT: */
/*     PMATX(J,I) = INTERACTION MATRIX; POTENTIAL AT MATCH POINT I DUE */
/*                  TO BASIS FUNCTION J */
/*     RHS(I) = RIGHT HAND SIDE VECTOR FOR THE MATRIX EQUATION */
/*     SLENI = AVERAGE LENGTH OF SEGMENTS AT THE JUNCTION */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    --jncseg;
    --jncend;
    --rhs;
    pmatx_dim1 = *jndim;
    pmatx_offset = 1 + pmatx_dim1;
    pmatx -= pmatx_offset;

    /* Function Body */
    ntot = *njwire * *nsegpw;
    i__1 = ntot;
    for (iw = 1; iw <= i__1; ++iw) {
	i__2 = iw;
	rhs[i__2].r = 1.f, rhs[i__2].i = 0.f;
	i__2 = ntot;
	for (jw = 1; jw <= i__2; ++jw) {
/* L2: */
	    i__3 = iw + jw * pmatx_dim1;
	    pmatx[i__3].r = 0.f, pmatx[i__3].i = 0.f;
	}
    }

/*     Use average segment length and adjust length and radius to avoid */
/*     instabilities in the thin-wire solution for charge. */

    *sleni = 0.f;
    bimax = 0.f;
    i__3 = *njwire;
    for (iw = 1; iw <= i__3; ++iw) {
	iseg = jncseg[iw];
	*sleni += data_1.si[iseg - 1];
	if (data_1.bi[iseg - 1] > bimax) {
	    bimax = data_1.bi[iseg - 1];
	}
/* L1: */
    }
    *sleni /= *njwire;
    if (*njwire > 2) {
	bifac = .0628318f / (z_abs(xk) * bimax * *njwire);
	if (bifac > 1.f) {
	    bifac = 1.f;
	}
    } else {
	bifac = 1.f;
    }
    if (*sleni < bimax * bifac) {
	*sleni = bimax * bifac;
    }
    slenj = *sleni;
    ieq = 0;

/*     Evaluation point loop */

    i__3 = *njwire;
    for (iw = 1; iw <= i__3; ++iw) {
	iseg = jncseg[iw];
	xidir = cab[iseg - 1];
	yidir = sab[iseg - 1];
	zidir = data_1.salp[iseg - 1];
	if (jncend[iw] > 0) {
	    xidir = -xidir;
	    yidir = -yidir;
	    zidir = -zidir;
	}
	slend = (*sleni - data_1.si[iseg - 1]) * .5f;
	xi = data_1.x[iseg - 1] + slend * xidir;
	yi = data_1.y[iseg - 1] + slend * yidir;
	zi = data_1.z__[iseg - 1] + slend * zidir;
	i__2 = *nsegpw;
	for (is = 1; is <= i__2; ++is) {
	    ++ieq;
	    if (is == 2) {
		xi += xidir * *sleni * .5f;
		yi += yidir * *sleni * .5f;
		zi += zidir * *sleni * .5f;
	    } else if (is > 2) {
		xi += xidir * *sleni;
		yi += yidir * *sleni;
		zi += zidir * *sleni;
	    }

/*     SOURCE SEGMENT LOOP */

	    jeq = 0;
	    i__1 = *njwire;
	    for (jw = 1; jw <= i__1; ++jw) {
		jseg = jncseg[jw];
		xjdir = cab[jseg - 1];
		yjdir = sab[jseg - 1];
		zjdir = data_1.salp[jseg - 1];
		if (jncend[jw] > 0) {
		    xjdir = -xjdir;
		    yjdir = -yjdir;
		    zjdir = -zjdir;
		}
		aradj = data_1.bi[jseg - 1] * bifac;
		slend = (slenj - data_1.si[jseg - 1]) * .5f;
		xj = data_1.x[jseg - 1] + slend * xjdir;
		yj = data_1.y[jseg - 1] + slend * yjdir;
		zj = data_1.z__[jseg - 1] + slend * zjdir;
		xjend = xj - xjdir * slenj * .5f;
		yjend = yj - yjdir * slenj * .5f;
		zjend = zj - zjdir * slenj * .5f;
		nspwm = *nsegpw - 1;
		i__4 = *nsegpw;
		for (js = 1; js <= i__4; ++js) {
		    ++jeq;
		    if (js < *nsegpw) {
			if (js > 1) {
			    xj += xjdir * slenj;
			    yj += yjdir * slenj;
			    zj += zjdir * slenj;
			}
			scapot_(&xi, &yi, &zi, &xj, &yj, &zj, &slenj, &aradj, 
				&xjdir, &yjdir, &zjdir, xk, &spp, &spm);
			i__5 = jeq + ieq * pmatx_dim1;
			i__6 = jeq + ieq * pmatx_dim1;
			z__1.r = pmatx[i__6].r + spm.r, z__1.i = pmatx[i__6]
				.i + spm.i;
			pmatx[i__5].r = z__1.r, pmatx[i__5].i = z__1.i;
			if (js < nspwm) {
			    i__5 = jeq + 1 + ieq * pmatx_dim1;
			    i__6 = jeq + 1 + ieq * pmatx_dim1;
			    z__1.r = pmatx[i__6].r + spp.r, z__1.i = pmatx[
				    i__6].i + spp.i;
			    pmatx[i__5].r = z__1.r, pmatx[i__5].i = z__1.i;
			}
		    } else {
			scapox_(&xi, &yi, &zi, &xjend, &yjend, &zjend, &aradj,
				 &xjdir, &yjdir, &zjdir, xk, &seminf);
			i__5 = jeq + ieq * pmatx_dim1;
			z__1.r = slenj * seminf.r, z__1.i = slenj * seminf.i;
			pmatx[i__5].r = z__1.r, pmatx[i__5].i = z__1.i;
		    }
/* L3: */
		}
/* L4: */
	    }
/* L5: */
	}
    }
    return 0;
} /* qmfil_ */

#undef sab
#undef cab


/* Subroutine */ int scapot_(doublereal *xi, doublereal *yi, doublereal *zi, 
	doublereal *xj, doublereal *yj, doublereal *zj, doublereal *slenj, 
	doublereal *aradj, doublereal *xjdir, doublereal *yjdir, doublereal *
	zjdir, doublecomplex *xk, doublecomplex *spp, doublecomplex *spm)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal zz, rho, xij, yij, zij, rhox, rhoy, rhoz;
    extern /* Subroutine */ int spmpot_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SCAPOT evaluates the integral for scalar potential due to charge */
/*     on a wire segment.  The factor 1/(4*PI*EPSILON) has been omitted */
/*     since only relative values in a medium with constant permittivity */
/*     are needed. */

/*     INPUT: */
/*     XI,YI,ZI = COORDINATES OF THE EVALUATION POINT */
/*     XJ,YJ,ZJ = COORDINATES OF THE CENTER OF THE SEGMENT */
/*     ARADJ = RADIUS OF THE WIRE */
/*     XJDIR,YJDIR,ZJDIR = UNIT VECTOR IN THE OUTWARD DIRECTION ON THE */
/*                         WIRE */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE WIRE */

/*     OUTPUT: */
/*     SPP = SCALAR POTENTIAL DUE TO CHARGE DISTRIBUTION OF .5*SLEN+Z */
/*     SPM = SCALAR POTENTIAL DUE TO CHARGE DISTRIBUTION OF .5*SLEN-Z */

    xij = *xi - *xj;
    yij = *yi - *yj;
    zij = *zi - *zj;
    zz = xij * *xjdir + yij * *yjdir + zij * *zjdir;
    rhox = xij - *xjdir * zz;
    rhoy = yij - *yjdir * zz;
    rhoz = zij - *zjdir * zz;
/* Computing 2nd power */
    d__1 = rhox;
/* Computing 2nd power */
    d__2 = rhoy;
/* Computing 2nd power */
    d__3 = rhoz;
/* Computing 2nd power */
    d__4 = *aradj;
    rho = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3 + d__4 * d__4);
    spmpot_(&rho, &zz, slenj, xk, spp, spm);
    return 0;
} /* scapot_ */

/* Subroutine */ int scapox_(doublereal *xi, doublereal *yi, doublereal *zi, 
	doublereal *xjend, doublereal *yjend, doublereal *zjend, doublereal *
	aradj, doublereal *xjdir, doublereal *yjdir, doublereal *zjdir, 
	doublecomplex *xk, doublecomplex *seminf)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static doublereal zz, rho, xij, yij, zij;
    static doublecomplex spp;
    static doublereal slen, rhox, rhoy, rhoz;
    extern /* Subroutine */ int hank2z_(doublecomplex *, doublecomplex *);
    static doublecomplex hankkr;
    extern /* Subroutine */ int exrint_(doublereal *, doublereal *, 
	    doublereal *, doublecomplex *, doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SCAPOX evaluates the integral for scalar potential due to unit */
/*     charge on a semi-infinite section of wire.  The factor */
/*     1/(4*PI*EPSILON) has been omitted since only relative values in */
/*     a medium with constant permittivity are needed. */

/*     INPUT: */
/*     XI,YI,ZI = COORDINATES OF THE EVALUATION POINT */
/*     XJEND,YJEND,ZJEND = COORDINATES OF THE END OF THE SEMI-INFINITE */
/*                         WIRE */
/*     ARADJ = RADIUS OF THE WIRE */
/*     XJDIR,YJDIR,ZJDIR = UNIT VECTOR IN THE OUTWARD DIRECTION ON THE */
/*                         WIRE */
/*     XK = WAVE NUMBER IN THE MEDIUM CONTAINING THE WIRE */

/*     OUTPUT: */
/*     SEMINF = SCALAR POTENTIAL DUE TO UNIT CHARGE ON THE WIRE */

    xij = *xi - *xjend;
    yij = *yi - *yjend;
    zij = *zi - *zjend;
    zz = xij * *xjdir + yij * *yjdir + zij * *zjdir;
    slen = abs(zz);
    rhox = xij - *xjdir * zz;
    rhoy = yij - *yjdir * zz;
    rhoz = zij - *zjdir * zz;
/* Computing 2nd power */
    d__1 = rhox;
/* Computing 2nd power */
    d__2 = rhoy;
/* Computing 2nd power */
    d__3 = rhoz;
/* Computing 2nd power */
    d__4 = *aradj;
    rho = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3 + d__4 * d__4);
    d__1 = zz * .5f;
    exrint_(&rho, &d__1, &slen, xk, &spp);
    if (zz < 0.f) {
	z__1.r = -spp.r, z__1.i = -spp.i;
	spp.r = z__1.r, spp.i = z__1.i;
    }
    z__1.r = rho * xk->r, z__1.i = rho * xk->i;
    hank2z_(&z__1, &hankkr);
    z__2.r = hankkr.r * 0.f - hankkr.i * -1.5707963f, z__2.i = hankkr.r * 
	    -1.5707963f + hankkr.i * 0.f;
    z__1.r = z__2.r + spp.r, z__1.i = z__2.i + spp.i;
    seminf->r = z__1.r, seminf->i = z__1.i;
    return 0;
} /* scapox_ */

/* Subroutine */ int spmpot_(doublereal *rho, doublereal *zob, doublereal *
	slen, doublecomplex *xk, doublecomplex *spp, doublecomplex *spm)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4, d__5;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11, z__12, z__13, z__14;

    /* Builtin functions */
    double sqrt(doublereal), log(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r1, s1, s2, r2, sh;
    static doublecomplex rx;
    static doublereal rz, ri1, ri2, ri3, ri4, ri5;
    static doublecomplex tm1, tm2, tm3, tm4, tm5;
    static doublereal ss1, rs1, rq1, ss2, rs2, rq2;
    static doublecomplex xkj;
    static doublereal rhs;
    static doublecomplex xjs, exr0, exr1;
    static doublereal difr;
    static doublecomplex expr;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     SPMPOT evaluates the integrals for the scalar potential due to */
/*     linear charge distributions on a wire segment on the Z axis of a */
/*     cylindrical coordinate system.  The exponential integrals are */
/*     evaluated by series expansion.  The factor 1/(4*PI*EPSILON) has */
/*     been omitted since only relative values in a medium with constant */
/*     permittivity are needed. */

/*     INPUT: */
/*     RHO = RHO COORDINATE OF EVALUATION POINT (M) */
/*     ZOB = Z COORDINATE OF EVALUATION POINT (M) */
/*     SLEN = SEGMENT LENGTH (M) */
/*     XK = WAVE NUMBER IN THE MEDIUM IN WHICH THE SEGMENT IS LOCATED */

/*     OUTPUT: */
/*     SPP = SCALAR POTENTIAL DUE TO CHARGE DISTRIBUTION OF .5*SLEN+Z */
/*     SPM = SCALAR POTENTIAL DUE TO CHARGE DISTRIBUTION OF .5*SLEN-Z */

    z__1.r = xk->r * -0.f - xk->i * -1.f, z__1.i = xk->r * -1.f + xk->i * 
	    -0.f;
    xkj.r = z__1.r, xkj.i = z__1.i;
    rhs = *rho * *rho;
    sh = *slen * .5f;
    s1 = -sh - *zob;
    ss1 = s1 * s1;
    rs1 = rhs + ss1;
    rq1 = rs1 * rs1;
    r1 = sqrt(rs1);
    s2 = sh - *zob;
    ss2 = s2 * s2;
    rs2 = rhs + ss2;
    rq2 = rs2 * rs2;
    r2 = sqrt(rs2);

/*     RIN IS THE INTEGRAL OF R**(N-2) FROM -SH TO SH */

    if (s1 > 0.f) {
	ri1 = log((r2 + s2) / (r1 + s1));
    } else {
	difr = r2 - s2;
	if (s2 > 0.f && *rho < r2 * .05f) {
	    difr = rhs * .5f / s2 * (1.f - rhs * .25f / ss2);
	}
	ri1 = log((r1 - s1) / difr);
    }
    ri2 = s2 - s1;
    ri3 = (rhs * ri1 + s2 * r2 - s1 * r1) * .5f;
    ri4 = rhs * ri2 + (ss2 * s2 - ss1 * s1) / 3.f;
    ri5 = rhs * .75f * ri3 + (s2 * rs2 * r2 - s1 * rs1 * r1) * .25f;
    z__1.r = xkj.r * xkj.r - xkj.i * xkj.i, z__1.i = xkj.r * xkj.i + xkj.i * 
	    xkj.r;
    xjs.r = z__1.r, xjs.i = z__1.i;
    rz = sqrt(rhs + *zob * *zob);
    z__1.r = rz * xkj.r, z__1.i = rz * xkj.i;
    rx.r = z__1.r, rx.i = z__1.i;
    z__8.r = rx.r * .041666667f, z__8.i = rx.i * .041666667f;
    z__7.r = z__8.r - .16666667f, z__7.i = z__8.i;
    z__6.r = z__7.r * rx.r - z__7.i * rx.i, z__6.i = z__7.r * rx.i + z__7.i * 
	    rx.r;
    z__5.r = z__6.r + .5f, z__5.i = z__6.i;
    z__4.r = z__5.r * rx.r - z__5.i * rx.i, z__4.i = z__5.r * rx.i + z__5.i * 
	    rx.r;
    z__3.r = z__4.r - 1.f, z__3.i = z__4.i;
    z__2.r = z__3.r * rx.r - z__3.i * rx.i, z__2.i = z__3.r * rx.i + z__3.i * 
	    rx.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    tm1.r = z__1.r, tm1.i = z__1.i;
    z__2.r = -xkj.r, z__2.i = -xkj.i;
    z__8.r = rx.r * .16666667f, z__8.i = rx.i * .16666667f;
    z__7.r = z__8.r - .5f, z__7.i = z__8.i;
    z__6.r = z__7.r * rx.r - z__7.i * rx.i, z__6.i = z__7.r * rx.i + z__7.i * 
	    rx.r;
    z__5.r = z__6.r + 1.f, z__5.i = z__6.i;
    z__4.r = z__5.r * rx.r - z__5.i * rx.i, z__4.i = z__5.r * rx.i + z__5.i * 
	    rx.r;
    z__3.r = z__4.r - 1.f, z__3.i = z__4.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    tm2.r = z__1.r, tm2.i = z__1.i;
    z__5.r = rx.r * .25f, z__5.i = rx.i * .25f;
    z__4.r = z__5.r - .5f, z__4.i = z__5.i;
    z__3.r = z__4.r * rx.r - z__4.i * rx.i, z__3.i = z__4.r * rx.i + z__4.i * 
	    rx.r;
    z__2.r = z__3.r + .5f, z__2.i = z__3.i;
    z__1.r = xjs.r * z__2.r - xjs.i * z__2.i, z__1.i = xjs.r * z__2.i + xjs.i 
	    * z__2.r;
    tm3.r = z__1.r, tm3.i = z__1.i;
    z__3.r = xkj.r * .16666667f, z__3.i = xkj.i * .16666667f;
    z__2.r = z__3.r * xjs.r - z__3.i * xjs.i, z__2.i = z__3.r * xjs.i + 
	    z__3.i * xjs.r;
    z__4.r = 1.f - rx.r, z__4.i = -rx.i;
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    tm4.r = z__1.r, tm4.i = z__1.i;
    z__2.r = xjs.r * .041666667f, z__2.i = xjs.i * .041666667f;
    z__1.r = z__2.r * xjs.r - z__2.i * xjs.i, z__1.i = z__2.r * xjs.i + 
	    z__2.i * xjs.r;
    tm5.r = z__1.r, tm5.i = z__1.i;
    z_exp(&z__1, &rx);
    expr.r = z__1.r, expr.i = z__1.i;

/*     EXR0 IS THE SERIES APPROX. FOR THE INTEGRAL OF EXP(-J*K*R)/R */

    z__6.r = ri1 * tm1.r, z__6.i = ri1 * tm1.i;
    z__7.r = ri2 * tm2.r, z__7.i = ri2 * tm2.i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__8.r = ri3 * tm3.r, z__8.i = ri3 * tm3.i;
    z__4.r = z__5.r + z__8.r, z__4.i = z__5.i + z__8.i;
    z__9.r = ri4 * tm4.r, z__9.i = ri4 * tm4.i;
    z__3.r = z__4.r + z__9.r, z__3.i = z__4.i + z__9.i;
    z__10.r = ri5 * tm5.r, z__10.i = ri5 * tm5.i;
    z__2.r = z__3.r + z__10.r, z__2.i = z__3.i + z__10.i;
    z__1.r = z__2.r * expr.r - z__2.i * expr.i, z__1.i = z__2.r * expr.i + 
	    z__2.i * expr.r;
    exr0.r = z__1.r, exr0.i = z__1.i;

/*     EXR1 IS THE SERIES APPROX. FOR THE INTEGRAL OF Z*EXP(-J*K*R)/R */

    d__1 = r2 - r1;
    z__6.r = d__1 * tm1.r, z__6.i = d__1 * tm1.i;
    d__2 = rs2 - rs1;
    z__8.r = d__2 * tm2.r, z__8.i = d__2 * tm2.i;
    z__7.r = z__8.r * .5f, z__7.i = z__8.i * .5f;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    d__3 = rs2 * r2 - rs1 * r1;
    z__10.r = d__3 * tm3.r, z__10.i = d__3 * tm3.i;
    z__9.r = z__10.r / 3.f, z__9.i = z__10.i / 3.f;
    z__4.r = z__5.r + z__9.r, z__4.i = z__5.i + z__9.i;
    d__4 = rq2 - rq1;
    z__12.r = d__4 * tm4.r, z__12.i = d__4 * tm4.i;
    z__11.r = z__12.r * .25f, z__11.i = z__12.i * .25f;
    z__3.r = z__4.r + z__11.r, z__3.i = z__4.i + z__11.i;
    d__5 = rq2 * r2 - rq1 * r1;
    z__14.r = d__5 * tm5.r, z__14.i = d__5 * tm5.i;
    z__13.r = z__14.r * .2f, z__13.i = z__14.i * .2f;
    z__2.r = z__3.r + z__13.r, z__2.i = z__3.i + z__13.i;
    z__1.r = z__2.r * expr.r - z__2.i * expr.i, z__1.i = z__2.r * expr.i + 
	    z__2.i * expr.r;
    exr1.r = z__1.r, exr1.i = z__1.i;
    d__1 = sh + *zob;
    z__2.r = d__1 * exr0.r, z__2.i = d__1 * exr0.i;
    z__1.r = exr1.r + z__2.r, z__1.i = exr1.i + z__2.i;
    spp->r = z__1.r, spp->i = z__1.i;
    z__2.r = -exr1.r, z__2.i = -exr1.i;
    d__1 = sh - *zob;
    z__3.r = d__1 * exr0.r, z__3.i = d__1 * exr0.i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    spm->r = z__1.r, spm->i = z__1.i;
    return 0;
} /* spmpot_ */

/* Subroutine */ int hank2z_(doublecomplex *z__, doublecomplex *h0)
{
    /* Initialized data */

    static doublereal pi = 3.141592654;
    static doublereal gamma = .5772156649;
    static doublereal c2 = .3674669052;
    static integer init = 0;

    /* Format strings */
    static char fmt_9[] = "(\002 HANK2Z: ERROR - CANNOT EVALUATE H(Z) FOR Z="
	    "0.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void z_log(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, k, m[101];
    static doublereal a1[25], a3[25];
    static doublecomplex j0, y0, zi;
    static integer iz;
    static doublecomplex zk;
    static doublereal psi;
    static integer miz;
    static doublereal zms, test;
    static doublecomplex clogz;

    /* Fortran I/O blocks */
    static cilist io___2671 = { 0, 6, 0, fmt_9, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     HANK2Z evaluates the Hankel function of second kind, order zero */
/*     with complex argument Z.  Series expansion is used for small to */
/*     moderate argument size.  This routine should not be used for */
/*     arguments greater than about 10. */

/*     INPUT: Z = FUNCTION ARGUMENT */
/*     OUTPUT: H0 = HANKEL FUNCTION OF SECOND KIND, ORDER ZERO OF */
/*                  ARGUMENT Z */

    if (init == 0) {
	goto L5;
    }
L1:
    d_cnjg(&z__2, z__);
    z__1.r = z__->r * z__2.r - z__->i * z__2.i, z__1.i = z__->r * z__2.i + 
	    z__->i * z__2.r;
    zms = z__1.r;
    if (zms == 0.f) {
	s_wsfe(&io___2671);
	e_wsfe();
	s_stop("", (ftnlen)0);
    } else if (zms < .0025f) {
	z_log(&z__3, z__);
	z__2.r = z__3.r - .11593f, z__2.i = z__3.i + 1.5708f;
	z__1.r = z__2.r * 0.f - z__2.i * -.6366198f, z__1.i = z__2.r * 
		-.6366198f + z__2.i * 0.f;
	h0->r = z__1.r, h0->i = z__1.i;
	return 0;
    }
    iz = (integer) (zms + 1.f);
    if (iz > 101) {
	iz = 101;
    }
    miz = m[iz - 1];
    j0.r = 1.f, j0.i = 0.f;
    y0.r = 0.f, y0.i = 0.f;
    zk.r = j0.r, zk.i = j0.i;
    z__1.r = z__->r * z__->r - z__->i * z__->i, z__1.i = z__->r * z__->i + 
	    z__->i * z__->r;
    zi.r = z__1.r, zi.i = z__1.i;
    i__1 = miz;
    for (k = 1; k <= i__1; ++k) {
	i__2 = k - 1;
	z__2.r = a1[i__2] * zk.r, z__2.i = a1[i__2] * zk.i;
	z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + 
		z__2.i * zi.r;
	zk.r = z__1.r, zk.i = z__1.i;
	z__1.r = j0.r + zk.r, z__1.i = j0.i + zk.i;
	j0.r = z__1.r, j0.i = z__1.i;
/* L3: */
	i__2 = k - 1;
	z__2.r = a3[i__2] * zk.r, z__2.i = a3[i__2] * zk.i;
	z__1.r = y0.r + z__2.r, z__1.i = y0.i + z__2.i;
	y0.r = z__1.r, y0.i = z__1.i;
    }
    z__2.r = z__->r * .5f, z__2.i = z__->i * .5f;
    z_log(&z__1, &z__2);
    clogz.r = z__1.r, clogz.i = z__1.i;
    z__5.r = j0.r * 2.f, z__5.i = j0.i * 2.f;
    z__4.r = z__5.r * clogz.r - z__5.i * clogz.i, z__4.i = z__5.r * clogz.i + 
	    z__5.i * clogz.r;
    z__3.r = z__4.r - y0.r, z__3.i = z__4.i - y0.i;
    z__2.r = z__3.r / pi, z__2.i = z__3.i / pi;
    z__1.r = z__2.r + c2, z__1.i = z__2.i;
    y0.r = z__1.r, y0.i = z__1.i;
    z__2.r = y0.r * 0.f - y0.i * 1.f, z__2.i = y0.r * 1.f + y0.i * 0.f;
    z__1.r = j0.r - z__2.r, z__1.i = j0.i - z__2.i;
    h0->r = z__1.r, h0->i = z__1.i;
    return 0;
/*     INITIALIZATION OF CONSTANTS */
L5:
    psi = -gamma;
    for (k = 1; k <= 25; ++k) {
	a1[k - 1] = -.25 / (k * k);
	psi += 1. / k;
/* L6: */
	a3[k - 1] = psi + psi;
    }
    for (i__ = 1; i__ <= 101; ++i__) {
	test = 1.;
	for (k = 1; k <= 24; ++k) {
	    init = k;
	    test = -test * i__ * a1[k - 1];
	    if (test * a3[k - 1] < 1e-6) {
		goto L8;
	    }
/* L7: */
	}
L8:
	m[i__ - 1] = init;
    }
    goto L1;

} /* hank2z_ */

/* Subroutine */ int hank12_(doublecomplex *z__, integer *ikind, 
	doublecomplex *h0, doublecomplex *h0p)
{
    /* Initialized data */

    static doublereal pi = 3.141592654;
    static doublereal gamma = .5772156649;
    static doublereal c1 = -.0245785095;
    static doublereal c2 = .3674669052;
    static doublereal c3 = .7978845608;
    static doublereal p10 = .0703125;
    static doublereal p20 = .1121520996;
    static doublereal q10 = .125;
    static doublereal q20 = .0732421875;
    static doublereal p11 = .1171875;
    static doublereal p21 = .1441955566;
    static doublereal q11 = .375;
    static doublereal q21 = .1025390625;
    static doublereal pof = .7853981635;
    static integer init = 0;

    /* Format strings */
    static char fmt_9[] = "(\002 HANK12: ERROR - CANNOT EVALUATE H(Z) FOR Z="
	    "0.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *);
    integer s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void z_log(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *), z_sqrt(doublecomplex *, doublecomplex *);
    double sqrt(doublereal), cos(doublereal);

    /* Local variables */
    static integer i__, k, m[101];
    static doublereal a1[25], a2[25], a3[25], a4[25];
    static doublecomplex j0, y0;
    static integer ib;
    static doublecomplex zi;
    static integer iz;
    static doublecomplex zk, j0p, zi2, y0p, p0z, p1z, q0z, q1z, fjx;
    static doublereal psi;
    static integer miz;
    static doublereal zms, test;
    static doublecomplex clogz;

    /* Fortran I/O blocks */
    static cilist io___2703 = { 0, 3, 0, fmt_9, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     HANK12 evaluates the Hankel function of the first or second kind, */
/*     order zero, and its derivative for complex argument Z. */

/*     INPUT: Z = function argument */
/*            IKIND = 1 for Hankel function of first kind, 2 for 2nd kind */
/*     OUTPUT: H0 = Hankel function of order zero and argument Z */
/*             HOP = derivative of the Hankel function. */

    if (init == 0) {
	goto L5;
    }
L1:
    fjx.r = 0.f, fjx.i = 1.f;
    if (*ikind == 2) {
	z__1.r = -fjx.r, z__1.i = -fjx.i;
	fjx.r = z__1.r, fjx.i = z__1.i;
    }
    d_cnjg(&z__2, z__);
    z__1.r = z__->r * z__2.r - z__->i * z__2.i, z__1.i = z__->r * z__2.i + 
	    z__->i * z__2.r;
    zms = z__1.r;
    if (zms != 0.f) {
	goto L2;
    }
    s_wsfe(&io___2703);
    e_wsfe();
    s_stop("", (ftnlen)0);
L2:
    ib = 0;
    if (zms > 16.81f) {
	goto L4;
    }
    if (zms > 16.f) {
	ib = 1;
    }
/*     SERIES EXPANSION */
    iz = (integer) (zms + 1.f);
    miz = m[iz - 1];
    j0.r = 1.f, j0.i = 0.f;
    j0p.r = j0.r, j0p.i = j0.i;
    y0.r = 0.f, y0.i = 0.f;
    y0p.r = y0.r, y0p.i = y0.i;
    zk.r = j0.r, zk.i = j0.i;
    z__1.r = z__->r * z__->r - z__->i * z__->i, z__1.i = z__->r * z__->i + 
	    z__->i * z__->r;
    zi.r = z__1.r, zi.i = z__1.i;
    i__1 = miz;
    for (k = 1; k <= i__1; ++k) {
	i__2 = k - 1;
	z__2.r = a1[i__2] * zk.r, z__2.i = a1[i__2] * zk.i;
	z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + 
		z__2.i * zi.r;
	zk.r = z__1.r, zk.i = z__1.i;
	z__1.r = j0.r + zk.r, z__1.i = j0.i + zk.i;
	j0.r = z__1.r, j0.i = z__1.i;
	i__2 = k - 1;
	z__2.r = a2[i__2] * zk.r, z__2.i = a2[i__2] * zk.i;
	z__1.r = j0p.r + z__2.r, z__1.i = j0p.i + z__2.i;
	j0p.r = z__1.r, j0p.i = z__1.i;
	i__2 = k - 1;
	z__2.r = a3[i__2] * zk.r, z__2.i = a3[i__2] * zk.i;
	z__1.r = y0.r + z__2.r, z__1.i = y0.i + z__2.i;
	y0.r = z__1.r, y0.i = z__1.i;
/* L3: */
	i__2 = k - 1;
	z__2.r = a4[i__2] * zk.r, z__2.i = a4[i__2] * zk.i;
	z__1.r = y0p.r + z__2.r, z__1.i = y0p.i + z__2.i;
	y0p.r = z__1.r, y0p.i = z__1.i;
    }
    z__2.r = z__->r * -.5f, z__2.i = z__->i * -.5f;
    z__1.r = z__2.r * j0p.r - z__2.i * j0p.i, z__1.i = z__2.r * j0p.i + 
	    z__2.i * j0p.r;
    j0p.r = z__1.r, j0p.i = z__1.i;
    z__2.r = z__->r * .5f, z__2.i = z__->i * .5f;
    z_log(&z__1, &z__2);
    clogz.r = z__1.r, clogz.i = z__1.i;
    z__5.r = j0.r * 2.f, z__5.i = j0.i * 2.f;
    z__4.r = z__5.r * clogz.r - z__5.i * clogz.i, z__4.i = z__5.r * clogz.i + 
	    z__5.i * clogz.r;
    z__3.r = z__4.r - y0.r, z__3.i = z__4.i - y0.i;
    z__2.r = z__3.r / pi, z__2.i = z__3.i / pi;
    z__1.r = z__2.r + c2, z__1.i = z__2.i;
    y0.r = z__1.r, y0.i = z__1.i;
    z_div(&z__5, &c_b1407, z__);
    z__7.r = j0p.r * 2.f, z__7.i = j0p.i * 2.f;
    z__6.r = z__7.r * clogz.r - z__7.i * clogz.i, z__6.i = z__7.r * clogz.i + 
	    z__7.i * clogz.r;
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z__9.r = y0p.r * .5f, z__9.i = y0p.i * .5f;
    z__8.r = z__9.r * z__->r - z__9.i * z__->i, z__8.i = z__9.r * z__->i + 
	    z__9.i * z__->r;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = z__3.r / pi, z__2.i = z__3.i / pi;
    z__10.r = c1 * z__->r, z__10.i = c1 * z__->i;
    z__1.r = z__2.r + z__10.r, z__1.i = z__2.i + z__10.i;
    y0p.r = z__1.r, y0p.i = z__1.i;
    z__2.r = fjx.r * y0.r - fjx.i * y0.i, z__2.i = fjx.r * y0.i + fjx.i * 
	    y0.r;
    z__1.r = j0.r + z__2.r, z__1.i = j0.i + z__2.i;
    h0->r = z__1.r, h0->i = z__1.i;
    z__2.r = fjx.r * y0p.r - fjx.i * y0p.i, z__2.i = fjx.r * y0p.i + fjx.i * 
	    y0p.r;
    z__1.r = j0p.r + z__2.r, z__1.i = j0p.i + z__2.i;
    h0p->r = z__1.r, h0p->i = z__1.i;
    if (ib == 0) {
	return 0;
    }
    y0.r = h0->r, y0.i = h0->i;
    y0p.r = h0p->r, y0p.i = h0p->i;
/*     ASYMPTOTIC EXPANSION */
L4:
    z_div(&z__1, &c_b336, z__);
    zi.r = z__1.r, zi.i = z__1.i;
    z__1.r = zi.r * zi.r - zi.i * zi.i, z__1.i = zi.r * zi.i + zi.i * zi.r;
    zi2.r = z__1.r, zi2.i = z__1.i;
    z__4.r = p20 * zi2.r, z__4.i = p20 * zi2.i;
    z__3.r = z__4.r - p10, z__3.i = z__4.i;
    z__2.r = z__3.r * zi2.r - z__3.i * zi2.i, z__2.i = z__3.r * zi2.i + 
	    z__3.i * zi2.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    p0z.r = z__1.r, p0z.i = z__1.i;
    z__4.r = p21 * zi2.r, z__4.i = p21 * zi2.i;
    z__3.r = p11 - z__4.r, z__3.i = -z__4.i;
    z__2.r = z__3.r * zi2.r - z__3.i * zi2.i, z__2.i = z__3.r * zi2.i + 
	    z__3.i * zi2.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    p1z.r = z__1.r, p1z.i = z__1.i;
    z__3.r = q20 * zi2.r, z__3.i = q20 * zi2.i;
    z__2.r = z__3.r - q10, z__2.i = z__3.i;
    z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + z__2.i * 
	    zi.r;
    q0z.r = z__1.r, q0z.i = z__1.i;
    z__3.r = q21 * zi2.r, z__3.i = q21 * zi2.i;
    z__2.r = q11 - z__3.r, z__2.i = -z__3.i;
    z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + z__2.i * 
	    zi.r;
    q1z.r = z__1.r, q1z.i = z__1.i;
    z__5.r = z__->r - pof, z__5.i = z__->i;
    z__4.r = fjx.r * z__5.r - fjx.i * z__5.i, z__4.i = fjx.r * z__5.i + fjx.i 
	    * z__5.r;
    z_exp(&z__3, &z__4);
    z_sqrt(&z__6, &zi);
    z__2.r = z__3.r * z__6.r - z__3.i * z__6.i, z__2.i = z__3.r * z__6.i + 
	    z__3.i * z__6.r;
    z__1.r = c3 * z__2.r, z__1.i = c3 * z__2.i;
    zk.r = z__1.r, zk.i = z__1.i;
    z__3.r = fjx.r * q0z.r - fjx.i * q0z.i, z__3.i = fjx.r * q0z.i + fjx.i * 
	    q0z.r;
    z__2.r = p0z.r + z__3.r, z__2.i = p0z.i + z__3.i;
    z__1.r = zk.r * z__2.r - zk.i * z__2.i, z__1.i = zk.r * z__2.i + zk.i * 
	    z__2.r;
    h0->r = z__1.r, h0->i = z__1.i;
    z__2.r = fjx.r * zk.r - fjx.i * zk.i, z__2.i = fjx.r * zk.i + fjx.i * 
	    zk.r;
    z__4.r = fjx.r * q1z.r - fjx.i * q1z.i, z__4.i = fjx.r * q1z.i + fjx.i * 
	    q1z.r;
    z__3.r = p1z.r + z__4.r, z__3.i = p1z.i + z__4.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    h0p->r = z__1.r, h0p->i = z__1.i;
    if (ib == 0) {
	return 0;
    }
    zms = cos((sqrt(zms) - 4.f) * 31.41592654f);
    d__1 = zms + 1.f;
    z__3.r = d__1 * y0.r, z__3.i = d__1 * y0.i;
    d__2 = 1.f - zms;
    z__4.r = d__2 * h0->r, z__4.i = d__2 * h0->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    h0->r = z__1.r, h0->i = z__1.i;
    d__1 = zms + 1.f;
    z__3.r = d__1 * y0p.r, z__3.i = d__1 * y0p.i;
    d__2 = 1.f - zms;
    z__4.r = d__2 * h0p->r, z__4.i = d__2 * h0p->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    h0p->r = z__1.r, h0p->i = z__1.i;
    return 0;
/*     INITIALIZATION OF CONSTANTS */
L5:
    psi = -gamma;
    for (k = 1; k <= 25; ++k) {
	a1[k - 1] = -.25 / (k * k);
	a2[k - 1] = 1. / (k + 1.);
	psi += 1. / k;
	a3[k - 1] = psi + psi;
/* L6: */
	a4[k - 1] = (psi + psi + 1. / (k + 1.)) / (k + 1.);
    }
    for (i__ = 1; i__ <= 101; ++i__) {
	test = 1.;
	for (k = 1; k <= 24; ++k) {
	    init = k;
	    test = -test * i__ * a1[k - 1];
	    if (test * a3[k - 1] < 1e-6) {
		goto L8;
	    }
/* L7: */
	}
L8:
	m[i__ - 1] = init;
    }
    goto L1;

} /* hank12_ */

/* Subroutine */ int cmngf_(doublecomplex *cb, doublecomplex *cc, 
	doublecomplex *cd, integer *nb, integer *nc, integer *nd)
{
    /* System generated locals */
    integer cb_dim1, cb_offset, cc_dim1, cc_offset, cd_dim1, cd_offset, i__1, 
	    i__2, i__3, i__4, i__5;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *);

    /* Local variables */
    static integer i__, j, i1, i2, it, ir, ix, im1, im2, in2, in1;
    extern /* Subroutine */ int tbf_(integer *, integer *);
    static integer meq, imx, ist, jss, isv, itx, jsx, m1eq, m2eq, ibfl, iblk, 
	    neqn, neqp;
    extern /* Subroutine */ int cmss_(integer *, integer *, integer *, 
	    integer *, doublecomplex *, integer *, integer *);
    static integer neqs;
    extern /* Subroutine */ int cmws_(integer *, integer *, integer *, 
	    doublecomplex *, integer *, doublecomplex *, integer *, integer *)
	    , cmsw_(integer *, integer *, integer *, integer *, doublecomplex 
	    *, doublecomplex *, integer *, integer *, integer *), trio_(
	    integer *), cmww_(integer *, integer *, integer *, doublecomplex *
	    , integer *, doublecomplex *, integer *, integer *);
    static integer isvv;
    extern /* Subroutine */ int recot_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static integer neqsp;
    extern /* Subroutine */ int daopen_(integer *, char *, char *, char *, 
	    integer *, ftnlen, ftnlen, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CMNGF fills interaction matrices B, C, and D for N.G.F. solution. */

/*     INPUT: */
/*     NB = row dimension for CB */
/*     NC = row dimension for CC */
/*     ND = row dimension for CD */

/*     OUTPUT: */
/*     CB = matrix B (returned or written to disk) */
/*     CC = matrix C stored transposed (returned or written to disk) */
/*     CD = matrix D stored transposed (returned or written to disk) */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    cb_dim1 = *nb;
    cb_offset = 1 + cb_dim1;
    cb -= cb_offset;
    cc_dim1 = *nc;
    cc_offset = 1 + cc_dim1;
    cc -= cc_offset;
    cd_dim1 = *nd;
    cd_offset = 1 + cd_dim1;
    cd -= cd_offset;

    /* Function Body */
    if (matpar_1.icasx > 1) {

/*        OPEN FILES FOR B, C AND D MATRICES */

	ibfl = 12;
	if (matpar_1.icasx > 2) {
	    ibfl = 15;
	}
	cl__1.cerr = 1;
	cl__1.cunit = ibfl;
	cl__1.csta = "DELETE";
	i__1 = f_clos(&cl__1);
	if (i__1 != 0) {
	    goto L1;
	}
L1:
	i__1 = matpar_1.npbx * *nd;
	daopen_(&ibfl, "TAPEB.NEC", "unknown", "DELETE", &i__1, (ftnlen)9, (
		ftnlen)7, (ftnlen)6);
	cl__1.cerr = 1;
	cl__1.cunit = 13;
	cl__1.csta = "DELETE";
	i__1 = f_clos(&cl__1);
	if (i__1 != 0) {
	    goto L5;
	}
L5:
	i__1 = matpar_1.npbl * *nc;
	daopen_(&c__13, "TAPEC.NEC", "unknown", "DELETE", &i__1, (ftnlen)9, (
		ftnlen)7, (ftnlen)6);
	cl__1.cerr = 1;
	cl__1.cunit = 14;
	cl__1.csta = "DELETE";
	i__1 = f_clos(&cl__1);
	if (i__1 != 0) {
	    goto L7;
	}
L7:
	i__1 = matpar_1.npbl * *nd;
	daopen_(&c__14, "TAPED.NEC", "unknown", "DELETE", &i__1, (ftnlen)9, (
		ftnlen)7, (ftnlen)6);
    }
    m1eq = data_1.m1 << 1;
    m2eq = m1eq + 1;
    meq = data_1.m << 1;
    neqp = *nd - (segj_1.npcon << 1);
    neqs = neqp - segj_1.nscon;
    neqsp = neqs + *nc;
    neqn = *nc + data_1.n - data_1.n1;
    itx = 1;
    if (segj_1.nscon > 0) {
	itx = 2;
    }
    if (matpar_1.icasx <= 2) {
	i__1 = *nd;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *nd;
	    for (i__ = 1; i__ <= i__2; ++i__) {
/* L2: */
		i__3 = i__ + j * cd_dim1;
		cd[i__3].r = 0.f, cd[i__3].i = 0.f;
	    }
	    i__3 = *nb;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		i__2 = i__ + j * cb_dim1;
		cb[i__2].r = 0.f, cb[i__2].i = 0.f;
/* L3: */
		i__2 = i__ + j * cc_dim1;
		cc[i__2].r = 0.f, cc[i__2].i = 0.f;
	    }
/* L4: */
	}
    }
    ist = data_1.n - data_1.n1 + 1;
    it = matpar_1.npbx;
    isv = -matpar_1.npbx;

/*     LOOP THRU 24 FILLS B.  FOR ICASX=1 OR 2 ALSO FILLS D(WW), D(WS) */

    i__1 = matpar_1.nbbx;
    for (iblk = 1; iblk <= i__1; ++iblk) {
	isv += matpar_1.npbx;
	if (iblk == matpar_1.nbbx) {
	    it = matpar_1.nlbx;
	}
	if (matpar_1.icasx >= 3) {
	    i__2 = *nd;
	    for (j = 1; j <= i__2; ++j) {
		i__3 = it;
		for (i__ = 1; i__ <= i__3; ++i__) {
/* L6: */
		    i__4 = i__ + j * cb_dim1;
		    cb[i__4].r = 0.f, cb[i__4].i = 0.f;
		}
	    }
	}
	i1 = isv + 1;
	i2 = isv + it;
	in2 = i2;
	if (in2 > data_1.n1) {
	    in2 = data_1.n1;
	}
	im1 = i1 - data_1.n1;
	im2 = i2 - data_1.n1;
	if (im1 < 1) {
	    im1 = 1;
	}
	imx = 1;
	if (i1 <= data_1.n1) {
	    imx = data_1.n1 - i1 + 2;
	}
	if (data_1.n2 <= data_1.n) {

/*        FILL B(WW),B(WS).  FOR ICASX=1,2 FILL D(WW),D(WS) */
	    i__4 = data_1.n;
	    for (j = data_1.n2; j <= i__4; ++j) {
		trio_(&j);
		i__3 = segj_1.jsno;
		for (i__ = 1; i__ <= i__3; ++i__) {
		    jss = segj_1.jco[i__ - 1];
		    if (jss >= data_1.n2) {

/*           SET JCO WHEN SOURCE IS NEW BASIS FUNCTION ON NEW SEGMENT */
			segj_1.jco[i__ - 1] = jss - data_1.n1;
		    } else {

/*           SOURCE IS PORTION OF MODIFIED BASIS FUNCTION ON NEW SEGMENT */
			segj_1.jco[i__ - 1] = neqs + data_1.iconx[jss - 1];
		    }
/* L9: */
		}
		if (i1 <= in2) {
		    cmww_(&j, &i1, &in2, &cb[cb_offset], nb, &cb[cb_offset], 
			    nb, &c__0);
		}
		if (im1 <= im2) {
		    cmws_(&j, &im1, &im2, &cb[imx + cb_dim1], nb, &cb[
			    cb_offset], nb, &c__0);
		}
		if (matpar_1.icasx > 2) {
		    goto L11;
		}
		cmww_(&j, &data_1.n2, &data_1.n, &cd[cd_offset], nd, &cd[
			cd_offset], nd, &c__1);
		if (data_1.m2 <= data_1.m) {
		    cmws_(&j, &m2eq, &meq, &cd[ist * cd_dim1 + 1], nd, &cd[
			    cd_offset], nd, &c__1);
		}
L11:
		;
	    }
	}
	if (segj_1.nscon != 0) {

/*        FILL B(WW)PRIME */
	    i__4 = segj_1.nscon;
	    for (i__ = 1; i__ <= i__4; ++i__) {
		j = segj_1.iscon[i__ - 1];

/*        SOURCES ARE NEW OR MODIFIED BASIS FUNCTIONS ON OLD SEGMENTS */
/*        WHICH CONNECT TO NEW SEGMENTS */

		trio_(&j);
		jss = 0;
		i__3 = segj_1.jsno;
		for (ix = 1; ix <= i__3; ++ix) {
		    ir = segj_1.jco[ix - 1];
		    if (ir >= data_1.n2) {
			ir -= data_1.n1;
		    } else {
			ir = data_1.iconx[ir - 1];
			if (ir == 0) {
			    goto L15;
			}
			ir = neqs + ir;
		    }
		    ++jss;
		    segj_1.jco[jss - 1] = ir;
		    i__2 = jss - 1;
		    i__5 = ix - 1;
		    segj_1.ax[i__2].r = segj_1.ax[i__5].r, segj_1.ax[i__2].i =
			     segj_1.ax[i__5].i;
		    i__2 = jss - 1;
		    i__5 = ix - 1;
		    segj_1.bx[i__2].r = segj_1.bx[i__5].r, segj_1.bx[i__2].i =
			     segj_1.bx[i__5].i;
		    i__2 = jss - 1;
		    i__5 = ix - 1;
		    segj_1.cx[i__2].r = segj_1.cx[i__5].r, segj_1.cx[i__2].i =
			     segj_1.cx[i__5].i;
L15:
		    ;
		}
		segj_1.jsno = jss;
		if (i1 <= in2) {
		    cmww_(&j, &i1, &in2, &cb[cb_offset], nb, &cb[cb_offset], 
			    nb, &c__0);
		}
		if (im1 <= im2) {
		    cmws_(&j, &im1, &im2, &cb[imx + cb_dim1], nb, &cb[
			    cb_offset], nb, &c__0);
		}

/*        SOURCE IS SINGULAR COMPONENT OF PATCH CURRENT THAT IS PART OF */
/*        MODIFIED BASIS FUNCTION FOR OLD SEGMENT THAT CONNECTS TO A NEW */
/*        SEGMENT ON END OPPOSITE PATCH. */

		if (i1 <= in2) {
		    cmsw_(&j, &i__, &i1, &in2, &cb[cb_offset], &cb[cb_offset],
			     &c__0, nb, &c_n1);
		}

/*        SOURCES ARE PORTIONS OF MODIFIED BASIS FUNCTION J ON OLD SEGMENTS */
/*        EXCLUDING OLD SEGMENTS THAT DIRECTLY CONNECT TO NEW SEGMENTS. */

		tbf_(&j, &c__1);
		jsx = segj_1.jsno;
		segj_1.jsno = 1;
		ir = segj_1.jco[0];
		segj_1.jco[0] = neqs + i__;
		i__3 = jsx;
		for (ix = 1; ix <= i__3; ++ix) {
		    if (ix != 1) {
			ir = segj_1.jco[ix - 1];
			i__2 = ix - 1;
			segj_1.ax[0].r = segj_1.ax[i__2].r, segj_1.ax[0].i = 
				segj_1.ax[i__2].i;
			i__2 = ix - 1;
			segj_1.bx[0].r = segj_1.bx[i__2].r, segj_1.bx[0].i = 
				segj_1.bx[i__2].i;
			i__2 = ix - 1;
			segj_1.cx[0].r = segj_1.cx[i__2].r, segj_1.cx[0].i = 
				segj_1.cx[i__2].i;
		    }
		    if (ir > data_1.n1) {
			goto L19;
		    }
		    if (data_1.iconx[ir - 1] != 0) {
			goto L19;
		    }
		    if (i1 <= in2) {
			cmww_(&ir, &i1, &in2, &cb[cb_offset], nb, &cb[
				cb_offset], nb, &c__0);
		    }
		    if (im1 <= im2) {
			cmws_(&ir, &im1, &im2, &cb[imx + cb_dim1], nb, &cb[
				cb_offset], nb, &c__0);
		    }
L19:
		    ;
		}
	    }
	}
	if (segj_1.npcon != 0) {
	    jss = neqp;

/*        FILL B(SS)PRIME TO SET OLD PATCH BASIS FUNCTIONS TO ZERO FOR */
/*        PATCHES THAT CONNECT TO NEW SEGMENTS */

	    i__3 = segj_1.npcon;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		ix = (segj_1.ipcon[i__ - 1] << 1) + data_1.n1 - isv;
		ir = ix - 1;
		++jss;
		if (ir > 0 && ir <= it) {
		    i__4 = ir + jss * cb_dim1;
		    cb[i__4].r = 1.f, cb[i__4].i = 0.f;
		}
		++jss;
		if (ix > 0 && ix <= it) {
		    i__4 = ix + jss * cb_dim1;
		    cb[i__4].r = 1.f, cb[i__4].i = 0.f;
		}
/* L21: */
	    }
	}
	if (data_1.m2 <= data_1.m) {

/*        FILL B(SW) AND B(SS) */
	    if (i1 <= in2) {
		cmsw_(&data_1.m2, &data_1.m, &i1, &in2, &cb[ist * cb_dim1 + 1]
			, &cb[cb_offset], &data_1.n1, nb, &c__0);
	    }
	    if (im1 <= im2) {
		cmss_(&data_1.m2, &data_1.m, &im1, &im2, &cb[imx + ist * 
			cb_dim1], nb, &c__0);
	    }
	}
	if (matpar_1.icasx != 1) {
	    i__3 = matpar_1.npbx * *nd;
	    recot_(&cb[cb_offset], &ibfl, &c__1, &i__3, &iblk, " WRITE CB IN"
		    " CNNGF", (ftnlen)18);
	}
/* L24: */
    }

/*     FILLING B COMPLETE.  START ON C AND D */

    it = matpar_1.npbl;
    isv = -matpar_1.npbl;
    i__1 = matpar_1.nbbl;
    for (iblk = 1; iblk <= i__1; ++iblk) {
	isv += matpar_1.npbl;
	isvv = isv + *nc;
	if (iblk == matpar_1.nbbl) {
	    it = matpar_1.nlbl;
	}
	if (matpar_1.icasx >= 3) {
	    i__3 = it;
	    for (j = 1; j <= i__3; ++j) {
		i__4 = *nc;
		for (i__ = 1; i__ <= i__4; ++i__) {
/* L25: */
		    i__2 = i__ + j * cc_dim1;
		    cc[i__2].r = 0.f, cc[i__2].i = 0.f;
		}
		i__2 = *nd;
		for (i__ = 1; i__ <= i__2; ++i__) {
/* L26: */
		    i__4 = i__ + j * cd_dim1;
		    cd[i__4].r = 0.f, cd[i__4].i = 0.f;
		}
	    }
	}
	i1 = isvv + 1;
	i2 = isvv + it;
	in1 = i1 - m1eq;
	in2 = i2 - m1eq;
	if (in2 > data_1.n) {
	    in2 = data_1.n;
	}
	im1 = i1 - data_1.n;
	im2 = i2 - data_1.n;
	if (im1 < m2eq) {
	    im1 = m2eq;
	}
	if (im2 > meq) {
	    im2 = meq;
	}
	imx = 1;
	if (in1 <= in2) {
	    imx = neqn - i1 + 2;
	}
	if (matpar_1.icasx > 2 && data_1.n2 <= data_1.n) {

/*        SAME AS DO 24 LOOP TO FILL D(WW) FOR ICASX GREATER THAN 2 */

	    i__4 = data_1.n;
	    for (j = data_1.n2; j <= i__4; ++j) {
		trio_(&j);
		i__2 = segj_1.jsno;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    jss = segj_1.jco[i__ - 1];
		    if (jss >= data_1.n2) {
			segj_1.jco[i__ - 1] = jss - data_1.n1;
		    } else {
			segj_1.jco[i__ - 1] = neqs + data_1.iconx[jss - 1];
		    }
/* L29: */
		}
		if (in1 <= in2) {
		    cmww_(&j, &in1, &in2, &cd[cd_offset], nd, &cd[cd_offset], 
			    nd, &c__1);
		}
		if (im1 <= im2) {
		    cmws_(&j, &im1, &im2, &cd[imx * cd_dim1 + 1], nd, &cd[
			    cd_offset], nd, &c__1);
		}
/* L31: */
	    }
	}
	if (data_1.m2 <= data_1.m) {

/*        FILL D(SW) AND D(SS) */
	    if (in1 <= in2) {
		cmsw_(&data_1.m2, &data_1.m, &in1, &in2, &cd[ist + cd_dim1], &
			cd[cd_offset], &data_1.n1, nd, &c__1);
	    }
	    if (im1 <= im2) {
		cmss_(&data_1.m2, &data_1.m, &im1, &im2, &cd[ist + imx * 
			cd_dim1], nd, &c__1);
	    }
	}
	if (data_1.n1 > 0) {

/*        FILL C(WW),C(WS), D(WW)PRIME, AND D(WS)PRIME. */
	    i__4 = data_1.n1;
	    for (j = 1; j <= i__4; ++j) {
		trio_(&j);
		if (segj_1.nscon != 0) {
		    i__2 = segj_1.jsno;
		    for (ix = 1; ix <= i__2; ++ix) {
			jss = segj_1.jco[ix - 1];
			if (jss >= data_1.n2) {
			    segj_1.jco[ix - 1] = jss + m1eq;
			} else {
			    ir = data_1.iconx[jss - 1];
			    if (ir != 0) {
				segj_1.jco[ix - 1] = neqsp + ir;
			    }
			}
/* L35: */
		    }
		}
		if (in1 <= in2) {
		    cmww_(&j, &in1, &in2, &cc[cc_offset], nc, &cd[cd_offset], 
			    nd, &itx);
		}
		if (im1 <= im2) {
		    cmws_(&j, &im1, &im2, &cc[imx * cc_dim1 + 1], nc, &cd[imx 
			    * cd_dim1 + 1], nd, &itx);
		}
/* L37: */
	    }
	    if (segj_1.nscon != 0) {

/*           FILL C(WW)PRIME */
		i__4 = segj_1.nscon;
		for (ix = 1; ix <= i__4; ++ix) {
		    ir = segj_1.iscon[ix - 1];
		    jss = neqs + ix - isv;
		    if (jss > 0 && jss <= it) {
			i__2 = ir + jss * cc_dim1;
			cc[i__2].r = 1.f, cc[i__2].i = 0.f;
		    }
/* L38: */
		}
	    }
	}
	if (segj_1.npcon != 0) {

/*        FILL C(SS)PRIME */
	    jss = neqp - isv;
	    i__4 = segj_1.npcon;
	    for (i__ = 1; i__ <= i__4; ++i__) {
		ix = (segj_1.ipcon[i__ - 1] << 1) + data_1.n1;
		ir = ix - 1;
		++jss;
		if (jss > 0 && jss <= it) {
		    i__2 = ir + jss * cc_dim1;
		    cc[i__2].r = 1.f, cc[i__2].i = 0.f;
		}
		++jss;
		if (jss > 0 && jss <= it) {
		    i__2 = ix + jss * cc_dim1;
		    cc[i__2].r = 1.f, cc[i__2].i = 0.f;
		}
/* L40: */
	    }
	}
	if (data_1.m1 > 0) {

/*        FILL C(SW) AND C(SS) */
	    if (in1 <= in2) {
		cmsw_(&c__1, &data_1.m1, &in1, &in2, &cc[data_1.n2 + cc_dim1],
			 &cc[cc_offset], &c__0, nc, &c__1);
	    }
	    if (im1 <= im2) {
		cmss_(&c__1, &data_1.m1, &im1, &im2, &cc[data_1.n2 + imx * 
			cc_dim1], nc, &c__1);
	    }
	}
	if (matpar_1.icasx != 1) {
	    i__4 = *nc * it;
	    recot_(&cc[cc_offset], &c__13, &c__1, &i__4, &iblk, " WRITE CC I"
		    "N CMNGF", (ftnlen)18);
	    i__4 = *nd * it;
	    recot_(&cd[cd_offset], &c__14, &c__1, &i__4, &iblk, " WRITE CD I"
		    "N CMNGF", (ftnlen)18);
	}
/* L43: */
    }
    return 0;
} /* cmngf_ */

/* Subroutine */ int cmset_(integer *nrow, doublecomplex *cm, integer *iu1)
{
    /* System generated locals */
    integer cm_dim1, cm_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
    doublecomplex z__1, z__2;
    cllist cl__1;

    /* Builtin functions */
    integer f_clos(cllist *);

    /* Local variables */
    static integer i__, j, k, i1, i2, ka, ij, kk, it, im1, im2, in2, jm1, jm2,
	     mp2, neq, nop, ist, jst, isv, npeq;
    extern /* Subroutine */ int cmss_(integer *, integer *, integer *, 
	    integer *, doublecomplex *, integer *, integer *), cmws_(integer *
	    , integer *, integer *, doublecomplex *, integer *, doublecomplex 
	    *, integer *, integer *), cmsw_(integer *, integer *, integer *, 
	    integer *, doublecomplex *, doublecomplex *, integer *, integer *,
	     integer *), trio_(integer *), cmww_(integer *, integer *, 
	    integer *, doublecomplex *, integer *, doublecomplex *, integer *,
	     integer *);
    static integer iout;
    static doublecomplex deter;
    extern /* Subroutine */ int recot_(doublecomplex *, integer *, integer *, 
	    integer *, integer *, char *, ftnlen);
    static integer ixblk1;
    extern /* Subroutine */ int daopen_(integer *, char *, char *, char *, 
	    integer *, ftnlen, ftnlen, ftnlen);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     CMSET fills the complex MoM matrix in the array CM. */

/*     INPUT: */
/*     NROW = row dimension of transposed matrix (total no. of equations) */
/*     IU1 = logical unit number for writing matrix blocks to disk */

/*     OUTPUT: */
/*     CM = array for storing matrix or blocks of matrix */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    cm_dim1 = *nrow;
    cm_offset = 1 + cm_dim1;
    cm -= cm_offset;

    /* Function Body */
    mp2 = data_1.mp << 1;
    npeq = data_1.np + mp2;
    neq = data_1.n + (data_1.m << 1);
    nop = neq / npeq;
    iout = matpar_1.npblk * *nrow;
    it = matpar_1.npblk;

/*     OPEN FILE FOR MATRIX IF NEEDED. */

    if (matpar_1.icase > 2) {
	cl__1.cerr = 1;
	cl__1.cunit = *iu1;
	cl__1.csta = "DELETE";
	i__1 = f_clos(&cl__1);
	if (i__1 != 0) {
	    goto L5;
	}
L5:
	daopen_(iu1, "TAPE11.NEC", "unknown", "DELETE", &iout, (ftnlen)10, (
		ftnlen)7, (ftnlen)6);
    }

/*     CYCLE OVER MATRIX BLOCKS */

    i__1 = matpar_1.nbloks;
    for (ixblk1 = 1; ixblk1 <= i__1; ++ixblk1) {
	isv = (ixblk1 - 1) * matpar_1.npblk;
	if (ixblk1 == matpar_1.nbloks) {
	    it = matpar_1.nlast;
	}
	i__2 = *nrow;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i__3 = it;
	    for (j = 1; j <= i__3; ++j) {
/* L1: */
		i__4 = i__ + j * cm_dim1;
		cm[i__4].r = 0.f, cm[i__4].i = 0.f;
	    }
	}
	i1 = isv + 1;
	i2 = isv + it;
	in2 = i2;
	if (in2 > data_1.np) {
	    in2 = data_1.np;
	}
	im1 = i1 - data_1.np;
	im2 = i2 - data_1.np;
	if (im1 < 1) {
	    im1 = 1;
	}
	ist = 1;
	if (i1 <= data_1.np) {
	    ist = data_1.np - i1 + 2;
	}

/*     WIRE SOURCE LOOP */

	if (data_1.n > 0) {
	    i__4 = data_1.n;
	    for (j = 1; j <= i__4; ++j) {
		trio_(&j);
		i__3 = segj_1.jsno;
		for (i__ = 1; i__ <= i__3; ++i__) {
		    ij = segj_1.jco[i__ - 1];
/* L2: */
		    segj_1.jco[i__ - 1] = (ij - 1) / data_1.np * mp2 + ij;
		}
		if (i1 <= in2) {
		    cmww_(&j, &i1, &in2, &cm[cm_offset], nrow, &cm[cm_offset],
			     nrow, &c__1);
		}
		if (im1 <= im2) {
		    cmws_(&j, &im1, &im2, &cm[ist * cm_dim1 + 1], nrow, &cm[
			    cm_offset], nrow, &c__1);
		}
/* L4: */
	    }
	}

/*     MATRIX ELEMENTS FOR PATCH CURRENT SOURCES */

	if (data_1.m > 0) {
	    jm1 = 1 - data_1.mp;
	    jm2 = 0;
	    jst = 1 - mp2;
	    i__4 = nop;
	    for (i__ = 1; i__ <= i__4; ++i__) {
		jm1 += data_1.mp;
		jm2 += data_1.mp;
		jst += npeq;
		if (i1 <= in2) {
		    cmsw_(&jm1, &jm2, &i1, &in2, &cm[jst + cm_dim1], &cm[
			    cm_offset], &c__0, nrow, &c__1);
		}
		if (im1 <= im2) {
		    cmss_(&jm1, &jm2, &im1, &im2, &cm[jst + ist * cm_dim1], 
			    nrow, &c__1);
		}
/* L6: */
	    }
	}
	if (matpar_1.icase == 2 || matpar_1.icase > 3) {

/*        COMBINE ELEMENTS FOR SYMMETRY MODES */

	    i__4 = it;
	    for (i__ = 1; i__ <= i__4; ++i__) {
		i__3 = npeq;
		for (j = 1; j <= i__3; ++j) {
		    i__2 = nop;
		    for (k = 1; k <= i__2; ++k) {
			ka = j + (k - 1) * npeq;
/* L8: */
			i__5 = k - 1;
			i__6 = ka + i__ * cm_dim1;
			scratm_1.d__[i__5].r = cm[i__6].r, scratm_1.d__[i__5]
				.i = cm[i__6].i;
		    }
		    deter.r = scratm_1.d__[0].r, deter.i = scratm_1.d__[0].i;
		    i__5 = nop;
		    for (kk = 2; kk <= i__5; ++kk) {
/* L9: */
			i__6 = kk - 1;
			z__1.r = deter.r + scratm_1.d__[i__6].r, z__1.i = 
				deter.i + scratm_1.d__[i__6].i;
			deter.r = z__1.r, deter.i = z__1.i;
		    }
		    i__6 = j + i__ * cm_dim1;
		    cm[i__6].r = deter.r, cm[i__6].i = deter.i;
		    i__6 = nop;
		    for (k = 2; k <= i__6; ++k) {
			ka = j + (k - 1) * npeq;
			deter.r = scratm_1.d__[0].r, deter.i = scratm_1.d__[0]
				.i;
			i__5 = nop;
			for (kk = 2; kk <= i__5; ++kk) {
/* L10: */
			    i__2 = kk - 1;
			    i__7 = k + kk * 20 - 21;
			    z__2.r = scratm_1.d__[i__2].r * smat_1.ssx[i__7]
				    .r - scratm_1.d__[i__2].i * smat_1.ssx[
				    i__7].i, z__2.i = scratm_1.d__[i__2].r * 
				    smat_1.ssx[i__7].i + scratm_1.d__[i__2].i 
				    * smat_1.ssx[i__7].r;
			    z__1.r = deter.r + z__2.r, z__1.i = deter.i + 
				    z__2.i;
			    deter.r = z__1.r, deter.i = z__1.i;
			}
			i__2 = ka + i__ * cm_dim1;
			cm[i__2].r = deter.r, cm[i__2].i = deter.i;
/* L11: */
		    }
		}
	    }
	}

/*     WRITE BLOCK FOR OUT-OF-CORE CASES. */
	if (matpar_1.icase > 2) {
	    recot_(&cm[cm_offset], iu1, &c__1, &iout, &ixblk1, "Write from C"
		    "MSET", (ftnlen)16);
	}
/* L13: */
    }
    return 0;
} /* cmset_ */

/* Subroutine */ int hsflx_(doublereal *s, doublereal *rh, doublereal *zpx, 
	doublecomplex *xk, doublecomplex *hpk, doublecomplex *hps, 
	doublecomplex *hpc)
{
    /* Initialized data */

    static doublecomplex fj = {0.,1.};
    static doublereal pi4 = 12.56637062;
    static doublereal pi8 = 25.13274123;

    /* System generated locals */
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Builtin functions */
    void z_cos(doublecomplex *, doublecomplex *), z_sin(doublecomplex *, 
	    doublecomplex *);
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublereal r1, r2;
    static doublecomplex t1, t2;
    static doublereal z1, z2, dh;
    static doublecomplex dk;
    extern /* Subroutine */ int gh_(doublereal *, doublecomplex *);
    static doublereal zr;
    static doublecomplex cdk, sdk;
    static doublereal hss, rhz;
    static doublecomplex ekr1, ekr2, cons;
    extern /* Subroutine */ int rombg_(doublereal *, doublereal *, integer *, 
	    S_fp, doublecomplex *, doublereal *, doublereal *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     HSFLX calculates H field of a current filament on the Z axis with */
/*     sine, cosine and constant distributions. */

    if (*rh < 1e-20f) {
	hps->r = 0.f, hps->i = 0.f;
	hpc->r = 0.f, hpc->i = 0.f;
	hpk->r = 0.f, hpk->i = 0.f;
	return 0;
    }
    z__1.r = fj.r * xk->r - fj.i * xk->i, z__1.i = fj.r * xk->i + fj.i * 
	    xk->r;
    tmh_1.xkj.r = z__1.r, tmh_1.xkj.i = z__1.i;
    tmh_1.rh2 = *rh * *rh;
    if (*zpx < 0.f) {
	tmh_1.zp = -(*zpx);
	hss = -1.f;
    } else {
	tmh_1.zp = *zpx;
	hss = 1.f;
    }
    dh = *s * .5f;
    z1 = tmh_1.zp + dh;
    z2 = tmh_1.zp - dh;
    if (z2 < *s * 1e-7f) {
	rhz = 1.f;
    } else {
	rhz = *rh / z2;
    }
    z__1.r = dh * xk->r, z__1.i = dh * xk->i;
    dk.r = z__1.r, dk.i = z__1.i;
    z_cos(&z__1, &dk);
    cdk.r = z__1.r, cdk.i = z__1.i;
    z_sin(&z__1, &dk);
    sdk.r = z__1.r, sdk.i = z__1.i;
    d__1 = -dh;
    rombg_(&d__1, &dh, &c__1, (S_fp)gh_, hpk, &c_b332, &c_b2721);
    z__2.r = *rh * hpk->r, z__2.i = *rh * hpk->i;
    z__1.r = z__2.r / pi4, z__1.i = z__2.i / pi4;
    hpk->r = z__1.r, hpk->i = z__1.i;
    if (rhz > .001f) {
	r1 = sqrt(tmh_1.rh2 + z1 * z1);
	r2 = sqrt(tmh_1.rh2 + z2 * z2);
	z__3.r = -tmh_1.xkj.r, z__3.i = -tmh_1.xkj.i;
	z__2.r = r1 * z__3.r, z__2.i = r1 * z__3.i;
	z_exp(&z__1, &z__2);
	ekr1.r = z__1.r, ekr1.i = z__1.i;
	z__3.r = -tmh_1.xkj.r, z__3.i = -tmh_1.xkj.i;
	z__2.r = r2 * z__3.r, z__2.i = r2 * z__3.i;
	z_exp(&z__1, &z__2);
	ekr2.r = z__1.r, ekr2.i = z__1.i;
	z__2.r = z1 * ekr1.r, z__2.i = z1 * ekr1.i;
	z__1.r = z__2.r / r1, z__1.i = z__2.i / r1;
	t1.r = z__1.r, t1.i = z__1.i;
	z__2.r = z2 * ekr2.r, z__2.i = z2 * ekr2.i;
	z__1.r = z__2.r / r2, z__1.i = z__2.i / r2;
	t2.r = z__1.r, t2.i = z__1.i;
	z__4.r = ekr2.r - ekr1.r, z__4.i = ekr2.i - ekr1.i;
	z__3.r = cdk.r * z__4.r - cdk.i * z__4.i, z__3.i = cdk.r * z__4.i + 
		cdk.i * z__4.r;
	z__6.r = fj.r * sdk.r - fj.i * sdk.i, z__6.i = fj.r * sdk.i + fj.i * 
		sdk.r;
	z__7.r = t2.r + t1.r, z__7.i = t2.i + t1.i;
	z__5.r = z__6.r * z__7.r - z__6.i * z__7.i, z__5.i = z__6.r * z__7.i 
		+ z__6.i * z__7.r;
	z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
	z__1.r = hss * z__2.r, z__1.i = hss * z__2.i;
	hps->r = z__1.r, hps->i = z__1.i;
	z__3.r = -sdk.r, z__3.i = -sdk.i;
	z__4.r = ekr2.r + ekr1.r, z__4.i = ekr2.i + ekr1.i;
	z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i 
		+ z__3.i * z__4.r;
	z__6.r = fj.r * cdk.r - fj.i * cdk.i, z__6.i = fj.r * cdk.i + fj.i * 
		cdk.r;
	z__7.r = t2.r - t1.r, z__7.i = t2.i - t1.i;
	z__5.r = z__6.r * z__7.r - z__6.i * z__7.i, z__5.i = z__6.r * z__7.i 
		+ z__6.i * z__7.r;
	z__1.r = z__2.r - z__5.r, z__1.i = z__2.i - z__5.i;
	hpc->r = z__1.r, hpc->i = z__1.i;
	z__2.r = -fj.r, z__2.i = -fj.i;
	d__1 = pi4 * *rh;
	z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
	cons.r = z__1.r, cons.i = z__1.i;
	z__1.r = cons.r * hps->r - cons.i * hps->i, z__1.i = cons.r * hps->i 
		+ cons.i * hps->r;
	hps->r = z__1.r, hps->i = z__1.i;
	z__1.r = cons.r * hpc->r - cons.i * hpc->i, z__1.i = cons.r * hpc->i 
		+ cons.i * hpc->r;
	hpc->r = z__1.r, hpc->i = z__1.i;
	z__1.r = hpc->r - hpk->r, z__1.i = hpc->i - hpk->i;
	hpc->r = z__1.r, hpc->i = z__1.i;
    } else {
	z__3.r = fj.r * sdk.r - fj.i * sdk.i, z__3.i = fj.r * sdk.i + fj.i * 
		sdk.r;
	z__2.r = cdk.r + z__3.r, z__2.i = cdk.i + z__3.i;
	d__1 = z2 * z2;
	z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
	ekr1.r = z__1.r, ekr1.i = z__1.i;
	z__3.r = fj.r * sdk.r - fj.i * sdk.i, z__3.i = fj.r * sdk.i + fj.i * 
		sdk.r;
	z__2.r = cdk.r - z__3.r, z__2.i = cdk.i - z__3.i;
	d__1 = z1 * z1;
	z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
	ekr2.r = z__1.r, ekr2.i = z__1.i;
	zr = 1.f / z1 - 1.f / z2;
	z__5.r = -tmh_1.xkj.r, z__5.i = -tmh_1.xkj.i;
	z__4.r = tmh_1.zp * z__5.r, z__4.i = tmh_1.zp * z__5.i;
	z_exp(&z__3, &z__4);
	z__2.r = *rh * z__3.r, z__2.i = *rh * z__3.i;
	z__1.r = z__2.r / pi8, z__1.i = z__2.i / pi8;
	t2.r = z__1.r, t2.i = z__1.i;
	z__4.r = zr * xk->r, z__4.i = zr * xk->i;
	z__6.r = ekr1.r + ekr2.r, z__6.i = ekr1.i + ekr2.i;
	z__5.r = z__6.r * sdk.r - z__6.i * sdk.i, z__5.i = z__6.r * sdk.i + 
		z__6.i * sdk.r;
	z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
	z__2.r = t2.r * z__3.r - t2.i * z__3.i, z__2.i = t2.r * z__3.i + t2.i 
		* z__3.r;
	z__1.r = hss * z__2.r, z__1.i = hss * z__2.i;
	hps->r = z__1.r, hps->i = z__1.i;
	z__4.r = ekr1.r - ekr2.r, z__4.i = ekr1.i - ekr2.i;
	z__3.r = z__4.r * cdk.r - z__4.i * cdk.i, z__3.i = z__4.r * cdk.i + 
		z__4.i * cdk.r;
	z__5.r = zr * tmh_1.xkj.r, z__5.i = zr * tmh_1.xkj.i;
	z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
	z__1.r = t2.r * z__2.r - t2.i * z__2.i, z__1.i = t2.r * z__2.i + t2.i 
		* z__2.r;
	hpc->r = z__1.r, hpc->i = z__1.i;
	z__1.r = hpc->r - hpk->r, z__1.i = hpc->i - hpk->i;
	hpc->r = z__1.r, hpc->i = z__1.i;
    }
    return 0;
} /* hsflx_ */

/* Subroutine */ int cmsw_(integer *j1, integer *j2, integer *i1, integer *i2,
	 doublecomplex *cm, doublecomplex *cw, integer *ncw, integer *nrow, 
	integer *itrp)
{
    /* System generated locals */
    integer cm_dim1, cm_offset, cw_dim1, cw_offset, i__1, i__2, i__3, i__4, 
	    i__5, i__6, i__7, i__8;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    void z_sin(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, j, k, il, jl, js;
    static doublereal xi, yi;
    static doublecomplex xk;
    static doublereal zi;
    static integer ip;
#define t1x ((doublereal *)&data_1 + 3630)
#define t1y ((doublereal *)&data_1 + 6050)
#define t1z ((doublereal *)&data_1 + 7260)
#define cab ((doublereal *)&data_1 + 6050)
#define sab ((doublereal *)&data_1 + 7260)
    static doublecomplex exc, eyc, ezc;
    static integer ldp;
    static doublereal cabi, sabi;
    static doublecomplex emel[9];
    static integer icgo, ipch, neqs;
    extern /* Subroutine */ int trio_(integer *);
    static doublereal salpi, fsign;
    extern /* Subroutine */ int pcint_(doublereal *, doublereal *, doublereal 
	    *, doublereal *, doublereal *, doublereal *, doublecomplex *), 
	    unere_(doublereal *, doublereal *, doublereal *);
    extern /* Double Complex */ VOID ccosm1_(doublecomplex *, doublecomplex *)
	    ;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CMSW computes matrix elements for E along wires due to patch */
/*     currents. */

/*     Include file NECPAR.INC sets demensions for NEC-4 */

/*     MAXSEG = MAXIMUM NUMBER OF SEGMENTS + PATCHES */
/*     MAXMAT = MAXIMUM OF (N+2*M) FOR INCORE MATRIX SOLUTION, WHERE */
/*              N = NUMBER OF SEGMENTS, M = NUMBER OF PATCHES */
/*              (IN NEC-3, IRESRV = MAXMAT**2) */
/*     LOADMX = MAXIMUM NUMBER OF LOADING COMMANDS */
/*     NETMX = MAXIMUM NUMBER OF SEGMENTS WITH NETWORK CONNECTIONS */
/*     NSOMAX = MAXIMUM NUMBER OF SOURCES (EX COMMANDS) */
/*     MAXIS  = MAMIMUM NUMBER OF IS COMMANDS */
/*     NSJMAX = MAXIMUM NUMBER OF SEGMENTS CONNECTING AT A JUNCTION */
/*     NSCNGF = MAXIMUM NUMBER OF NGF SEGMENTS CONNECTING TO NEW SEG. */
/*     NSPNGF = MAXIMUM NUMBER OF NGF PATCHES CONNECTING TO NEW SEG. */
/*     MAXSYM = MAXIMUM NUMBER OF SYMMETRIC SECTIONS */

    /* Parameter adjustments */
    cw_dim1 = *nrow;
    cw_offset = 1 + cw_dim1;
    cw -= cw_offset;
    cm_dim1 = *nrow;
    cm_offset = 1 + cm_dim1;
    cm -= cm_offset;

    /* Function Body */
    ldp = data_1.ld + 1;
    neqs = data_1.n - data_1.n1 + (data_1.m - data_1.m1 << 1);
    if (*itrp < 0) {
	goto L15;
    }
    k = 0;
    icgo = 1;
/*     OBSERVATION LOOP */
    i__1 = *i2;
    for (i__ = *i1; i__ <= i__1; ++i__) {
	++k;
	xi = data_1.x[i__ - 1];
	yi = data_1.y[i__ - 1];
	zi = data_1.z__[i__ - 1];
	cabi = cab[i__ - 1];
	sabi = sab[i__ - 1];
	salpi = data_1.salp[i__ - 1];
	ipch = 0;
	if (data_1.icon1[i__ - 1] > 30000) {
	    ipch = data_1.icon1[i__ - 1] - 30000;
	    fsign = -1.f;
	}
	if (data_1.icon2[i__ - 1] > 30000) {
	    ipch = data_1.icon2[i__ - 1] - 30000;
	    fsign = 1.f;
	}
	jl = 0;
/*     SOURCE LOOP */
	i__2 = *j2;
	for (j = *j1; j <= i__2; ++j) {
	    js = ldp - j;
	    jl += 2;
	    datap_1.t1xj = t1x[js - 1];
	    datap_1.t1yj = t1y[js - 1];
	    datap_1.t1zj = t1z[js - 1];
	    datap_1.t2xj = data_1.t2x[js - 1];
	    datap_1.t2yj = data_1.t2y[js - 1];
	    datap_1.t2zj = data_1.t2z[js - 1];
	    datap_1.xpatj = data_1.x[js - 1];
	    datap_1.ypatj = data_1.y[js - 1];
	    datap_1.zpatj = data_1.z__[js - 1];
	    datap_1.spatj = data_1.bi[js - 1];
	    if (datap_1.zpatj >= 0.f) {
		xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
	    } else {
		xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
	    }
/*     GROUND LOOP */
	    i__3 = gnd_1.ksymp;
	    for (ip = 1; ip <= i__3; ++ip) {
		datap_1.ipgnd = ip;
		if (ipch != j && icgo == 1) {
		    goto L11;
		}
		if (ip == 2) {
		    goto L11;
		}
		if (icgo > 1) {
		    goto L8;
		}
		pcint_(&xi, &yi, &zi, &cabi, &sabi, &salpi, emel);
		d__1 = data_1.si[i__ - 1] * .5f * fsign;
		z__1.r = d__1 * xk.r, z__1.i = d__1 * xk.i;
		ezc.r = z__1.r, ezc.i = z__1.i;
		z_sin(&z__1, &ezc);
		eyc.r = z__1.r, eyc.i = z__1.i;
		ccosm1_(&z__1, &ezc);
		ezc.r = z__1.r, ezc.i = z__1.i;
		z__2.r = fsign * emel[8].r, z__2.i = fsign * emel[8].i;
		z_div(&z__1, &z__2, &gnd_1.xku);
		exc.r = z__1.r, exc.i = z__1.i;
		trio_(&i__);
		if (i__ > data_1.n1) {
		    il = i__ - *ncw;
		    if (i__ <= data_1.np) {
			il = ((il - 1) / data_1.np << 1) * data_1.mp + il;
		    }
		} else {
		    il = neqs + data_1.iconx[i__ - 1];
		}
		if (*itrp == 0) {
		    i__4 = k + il * cw_dim1;
		    i__5 = k + il * cw_dim1;
		    i__6 = segj_1.jsno - 1;
		    i__7 = segj_1.jsno - 1;
		    z__5.r = segj_1.bx[i__7].r * eyc.r - segj_1.bx[i__7].i * 
			    eyc.i, z__5.i = segj_1.bx[i__7].r * eyc.i + 
			    segj_1.bx[i__7].i * eyc.r;
		    z__4.r = segj_1.ax[i__6].r + z__5.r, z__4.i = segj_1.ax[
			    i__6].i + z__5.i;
		    i__8 = segj_1.jsno - 1;
		    z__6.r = segj_1.cx[i__8].r * ezc.r - segj_1.cx[i__8].i * 
			    ezc.i, z__6.i = segj_1.cx[i__8].r * ezc.i + 
			    segj_1.cx[i__8].i * ezc.r;
		    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
		    z__2.r = exc.r * z__3.r - exc.i * z__3.i, z__2.i = exc.r *
			     z__3.i + exc.i * z__3.r;
		    z__1.r = cw[i__5].r + z__2.r, z__1.i = cw[i__5].i + 
			    z__2.i;
		    cw[i__4].r = z__1.r, cw[i__4].i = z__1.i;
		} else {
		    i__4 = il + k * cw_dim1;
		    i__5 = il + k * cw_dim1;
		    i__6 = segj_1.jsno - 1;
		    i__7 = segj_1.jsno - 1;
		    z__5.r = segj_1.bx[i__7].r * eyc.r - segj_1.bx[i__7].i * 
			    eyc.i, z__5.i = segj_1.bx[i__7].r * eyc.i + 
			    segj_1.bx[i__7].i * eyc.r;
		    z__4.r = segj_1.ax[i__6].r + z__5.r, z__4.i = segj_1.ax[
			    i__6].i + z__5.i;
		    i__8 = segj_1.jsno - 1;
		    z__6.r = segj_1.cx[i__8].r * ezc.r - segj_1.cx[i__8].i * 
			    ezc.i, z__6.i = segj_1.cx[i__8].r * ezc.i + 
			    segj_1.cx[i__8].i * ezc.r;
		    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
		    z__2.r = exc.r * z__3.r - exc.i * z__3.i, z__2.i = exc.r *
			     z__3.i + exc.i * z__3.r;
		    z__1.r = cw[i__5].r + z__2.r, z__1.i = cw[i__5].i + 
			    z__2.i;
		    cw[i__4].r = z__1.r, cw[i__4].i = z__1.i;
		}
L8:
		if (*itrp == 0) {
		    i__4 = k + (jl - 1) * cm_dim1;
		    i__5 = icgo - 1;
		    cm[i__4].r = emel[i__5].r, cm[i__4].i = emel[i__5].i;
		    i__4 = k + jl * cm_dim1;
		    i__5 = icgo + 3;
		    cm[i__4].r = emel[i__5].r, cm[i__4].i = emel[i__5].i;
		} else {
		    i__4 = jl - 1 + k * cm_dim1;
		    i__5 = icgo - 1;
		    cm[i__4].r = emel[i__5].r, cm[i__4].i = emel[i__5].i;
		    i__4 = jl + k * cm_dim1;
		    i__5 = icgo + 3;
		    cm[i__4].r = emel[i__5].r, cm[i__4].i = emel[i__5].i;
		}
		++icgo;
		if (icgo == 5) {
		    icgo = 1;
		}
		goto L13;
L11:
		unere_(&xi, &yi, &zi);
		if (*itrp == 0) {
/*     NORMAL FILL */
		    i__4 = k + (jl - 1) * cm_dim1;
		    i__5 = k + (jl - 1) * cm_dim1;
		    z__4.r = cabi * datap_1.h1x.r, z__4.i = cabi * 
			    datap_1.h1x.i;
		    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + 
			    z__4.i;
		    z__5.r = sabi * datap_1.h1y.r, z__5.i = sabi * 
			    datap_1.h1y.i;
		    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
		    z__6.r = salpi * datap_1.h1z.r, z__6.i = salpi * 
			    datap_1.h1z.i;
		    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
		    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
		    i__4 = k + jl * cm_dim1;
		    i__5 = k + jl * cm_dim1;
		    z__4.r = cabi * datap_1.h2x.r, z__4.i = cabi * 
			    datap_1.h2x.i;
		    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + 
			    z__4.i;
		    z__5.r = sabi * datap_1.h2y.r, z__5.i = sabi * 
			    datap_1.h2y.i;
		    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
		    z__6.r = salpi * datap_1.h2z.r, z__6.i = salpi * 
			    datap_1.h2z.i;
		    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
		    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
		} else {
/*     TRANSPOSED FILL */
		    i__4 = jl - 1 + k * cm_dim1;
		    i__5 = jl - 1 + k * cm_dim1;
		    z__4.r = cabi * datap_1.h1x.r, z__4.i = cabi * 
			    datap_1.h1x.i;
		    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + 
			    z__4.i;
		    z__5.r = sabi * datap_1.h1y.r, z__5.i = sabi * 
			    datap_1.h1y.i;
		    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
		    z__6.r = salpi * datap_1.h1z.r, z__6.i = salpi * 
			    datap_1.h1z.i;
		    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
		    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
		    i__4 = jl + k * cm_dim1;
		    i__5 = jl + k * cm_dim1;
		    z__4.r = cabi * datap_1.h2x.r, z__4.i = cabi * 
			    datap_1.h2x.i;
		    z__3.r = cm[i__5].r + z__4.r, z__3.i = cm[i__5].i + 
			    z__4.i;
		    z__5.r = sabi * datap_1.h2y.r, z__5.i = sabi * 
			    datap_1.h2y.i;
		    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
		    z__6.r = salpi * datap_1.h2z.r, z__6.i = salpi * 
			    datap_1.h2z.i;
		    z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
		    cm[i__4].r = z__1.r, cm[i__4].i = z__1.i;
		}
L13:
		;
	    }
/* L14: */
	}
    }
    return 0;
/*     FOR OLD SEG. CONNECTING TO OLD PATCH ON ONE END AND NEW SEG. ON */
/*     OTHER END INTEGRATE SINGULAR COMPONENT (9) OF SURFACE CURRENT ONLY */
L15:
    if (*j1 < *i1 || *j1 > *i2) {
	return 0;
    }
    ipch = data_1.icon1[*j1 - 1];
    if (ipch > 30000) {
	ipch += -30000;
	fsign = -1.f;
    } else {
	ipch = data_1.icon2[*j1 - 1];
	if (ipch < 30000) {
	    return 0;
	}
	ipch += -30000;
	fsign = 1.f;
    }
    if (ipch > data_1.m1) {
	return 0;
    }
    js = ldp - ipch;
    datap_1.ipgnd = 1;
    datap_1.t1xj = t1x[js - 1];
    datap_1.t1yj = t1y[js - 1];
    datap_1.t1zj = t1z[js - 1];
    datap_1.t2xj = data_1.t2x[js - 1];
    datap_1.t2yj = data_1.t2y[js - 1];
    datap_1.t2zj = data_1.t2z[js - 1];
    datap_1.xpatj = data_1.x[js - 1];
    datap_1.ypatj = data_1.y[js - 1];
    datap_1.zpatj = data_1.z__[js - 1];
    datap_1.spatj = data_1.bi[js - 1];
    xi = data_1.x[*j1 - 1];
    yi = data_1.y[*j1 - 1];
    zi = data_1.z__[*j1 - 1];
    cabi = cab[*j1 - 1];
    sabi = sab[*j1 - 1];
    salpi = data_1.salp[*j1 - 1];
    pcint_(&xi, &yi, &zi, &cabi, &sabi, &salpi, emel);
    xk.r = gnd_1.xku.r, xk.i = gnd_1.xku.i;
    if (data_1.z__[*j1 - 1] < 0.f) {
	xk.r = gnd_1.xkl.r, xk.i = gnd_1.xkl.i;
    }
    d__1 = data_1.si[*j1 - 1] * .5f * fsign;
    z__1.r = d__1 * xk.r, z__1.i = d__1 * xk.i;
    ezc.r = z__1.r, ezc.i = z__1.i;
    z_sin(&z__1, &ezc);
    eyc.r = z__1.r, eyc.i = z__1.i;
    ccosm1_(&z__1, &ezc);
    ezc.r = z__1.r, ezc.i = z__1.i;
    z__2.r = fsign * emel[8].r, z__2.i = fsign * emel[8].i;
    z_div(&z__1, &z__2, &gnd_1.xku);
    exc.r = z__1.r, exc.i = z__1.i;
    il = segj_1.jco[segj_1.jsno - 1];
    k = *j1 - *i1 + 1;
    i__2 = k + il * cw_dim1;
    i__1 = k + il * cw_dim1;
    i__3 = segj_1.jsno - 1;
    i__4 = segj_1.jsno - 1;
    z__5.r = segj_1.bx[i__4].r * eyc.r - segj_1.bx[i__4].i * eyc.i, z__5.i = 
	    segj_1.bx[i__4].r * eyc.i + segj_1.bx[i__4].i * eyc.r;
    z__4.r = segj_1.ax[i__3].r + z__5.r, z__4.i = segj_1.ax[i__3].i + z__5.i;
    i__5 = segj_1.jsno - 1;
    z__6.r = segj_1.cx[i__5].r * ezc.r - segj_1.cx[i__5].i * ezc.i, z__6.i = 
	    segj_1.cx[i__5].r * ezc.i + segj_1.cx[i__5].i * ezc.r;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__2.r = exc.r * z__3.r - exc.i * z__3.i, z__2.i = exc.r * z__3.i + exc.i 
	    * z__3.r;
    z__1.r = cw[i__1].r + z__2.r, z__1.i = cw[i__1].i + z__2.i;
    cw[i__2].r = z__1.r, cw[i__2].i = z__1.i;
    return 0;
} /* cmsw_ */

#undef sab
#undef cab
#undef t1z
#undef t1y
#undef t1x


/* Double Complex */ VOID ccosm1_(doublecomplex * ret_val, doublecomplex *z__)
{
    /* System generated locals */
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    void z_cos(doublecomplex *, doublecomplex *);

    /* Local variables */
    static doublecomplex zs;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     Purpose: */
/*     CCOSM1 computes COS(Z)-1 for complex Z.  A series is used for */
/*     small Z to maintain accuracy. */

    if (z_abs(z__) > .01f) {
	z_cos(&z__2, z__);
	z__1.r = z__2.r - 1.f, z__1.i = z__2.i;
	 ret_val->r = z__1.r,  ret_val->i = z__1.i;
    } else {
	z__1.r = z__->r * z__->r - z__->i * z__->i, z__1.i = z__->r * z__->i 
		+ z__->i * z__->r;
	zs.r = z__1.r, zs.i = z__1.i;
	z__6.r = zs.r * .0013888889f, z__6.i = zs.i * .0013888889f;
	z__5.r = z__6.r - .041666666667f, z__5.i = z__6.i;
	z__4.r = z__5.r * zs.r - z__5.i * zs.i, z__4.i = z__5.r * zs.i + 
		z__5.i * zs.r;
	z__3.r = z__4.r + .5f, z__3.i = z__4.i;
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z__1.r = z__2.r * zs.r - z__2.i * zs.i, z__1.i = z__2.r * zs.i + 
		z__2.i * zs.r;
	 ret_val->r = z__1.r,  ret_val->i = z__1.i;
    }
    return ;
} /* ccosm1_ */

/* Subroutine */ int somntx_(doublecomplex *epsc1, integer *ismprx)
{
    /* Format strings */
    static char fmt_2[] = "(/,\002 Time to generate Sommerfeld ground tables"
	    " =\002,f7.2,\002 seconds\002,/)";

    /* System generated locals */
    doublecomplex z__1, z__2;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *), d_cnjg(doublecomplex *, 
	    doublecomplex *), z_div(doublecomplex *, doublecomplex *, 
	    doublecomplex *);
    double z_abs(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static doublereal tim1, tim2, elgnd;
    extern /* Subroutine */ int second_(doublereal *), somlsq_(doublecomplex *
	    , doublereal *), somtrp_(doublecomplex *, doublereal *);

    /* Fortran I/O blocks */
    static cilist io___2830 = { 0, 3, 0, fmt_2, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOMNTX generates interpolation tables and least-squares approx- */
/*     imation parameters to approximate sommerfeld integrals for field */
/*     transmitted across the interface. */

/*     INPUT: */
/*     EPSC1 = relative permittivity of the ground */
/*     SIG1 = conductivity of the ground (S/m) */
/*     FMHZ = frequency in MHz. */


/*     SOMMERFELD INTEGRAL EVALUATION USES EXP(-JWT), NEC USES EXP(+JWT), */
/*     HENCE NEED CONJG(GCK1).  CONJUGATE OF FIELDS OCCURS IN SUBROUTINE */
/*     EVLUB. */

    prntcm_1.ismprt = *ismprx;
    gparm_1.gck2.r = 6.2831853071796, gparm_1.gck2.i = 0.;
    z_sqrt(&z__2, epsc1);
    z__1.r = gparm_1.gck2.r * z__2.r - gparm_1.gck2.i * z__2.i, z__1.i = 
	    gparm_1.gck2.r * z__2.i + gparm_1.gck2.i * z__2.r;
    gparm_1.gck1.r = z__1.r, gparm_1.gck1.i = z__1.i;
    z__1.r = gparm_1.gck1.r * gparm_1.gck1.r - gparm_1.gck1.i * 
	    gparm_1.gck1.i, z__1.i = gparm_1.gck1.r * gparm_1.gck1.i + 
	    gparm_1.gck1.i * gparm_1.gck1.r;
    gparm_1.gck1sq.r = z__1.r, gparm_1.gck1sq.i = z__1.i;
    z__1.r = gparm_1.gck2.r * gparm_1.gck2.r - gparm_1.gck2.i * 
	    gparm_1.gck2.i, z__1.i = gparm_1.gck2.r * gparm_1.gck2.i + 
	    gparm_1.gck2.i * gparm_1.gck2.r;
    gparm_1.gck2sq.r = z__1.r, gparm_1.gck2sq.i = z__1.i;
    d_cnjg(&z__1, &gparm_1.gck1);
    evlcom_1.cck1.r = z__1.r, evlcom_1.cck1.i = z__1.i;
    d_cnjg(&z__1, &gparm_1.gck2);
    evlcom_1.cck2.r = z__1.r, evlcom_1.cck2.i = z__1.i;
    d_cnjg(&z__1, &gparm_1.gck1sq);
    evlcom_1.cck1s.r = z__1.r, evlcom_1.cck1s.i = z__1.i;
    d_cnjg(&z__1, &gparm_1.gck2sq);
    evlcom_1.cck2s.r = z__1.r, evlcom_1.cck2s.i = z__1.i;
    z_div(&z__1, &gparm_1.gck2, &gparm_1.gck1);
    elgnd = z_abs(&z__1);
    if (elgnd > .3f) {
	elgnd = .3f;
    }
    evlcom_1.con1.r = 0.f, evlcom_1.con1.i = 188.37f;
    second_(&tim1);
    somlsq_(epsc1, &elgnd);
    somtrp_(epsc1, &elgnd);
    second_(&tim2);
    tim2 -= tim1;
    s_wsfe(&io___2830);
    do_fio(&c__1, (char *)&tim2, (ftnlen)sizeof(doublereal));
    e_wsfe();
    return 0;

} /* somntx_ */

/* Subroutine */ int bessel_(doublecomplex *z__, doublecomplex *j0, 
	doublecomplex *j0p)
{
    /* Initialized data */

    static doublereal c3 = .7978845608;
    static doublereal p10 = .0703125;
    static doublereal p20 = .1121520996;
    static doublereal q10 = .125;
    static doublereal q20 = .0732421875;
    static doublereal p11 = .1171875;
    static doublereal p21 = .1441955566;
    static doublereal q11 = .375;
    static doublereal q21 = .1025390625;
    static doublereal pof = .7853981635;
    static integer init = 0;
    static doublecomplex fj = {0.,1.};

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *), z_div(doublecomplex *, 
	    doublecomplex *, doublecomplex *), z_exp(doublecomplex *, 
	    doublecomplex *), z_sqrt(doublecomplex *, doublecomplex *);
    double sqrt(doublereal), cos(doublereal);

    /* Local variables */
    static integer i__, k, m[101];
    static doublereal a1[25], a2[25];
    static integer ib;
    static doublecomplex cz, zi;
    static integer iz;
    static doublecomplex zk, sz, j0x, zi2, p0z, p1z, q0z, q1z;
    static integer miz;
    static doublereal zms;
    static doublecomplex j0px;
    static doublereal test;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     BESSEL EVALUATES THE ZERO-ORDER BESSEL FUNCTION AND ITS DERIVATIVE */
/*     FOR COMPLEX ARGUMENT Z. */

    if (init == 0) {
	goto L5;
    }
L1:
    d_cnjg(&z__2, z__);
    z__1.r = z__->r * z__2.r - z__->i * z__2.i, z__1.i = z__->r * z__2.i + 
	    z__->i * z__2.r;
    zms = z__1.r;
    if (zms > 1e-12f) {
	goto L2;
    }
    j0->r = 1.f, j0->i = 0.f;
    z__1.r = z__->r * -.5f, z__1.i = z__->i * -.5f;
    j0p->r = z__1.r, j0p->i = z__1.i;
    return 0;
L2:
    ib = 0;
    if (zms > 37.21f) {
	goto L4;
    }
    if (zms > 36.f) {
	ib = 1;
    }
/*     SERIES EXPANSION */
    iz = (integer) (zms + 1.f);
    miz = m[iz - 1];
    j0->r = 1.f, j0->i = 0.f;
    j0p->r = j0->r, j0p->i = j0->i;
    zk.r = j0->r, zk.i = j0->i;
    z__1.r = z__->r * z__->r - z__->i * z__->i, z__1.i = z__->r * z__->i + 
	    z__->i * z__->r;
    zi.r = z__1.r, zi.i = z__1.i;
    i__1 = miz;
    for (k = 1; k <= i__1; ++k) {
	i__2 = k - 1;
	z__2.r = a1[i__2] * zk.r, z__2.i = a1[i__2] * zk.i;
	z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + 
		z__2.i * zi.r;
	zk.r = z__1.r, zk.i = z__1.i;
	z__1.r = j0->r + zk.r, z__1.i = j0->i + zk.i;
	j0->r = z__1.r, j0->i = z__1.i;
/* L3: */
	i__2 = k - 1;
	z__2.r = a2[i__2] * zk.r, z__2.i = a2[i__2] * zk.i;
	z__1.r = j0p->r + z__2.r, z__1.i = j0p->i + z__2.i;
	j0p->r = z__1.r, j0p->i = z__1.i;
    }
    z__2.r = z__->r * -.5f, z__2.i = z__->i * -.5f;
    z__1.r = z__2.r * j0p->r - z__2.i * j0p->i, z__1.i = z__2.r * j0p->i + 
	    z__2.i * j0p->r;
    j0p->r = z__1.r, j0p->i = z__1.i;
    if (ib == 0) {
	return 0;
    }
    j0x.r = j0->r, j0x.i = j0->i;
    j0px.r = j0p->r, j0px.i = j0p->i;
/*     ASYMPTOTIC EXPANSION */
L4:
    z_div(&z__1, &c_b336, z__);
    zi.r = z__1.r, zi.i = z__1.i;
    z__1.r = zi.r * zi.r - zi.i * zi.i, z__1.i = zi.r * zi.i + zi.i * zi.r;
    zi2.r = z__1.r, zi2.i = z__1.i;
    z__4.r = p20 * zi2.r, z__4.i = p20 * zi2.i;
    z__3.r = z__4.r - p10, z__3.i = z__4.i;
    z__2.r = z__3.r * zi2.r - z__3.i * zi2.i, z__2.i = z__3.r * zi2.i + 
	    z__3.i * zi2.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    p0z.r = z__1.r, p0z.i = z__1.i;
    z__4.r = p21 * zi2.r, z__4.i = p21 * zi2.i;
    z__3.r = p11 - z__4.r, z__3.i = -z__4.i;
    z__2.r = z__3.r * zi2.r - z__3.i * zi2.i, z__2.i = z__3.r * zi2.i + 
	    z__3.i * zi2.r;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    p1z.r = z__1.r, p1z.i = z__1.i;
    z__3.r = q20 * zi2.r, z__3.i = q20 * zi2.i;
    z__2.r = z__3.r - q10, z__2.i = z__3.i;
    z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + z__2.i * 
	    zi.r;
    q0z.r = z__1.r, q0z.i = z__1.i;
    z__3.r = q21 * zi2.r, z__3.i = q21 * zi2.i;
    z__2.r = q11 - z__3.r, z__2.i = -z__3.i;
    z__1.r = z__2.r * zi.r - z__2.i * zi.i, z__1.i = z__2.r * zi.i + z__2.i * 
	    zi.r;
    q1z.r = z__1.r, q1z.i = z__1.i;
    z__3.r = z__->r - pof, z__3.i = z__->i;
    z__2.r = fj.r * z__3.r - fj.i * z__3.i, z__2.i = fj.r * z__3.i + fj.i * 
	    z__3.r;
    z_exp(&z__1, &z__2);
    zk.r = z__1.r, zk.i = z__1.i;
    z_div(&z__1, &c_b336, &zk);
    zi2.r = z__1.r, zi2.i = z__1.i;
    z__2.r = zk.r + zi2.r, z__2.i = zk.i + zi2.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    cz.r = z__1.r, cz.i = z__1.i;
    z__2.r = fj.r * .5f, z__2.i = fj.i * .5f;
    z__3.r = zi2.r - zk.r, z__3.i = zi2.i - zk.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    sz.r = z__1.r, sz.i = z__1.i;
    z_sqrt(&z__2, &zi);
    z__1.r = c3 * z__2.r, z__1.i = c3 * z__2.i;
    zk.r = z__1.r, zk.i = z__1.i;
    z__3.r = p0z.r * cz.r - p0z.i * cz.i, z__3.i = p0z.r * cz.i + p0z.i * 
	    cz.r;
    z__4.r = q0z.r * sz.r - q0z.i * sz.i, z__4.i = q0z.r * sz.i + q0z.i * 
	    sz.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = zk.r * z__2.r - zk.i * z__2.i, z__1.i = zk.r * z__2.i + zk.i * 
	    z__2.r;
    j0->r = z__1.r, j0->i = z__1.i;
    z__2.r = -zk.r, z__2.i = -zk.i;
    z__4.r = p1z.r * sz.r - p1z.i * sz.i, z__4.i = p1z.r * sz.i + p1z.i * 
	    sz.r;
    z__5.r = q1z.r * cz.r - q1z.i * cz.i, z__5.i = q1z.r * cz.i + q1z.i * 
	    cz.r;
    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    j0p->r = z__1.r, j0p->i = z__1.i;
    if (ib == 0) {
	return 0;
    }
    zms = cos((sqrt(zms) - 6.f) * 31.41592654f);
    d__1 = zms + 1.f;
    z__3.r = d__1 * j0x.r, z__3.i = d__1 * j0x.i;
    d__2 = 1.f - zms;
    z__4.r = d__2 * j0->r, z__4.i = d__2 * j0->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    j0->r = z__1.r, j0->i = z__1.i;
    d__1 = zms + 1.f;
    z__3.r = d__1 * j0px.r, z__3.i = d__1 * j0px.i;
    d__2 = 1.f - zms;
    z__4.r = d__2 * j0p->r, z__4.i = d__2 * j0p->i;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
    j0p->r = z__1.r, j0p->i = z__1.i;
    return 0;
/*     INITIALIZATION OF CONSTANTS */
L5:
    for (k = 1; k <= 25; ++k) {
	a1[k - 1] = -.25 / (k * k);
/* L6: */
	a2[k - 1] = 1. / (k + 1.);
    }
    for (i__ = 1; i__ <= 101; ++i__) {
	test = 1.;
	for (k = 1; k <= 24; ++k) {
	    init = k;
	    test = -test * i__ * a1[k - 1];
	    if (test < 1e-6) {
		goto L8;
	    }
/* L7: */
	}
L8:
	m[i__ - 1] = init;
    }
    goto L1;
} /* bessel_ */

/* Subroutine */ int caxpy_(integer *n, doublecomplex *ca, doublecomplex *cx, 
	integer *incx, doublecomplex *cy, integer *incy)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    double d_imag(doublecomplex *);

    /* Local variables */
    static integer i__, ns, kx, ky;
    static doublereal canorm;

/*  ***BEGIN PROLOGUE  CAXPY */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A */
/*     KEYWORDS  BLAS,COMPLEX */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     COMPLEX COMPUTATION Y = A*X + Y */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CA  COMPLEX SCALAR MULTIPLIER */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */
/*       CY  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCY  STORAGE SPACING BETWEEN ELEMENTS OF CY */

/*     --OUTPUT-- */
/*       CY  COMPLEX RESULT (UNCHANGED IF N.LE.0) */

/*     OVERWRITE COMPLEX CY WITH COMPLEX  CA*CX + CY. */
/*     FOR I = 0 TO N-1, REPLACE  CY(LY+I*INCY) WITH CA*CX(LX+I*INCX) + */
/*       CY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N */
/*       AND LY IS DEFINED IN A SIMILAR WAY USING INCY. */


/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED    (NONE) */
/*  ***END PROLOGUE  CAXPY */
/*     FIRST EXECUTABLE STATEMENT  CAXPY */
    /* Parameter adjustments */
    --cy;
    --cx;

    /* Function Body */
    canorm = (d__1 = ca->r, abs(d__1)) + (d__2 = d_imag(ca), abs(d__2));
    if (*n <= 0 || canorm == 0.f) {
	return 0;
    }
    if (*incx == *incy && *incx > 0) {
	goto L2;
    }
    kx = 1;
    ky = 1;
    if (*incx < 0) {
	kx = (1 - *n) * *incx + 1;
    }
    if (*incy < 0) {
	ky = (1 - *n) * *incy + 1;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = ky;
	i__3 = ky;
	i__4 = kx;
	z__2.r = ca->r * cx[i__4].r - ca->i * cx[i__4].i, z__2.i = ca->r * cx[
		i__4].i + ca->i * cx[i__4].r;
	z__1.r = cy[i__3].r + z__2.r, z__1.i = cy[i__3].i + z__2.i;
	cy[i__2].r = z__1.r, cy[i__2].i = z__1.i;
	kx += *incx;
	ky += *incy;
/* L1: */
    }
    return 0;
L2:
    ns = *n * *incx;
    i__1 = ns;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	i__3 = i__;
	i__4 = i__;
	z__2.r = ca->r * cx[i__4].r - ca->i * cx[i__4].i, z__2.i = ca->r * cx[
		i__4].i + ca->i * cx[i__4].r;
	i__5 = i__;
	z__1.r = z__2.r + cy[i__5].r, z__1.i = z__2.i + cy[i__5].i;
	cy[i__3].r = z__1.r, cy[i__3].i = z__1.i;
/* L3: */
    }
    return 0;
} /* caxpy_ */

/* Subroutine */ int ccopy_(integer *n, doublecomplex *cx, integer *incx, 
	doublecomplex *cy, integer *incy)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, ns, kx, ky;

/*  ***BEGIN PROLOGUE  CCOPY */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A */
/*     KEYWORDS  COMPLEX,BLAS,VECTOR,COPY,VECTOR COPY */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     COMPLEX VECTOR COPY Y = X */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */
/*       CY  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCY  STORAGE SPACING BETWEEN ELEMENTS OF CY */

/*     --OUTPUT-- */
/*       CY  COPY OF VECTOR CX (UNCHANGED IF N.LE.0) */

/*     COPY COMPLEX CX TO COMPLEX CY. */
/*     FOR I = 0 TO N-1, COPY CX(LX+I*INCX) TO CY(LY+I*INCY), */
/*     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS */
/*     DEFINED IN A SIMILAR WAY USING INCY. */


/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED  (NONE) */
/*  ***END PROLOGUE  CCOPY */
/*     FIRST EXECUTABLE STATEMENT  CCOPY */
    /* Parameter adjustments */
    --cy;
    --cx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*incx == *incy && *incx > 0) {
	goto L2;
    }
    kx = 1;
    ky = 1;
    if (*incx < 0) {
	kx = (1 - *n) * *incx + 1;
    }
    if (*incy < 0) {
	ky = (1 - *n) * *incy + 1;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = ky;
	i__3 = kx;
	cy[i__2].r = cx[i__3].r, cy[i__2].i = cx[i__3].i;
	kx += *incx;
	ky += *incy;
/* L1: */
    }
    return 0;
L2:
    ns = *n * *incx;
    i__1 = ns;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	i__3 = i__;
	i__4 = i__;
	cy[i__3].r = cx[i__4].r, cy[i__3].i = cx[i__4].i;
/* L3: */
    }
    return 0;
} /* ccopy_ */

/* Double Complex */ VOID cdotc_(doublecomplex * ret_val, integer *n, 
	doublecomplex *cx, integer *incx, doublecomplex *cy, integer *incy)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void d_cnjg(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, ns, kx, ky;

/*  ***BEGIN PROLOGUE  CDOTC */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A */
/*     KEYWORDS  COMPLEX,BLAS,VECTOR,DOT PRODUCT,INNER PRODUCT */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     DOT PRODUCT OF COMPLEX VECTORS, USES COMPLX CONJG OF FIRST VECTOR */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */
/*       CY  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCY  STORAGE SPACING BETWEEN ELEMENTS OF CY */

/*     --OUTPUT-- */
/*     CDOTC  COMPLEX RESULT (ZERO IF N.LE.0) */

/*     RETURNS THE DOT PRODUCT FOR COMPLEX CX AND CY, USES CONJUGATE(CX) */
/*     CDOTC = SUM FOR I = 0 TO N-1 OF CONJ(CX(LX+I*INCX))*CY(LY+I*INCY) */
/*     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS */
/*     DEFINED IN A SIMILAR WAY USING INCY. */


/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED   (NONE) */
/*  ***END PROLOGUE  CDOTC */
/*     FIRST EXECUTABLE STATEMENT  CDOTC */
    /* Parameter adjustments */
    --cy;
    --cx;

    /* Function Body */
     ret_val->r = 0.f,  ret_val->i = 0.f;
    if (*n <= 0) {
	return ;
    }
    if (*incx == *incy && *incx > 0) {
	goto L2;
    }
    kx = 1;
    ky = 1;
    if (*incx < 0) {
	kx = (1 - *n) * *incx + 1;
    }
    if (*incy < 0) {
	ky = (1 - *n) * *incy + 1;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	d_cnjg(&z__3, &cx[kx]);
	i__2 = ky;
	z__2.r = z__3.r * cy[i__2].r - z__3.i * cy[i__2].i, z__2.i = z__3.r * 
		cy[i__2].i + z__3.i * cy[i__2].r;
	z__1.r =  ret_val->r + z__2.r, z__1.i =  ret_val->i + z__2.i;
	 ret_val->r = z__1.r,  ret_val->i = z__1.i;
	kx += *incx;
	ky += *incy;
/* L1: */
    }
    return ;
L2:
    ns = *n * *incx;
    i__1 = ns;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	d_cnjg(&z__3, &cx[i__]);
	i__3 = i__;
	z__2.r = z__3.r * cy[i__3].r - z__3.i * cy[i__3].i, z__2.i = z__3.r * 
		cy[i__3].i + z__3.i * cy[i__3].r;
	z__1.r = z__2.r +  ret_val->r, z__1.i = z__2.i +  ret_val->i;
	 ret_val->r = z__1.r,  ret_val->i = z__1.i;
/* L3: */
    }
    return ;
} /* cdotc_ */

/* Subroutine */ int cqrdc_(doublecomplex *x, integer *ldx, integer *n, 
	integer *p, doublecomplex *qraux, integer *jpvt, doublecomplex *work, 
	integer *job)
{
    /* System generated locals */
    integer x_dim1, x_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double d_imag(doublecomplex *), z_abs(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), z_sqrt(
	    doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer j, l;
    static doublecomplex t;
    static integer jj, jp, pl, pu;
    static doublereal tt;
    static integer lp1, lup;
    static logical negj;
    static integer maxj;
    extern /* Subroutine */ int cscal_(integer *, doublecomplex *, 
	    doublecomplex *, integer *);
    extern /* Double Complex */ VOID cdotc_(doublecomplex *, integer *, 
	    doublecomplex *, integer *, doublecomplex *, integer *);
    extern /* Subroutine */ int cswap_(integer *, doublecomplex *, integer *, 
	    doublecomplex *, integer *);
    static logical swapj;
    extern /* Subroutine */ int caxpy_(integer *, doublecomplex *, 
	    doublecomplex *, integer *, doublecomplex *, integer *);
    static doublecomplex nrmxl;
    extern doublereal scnrm2_(integer *, doublecomplex *, integer *);
    static doublereal maxnrm;


/*     CQRDC USES HOUSEHOLDER TRANSFORMATIONS TO COMPUTE THE QR */
/*     FACTORIZATION OF AN N BY P MATRIX X.  COLUMN PIVOTING */
/*     BASED ON THE 2-NORMS OF THE REDUCED COLUMNS MAY BE */
/*     PERFORMED AT THE USERS OPTION. */

/*     ON ENTRY */

/*        X       COMPLEX(LDX,P), WHERE LDX .GE. N. */
/*                X CONTAINS THE MATRIX WHOSE DECOMPOSITION IS TO BE */
/*                COMPUTED. */

/*        LDX     INTEGER. */
/*                LDX IS THE LEADING DIMENSION OF THE ARRAY X. */

/*        N       INTEGER. */
/*                N IS THE NUMBER OF ROWS OF THE MATRIX X. */

/*        P       INTEGER. */
/*                P IS THE NUMBER OF COLUMNS OF THE MATRIX X. */

/*        JPVT    INTEGER(P). */
/*                JPVT CONTAINS INTEGERS THAT CONTROL THE SELECTION */
/*                OF THE PIVOT COLUMNS.  THE K-TH COLUMN X(K) OF X */
/*                IS PLACED IN ONE OF THREE CLASSES ACCORDING TO THE */
/*                VALUE OF JPVT(K). */

/*                   IF JPVT(K) .GT. 0, THEN X(K) IS AN INITIAL */
/*                                      COLUMN. */

/*                   IF JPVT(K) .EQ. 0, THEN X(K) IS A FREE COLUMN. */

/*                   IF JPVT(K) .LT. 0, THEN X(K) IS A FINAL COLUMN. */

/*                BEFORE THE DECOMPOSITION IS COMPUTED, INITIAL COLUMNS */
/*                ARE MOVED TO THE BEGINNING OF THE ARRAY X AND FINAL */
/*                COLUMNS TO THE END.  BOTH INITIAL AND FINAL COLUMNS */
/*                ARE FROZEN IN PLACE DURING THE COMPUTATION AND ONLY */
/*                FREE COLUMNS ARE MOVED.  AT THE K-TH STAGE OF THE */
/*                REDUCTION, IF X(K) IS OCCUPIED BY A FREE COLUMN */
/*                IT IS INTERCHANGED WITH THE FREE COLUMN OF LARGEST */
/*                REDUCED NORM.  JPVT IS NOT REFERENCED IF */
/*                JOB .EQ. 0. */

/*        WORK    COMPLEX(P). */
/*                WORK IS A WORK ARRAY.  WORK IS NOT REFERENCED IF */
/*                JOB .EQ. 0. */

/*        JOB     INTEGER. */
/*                JOB IS AN INTEGER THAT INITIATES COLUMN PIVOTING. */
/*                IF JOB .EQ. 0, NO PIVOTING IS DONE. */
/*                IF JOB .NE. 0, PIVOTING IS DONE. */

/*     ON RETURN */

/*        X       X CONTAINS IN ITS UPPER TRIANGLE THE UPPER */
/*                TRIANGULAR MATRIX R OF THE QR FACTORIZATION. */
/*                BELOW ITS DIAGONAL X CONTAINS INFORMATION FROM */
/*                WHICH THE UNITARY PART OF THE DECOMPOSITION */
/*                CAN BE RECOVERED.  NOTE THAT IF PIVOTING HAS */
/*                BEEN REQUESTED, THE DECOMPOSITION IS NOT THAT */
/*                OF THE ORIGINAL MATRIX X BUT THAT OF X */
/*                WITH ITS COLUMNS PERMUTED AS DESCRIBED BY JPVT. */

/*        QRAUX   COMPLEX(P). */
/*                QRAUX CONTAINS FURTHER INFORMATION REQUIRED TO RECOVER */
/*                THE UNITARY PART OF THE DECOMPOSITION. */

/*        JPVT    JPVT(K) CONTAINS THE INDEX OF THE COLUMN OF THE */
/*                ORIGINAL MATRIX THAT HAS BEEN INTERCHANGED INTO */
/*                THE K-TH COLUMN, IF PIVOTING WAS REQUESTED. */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB. */

/*     CQRDC USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS. */

/*     BLAS CAXPY,CDOTC,CSCAL,CSWAP,SCNRM2 */
/*     FORTRAN ABS,AIMAG,AMAX1,ABS,DCMPLX,CSQRT,MIN0,REAL */

/*     INTERNAL VARIABLES */



    /* Parameter adjustments */
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    --qraux;
    --jpvt;
    --work;

    /* Function Body */
    pl = 1;
    pu = 0;
    if (*job == 0) {
	goto L6;
    }

/*        PIVOTING HAS BEEN REQUESTED.  REARRANGE THE COLUMNS */
/*        ACCORDING TO JPVT. */

    i__1 = *p;
    for (j = 1; j <= i__1; ++j) {
	swapj = jpvt[j] > 0;
	negj = jpvt[j] < 0;
	jpvt[j] = j;
	if (negj) {
	    jpvt[j] = -j;
	}
	if (! swapj) {
	    goto L1;
	}
	if (j != pl) {
	    cswap_(n, &x[pl * x_dim1 + 1], &c__1, &x[j * x_dim1 + 1], &c__1);
	}
	jpvt[j] = jpvt[pl];
	jpvt[pl] = j;
	++pl;
L1:
/* L2: */
	;
    }
    pu = *p;
    i__1 = *p;
    for (jj = 1; jj <= i__1; ++jj) {
	j = *p - jj + 1;
	if (jpvt[j] >= 0) {
	    goto L4;
	}
	jpvt[j] = -jpvt[j];
	if (j == pu) {
	    goto L3;
	}
	cswap_(n, &x[pu * x_dim1 + 1], &c__1, &x[j * x_dim1 + 1], &c__1);
	jp = jpvt[pu];
	jpvt[pu] = jpvt[j];
	jpvt[j] = jp;
L3:
	--pu;
L4:
/* L5: */
	;
    }
L6:

/*     COMPUTE THE NORMS OF THE FREE COLUMNS. */

    if (pu < pl) {
	goto L8;
    }
    i__1 = pu;
    for (j = pl; j <= i__1; ++j) {
	i__2 = j;
	d__1 = scnrm2_(n, &x[j * x_dim1 + 1], &c__1);
	z__1.r = d__1, z__1.i = 0.;
	qraux[i__2].r = z__1.r, qraux[i__2].i = z__1.i;
	i__2 = j;
	i__3 = j;
	work[i__2].r = qraux[i__3].r, work[i__2].i = qraux[i__3].i;
/* L7: */
    }
L8:

/*     PERFORM THE HOUSEHOLDER REDUCTION OF X. */

    lup = min(*n,*p);
    i__1 = lup;
    for (l = 1; l <= i__1; ++l) {
	if (l < pl || l >= pu) {
	    goto L12;
	}

/*           LOCATE THE COLUMN OF LARGEST NORM AND BRING IT */
/*           INTO THE PIVOT POSITION. */

	maxnrm = 0.f;
	maxj = l;
	i__2 = pu;
	for (j = l; j <= i__2; ++j) {
	    i__3 = j;
	    if (qraux[i__3].r <= maxnrm) {
		goto L9;
	    }
	    i__3 = j;
	    maxnrm = qraux[i__3].r;
	    maxj = j;
L9:
/* L10: */
	    ;
	}
	if (maxj == l) {
	    goto L11;
	}
	cswap_(n, &x[l * x_dim1 + 1], &c__1, &x[maxj * x_dim1 + 1], &c__1);
	i__2 = maxj;
	i__3 = l;
	qraux[i__2].r = qraux[i__3].r, qraux[i__2].i = qraux[i__3].i;
	i__2 = maxj;
	i__3 = l;
	work[i__2].r = work[i__3].r, work[i__2].i = work[i__3].i;
	jp = jpvt[maxj];
	jpvt[maxj] = jpvt[l];
	jpvt[l] = jp;
L11:
L12:
	i__2 = l;
	qraux[i__2].r = 0.f, qraux[i__2].i = 0.f;
	if (l == *n) {
	    goto L19;
	}

/*           COMPUTE THE HOUSEHOLDER TRANSFORMATION FOR COLUMN L. */

	i__2 = *n - l + 1;
	d__1 = scnrm2_(&i__2, &x[l + l * x_dim1], &c__1);
	z__1.r = d__1, z__1.i = 0.;
	nrmxl.r = z__1.r, nrmxl.i = z__1.i;
	if ((d__1 = nrmxl.r, abs(d__1)) + (d__2 = d_imag(&nrmxl), abs(d__2)) 
		== 0.f) {
	    goto L18;
	}
	i__2 = l + l * x_dim1;
	if ((d__1 = x[i__2].r, abs(d__1)) + (d__2 = d_imag(&x[l + l * x_dim1])
		, abs(d__2)) != 0.f) {
	    d__3 = z_abs(&nrmxl);
	    i__3 = l + l * x_dim1;
	    d__4 = z_abs(&x[l + l * x_dim1]);
	    z__2.r = x[i__3].r / d__4, z__2.i = x[i__3].i / d__4;
	    z__1.r = d__3 * z__2.r, z__1.i = d__3 * z__2.i;
	    nrmxl.r = z__1.r, nrmxl.i = z__1.i;
	}
	i__2 = *n - l + 1;
	z_div(&z__1, &c_b336, &nrmxl);
	cscal_(&i__2, &z__1, &x[l + l * x_dim1], &c__1);
	i__2 = l + l * x_dim1;
	i__3 = l + l * x_dim1;
	z__1.r = x[i__3].r + 1.f, z__1.i = x[i__3].i + 0.f;
	x[i__2].r = z__1.r, x[i__2].i = z__1.i;

/*              APPLY THE TRANSFORMATION TO THE REMAINING COLUMNS, */
/*              UPDATING THE NORMS. */

	lp1 = l + 1;
	if (*p < lp1) {
	    goto L17;
	}
	i__2 = *p;
	for (j = lp1; j <= i__2; ++j) {
	    i__3 = *n - l + 1;
	    cdotc_(&z__3, &i__3, &x[l + l * x_dim1], &c__1, &x[l + j * x_dim1]
		    , &c__1);
	    z__2.r = -z__3.r, z__2.i = -z__3.i;
	    z_div(&z__1, &z__2, &x[l + l * x_dim1]);
	    t.r = z__1.r, t.i = z__1.i;
	    i__3 = *n - l + 1;
	    caxpy_(&i__3, &t, &x[l + l * x_dim1], &c__1, &x[l + j * x_dim1], &
		    c__1);
	    if (j < pl || j > pu) {
		goto L15;
	    }
	    i__3 = j;
	    if ((d__1 = qraux[i__3].r, abs(d__1)) + (d__2 = d_imag(&qraux[j]),
		     abs(d__2)) == 0.f) {
		goto L15;
	    }
	    i__3 = j;
/* Computing 2nd power */
	    d__1 = z_abs(&x[l + j * x_dim1]) / qraux[i__3].r;
	    tt = 1.f - d__1 * d__1;
	    tt = max(tt,0.);
	    z__1.r = tt, z__1.i = 0.;
	    t.r = z__1.r, t.i = z__1.i;
	    i__3 = j;
	    i__4 = j;
/* Computing 2nd power */
	    d__1 = qraux[i__3].r / work[i__4].r;
	    tt = tt * .05f * (d__1 * d__1) + 1.f;
	    if (tt == 1.f) {
		goto L13;
	    }
	    i__3 = j;
	    i__4 = j;
	    z_sqrt(&z__2, &t);
	    z__1.r = qraux[i__4].r * z__2.r - qraux[i__4].i * z__2.i, z__1.i =
		     qraux[i__4].r * z__2.i + qraux[i__4].i * z__2.r;
	    qraux[i__3].r = z__1.r, qraux[i__3].i = z__1.i;
	    goto L14;
L13:
	    i__3 = j;
	    i__4 = *n - l;
	    d__1 = scnrm2_(&i__4, &x[l + 1 + j * x_dim1], &c__1);
	    z__1.r = d__1, z__1.i = 0.;
	    qraux[i__3].r = z__1.r, qraux[i__3].i = z__1.i;
	    i__3 = j;
	    i__4 = j;
	    work[i__3].r = qraux[i__4].r, work[i__3].i = qraux[i__4].i;
L14:
L15:
/* L16: */
	    ;
	}
L17:

/*              SAVE THE TRANSFORMATION. */

	i__2 = l;
	i__3 = l + l * x_dim1;
	qraux[i__2].r = x[i__3].r, qraux[i__2].i = x[i__3].i;
	i__2 = l + l * x_dim1;
	z__1.r = -nrmxl.r, z__1.i = -nrmxl.i;
	x[i__2].r = z__1.r, x[i__2].i = z__1.i;
L18:
L19:
/* L20: */
	;
    }
    return 0;
} /* cqrdc_ */

/* Subroutine */ int cqrsl_(doublecomplex *x, integer *ldx, integer *n, 
	integer *k, doublecomplex *qraux, doublecomplex *y, doublecomplex *qy,
	 doublecomplex *qty, doublecomplex *b, doublecomplex *rsd, 
	doublecomplex *xb, integer *job, integer *info)
{
    /* System generated locals */
    integer x_dim1, x_offset, i__1, i__2, i__3;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, j;
    static doublecomplex t;
    static logical cb;
    static integer jj;
    static logical cr;
    static integer ju, kp1;
    static logical cxb, cqy;
    static doublecomplex temp;
    static logical cqty;
    extern /* Double Complex */ VOID cdotc_(doublecomplex *, integer *, 
	    doublecomplex *, integer *, doublecomplex *, integer *);
    extern /* Subroutine */ int ccopy_(integer *, doublecomplex *, integer *, 
	    doublecomplex *, integer *), caxpy_(integer *, doublecomplex *, 
	    doublecomplex *, integer *, doublecomplex *, integer *);


/*     CQRSL APPLIES THE OUTPUT OF CQRDC TO COMPUTE COORDINATE */
/*     TRANSFORMATIONS, PROJECTIONS, AND LEAST SQUARES SOLUTIONS. */
/*     FOR K .LE. MIN(N,P), LET XK BE THE MATRIX */

/*            XK = (X(JPVT(1)),X(JPVT(2)), ... ,X(JPVT(K))) */

/*     FORMED FROM COLUMNNS JPVT(1), ... ,JPVT(K) OF THE ORIGINAL */
/*     N X P MATRIX X THAT WAS INPUT TO CQRDC (IF NO PIVOTING WAS */
/*     DONE, XK CONSISTS OF THE FIRST K COLUMNS OF X IN THEIR */
/*     ORIGINAL ORDER).  CQRDC PRODUCES A FACTORED UNITARY MATRIX Q */
/*     AND AN UPPER TRIANGULAR MATRIX R SUCH THAT */

/*              XK = Q * (R) */
/*                       (0) */

/*     THIS INFORMATION IS CONTAINED IN CODED FORM IN THE ARRAYS */
/*     X AND QRAUX. */

/*     ON ENTRY */

/*        X      COMPLEX(LDX,P). */
/*               X CONTAINS THE OUTPUT OF CQRDC. */

/*        LDX    INTEGER. */
/*               LDX IS THE LEADING DIMENSION OF THE ARRAY X. */

/*        N      INTEGER. */
/*               N IS THE NUMBER OF ROWS OF THE MATRIX XK.  IT MUST */
/*               HAVE THE SAME VALUE AS N IN CQRDC. */

/*        K      INTEGER. */
/*               K IS THE NUMBER OF COLUMNS OF THE MATRIX XK.  K */
/*               MUST NNOT BE GREATER THAN MIN(N,P), WHERE P IS THE */
/*               SAME AS IN THE CALLING SEQUENCE TO CQRDC. */

/*        QRAUX  COMPLEX(P). */
/*               QRAUX CONTAINS THE AUXILIARY OUTPUT FROM CQRDC. */

/*        Y      COMPLEX(N) */
/*               Y CONTAINS AN N-VECTOR THAT IS TO BE MANIPULATED */
/*               BY CQRSL. */

/*        JOB    INTEGER. */
/*               JOB SPECIFIES WHAT IS TO BE COMPUTED.  JOB HAS */
/*               THE DECIMAL EXPANSION ABCDE, WITH THE FOLLOWING */
/*               MEANING. */

/*                    IF A.NE.0, COMPUTE QY. */
/*                    IF B,C,D, OR E .NE. 0, COMPUTE QTY. */
/*                    IF C.NE.0, COMPUTE B. */
/*                    IF D.NE.0, COMPUTE RSD. */
/*                    IF E.NE.0, COMPUTE XB. */

/*               NOTE THAT A REQUEST TO COMPUTE B, RSD, OR XB */
/*               AUTOMATICALLY TRIGGERS THE COMPUTATION OF QTY, FOR */
/*               WHICH AN ARRAY MUST BE PROVIDED IN THE CALLING */
/*               SEQUENCE. */

/*     ON RETURN */

/*        QY     COMPLEX(N). */
/*               QY CONNTAINS Q*Y, IF ITS COMPUTATION HAS BEEN */
/*               REQUESTED. */

/*        QTY    COMPLEX(N). */
/*               QTY CONTAINS CTRANS(Q)*Y, IF ITS COMPUTATION HAS */
/*               BEEN REQUESTED.  HERE CTRANS(Q) IS THE CONJUGATE */
/*               TRANSPOSE OF THE MATRIX Q. */

/*        B      COMPLEX(K) */
/*               B CONTAINS THE SOLUTION OF THE LEAST SQUARES PROBLEM */

/*                    MINIMIZE NORM2(Y - XK*B), */

/*               IF ITS COMPUTATION HAS BEEN REQUESTED.  (NOTE THAT */
/*               IF PIVOTING WAS REQUESTED IN CQRDC, THE J-TH */
/*               COMPONENT OF B WILL BE ASSOCIATED WITH COLUMN JPVT(J) */
/*               OF THE ORIGINAL MATRIX X THAT WAS INPUT INTO CQRDC.) */

/*        RSD    COMPLEX(N). */
/*               RSD CONTAINS THE LEAST SQUARES RESIDUAL Y - XK*B, */
/*               IF ITS COMPUTATION HAS BEEN REQUESTED.  RSD IS */
/*               ALSO THE ORTHOGONAL PROJECTION OF Y ONTO THE */
/*               ORTHOGONAL COMPLEMENT OF THE COLUMN SPACE OF XK. */

/*        XB     COMPLEX(N). */
/*               XB CONTAINS THE LEAST SQUARES APPROXIMATION XK*B, */
/*               IF ITS COMPUTATION HAS BEEN REQUESTED.  XB IS ALSO */
/*               THE ORTHOGONAL PROJECTION OF Y ONTO THE COLUMN SPACE */
/*               OF X. */

/*        INFO   INTEGER. */
/*               INFO IS ZERO UNLESS THE COMPUTATION OF B HAS */
/*               BEEN REQUESTED AND R IS EXACTLY SINGULAR.  IN */
/*               THIS CASE, INFO IS THE INDEX OF THE FIRST ZERO */
/*               DIAGONAL ELEMENT OF R AND B IS LEFT UNALTERED. */

/*     THE PARAMETERS QY, QTY, B, RSD, AND XB ARE NOT REFERENCED */
/*     IF THEIR COMPUTATION IS NOT REQUESTED AND IN THIS CASE */
/*     CAN BE REPLACED BY DUMMY VARIABLES IN THE CALLING PROGRAM. */
/*     TO SAVE STORAGE, THE USER MAY IN SOME CASES USE THE SAME */
/*     ARRAY FOR DIFFERENT PARAMETERS IN THE CALLING SEQUENCE.  A */
/*     FREQUENTLY OCCURING EXAMPLE IS WHEN ONE WISHES TO COMPUTE */
/*     ANY OF B, RSD, OR XB AND DOES NOT NEED Y OR QTY.  IN THIS */
/*     CASE ONE MAY IDENTIFY Y, QTY, AND ONE OF B, RSD, OR XB, WHILE */
/*     PROVIDING SEPARATE ARRAYS FOR ANYTHING ELSE THAT IS TO BE */
/*     COMPUTED.  THUS THE CALLING SEQUENCE */

/*          CALL CQRSL(X,LDX,N,K,QRAUX,Y,DUM,Y,B,Y,DUM,110,INFO) */

/*     WILL RESULT IN THE COMPUTATION OF B AND RSD, WITH RSD */
/*     OVERWRITING Y.  MORE GENERALLY, EACH ITEM IN THE FOLLOWING */
/*     LIST CONTAINS GROUPS OF PERMISSIBLE IDENTIFICATIONS FOR */
/*     A SINGLE CALLINNG SEQUENCE. */

/*          1. (Y,QTY,B) (RSD) (XB) (QY) */

/*          2. (Y,QTY,RSD) (B) (XB) (QY) */

/*          3. (Y,QTY,XB) (B) (RSD) (QY) */

/*          4. (Y,QY) (QTY,B) (RSD) (XB) */

/*          5. (Y,QY) (QTY,RSD) (B) (XB) */

/*          6. (Y,QY) (QTY,XB) (B) (RSD) */

/*     IN ANY GROUP THE VALUE RETURNED IN THE ARRAY ALLOCATED TO */
/*     THE GROUP CORRESPONDS TO THE LAST MEMBER OF THE GROUP. */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB. */

/*     CQRSL USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS. */

/*     BLAS CAXPY,CCOPY,CDOTC */
/*     FORTRAN ABS,AIMAG,MIN0,MOD,REAL */

/*     INTERNAL VARIABLES */



/*     SET INFO FLAG. */

    /* Parameter adjustments */
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    --qraux;
    --y;
    --qy;
    --qty;
    --b;
    --rsd;
    --xb;

    /* Function Body */
    *info = 0;

/*     DETERMINE WHAT IS TO BE COMPUTED. */

    cqy = *job / 10000 != 0;
    cqty = *job % 10000 != 0;
    cb = *job % 1000 / 100 != 0;
    cr = *job % 100 / 10 != 0;
    cxb = *job % 10 != 0;
/* Computing MIN */
    i__1 = *k, i__2 = *n - 1;
    ju = min(i__1,i__2);

/*     SPECIAL ACTION WHEN N=1. */

    if (ju != 0) {
	goto L4;
    }
    if (cqy) {
	qy[1].r = y[1].r, qy[1].i = y[1].i;
    }
    if (cqty) {
	qty[1].r = y[1].r, qty[1].i = y[1].i;
    }
    if (cxb) {
	xb[1].r = y[1].r, xb[1].i = y[1].i;
    }
    if (! cb) {
	goto L3;
    }
    i__1 = x_dim1 + 1;
    if ((d__1 = x[i__1].r, abs(d__1)) + (d__2 = d_imag(&x[x_dim1 + 1]), abs(
	    d__2)) != 0.f) {
	goto L1;
    }
    *info = 1;
    goto L2;
L1:
    z_div(&z__1, &y[1], &x[x_dim1 + 1]);
    b[1].r = z__1.r, b[1].i = z__1.i;
L2:
L3:
    if (cr) {
	rsd[1].r = 0.f, rsd[1].i = 0.f;
    }
    goto L25;
L4:

/*        SET UP TO COMPUTE QY OR QTY. */

    if (cqy) {
	ccopy_(n, &y[1], &c__1, &qy[1], &c__1);
    }
    if (cqty) {
	ccopy_(n, &y[1], &c__1, &qty[1], &c__1);
    }
    if (! cqy) {
	goto L7;
    }

/*           COMPUTE QY. */

    i__1 = ju;
    for (jj = 1; jj <= i__1; ++jj) {
	j = ju - jj + 1;
	i__2 = j;
	if ((d__1 = qraux[i__2].r, abs(d__1)) + (d__2 = d_imag(&qraux[j]), 
		abs(d__2)) == 0.f) {
	    goto L5;
	}
	i__2 = j + j * x_dim1;
	temp.r = x[i__2].r, temp.i = x[i__2].i;
	i__2 = j + j * x_dim1;
	i__3 = j;
	x[i__2].r = qraux[i__3].r, x[i__2].i = qraux[i__3].i;
	i__2 = *n - j + 1;
	cdotc_(&z__3, &i__2, &x[j + j * x_dim1], &c__1, &qy[j], &c__1);
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &x[j + j * x_dim1]);
	t.r = z__1.r, t.i = z__1.i;
	i__2 = *n - j + 1;
	caxpy_(&i__2, &t, &x[j + j * x_dim1], &c__1, &qy[j], &c__1);
	i__2 = j + j * x_dim1;
	x[i__2].r = temp.r, x[i__2].i = temp.i;
L5:
/* L6: */
	;
    }
L7:
    if (! cqty) {
	goto L10;
    }

/*           COMPUTE CTRANS(Q)*Y. */

    i__1 = ju;
    for (j = 1; j <= i__1; ++j) {
	i__2 = j;
	if ((d__1 = qraux[i__2].r, abs(d__1)) + (d__2 = d_imag(&qraux[j]), 
		abs(d__2)) == 0.f) {
	    goto L8;
	}
	i__2 = j + j * x_dim1;
	temp.r = x[i__2].r, temp.i = x[i__2].i;
	i__2 = j + j * x_dim1;
	i__3 = j;
	x[i__2].r = qraux[i__3].r, x[i__2].i = qraux[i__3].i;
	i__2 = *n - j + 1;
	cdotc_(&z__3, &i__2, &x[j + j * x_dim1], &c__1, &qty[j], &c__1);
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &x[j + j * x_dim1]);
	t.r = z__1.r, t.i = z__1.i;
	i__2 = *n - j + 1;
	caxpy_(&i__2, &t, &x[j + j * x_dim1], &c__1, &qty[j], &c__1);
	i__2 = j + j * x_dim1;
	x[i__2].r = temp.r, x[i__2].i = temp.i;
L8:
/* L9: */
	;
    }
L10:

/*        SET UP TO COMPUTE B, RSD, OR XB. */

    if (cb) {
	ccopy_(k, &qty[1], &c__1, &b[1], &c__1);
    }
    kp1 = *k + 1;
    if (cxb) {
	ccopy_(k, &qty[1], &c__1, &xb[1], &c__1);
    }
    if (cr && *k < *n) {
	i__1 = *n - *k;
	ccopy_(&i__1, &qty[kp1], &c__1, &rsd[kp1], &c__1);
    }
    if (! cxb || kp1 > *n) {
	goto L12;
    }
    i__1 = *n;
    for (i__ = kp1; i__ <= i__1; ++i__) {
	i__2 = i__;
	xb[i__2].r = 0.f, xb[i__2].i = 0.f;
/* L11: */
    }
L12:
    if (! cr) {
	goto L14;
    }
    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__;
	rsd[i__2].r = 0.f, rsd[i__2].i = 0.f;
/* L13: */
    }
L14:
    if (! cb) {
	goto L19;
    }

/*           COMPUTE B. */

    i__1 = *k;
    for (jj = 1; jj <= i__1; ++jj) {
	j = *k - jj + 1;
	i__2 = j + j * x_dim1;
	if ((d__1 = x[i__2].r, abs(d__1)) + (d__2 = d_imag(&x[j + j * x_dim1])
		, abs(d__2)) != 0.f) {
	    goto L15;
	}
	*info = j;
/*           ......EXIT */
	goto L18;
L15:
	i__2 = j;
	z_div(&z__1, &b[j], &x[j + j * x_dim1]);
	b[i__2].r = z__1.r, b[i__2].i = z__1.i;
	if (j == 1) {
	    goto L16;
	}
	i__2 = j;
	z__1.r = -b[i__2].r, z__1.i = -b[i__2].i;
	t.r = z__1.r, t.i = z__1.i;
	i__2 = j - 1;
	caxpy_(&i__2, &t, &x[j * x_dim1 + 1], &c__1, &b[1], &c__1);
L16:
/* L17: */
	;
    }
L18:
L19:
    if (! cr && ! cxb) {
	goto L24;
    }

/*           COMPUTE RSD OR XB AS REQUIRED. */

    i__1 = ju;
    for (jj = 1; jj <= i__1; ++jj) {
	j = ju - jj + 1;
	i__2 = j;
	if ((d__1 = qraux[i__2].r, abs(d__1)) + (d__2 = d_imag(&qraux[j]), 
		abs(d__2)) == 0.f) {
	    goto L22;
	}
	i__2 = j + j * x_dim1;
	temp.r = x[i__2].r, temp.i = x[i__2].i;
	i__2 = j + j * x_dim1;
	i__3 = j;
	x[i__2].r = qraux[i__3].r, x[i__2].i = qraux[i__3].i;
	if (! cr) {
	    goto L20;
	}
	i__2 = *n - j + 1;
	cdotc_(&z__3, &i__2, &x[j + j * x_dim1], &c__1, &rsd[j], &c__1);
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &x[j + j * x_dim1]);
	t.r = z__1.r, t.i = z__1.i;
	i__2 = *n - j + 1;
	caxpy_(&i__2, &t, &x[j + j * x_dim1], &c__1, &rsd[j], &c__1);
L20:
	if (! cxb) {
	    goto L21;
	}
	i__2 = *n - j + 1;
	cdotc_(&z__3, &i__2, &x[j + j * x_dim1], &c__1, &xb[j], &c__1);
	z__2.r = -z__3.r, z__2.i = -z__3.i;
	z_div(&z__1, &z__2, &x[j + j * x_dim1]);
	t.r = z__1.r, t.i = z__1.i;
	i__2 = *n - j + 1;
	caxpy_(&i__2, &t, &x[j + j * x_dim1], &c__1, &xb[j], &c__1);
L21:
	i__2 = j + j * x_dim1;
	x[i__2].r = temp.r, x[i__2].i = temp.i;
L22:
/* L23: */
	;
    }
L24:
L25:
    return 0;
} /* cqrsl_ */

/* Subroutine */ int cscal_(integer *n, doublecomplex *ca, doublecomplex *cx, 
	integer *incx)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, ns;

/*  ***BEGIN PROLOGUE  CSCAL */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A, M2 */
/*     KEYWORDS  COMPLEX,BLAS,VECTOR,SCALE */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     COMPLEX VECTOR SCALE X = A*X */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CA  COMPLEX SCALE FACTOR */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */

/*     --OUTPUT-- */
/*     CSCAL  COMPLEX RESULT (UNCHANGED IF N.LE.0) */

/*     REPLACE COMPLEX CX BY COMPLEX CA*CX. */
/*     FOR I = 0 TO N-1, REPLACE CX(1+I*INCX) WITH  CA * CX(1+I*INCX) */


/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED  (NONE) */
/*  ***END PROLOGUE  CSCAL */
/*     FIRST EXECUTABLE STATEMENT  CSCAL */
    /* Parameter adjustments */
    --cx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    ns = *n * *incx;
    i__1 = ns;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	i__3 = i__;
	i__4 = i__;
	z__1.r = ca->r * cx[i__4].r - ca->i * cx[i__4].i, z__1.i = ca->r * cx[
		i__4].i + ca->i * cx[i__4].r;
	cx[i__3].r = z__1.r, cx[i__3].i = z__1.i;
/* L1: */
    }
    return 0;
} /* cscal_ */

/* Subroutine */ int cswap_(integer *n, doublecomplex *cx, integer *incx, 
	doublecomplex *cy, integer *incy)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, ns, kx, ky;
    static doublecomplex ctemp;

/*  ***BEGIN PROLOGUE  CSWAP */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A */
/*     KEYWORDS  COMPLEX,BLAS,VECTOR,INTERCHANGE */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     INTERCHANGE COMPLEX VECTORS */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */
/*       CY  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCY  STORAGE SPACING BETWEEN ELEMENTS OF CY */

/*     --OUTPUT-- */
/*       CX  INPUT VECTOR CY (UNCHANGED IF N.LE.0) */
/*       CY  INPUT VECTOR CX (UNCHANGED IF N.LE.0) */

/*     INTERCHANGE COMPLEX CX AND COMPLEX CY */
/*     FOR I = 0 TO N-1, INTERCHANGE  CX(LX+I*INCX) AND CY(LY+I*INCY), */
/*     WHERE LX = 1 IF INCX .GT. 0, ELSE LX = (-INCX)*N, AND LY IS */
/*     DEFINED IN A SIMILAR WAY USING INCY. */


/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED  (NONE) */
/*  ***END PROLOGUE  CSWAP */
/*     FIRST EXECUTABLE STATEMENT  CSWAP */
    /* Parameter adjustments */
    --cy;
    --cx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*incx == *incy && *incx > 0) {
	goto L2;
    }
    kx = 1;
    ky = 1;
    if (*incx < 0) {
	kx = (1 - *n) * *incx + 1;
    }
    if (*incy < 0) {
	ky = (1 - *n) * *incy + 1;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = kx;
	ctemp.r = cx[i__2].r, ctemp.i = cx[i__2].i;
	i__2 = kx;
	i__3 = ky;
	cx[i__2].r = cy[i__3].r, cx[i__2].i = cy[i__3].i;
	i__2 = ky;
	cy[i__2].r = ctemp.r, cy[i__2].i = ctemp.i;
	kx += *incx;
	ky += *incy;
/* L1: */
    }
    return 0;
L2:
    ns = *n * *incx;
    i__1 = ns;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	i__3 = i__;
	ctemp.r = cx[i__3].r, ctemp.i = cx[i__3].i;
	i__3 = i__;
	i__4 = i__;
	cx[i__3].r = cy[i__4].r, cx[i__3].i = cy[i__4].i;
	i__3 = i__;
	cy[i__3].r = ctemp.r, cy[i__3].i = ctemp.i;
/* L3: */
    }
    return 0;
} /* cswap_ */

/* Subroutine */ int evlub_(doublereal *rhox, doublereal *zzx, doublereal *
	zpx, integer *iqax, doublecomplex *erv, doublecomplex *ezv, 
	doublecomplex *erh, doublecomplex *eph, doublecomplex *ezh)
{
    /* Initialized data */

    static doublereal ck1r = 0.;
    static doublereal ck1i = 0.;
    static doublereal ck2r = 0.;
    static doublereal ck2i = 0.;
    static doublereal ptp = 1.5707;
    static doublereal acc = 1e-5;

    /* Format strings */
    static char fmt_23[] = "(\002 EVLUB: ERROR - RHO, ZZ, ZP, IQAX =\002,1p3"
	    "e12.5,i5)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11;

    /* Builtin functions */
    double d_imag(doublecomplex *), sqrt(doublereal);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double log(doublereal), z_abs(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void z_sqrt(doublecomplex *, doublecomplex *), d_cnjg(doublecomplex *, 
	    doublecomplex *), z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__;
    static doublereal r__;
    static doublecomplex d12, bk, fj, cp1, cp2, cp3, rf1, rf2;
    static doublereal sf1, sf2, sf3, del, cth;
    static doublecomplex xjk;
    static doublereal xli, dzs, xln, sth;
    static doublecomplex sum[6];
    static doublereal zmp, rsq;
    extern /* Subroutine */ int rom1_(integer *, doublecomplex *, doublereal *
	    , integer *, integer *);
    static doublereal aad12, sfac, dmis;
    static doublecomplex exjk, sdir;
    static doublereal rmis, zpsq, bmax1, bmax2, aloga;
    static doublecomplex ckdsq;
    static integer icyes;

    /* Fortran I/O blocks */
    static cilist io___2926 = { 0, 3, 0, fmt_23, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOMMERFELD INTEGRAL EVALUATION FOR E FIELD ACROSS INTERFACE. */
/*     EVALUA CONTROLS THE INTEGRATION CONTOUR IN THE COMPLEX LAMBDA */
/*     PLANE. */

    if (evlcom_2.ck1.r != ck1r || d_imag(&evlcom_2.ck1) != ck1i) {
	goto L1;
    }
    if (evlcom_2.ck2.r != ck2r || d_imag(&evlcom_2.ck2) != ck2i) {
	goto L1;
    }
    goto L4;
/*     SET CONSTANTS THAT DEPEND ON CK1 AND CK2 ONLY. */
L1:
    ck1r = evlcom_2.ck1.r;
    ck1i = d_imag(&evlcom_2.ck1);
    ck2r = evlcom_2.ck2.r;
    ck2i = d_imag(&evlcom_2.ck2);
    if (ck2r < ck1r) {
	goto L2;
    }
    evlcom_2.ckar = ck1r;
    evlcom_2.ckai = ck1i;
    evlcom_2.ckbr = ck2r;
    evlcom_2.ckbi = ck2i;
    goto L3;
L2:
    evlcom_2.ckar = ck2r;
    evlcom_2.ckai = ck2i;
    evlcom_2.ckbr = ck1r;
    evlcom_2.ckbi = ck1i;
L3:
    del = evlcom_2.ckbr * 1.01f;
    if (del < evlcom_2.ckar * 1.2f) {
	del = evlcom_2.ckar * 1.2f;
    }
    d__1 = evlcom_2.ckbi * .95f;
    z__1.r = del, z__1.i = d__1;
    cp3.r = z__1.r, cp3.i = z__1.i;
    z__1.r = evlcom_2.ck1.r * evlcom_2.ck1.r - evlcom_2.ck1.i * 
	    evlcom_2.ck1.i, z__1.i = evlcom_2.ck1.r * evlcom_2.ck1.i + 
	    evlcom_2.ck1.i * evlcom_2.ck1.r;
    evlcom_2.ck1sq.r = z__1.r, evlcom_2.ck1sq.i = z__1.i;
    z__1.r = evlcom_2.ck2.r * evlcom_2.ck2.r - evlcom_2.ck2.i * 
	    evlcom_2.ck2.i, z__1.i = evlcom_2.ck2.r * evlcom_2.ck2.i + 
	    evlcom_2.ck2.i * evlcom_2.ck2.r;
    evlcom_2.ck2sq.r = z__1.r, evlcom_2.ck2sq.i = z__1.i;
    evlcom_2.tsmag = (evlcom_2.ckbr * evlcom_2.ckbr + evlcom_2.ckbi * 
	    evlcom_2.ckbi) * 100.f;
    evlcom_2.tkmag = sqrt(evlcom_2.ckbr * evlcom_2.ckbr + evlcom_2.ckbi * 
	    evlcom_2.ckbi) * 100.f;
    z__1.r = evlcom_2.ck1sq.r + evlcom_2.ck2sq.r, z__1.i = evlcom_2.ck1sq.i + 
	    evlcom_2.ck2sq.i;
    evlcom_2.cksm.r = z__1.r, evlcom_2.cksm.i = z__1.i;
    z__2.r = evlcom_2.ck1sq.r - evlcom_2.ck2sq.r, z__2.i = evlcom_2.ck1sq.i - 
	    evlcom_2.ck2sq.i;
    z_div(&z__1, &z__2, &evlcom_2.cksm);
    evlcom_2.con2.r = z__1.r, evlcom_2.con2.i = z__1.i;
    z__2.r = evlcom_2.ck2sq.r * evlcom_2.con2.r - evlcom_2.ck2sq.i * 
	    evlcom_2.con2.i, z__2.i = evlcom_2.ck2sq.r * evlcom_2.con2.i + 
	    evlcom_2.ck2sq.i * evlcom_2.con2.r;
    z_div(&z__1, &z__2, &evlcom_2.cksm);
    evlcom_2.con3.r = z__1.r, evlcom_2.con3.i = z__1.i;
    aloga = -log(acc);
/*     SET CONSTANTS THAT DEPEND ON RHO, ZZ, AND ZP. */
L4:
    evlcom_2.rho = *rhox;
    evlcom_2.zz = *zzx;
    evlcom_2.zp = *zpx;
    zmp = evlcom_2.zz - evlcom_2.zp;
    r__ = sqrt(evlcom_2.rho * evlcom_2.rho + zmp * zmp);
    fj.r = 0.f, fj.i = 1.f;
    cntour_1.bael = 0.f;
    for (i__ = 1; i__ <= 6; ++i__) {
/* L5: */
	i__1 = i__ - 1;
	sum[i__1].r = 0.f, sum[i__1].i = 0.f;
    }
    evlcom_2.iqaz = *iqax;
    if (*iqax == 0) {
	goto L6;
    }
    if (r__ * z_abs(&evlcom_2.ck2) > 6.283185f) {
	evlcom_2.iqaz = 0;
    }
    if (r__ * evlcom_2.ckbr < 1e-5f) {
	goto L22;
    }
    if (evlcom_2.iqaz == 0) {
	goto L6;
    }
    zpsq = evlcom_2.zp * evlcom_2.zp;
    z__1.r = evlcom_2.ck2sq.r - evlcom_2.ck1sq.r, z__1.i = evlcom_2.ck2sq.i - 
	    evlcom_2.ck1sq.i;
    srgam_1.c1.r = z__1.r, srgam_1.c1.i = z__1.i;
    z__1.r = srgam_1.c1.r * srgam_1.c1.r - srgam_1.c1.i * srgam_1.c1.i, 
	    z__1.i = srgam_1.c1.r * srgam_1.c1.i + srgam_1.c1.i * 
	    srgam_1.c1.r;
    srgam_1.c2.r = z__1.r, srgam_1.c2.i = z__1.i;
    z__2.r = evlcom_2.ck2sq.r * evlcom_2.ck2sq.r - evlcom_2.ck2sq.i * 
	    evlcom_2.ck2sq.i, z__2.i = evlcom_2.ck2sq.r * evlcom_2.ck2sq.i + 
	    evlcom_2.ck2sq.i * evlcom_2.ck2sq.r;
    z__3.r = evlcom_2.ck1sq.r * evlcom_2.ck1sq.r - evlcom_2.ck1sq.i * 
	    evlcom_2.ck1sq.i, z__3.i = evlcom_2.ck1sq.r * evlcom_2.ck1sq.i + 
	    evlcom_2.ck1sq.i * evlcom_2.ck1sq.r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    srgam_1.c3.r = z__1.r, srgam_1.c3.i = z__1.i;
    z__3.r = evlcom_2.ck2sq.r * evlcom_2.ck2sq.r - evlcom_2.ck2sq.i * 
	    evlcom_2.ck2sq.i, z__3.i = evlcom_2.ck2sq.r * evlcom_2.ck2sq.i + 
	    evlcom_2.ck2sq.i * evlcom_2.ck2sq.r;
    z__2.r = z__3.r * evlcom_2.ck2sq.r - z__3.i * evlcom_2.ck2sq.i, z__2.i = 
	    z__3.r * evlcom_2.ck2sq.i + z__3.i * evlcom_2.ck2sq.r;
    z__5.r = evlcom_2.ck1sq.r * evlcom_2.ck1sq.r - evlcom_2.ck1sq.i * 
	    evlcom_2.ck1sq.i, z__5.i = evlcom_2.ck1sq.r * evlcom_2.ck1sq.i + 
	    evlcom_2.ck1sq.i * evlcom_2.ck1sq.r;
    z__4.r = z__5.r * evlcom_2.ck1sq.r - z__5.i * evlcom_2.ck1sq.i, z__4.i = 
	    z__5.r * evlcom_2.ck1sq.i + z__5.i * evlcom_2.ck1sq.r;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    srgam_1.c4.r = z__1.r, srgam_1.c4.i = z__1.i;
    z__2.r = evlcom_2.zp * srgam_1.c1.r, z__2.i = evlcom_2.zp * srgam_1.c1.i;
    z__1.r = z__2.r / 2.f, z__1.i = z__2.i / 2.f;
    srgam_1.a1.r = z__1.r, srgam_1.a1.i = z__1.i;
    z__2.r = zpsq * srgam_1.c2.r, z__2.i = zpsq * srgam_1.c2.i;
    z__1.r = z__2.r / 8.f, z__1.i = z__2.i / 8.f;
    srgam_1.a2.r = z__1.r, srgam_1.a2.i = z__1.i;
    z__6.r = zpsq * srgam_1.c2.r, z__6.i = zpsq * srgam_1.c2.i;
    z__5.r = z__6.r * srgam_1.c1.r - z__6.i * srgam_1.c1.i, z__5.i = z__6.r * 
	    srgam_1.c1.i + z__6.i * srgam_1.c1.r;
    z__4.r = z__5.r / 6.f, z__4.i = z__5.i / 6.f;
    z__3.r = srgam_1.c3.r + z__4.r, z__3.i = srgam_1.c3.i + z__4.i;
    z__2.r = evlcom_2.zp * z__3.r, z__2.i = evlcom_2.zp * z__3.i;
    z__1.r = z__2.r / 8.f, z__1.i = z__2.i / 8.f;
    srgam_1.a3.r = z__1.r, srgam_1.a3.i = z__1.i;
    z__4.r = srgam_1.c1.r * srgam_1.c3.r - srgam_1.c1.i * srgam_1.c3.i, 
	    z__4.i = srgam_1.c1.r * srgam_1.c3.i + srgam_1.c1.i * 
	    srgam_1.c3.r;
    z__7.r = zpsq * srgam_1.c2.r, z__7.i = zpsq * srgam_1.c2.i;
    z__6.r = z__7.r * srgam_1.c2.r - z__7.i * srgam_1.c2.i, z__6.i = z__7.r * 
	    srgam_1.c2.i + z__7.i * srgam_1.c2.r;
    z__5.r = z__6.r / 24.f, z__5.i = z__6.i / 24.f;
    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
    z__2.r = zpsq * z__3.r, z__2.i = zpsq * z__3.i;
    z__1.r = z__2.r / 16.f, z__1.i = z__2.i / 16.f;
    srgam_1.a4.r = z__1.r, srgam_1.a4.i = z__1.i;
    z__7.r = zpsq * srgam_1.c2.r, z__7.i = zpsq * srgam_1.c2.i;
    z__6.r = z__7.r * srgam_1.c3.r - z__7.i * srgam_1.c3.i, z__6.i = z__7.r * 
	    srgam_1.c3.i + z__7.i * srgam_1.c3.r;
    z__5.r = z__6.r / 4.f, z__5.i = z__6.i / 4.f;
    z__4.r = srgam_1.c4.r + z__5.r, z__4.i = srgam_1.c4.i + z__5.i;
    d__1 = zpsq * zpsq;
    z__11.r = d__1 * srgam_1.c2.r, z__11.i = d__1 * srgam_1.c2.i;
    z__10.r = z__11.r * srgam_1.c2.r - z__11.i * srgam_1.c2.i, z__10.i = 
	    z__11.r * srgam_1.c2.i + z__11.i * srgam_1.c2.r;
    z__9.r = z__10.r * srgam_1.c1.r - z__10.i * srgam_1.c1.i, z__9.i = 
	    z__10.r * srgam_1.c1.i + z__10.i * srgam_1.c1.r;
    z__8.r = z__9.r / 240.f, z__8.i = z__9.i / 240.f;
    z__3.r = z__4.r + z__8.r, z__3.i = z__4.i + z__8.i;
    z__2.r = evlcom_2.zp * z__3.r, z__2.i = evlcom_2.zp * z__3.i;
    z__1.r = z__2.r / 16.f, z__1.i = z__2.i / 16.f;
    srgam_1.a5.r = z__1.r, srgam_1.a5.i = z__1.i;
    z__3.r = -srgam_1.c4.r, z__3.i = -srgam_1.c4.i;
    z__2.r = z__3.r / 16.f, z__2.i = z__3.i / 16.f;
    z__8.r = srgam_1.a2.r * evlcom_2.ck2sq.r - srgam_1.a2.i * 
	    evlcom_2.ck2sq.i, z__8.i = srgam_1.a2.r * evlcom_2.ck2sq.i + 
	    srgam_1.a2.i * evlcom_2.ck2sq.r;
    z__7.r = z__8.r / 4.f, z__7.i = z__8.i / 4.f;
    z__6.r = z__7.r + srgam_1.a4.r, z__6.i = z__7.i + srgam_1.a4.i;
    z__5.r = z__6.r * evlcom_2.ck2sq.r - z__6.i * evlcom_2.ck2sq.i, z__5.i = 
	    z__6.r * evlcom_2.ck2sq.i + z__6.i * evlcom_2.ck2sq.r;
    z__4.r = z__5.r / 2.f, z__4.i = z__5.i / 2.f;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    srgam_1.b5.r = z__1.r, srgam_1.b5.i = z__1.i;
    z__6.r = srgam_1.a1.r * evlcom_2.ck2sq.r - srgam_1.a1.i * 
	    evlcom_2.ck2sq.i, z__6.i = srgam_1.a1.r * evlcom_2.ck2sq.i + 
	    srgam_1.a1.i * evlcom_2.ck2sq.r;
    z__5.r = z__6.r / 4.f, z__5.i = z__6.i / 4.f;
    z__4.r = z__5.r + srgam_1.a3.r, z__4.i = z__5.i + srgam_1.a3.i;
    z__3.r = z__4.r * evlcom_2.ck2sq.r - z__4.i * evlcom_2.ck2sq.i, z__3.i = 
	    z__4.r * evlcom_2.ck2sq.i + z__4.i * evlcom_2.ck2sq.r;
    z__2.r = z__3.r / 2.f, z__2.i = z__3.i / 2.f;
    z__1.r = srgam_1.a5.r - z__2.r, z__1.i = srgam_1.a5.i - z__2.i;
    srgam_1.b4.r = z__1.r, srgam_1.b4.i = z__1.i;
    z__4.r = -srgam_1.c3.r, z__4.i = -srgam_1.c3.i;
    z__3.r = z__4.r / 8.f, z__3.i = z__4.i / 8.f;
    z__6.r = srgam_1.a2.r * evlcom_2.ck2sq.r - srgam_1.a2.i * 
	    evlcom_2.ck2sq.i, z__6.i = srgam_1.a2.r * evlcom_2.ck2sq.i + 
	    srgam_1.a2.i * evlcom_2.ck2sq.r;
    z__5.r = z__6.r / 2.f, z__5.i = z__6.i / 2.f;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    z__1.r = z__2.r + srgam_1.a4.r, z__1.i = z__2.i + srgam_1.a4.i;
    srgam_1.b3.r = z__1.r, srgam_1.b3.i = z__1.i;
    z__3.r = srgam_1.a1.r * evlcom_2.ck2sq.r - srgam_1.a1.i * 
	    evlcom_2.ck2sq.i, z__3.i = srgam_1.a1.r * evlcom_2.ck2sq.i + 
	    srgam_1.a1.i * evlcom_2.ck2sq.r;
    z__2.r = z__3.r / 2.f, z__2.i = z__3.i / 2.f;
    z__1.r = srgam_1.a3.r - z__2.r, z__1.i = srgam_1.a3.i - z__2.i;
    srgam_1.b2.r = z__1.r, srgam_1.b2.i = z__1.i;
    z__3.r = -srgam_1.c1.r, z__3.i = -srgam_1.c1.i;
    z__2.r = z__3.r / 2.f, z__2.i = z__3.i / 2.f;
    z__1.r = z__2.r + srgam_1.a2.r, z__1.i = z__2.i + srgam_1.a2.i;
    srgam_1.b1.r = z__1.r, srgam_1.b1.i = z__1.i;
    z__2.r = srgam_1.c4.r / 16.f, z__2.i = srgam_1.c4.i / 16.f;
    z__7.r = srgam_1.a2.r * evlcom_2.ck1sq.r - srgam_1.a2.i * 
	    evlcom_2.ck1sq.i, z__7.i = srgam_1.a2.r * evlcom_2.ck1sq.i + 
	    srgam_1.a2.i * evlcom_2.ck1sq.r;
    z__6.r = z__7.r / 4.f, z__6.i = z__7.i / 4.f;
    z__5.r = z__6.r + srgam_1.a4.r, z__5.i = z__6.i + srgam_1.a4.i;
    z__4.r = z__5.r * evlcom_2.ck1sq.r - z__5.i * evlcom_2.ck1sq.i, z__4.i = 
	    z__5.r * evlcom_2.ck1sq.i + z__5.i * evlcom_2.ck1sq.r;
    z__3.r = z__4.r / 2.f, z__3.i = z__4.i / 2.f;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    srgam_1.c5.r = z__1.r, srgam_1.c5.i = z__1.i;
    z__6.r = srgam_1.a1.r * evlcom_2.ck1sq.r - srgam_1.a1.i * 
	    evlcom_2.ck1sq.i, z__6.i = srgam_1.a1.r * evlcom_2.ck1sq.i + 
	    srgam_1.a1.i * evlcom_2.ck1sq.r;
    z__5.r = z__6.r / 4.f, z__5.i = z__6.i / 4.f;
    z__4.r = z__5.r + srgam_1.a3.r, z__4.i = z__5.i + srgam_1.a3.i;
    z__3.r = z__4.r * evlcom_2.ck1sq.r - z__4.i * evlcom_2.ck1sq.i, z__3.i = 
	    z__4.r * evlcom_2.ck1sq.i + z__4.i * evlcom_2.ck1sq.r;
    z__2.r = z__3.r / 2.f, z__2.i = z__3.i / 2.f;
    z__1.r = srgam_1.a5.r - z__2.r, z__1.i = srgam_1.a5.i - z__2.i;
    srgam_1.c4.r = z__1.r, srgam_1.c4.i = z__1.i;
    z__3.r = srgam_1.c3.r / 8.f, z__3.i = srgam_1.c3.i / 8.f;
    z__5.r = srgam_1.a2.r * evlcom_2.ck1sq.r - srgam_1.a2.i * 
	    evlcom_2.ck1sq.i, z__5.i = srgam_1.a2.r * evlcom_2.ck1sq.i + 
	    srgam_1.a2.i * evlcom_2.ck1sq.r;
    z__4.r = z__5.r / 2.f, z__4.i = z__5.i / 2.f;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z__1.r = z__2.r + srgam_1.a4.r, z__1.i = z__2.i + srgam_1.a4.i;
    srgam_1.c3.r = z__1.r, srgam_1.c3.i = z__1.i;
    z__3.r = srgam_1.a1.r * evlcom_2.ck1sq.r - srgam_1.a1.i * 
	    evlcom_2.ck1sq.i, z__3.i = srgam_1.a1.r * evlcom_2.ck1sq.i + 
	    srgam_1.a1.i * evlcom_2.ck1sq.r;
    z__2.r = z__3.r / 2.f, z__2.i = z__3.i / 2.f;
    z__1.r = srgam_1.a3.r - z__2.r, z__1.i = srgam_1.a3.i - z__2.i;
    srgam_1.c2.r = z__1.r, srgam_1.c2.i = z__1.i;
    z__2.r = srgam_1.c1.r / 2.f, z__2.i = srgam_1.c1.i / 2.f;
    z__1.r = z__2.r + srgam_1.a2.r, z__1.i = z__2.i + srgam_1.a2.i;
    srgam_1.c1.r = z__1.r, srgam_1.c1.i = z__1.i;
L6:
    del = zmp;
    if (evlcom_2.rho > del) {
	del = evlcom_2.rho;
    }
    if (evlcom_2.zz < 0.f || evlcom_2.zp > 0.f) {
	s_wsfe(&io___2926);
	do_fio(&c__1, (char *)&(*rhox), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*zzx), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*zpx), (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&(*iqax), (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    if (zmp < evlcom_2.rho * .5f) {
	goto L10;
    }

/*     BESSEL FUNCTION FORM OF SOMMERFELD INTEGRALS */

    evlcom_2.jh = 0;
    cntour_1.a.r = 0.f, cntour_1.a.i = 0.f;
    del = 1.f / del;
    if (del <= evlcom_2.tkmag) {
	goto L8;
    }
    d__1 = evlcom_2.tkmag * .1f;
    d__2 = evlcom_2.tkmag * -.1f;
    z__1.r = d__1, z__1.i = d__2;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    rom1_(&c__6, sum, &c_b3178, &c__0, &icyes);
    cntour_1.a.r = cntour_1.b.r, cntour_1.a.i = cntour_1.b.i;
    d__1 = -del;
    z__1.r = del, z__1.i = d__1;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    rom1_(&c__6, sum, &c_b3178, &c__0, &icyes);
    goto L9;
L8:
    d__1 = -del;
    z__1.r = del, z__1.i = d__1;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    rom1_(&c__6, sum, &c_b3178, &c__0, &icyes);
L9:
    cntour_1.a.r = cntour_1.b.r, cntour_1.a.i = cntour_1.b.i;
    if (evlcom_2.zz > 1e-10f) {
	bmax1 = ck2r + aloga / evlcom_2.zz;
    } else {
	bmax1 = 1e10f;
    }
    if (abs(evlcom_2.zp) > 1e-10f) {
	bmax2 = ck1r + aloga / abs(evlcom_2.zp);
    } else {
	bmax2 = 1e10f;
    }
    if (bmax1 > bmax2) {
	bmax1 = bmax2;
    }
    d__1 = d_imag(&cntour_1.a);
    z__1.r = bmax1, z__1.i = d__1;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = ptp * del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    goto L18;

/*     HANKEL FUNCTION FORM OF SOMMERFELD INTEGRALS */

L10:
    evlcom_2.jh = 1;
    rmis = .06f / r__ + .04f;
    dmis = .8f / (zmp / evlcom_2.rho + 1.f);
    if (rmis > dmis) {
	rmis = dmis;
    }
    rmis *= evlcom_2.ckar;
    dmis = evlcom_2.ckar + rmis;
    if (dmis > evlcom_2.ckbr) {
	dmis = (evlcom_2.ckar + evlcom_2.ckbr) * .5f;
    }
    d__1 = evlcom_2.ckar - rmis;
    d__2 = evlcom_2.ckai - rmis;
    z__1.r = d__1, z__1.i = d__2;
    cp1.r = z__1.r, cp1.i = z__1.i;
    d__1 = evlcom_2.ckai - rmis;
    z__1.r = dmis, z__1.i = d__1;
    cp2.r = z__1.r, cp2.i = z__1.i;
    xli = aloga / evlcom_2.rho;
    z__2.r = zmp, z__2.i = evlcom_2.rho;
    d__1 = sqrt(evlcom_2.rho * evlcom_2.rho + zmp * zmp);
    z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
    sdir.r = z__1.r, sdir.i = z__1.i;
    del = ptp / del;
    if (del > evlcom_2.ckar) {
	del = evlcom_2.ckar;
    }
    z__2.r = evlcom_2.ck1sq.r - evlcom_2.ck2sq.r, z__2.i = evlcom_2.ck1sq.i - 
	    evlcom_2.ck2sq.i;
    z_sqrt(&z__1, &z__2);
    ckdsq.r = z__1.r, ckdsq.i = z__1.i;
    d__1 = -evlcom_2.zp;
    z__3.r = evlcom_2.zz, z__3.i = d__1;
    z__2.r = ckdsq.r * z__3.r - ckdsq.i * z__3.i, z__2.i = ckdsq.r * z__3.i + 
	    ckdsq.i * z__3.r;
    z__6.r = evlcom_2.ck1.r - evlcom_2.ck2.r, z__6.i = evlcom_2.ck1.i - 
	    evlcom_2.ck2.i;
    z__5.r = fj.r * z__6.r - fj.i * z__6.i, z__5.i = fj.r * z__6.i + fj.i * 
	    z__6.r;
    z__4.r = evlcom_2.rho * z__5.r, z__4.i = evlcom_2.rho * z__5.i;
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    d12.r = z__1.r, d12.i = z__1.i;
    xln = xli - d12.r / evlcom_2.rho;
    aad12 = (d__1 = d_imag(&d12), abs(d__1));
    if (aad12 < 12.57f) {
	goto L14;
    }
    if (evlcom_2.rho < 1e-5f) {
	goto L14;
    }
    if (zmp < 1e-10f) {
	goto L11;
    }
    if (evlcom_2.rho * aad12 < evlcom_2.zz * 4.f * d12.r) {
	goto L14;
    }
    if (xln <= 0.f) {
	goto L11;
    }
    z__4.r = evlcom_2.ck1.r * 0. - evlcom_2.ck1.i * 2., z__4.i = 
	    evlcom_2.ck1.r * 2. + evlcom_2.ck1.i * 0.;
    z_sqrt(&z__3, &z__4);
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__1.r = evlcom_2.zp * z__2.r, z__1.i = evlcom_2.zp * z__2.i;
    cntour_1.a.r = z__1.r, cntour_1.a.i = z__1.i;
    z__4.r = fj.r * evlcom_2.ck1.r - fj.i * evlcom_2.ck1.i, z__4.i = fj.r * 
	    evlcom_2.ck1.i + fj.i * evlcom_2.ck1.r;
    z__3.r = evlcom_2.zz * z__4.r, z__3.i = evlcom_2.zz * z__4.i;
    z_div(&z__2, &z__3, &ckdsq);
    z__1.r = z__2.r + evlcom_2.rho, z__1.i = z__2.i;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__2.r = xln * cntour_1.b.r, z__2.i = xln * cntour_1.b.i;
    d__1 = sqrt(xln);
    z__3.r = d__1 * cntour_1.a.r, z__3.i = d__1 * cntour_1.a.i;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    bk.r = z__1.r, bk.i = z__1.i;
    rmis = (d__1 = d_imag(&bk), abs(d__1)) * 4.f * d12.r;
    if (bk.r * aad12 < rmis) {
	goto L14;
    }
    rmis = cntour_1.a.r;
    if (rmis * rmis > cntour_1.b.r * 4.f) {
	goto L14;
    }
/*     INTEGRATE AROUND CKA BRANCH CUT, THEN ALONG CKB BRANCH CUT. */
L11:
    cntour_1.a.r = cp2.r, cntour_1.a.i = cp2.i;
    d__1 = cntour_1.a.r;
    z__1.r = d__1, z__1.i = xli;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    for (i__ = 1; i__ <= 6; ++i__) {
/* L12: */
	i__1 = i__ - 1;
	i__2 = i__ - 1;
	z__1.r = -sum[i__2].r, z__1.i = -sum[i__2].i;
	sum[i__1].r = z__1.r, sum[i__1].i = z__1.i;
    }
    cntour_1.b.r = cp1.r, cntour_1.b.i = cp1.i;
    rom1_(&c__6, sum, &c_b2760, &c__0, &icyes);
/*     PATH TO -INFINITY */
    d_cnjg(&z__2, &sdir);
    z__1.r = -z__2.r, z__1.i = -z__2.i;
    sdir.r = z__1.r, sdir.i = z__1.i;
    cntour_1.a.r = cp1.r, cntour_1.a.i = cp1.i;
    d__1 = xli - d_imag(&cntour_1.a);
    z__3.r = d__1 * sdir.r, z__3.i = d__1 * sdir.i;
    d__2 = d_imag(&sdir);
    z__2.r = z__3.r / d__2, z__2.i = z__3.i / d__2;
    z__1.r = cntour_1.a.r + z__2.r, z__1.i = cntour_1.a.i + z__2.i;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    for (i__ = 1; i__ <= 6; ++i__) {
/* L13: */
	i__1 = i__ - 1;
	i__2 = i__ - 1;
	z__1.r = -sum[i__2].r, z__1.i = -sum[i__2].i;
	sum[i__1].r = z__1.r, sum[i__1].i = z__1.i;
    }
    if (xln <= 0.f) {
	goto L18;
    }
/*     INTEGRATE CKB BRANCH CUT */
    evlcom_2.jh = 2;
    cntour_1.a.r = 0.f, cntour_1.a.i = 0.f;
    d__1 = sqrt(xln);
    cntour_1.b.r = d__1, cntour_1.b.i = 0.;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = sqrt(del) / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    goto L18;
/*     INTEGRATE BELOW BRANCH POINTS, THEN TO + INFINITY */
L14:
    cntour_1.a.r = cp2.r, cntour_1.a.i = cp2.i;
    cntour_1.b.r = cp3.r, cntour_1.b.i = cp3.i;
    if ((d__1 = d_imag(&cp3), abs(d__1)) > xli) {
	z__4.r = cp3.r - cp2.r, z__4.i = cp3.i - cp2.i;
	z__3.r = xli * z__4.r, z__3.i = xli * z__4.i;
	z__5.r = cp3.r - cp2.r, z__5.i = cp3.i - cp2.i;
	d__2 = d_imag(&z__5);
	z__2.r = z__3.r / d__2, z__2.i = z__3.i / d__2;
	z__1.r = cp2.r + z__2.r, z__1.i = cp2.i + z__2.i;
	cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    }
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    if (icyes == 1) {
	goto L15;
    }
    cntour_1.a.r = cp3.r, cntour_1.a.i = cp3.i;
    d__1 = xln - d_imag(&cntour_1.a) + evlcom_2.ckbi;
    z__3.r = d__1 * sdir.r, z__3.i = d__1 * sdir.i;
    d__2 = d_imag(&sdir);
    z__2.r = z__3.r / d__2, z__2.i = z__3.i / d__2;
    z__1.r = cntour_1.a.r + z__2.r, z__1.i = cntour_1.a.i + z__2.i;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
L15:
    for (i__ = 1; i__ <= 6; ++i__) {
/* L16: */
	i__1 = i__ - 1;
	i__2 = i__ - 1;
	z__1.r = -sum[i__2].r, z__1.i = -sum[i__2].i;
	sum[i__1].r = z__1.r, sum[i__1].i = z__1.i;
    }
    cntour_1.a.r = cp2.r, cntour_1.a.i = cp2.i;
    cntour_1.b.r = cp1.r, cntour_1.b.i = cp1.i;
    rom1_(&c__6, sum, &c_b2760, &c__0, &icyes);
/*     PATH TO -INFINITY */
    d_cnjg(&z__2, &sdir);
    z__1.r = -z__2.r, z__1.i = -z__2.i;
    sdir.r = z__1.r, sdir.i = z__1.i;
    cntour_1.a.r = cp1.r, cntour_1.a.i = cp1.i;
    d__1 = xli - d_imag(&cntour_1.a);
    z__3.r = d__1 * sdir.r, z__3.i = d__1 * sdir.i;
    d__2 = d_imag(&sdir);
    z__2.r = z__3.r / d__2, z__2.i = z__3.i / d__2;
    z__1.r = cntour_1.a.r + z__2.r, z__1.i = cntour_1.a.i + z__2.i;
    cntour_1.b.r = z__1.r, cntour_1.b.i = z__1.i;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dzs = del / z_abs(&z__1);
    rom1_(&c__6, sum, &dzs, &c__1, &icyes);
    for (i__ = 1; i__ <= 6; ++i__) {
/* L17: */
	i__1 = i__ - 1;
	i__2 = i__ - 1;
	z__1.r = -sum[i__2].r, z__1.i = -sum[i__2].i;
	sum[i__1].r = z__1.r, sum[i__1].i = z__1.i;
    }
L18:
    if (*iqax == 0 || evlcom_2.iqaz != 0) {
	goto L19;
    }
/*     SUBTRACT 1./R**2 AND 1./R**3 TERMS WHEN THE SINGULARITY IS TO */
/*     BE REMOVED BUT WAS NOT REMOVED IN THE INTEGRAND. */
    z__1.r = evlcom_2.ck2.r * 0.f - evlcom_2.ck2.i * -1.f, z__1.i = 
	    evlcom_2.ck2.r * -1.f + evlcom_2.ck2.i * 0.f;
    xjk.r = z__1.r, xjk.i = z__1.i;
    rsq = r__ * r__;
    z__5.r = -xjk.r, z__5.i = -xjk.i;
    z__4.r = r__ * z__5.r, z__4.i = r__ * z__5.i;
    z_exp(&z__3, &z__4);
    z__2.r = z__3.r * 2.f, z__2.i = z__3.i * 2.f;
    d__1 = rsq * r__;
    z__7.r = evlcom_2.ck1sq.r + evlcom_2.ck2sq.r, z__7.i = evlcom_2.ck1sq.i + 
	    evlcom_2.ck2sq.i;
    z__6.r = d__1 * z__7.r, z__6.i = d__1 * z__7.i;
    z_div(&z__1, &z__2, &z__6);
    exjk.r = z__1.r, exjk.i = z__1.i;
    d__1 = 3.f / rsq;
    z__4.r = xjk.r * 3.f, z__4.i = xjk.i * 3.f;
    z__3.r = z__4.r / r__, z__3.i = z__4.i / r__;
    z__2.r = d__1 + z__3.r, z__2.i = z__3.i;
    z__1.r = z__2.r - evlcom_2.ck2sq.r, z__1.i = z__2.i - evlcom_2.ck2sq.i;
    rf1.r = z__1.r, rf1.i = z__1.i;
    z__2.r = r__ * xjk.r, z__2.i = r__ * xjk.i;
    z__1.r = z__2.r + 1.f, z__1.i = z__2.i;
    rf2.r = z__1.r, rf2.i = z__1.i;
    d__1 = evlcom_2.rho * zmp;
    z__3.r = d__1 * rf1.r, z__3.i = d__1 * rf1.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = sum[0].r - z__2.r, z__1.i = sum[0].i - z__2.i;
    sum[0].r = z__1.r, sum[0].i = z__1.i;
    d__1 = zmp * zmp;
    z__5.r = d__1 * rf1.r, z__5.i = d__1 * rf1.i;
    z__4.r = z__5.r - rf2.r, z__4.i = z__5.i - rf2.i;
    z__6.r = rsq * evlcom_2.ck2sq.r, z__6.i = rsq * evlcom_2.ck2sq.i;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = sum[1].r - z__2.r, z__1.i = sum[1].i - z__2.i;
    sum[1].r = z__1.r, sum[1].i = z__1.i;
    d__1 = evlcom_2.rho * evlcom_2.rho;
    z__4.r = d__1 * rf1.r, z__4.i = d__1 * rf1.i;
    z__3.r = z__4.r - rf2.r, z__3.i = z__4.i - rf2.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = sum[2].r - z__2.r, z__1.i = sum[2].i - z__2.i;
    sum[2].r = z__1.r, sum[2].i = z__1.i;
    z__2.r = rf2.r * exjk.r - rf2.i * exjk.i, z__2.i = rf2.r * exjk.i + rf2.i 
	    * exjk.r;
    z__1.r = sum[3].r + z__2.r, z__1.i = sum[3].i + z__2.i;
    sum[3].r = z__1.r, sum[3].i = z__1.i;
    d__1 = evlcom_2.rho * zmp;
    z__3.r = d__1 * rf1.r, z__3.i = d__1 * rf1.i;
    z__2.r = z__3.r * exjk.r - z__3.i * exjk.i, z__2.i = z__3.r * exjk.i + 
	    z__3.i * exjk.r;
    z__1.r = sum[4].r + z__2.r, z__1.i = sum[4].i + z__2.i;
    sum[4].r = z__1.r, sum[4].i = z__1.i;
/*     COMBINE TERMS TO OBTAIN (FIELD)*R.  CONJUGATE SINCE NEC USES */
/*     EXP(+JWT). */
L19:
    z__3.r = evlcom_2.con1.r * sum[0].r - evlcom_2.con1.i * sum[0].i, z__3.i =
	     evlcom_2.con1.r * sum[0].i + evlcom_2.con1.i * sum[0].r;
    d_cnjg(&z__2, &z__3);
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__3.r = evlcom_2.con1.r * sum[1].r - evlcom_2.con1.i * sum[1].i, z__3.i =
	     evlcom_2.con1.r * sum[1].i + evlcom_2.con1.i * sum[1].r;
    d_cnjg(&z__2, &z__3);
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    z__4.r = sum[2].r + sum[5].r, z__4.i = sum[2].i + sum[5].i;
    z__3.r = evlcom_2.con1.r * z__4.r - evlcom_2.con1.i * z__4.i, z__3.i = 
	    evlcom_2.con1.r * z__4.i + evlcom_2.con1.i * z__4.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__5.r = sum[3].r + sum[5].r, z__5.i = sum[3].i + sum[5].i;
    z__4.r = evlcom_2.con1.r * z__5.r - evlcom_2.con1.i * z__5.i, z__4.i = 
	    evlcom_2.con1.r * z__5.i + evlcom_2.con1.i * z__5.r;
    d_cnjg(&z__3, &z__4);
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__4.r = evlcom_2.con1.r * sum[4].r - evlcom_2.con1.i * sum[4].i, z__4.i =
	     evlcom_2.con1.r * sum[4].i + evlcom_2.con1.i * sum[4].r;
    d_cnjg(&z__3, &z__4);
    z__2.r = -z__3.r, z__2.i = -z__3.i;
    z__1.r = r__ * z__2.r, z__1.i = r__ * z__2.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    if (*iqax == 0) {
	return 0;
    }
/*     SUBTRACT (1./R TERMS)*R WHEN THE SINGULARITY IS TO BE REMOVED. */
    sth = zmp / r__;
    cth = evlcom_2.rho / r__;
    if (cth < .1f) {
	goto L20;
    }
    sf1 = (1.f - sth) / cth;
    sf2 = sf1 / cth;
    goto L21;
L20:
    sf2 = evlcom_2.rho / zmp;
    sf2 = (1.f - sf2 * .25f * sf2) * .5f / zmp;
    sf1 = evlcom_2.rho * sf2;
    sf2 = r__ * sf2;
L21:
    sf3 = sth - sf2;
    sfac = evlcom_2.zp / r__;
    z__4.r = fj.r * evlcom_2.ck2.r - fj.i * evlcom_2.ck2.i, z__4.i = fj.r * 
	    evlcom_2.ck2.i + fj.i * evlcom_2.ck2.r;
    z__3.r = r__ * z__4.r, z__3.i = r__ * z__4.i;
    z_exp(&z__2, &z__3);
    z__1.r = z__2.r * evlcom_2.con1.r - z__2.i * evlcom_2.con1.i, z__1.i = 
	    z__2.r * evlcom_2.con1.i + z__2.i * evlcom_2.con1.r;
    exjk.r = z__1.r, exjk.i = z__1.i;
    z__5.r = sf1 * evlcom_2.con3.r, z__5.i = sf1 * evlcom_2.con3.i;
    z__7.r = sfac * evlcom_2.con2.r, z__7.i = sfac * evlcom_2.con2.i;
    z__6.r = cth * z__7.r, z__6.i = cth * z__7.i;
    z__4.r = z__5.r - z__6.r, z__4.i = z__5.i - z__6.i;
    z__3.r = exjk.r * z__4.r - exjk.i * z__4.i, z__3.i = exjk.r * z__4.i + 
	    exjk.i * z__4.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = erv->r - z__2.r, z__1.i = erv->i - z__2.i;
    erv->r = z__1.r, erv->i = z__1.i;
    z__6.r = sfac * evlcom_2.con2.r, z__6.i = sfac * evlcom_2.con2.i;
    z__5.r = sth * z__6.r, z__5.i = sth * z__6.i;
    z__4.r = evlcom_2.con3.r - z__5.r, z__4.i = evlcom_2.con3.i - z__5.i;
    z__3.r = exjk.r * z__4.r - exjk.i * z__4.i, z__3.i = exjk.r * z__4.i + 
	    exjk.i * z__4.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = ezv->r - z__2.r, z__1.i = ezv->i - z__2.i;
    ezv->r = z__1.r, ezv->i = z__1.i;
    d__1 = sf2 - 1.f;
    z__6.r = d__1 * evlcom_2.con3.r, z__6.i = d__1 * evlcom_2.con3.i;
    z__8.r = sfac * evlcom_2.con2.r, z__8.i = sfac * evlcom_2.con2.i;
    z__7.r = sf3 * z__8.r, z__7.i = sf3 * z__8.i;
    z__5.r = z__6.r + z__7.r, z__5.i = z__6.i + z__7.i;
    z__4.r = z__5.r + 1.f, z__4.i = z__5.i;
    z__3.r = exjk.r * z__4.r - exjk.i * z__4.i, z__3.i = exjk.r * z__4.i + 
	    exjk.i * z__4.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = erh->r - z__2.r, z__1.i = erh->i - z__2.i;
    erh->r = z__1.r, erh->i = z__1.i;
    z__4.r = -exjk.r, z__4.i = -exjk.i;
    z__8.r = -evlcom_2.con3.r, z__8.i = -evlcom_2.con3.i;
    z__9.r = sfac * evlcom_2.con2.r, z__9.i = sfac * evlcom_2.con2.i;
    z__7.r = z__8.r + z__9.r, z__7.i = z__8.i + z__9.i;
    z__6.r = sf2 * z__7.r, z__6.i = sf2 * z__7.i;
    z__5.r = z__6.r + 1.f, z__5.i = z__6.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = eph->r - z__2.r, z__1.i = eph->i - z__2.i;
    eph->r = z__1.r, eph->i = z__1.i;
    z__4.r = -exjk.r, z__4.i = -exjk.i;
    z__8.r = evlcom_2.con3.r * evlcom_2.ck1sq.r - evlcom_2.con3.i * 
	    evlcom_2.ck1sq.i, z__8.i = evlcom_2.con3.r * evlcom_2.ck1sq.i + 
	    evlcom_2.con3.i * evlcom_2.ck1sq.r;
    z_div(&z__7, &z__8, &evlcom_2.ck2sq);
    z__6.r = sf1 * z__7.r, z__6.i = sf1 * z__7.i;
    z__10.r = sfac * evlcom_2.con2.r, z__10.i = sfac * evlcom_2.con2.i;
    z__9.r = cth * z__10.r, z__9.i = cth * z__10.i;
    z__5.r = z__6.r + z__9.r, z__5.i = z__6.i + z__9.i;
    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + 
	    z__4.i * z__5.r;
    d_cnjg(&z__2, &z__3);
    z__1.r = ezh->r - z__2.r, z__1.i = ezh->i - z__2.i;
    ezh->r = z__1.r, ezh->i = z__1.i;
    return 0;
L22:
    erv->r = 0.f, erv->i = 0.f;
    ezv->r = 0.f, ezv->i = 0.f;
    erh->r = 0.f, erh->i = 0.f;
    eph->r = 0.f, eph->i = 0.f;
    ezh->r = 0.f, ezh->i = 0.f;
    return 0;

} /* evlub_ */

/* Subroutine */ int lambda_(doublereal *t, doublecomplex *xlam, 
	doublecomplex *dxlam)
{
    /* System generated locals */
    doublecomplex z__1, z__2;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     COMPUTE INTEGRATION PARAMETER XLAM=LAMBDA FROM PARAMETER T. */

    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    dxlam->r = z__1.r, dxlam->i = z__1.i;
    z__2.r = *t * dxlam->r, z__2.i = *t * dxlam->i;
    z__1.r = cntour_1.a.r + z__2.r, z__1.i = cntour_1.a.i + z__2.i;
    xlam->r = z__1.r, xlam->i = z__1.i;
    return 0;
} /* lambda_ */

/* Subroutine */ int rmsrs_(integer *ieq, doublecomplex *y, doublecomplex *ra,
	 doublereal *rmr, doublereal *rmrr, integer *inf, integer *ic)
{
    /* Format strings */
    static char fmt_3[] = "(\002 RMSRS: ERROR IN L. S. SOLUTION FOR COMPON"
	    "ENT\002,i3)";

    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    void d_cnjg(doublecomplex *, doublecomplex *);
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    static doublereal rms, yms, ymax;

    /* Fortran I/O blocks */
    static cilist io___2953 = { 0, 3, 0, fmt_3, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     RMSRC COMPUTES THE RMS VALUES OF THE RESIDUALS FROM THE LEAST- */
/*     SQUARES SOLUTION. */
    /* Parameter adjustments */
    --ra;
    --y;

    /* Function Body */
    if (*inf != 0) {
	s_wsfe(&io___2953);
	do_fio(&c__1, (char *)&(*ic), (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    *rmr = 0.f;
    *rmrr = 0.f;
    ymax = 0.f;
    i__1 = *ieq;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__;
	d_cnjg(&z__2, &ra[i__]);
	z__1.r = ra[i__2].r * z__2.r - ra[i__2].i * z__2.i, z__1.i = ra[i__2]
		.r * z__2.i + ra[i__2].i * z__2.r;
	rms = z__1.r;
	*rmr += rms;
	i__2 = i__;
	d_cnjg(&z__2, &y[i__]);
	z__1.r = y[i__2].r * z__2.r - y[i__2].i * z__2.i, z__1.i = y[i__2].r *
		 z__2.i + y[i__2].i * z__2.r;
	yms = z__1.r;
	if (yms < 1e-20f) {
	    yms = 1e-20f;
	}
	if (yms > ymax) {
	    ymax = yms;
	}
/* L2: */
	*rmrr += rms / yms;
    }
    *rmr = sqrt(*rmr / (*ieq * ymax));
    *rmrr = sqrt(*rmrr / *ieq);
    return 0;

} /* rmsrs_ */

/* Subroutine */ int rom1_(integer *n, doublecomplex *sum, doublereal *dzs, 
	integer *iconv, integer *icyes)
{
    /* Initialized data */

    static doublereal dzmn = 1e-6;
    static doublereal dzmx = .9999;
    static doublereal rx = 5e-4;
    static doublereal rxl = 5e-5;
    static doublereal rc = 1e-4;

    /* Format strings */
    static char fmt_18[] = "(\002 ROM1: STEP SIZE LIMITED AT LAMBDA =\002,1p"
	    "2e12.5)";
    static char fmt_19[] = "(1p10e12.5)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__;
    static doublereal z__;
    static doublecomplex g1[6], g2[6], g3[6], g4[6], g5[6];
    static doublereal ba;
    static doublecomplex t00, t01[6], t10[6], t02, t11, t20[6];
    static doublereal dz, ze, tr, baz, eps, trm, trx;
    extern /* Subroutine */ int saob_(doublereal *, doublecomplex *);
    static doublereal dzot;
    extern /* Subroutine */ int testc_(doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublereal *);
    static integer lstep;
    extern /* Subroutine */ int lambda_(doublereal *, doublecomplex *, 
	    doublecomplex *);

    /* Fortran I/O blocks */
    static cilist io___2986 = { 0, 3, 0, fmt_18, 0 };
    static cilist io___2987 = { 0, 3, 0, fmt_19, 0 };
    static cilist io___2988 = { 0, 3, 0, fmt_19, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     ROM1 INTEGRATES THE 6 SOMMERFELD INTEGRALS FROM A TO B IN LAMBDA. */
/*     THE METHOD OF VARIABLE INTERVAL WIDTH ROMBERG INTEGRATION IS USED. */

    /* Parameter adjustments */
    --sum;

    /* Function Body */
    lstep = 0;
    *icyes = 0;
    z__ = 0.f;
    ze = 1.f;
    eps = 1e-6f;
    z__1.r = cntour_1.b.r - cntour_1.a.r, z__1.i = cntour_1.b.i - 
	    cntour_1.a.i;
    ba = z_abs(&z__1);
    dz = *dzs;
    saob_(&z__, g1);
L1:
    if (z__ + dz > ze) {
	dz = ze - z__;
    }
    dzot = dz * .5f;
    d__1 = z__ + dzot;
    saob_(&d__1, g3);
    d__1 = z__ + dz;
    saob_(&d__1, g5);
L2:
    baz = (cntour_1.bael + ba * (z__ + dz)) / (dz * ba);
    trm = 0.f;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__2.r = g1[i__2].r + g5[i__3].r, z__2.i = g1[i__2].i + g5[i__3].i;
	z__1.r = dzot * z__2.r, z__1.i = dzot * z__2.i;
	t00.r = z__1.r, t00.i = z__1.i;
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__3.r = dz * g3[i__3].r, z__3.i = dz * g3[i__3].i;
	z__2.r = t00.r + z__3.r, z__2.i = t00.i + z__3.i;
	z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
	t01[i__2].r = z__1.r, t01[i__2].i = z__1.i;
	i__2 = i__ - 1;
	i__3 = i__ - 1;
	z__3.r = t01[i__3].r * 4.f, z__3.i = t01[i__3].i * 4.f;
	z__2.r = z__3.r - t00.r, z__2.i = z__3.i - t00.i;
	z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
	t10[i__2].r = z__1.r, t10[i__2].i = z__1.i;
/*     TEST CONVERGENCE OF 3 POINT ROMBERG RESULT */
	testc_(&t01[i__ - 1], &t10[i__ - 1], &sum[i__], &tr);
	if (tr > trm) {
	    trm = tr;
	}
/* L3: */
    }
    trm *= baz;
    if (trm > rx) {
	goto L6;
    }
    trm = 0.f;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L4: */
	i__2 = i__;
	i__3 = i__;
	i__4 = i__ - 1;
	z__1.r = sum[i__3].r + t10[i__4].r, z__1.i = sum[i__3].i + t10[i__4]
		.i;
	sum[i__2].r = z__1.r, sum[i__2].i = z__1.i;
    }
    if (*iconv == 0) {
	goto L11;
    }
    trx = rc / baz;
    i__2 = *n;
    for (i__ = 1; i__ <= i__2; ++i__) {
	if (z_abs(&t10[i__ - 1]) > trx * z_abs(&sum[i__])) {
	    goto L11;
	}
/* L5: */
    }
    *icyes = 1;
    z__ += dz;
    goto L17;
L6:
    d__1 = z__ + dz * .25f;
    saob_(&d__1, g2);
    d__1 = z__ + dz * .75f;
    saob_(&d__1, g4);
    trm = 0.f;
    i__2 = *n;
    for (i__ = 1; i__ <= i__2; ++i__) {
	i__3 = i__ - 1;
	i__4 = i__ - 1;
	i__1 = i__ - 1;
	z__4.r = g2[i__4].r + g4[i__1].r, z__4.i = g2[i__4].i + g4[i__1].i;
	z__3.r = dzot * z__4.r, z__3.i = dzot * z__4.i;
	z__2.r = t01[i__3].r + z__3.r, z__2.i = t01[i__3].i + z__3.i;
	z__1.r = z__2.r * .5f, z__1.i = z__2.i * .5f;
	t02.r = z__1.r, t02.i = z__1.i;
	z__3.r = t02.r * 4.f, z__3.i = t02.i * 4.f;
	i__3 = i__ - 1;
	z__2.r = z__3.r - t01[i__3].r, z__2.i = z__3.i - t01[i__3].i;
	z__1.r = z__2.r / 3.f, z__1.i = z__2.i / 3.f;
	t11.r = z__1.r, t11.i = z__1.i;
	i__3 = i__ - 1;
	z__3.r = t11.r * 16.f, z__3.i = t11.i * 16.f;
	i__4 = i__ - 1;
	z__2.r = z__3.r - t10[i__4].r, z__2.i = z__3.i - t10[i__4].i;
	z__1.r = z__2.r / 15.f, z__1.i = z__2.i / 15.f;
	t20[i__3].r = z__1.r, t20[i__3].i = z__1.i;
/*     TEST CONVERGENCE OF 5 POINT ROMBERG RESULT */
	testc_(&t11, &t20[i__ - 1], &sum[i__], &tr);
	if (tr > trm) {
	    trm = tr;
	}
/* L7: */
    }
    trm *= baz;
    if (trm > rx) {
	goto L13;
    }
L8:
    i__2 = *n;
    for (i__ = 1; i__ <= i__2; ++i__) {
/* L9: */
	i__3 = i__;
	i__4 = i__;
	i__1 = i__ - 1;
	z__1.r = sum[i__4].r + t20[i__1].r, z__1.i = sum[i__4].i + t20[i__1]
		.i;
	sum[i__3].r = z__1.r, sum[i__3].i = z__1.i;
    }
    if (*iconv == 0) {
	goto L11;
    }
    trx = rc / baz;
    i__3 = *n;
    for (i__ = 1; i__ <= i__3; ++i__) {
	if (z_abs(&t20[i__ - 1]) > trx * z_abs(&sum[i__])) {
	    goto L11;
	}
/* L10: */
    }
    *icyes = 1;
    z__ += dz;
    goto L17;
L11:
    z__ += dz;
    if ((d__1 = z__ - ze, abs(d__1)) < eps) {
	goto L17;
    }
    i__3 = *n;
    for (i__ = 1; i__ <= i__3; ++i__) {
/* L12: */
	i__4 = i__ - 1;
	i__1 = i__ - 1;
	g1[i__4].r = g5[i__1].r, g1[i__4].i = g5[i__1].i;
    }
    if (trm < rxl && dz < dzmx) {
	dz *= 2.f;
    }
    goto L1;
L13:
    if (dz >= dzmn) {
	goto L15;
    }
    if (lstep == 1) {
	goto L8;
    }
    lstep = 1;
    lambda_(&z__, &t00, &t11);
    s_wsfe(&io___2986);
    do_fio(&c__2, (char *)&t00, (ftnlen)sizeof(doublereal));
    e_wsfe();
    s_wsfe(&io___2987);
    do_fio(&c__1, (char *)&z__, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&dz, (ftnlen)sizeof(doublereal));
    do_fio(&c__2, (char *)&cntour_1.a, (ftnlen)sizeof(doublereal));
    do_fio(&c__2, (char *)&cntour_1.b, (ftnlen)sizeof(doublereal));
    e_wsfe();
    i__4 = *n;
    for (i__ = 1; i__ <= i__4; ++i__) {
/* L14: */
	s_wsfe(&io___2988);
	do_fio(&c__2, (char *)&g1[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g2[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g3[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g4[i__ - 1], (ftnlen)sizeof(doublereal));
	do_fio(&c__2, (char *)&g5[i__ - 1], (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    goto L8;
L15:
    dz *= .5f;
    dzot = dz * .5f;
    i__4 = *n;
    for (i__ = 1; i__ <= i__4; ++i__) {
	i__1 = i__ - 1;
	i__3 = i__ - 1;
	g5[i__1].r = g3[i__3].r, g5[i__1].i = g3[i__3].i;
/* L16: */
	i__1 = i__ - 1;
	i__3 = i__ - 1;
	g3[i__1].r = g2[i__3].r, g3[i__1].i = g2[i__3].i;
    }
    goto L2;
L17:
    cntour_1.bael += ba * z__;
    return 0;

} /* rom1_ */

/* Subroutine */ int rzzfit_(integer *ireg, integer *ifunc)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    static doublereal r__;
#define ff ((doublereal *)&fparm_1 + 16)
    static integer ic;
    static doublecomplex ra[100];
    static integer ix;
    static doublereal zp, zz;
    static doublecomplex re1[100], re2[100], re3[100], re4[100], re5[100];
#define cff ((doublecomplex *)&fparm_1)
    static doublecomplex eph, erh;
    static integer ieq, inf, irh;
    static doublereal rkf;
    static doublecomplex dum, ezh;
    static doublereal rho;
    static doublecomplex erv;
    static doublereal sth;
    static integer izp;
    static doublecomplex ezv, exx;
    static doublereal zpp;
    static integer izz;
    static doublecomplex cls1[3200]	/* was [100][32] */, cls2[3200]	/* 
	    was [100][32] */, cls3[3200]	/* was [100][32] */, cqra[32];
    static integer jdum, nfun;
    extern /* Subroutine */ int cqrdc_(doublecomplex *, integer *, integer *, 
	    integer *, doublecomplex *, integer *, doublecomplex *, integer *)
	    , fnfit_(doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublecomplex *), evlub_(doublereal *, doublereal *, doublereal *,
	     integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *), cqrsl_(doublecomplex *, 
	    integer *, integer *, integer *, doublecomplex *, doublecomplex *,
	     doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex 
	    *, doublecomplex *, integer *, integer *), rmsrs_(integer *, 
	    doublecomplex *, doublecomplex *, doublereal *, doublereal *, 
	    integer *, integer *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     RZZFIT SETS UP THE EQUATIONS FOR LEASE-SQUARES APPROXIMATION OF */
/*     THE SOMMERFELD INTEGRAL VALUES MATCHED AT THE POINTS SPECIFIED IN */
/*     COMMON/PTFIT/. */

    z_div(&z__1, &gparm_1.gck2, &gparm_1.gck1);
    cofit_1.rkfac = z_abs(&z__1);
    fparm_1.nfunc = 0;
    if (*ifunc > 0) {
	fparm_1.nfunc = 4;
    }
    ieq = 0;
    rho = ptfit_1.rh1 - ptfit_1.drh;
/*     LOOP OVER FIRST SET OF POINTS TO BE FIT. */
    i__1 = ptfit_1.nrh;
    for (irh = 1; irh <= i__1; ++irh) {
	rho += ptfit_1.drh;
	zz = ptfit_1.zz1 - ptfit_1.dzz;
	i__2 = ptfit_1.nzz;
	for (izz = 1; izz <= i__2; ++izz) {
	    zz += ptfit_1.dzz;
	    zpp = ptfit_1.zp1 - ptfit_1.dzp;
	    i__3 = ptfit_1.nzp;
	    for (izp = 1; izp <= i__3; ++izp) {
		zpp += ptfit_1.dzp;
		zp = -zpp;
		++ieq;
/*     OBTAIN FUNCTION VALUES. */
		fnfit_(&rho, &zz, &zp, &sth, &exx);
		ix = 2;
		i__4 = fparm_1.nfunf;
		for (i__ = 1; i__ <= i__4; ++i__) {
		    ++ix;
		    i__5 = ieq + i__ * 100 - 101;
		    d__1 = ff[i__ - 1] * sth;
		    cls1[i__5].r = d__1, cls1[i__5].i = 0.;
		    i__5 = ieq + i__ * 100 - 101;
		    i__6 = i__ - 1;
		    cls3[i__5].r = ff[i__6], cls3[i__5].i = 0.;
		    if (ix == 3) {
			goto L1;
		    }
		    i__5 = ieq + i__ * 100 - 101;
		    i__6 = i__ - 1;
		    cls2[i__5].r = ff[i__6], cls2[i__5].i = 0.;
		    goto L2;
L1:
		    i__5 = ieq + i__ * 100 - 101;
		    d__1 = ff[i__ - 1] * sth;
		    cls2[i__5].r = d__1, cls2[i__5].i = 0.;
		    ix = 0;
L2:
		    ;
		}
		if (fparm_1.nfunc == 0) {
		    goto L4;
		}
		i__4 = fparm_1.nfunc;
		for (i__ = 1; i__ <= i__4; ++i__) {
		    ic = i__ + fparm_1.nfunf;
		    i__5 = ieq + ic * 100 - 101;
		    i__6 = i__ - 1;
		    z__1.r = sth * cff[i__6].r, z__1.i = sth * cff[i__6].i;
		    cls1[i__5].r = z__1.r, cls1[i__5].i = z__1.i;
		    i__5 = ieq + ic * 100 - 101;
		    i__6 = i__ - 1;
		    cls2[i__5].r = cff[i__6].r, cls2[i__5].i = cff[i__6].i;
/* L3: */
		    i__5 = ieq + ic * 100 - 101;
		    i__6 = i__ - 1;
		    cls3[i__5].r = cff[i__6].r, cls3[i__5].i = cff[i__6].i;
		}
L4:
		evlub_(&rho, &zz, &zp, &ptfit_1.iqax, &erv, &ezv, &erh, &eph, 
			&ezh);
/* Computing 2nd power */
		d__1 = zz - zp;
		r__ = sqrt(rho * rho + d__1 * d__1);
/* Computing 2nd power */
		d__1 = zz - zp * cofit_1.rkfac;
		rkf = sqrt(rho * rho + d__1 * d__1);
		z__2.r = rkf, z__2.i = 0.;
		z__3.r = r__ * exx.r, z__3.i = r__ * exx.i;
		z_div(&z__1, &z__2, &z__3);
		exx.r = z__1.r, exx.i = z__1.i;
		i__5 = ieq - 1;
		z__1.r = erv.r * exx.r - erv.i * exx.i, z__1.i = erv.r * 
			exx.i + erv.i * exx.r;
		re1[i__5].r = z__1.r, re1[i__5].i = z__1.i;
		i__5 = ieq - 1;
		z__1.r = ezv.r * exx.r - ezv.i * exx.i, z__1.i = ezv.r * 
			exx.i + ezv.i * exx.r;
		re2[i__5].r = z__1.r, re2[i__5].i = z__1.i;
		i__5 = ieq - 1;
		z__1.r = erh.r * exx.r - erh.i * exx.i, z__1.i = erh.r * 
			exx.i + erh.i * exx.r;
		re3[i__5].r = z__1.r, re3[i__5].i = z__1.i;
		i__5 = ieq - 1;
		z__1.r = eph.r * exx.r - eph.i * exx.i, z__1.i = eph.r * 
			exx.i + eph.i * exx.r;
		re4[i__5].r = z__1.r, re4[i__5].i = z__1.i;
		i__5 = ieq - 1;
		z__1.r = ezh.r * exx.r - ezh.i * exx.i, z__1.i = ezh.r * 
			exx.i + ezh.i * exx.r;
		re5[i__5].r = z__1.r, re5[i__5].i = z__1.i;
/* L5: */
	    }
	}
    }
    if (ptfit_1.nsrh == 0) {
	goto L11;
    }
    rho = ptfit_1.srh1 - ptfit_1.dsrh;
/*     LOOP OVER SECOND SET OF POINTS TO BE FIT. */
    i__3 = ptfit_1.nsrh;
    for (irh = 1; irh <= i__3; ++irh) {
	rho += ptfit_1.dsrh;
	zz = ptfit_1.szz1 - ptfit_1.dszz;
	i__2 = ptfit_1.nszz;
	for (izz = 1; izz <= i__2; ++izz) {
	    zz += ptfit_1.dszz;
	    zpp = ptfit_1.szp1 - ptfit_1.dszp;
	    i__1 = ptfit_1.nszp;
	    for (izp = 1; izp <= i__1; ++izp) {
		zpp += ptfit_1.dszp;
		zp = -zpp;
		++ieq;
		fnfit_(&rho, &zz, &zp, &sth, &exx);
		ix = 2;
		i__5 = fparm_1.nfunf;
		for (i__ = 1; i__ <= i__5; ++i__) {
		    ++ix;
		    i__6 = ieq + i__ * 100 - 101;
		    d__1 = ff[i__ - 1] * sth;
		    cls1[i__6].r = d__1, cls1[i__6].i = 0.;
		    i__6 = ieq + i__ * 100 - 101;
		    i__4 = i__ - 1;
		    cls3[i__6].r = ff[i__4], cls3[i__6].i = 0.;
		    if (ix == 3) {
			goto L6;
		    }
		    i__6 = ieq + i__ * 100 - 101;
		    i__4 = i__ - 1;
		    cls2[i__6].r = ff[i__4], cls2[i__6].i = 0.;
		    goto L7;
L6:
		    i__6 = ieq + i__ * 100 - 101;
		    d__1 = ff[i__ - 1] * sth;
		    cls2[i__6].r = d__1, cls2[i__6].i = 0.;
		    ix = 0;
L7:
		    ;
		}
		if (fparm_1.nfunc == 0) {
		    goto L9;
		}
		i__5 = fparm_1.nfunc;
		for (i__ = 1; i__ <= i__5; ++i__) {
		    ic = i__ + fparm_1.nfunf;
		    i__6 = ieq + ic * 100 - 101;
		    i__4 = i__ - 1;
		    z__1.r = sth * cff[i__4].r, z__1.i = sth * cff[i__4].i;
		    cls1[i__6].r = z__1.r, cls1[i__6].i = z__1.i;
		    i__6 = ieq + ic * 100 - 101;
		    i__4 = i__ - 1;
		    cls2[i__6].r = cff[i__4].r, cls2[i__6].i = cff[i__4].i;
/* L8: */
		    i__6 = ieq + ic * 100 - 101;
		    i__4 = i__ - 1;
		    cls3[i__6].r = cff[i__4].r, cls3[i__6].i = cff[i__4].i;
		}
L9:
		evlub_(&rho, &zz, &zp, &ptfit_1.iqax, &erv, &ezv, &erh, &eph, 
			&ezh);
/* Computing 2nd power */
		d__1 = zz - zp;
		r__ = sqrt(rho * rho + d__1 * d__1);
/* Computing 2nd power */
		d__1 = zz - zp * cofit_1.rkfac;
		rkf = sqrt(rho * rho + d__1 * d__1);
		z__2.r = rkf, z__2.i = 0.;
		z__3.r = r__ * exx.r, z__3.i = r__ * exx.i;
		z_div(&z__1, &z__2, &z__3);
		exx.r = z__1.r, exx.i = z__1.i;
		i__6 = ieq - 1;
		z__1.r = erv.r * exx.r - erv.i * exx.i, z__1.i = erv.r * 
			exx.i + erv.i * exx.r;
		re1[i__6].r = z__1.r, re1[i__6].i = z__1.i;
		i__6 = ieq - 1;
		z__1.r = ezv.r * exx.r - ezv.i * exx.i, z__1.i = ezv.r * 
			exx.i + ezv.i * exx.r;
		re2[i__6].r = z__1.r, re2[i__6].i = z__1.i;
		i__6 = ieq - 1;
		z__1.r = erh.r * exx.r - erh.i * exx.i, z__1.i = erh.r * 
			exx.i + erh.i * exx.r;
		re3[i__6].r = z__1.r, re3[i__6].i = z__1.i;
		i__6 = ieq - 1;
		z__1.r = eph.r * exx.r - eph.i * exx.i, z__1.i = eph.r * 
			exx.i + eph.i * exx.r;
		re4[i__6].r = z__1.r, re4[i__6].i = z__1.i;
		i__6 = ieq - 1;
		z__1.r = ezh.r * exx.r - ezh.i * exx.i, z__1.i = ezh.r * 
			exx.i + ezh.i * exx.r;
		re5[i__6].r = z__1.r, re5[i__6].i = z__1.i;
/* L10: */
	    }
	}
    }
/*     LEAST SQUARES SOLUTION */
L11:
    nfun = fparm_1.nfunf + fparm_1.nfunc;
    cofit_1.mfunf[*ireg - 1] = fparm_1.nfunf;
    cofit_1.mfunc[*ireg - 1] = fparm_1.nfunc;
    cqrdc_(cls1, &c__100, &ieq, &nfun, cqra, &jdum, &dum, &c__0);
    cqrsl_(cls1, &c__100, &ieq, &nfun, cqra, re1, &dum, ra, &cofit_1.fac1[(*
	    ireg << 5) - 32], ra, &dum, &c__110, &inf);
    rmsrs_(&ieq, re1, ra, &ptfit_1.res1, &ptfit_1.rex1, &inf, &c__1);
    cqrsl_(cls1, &c__100, &ieq, &nfun, cqra, re5, &dum, ra, &cofit_1.fac5[(*
	    ireg << 5) - 32], ra, &dum, &c__110, &inf);
    rmsrs_(&ieq, re5, ra, &ptfit_1.res5, &ptfit_1.rex5, &inf, &c__5);
    cqrdc_(cls2, &c__100, &ieq, &nfun, cqra, &jdum, &dum, &c__0);
    cqrsl_(cls2, &c__100, &ieq, &nfun, cqra, re2, &dum, ra, &cofit_1.fac2[(*
	    ireg << 5) - 32], ra, &dum, &c__110, &inf);
    rmsrs_(&ieq, re2, ra, &ptfit_1.res2, &ptfit_1.rex2, &inf, &c__2);
    cqrdc_(cls3, &c__100, &ieq, &nfun, cqra, &jdum, &dum, &c__0);
    cqrsl_(cls3, &c__100, &ieq, &nfun, cqra, re3, &dum, ra, &cofit_1.fac3[(*
	    ireg << 5) - 32], ra, &dum, &c__110, &inf);
    rmsrs_(&ieq, re3, ra, &ptfit_1.res3, &ptfit_1.rex3, &inf, &c__3);
    cqrsl_(cls3, &c__100, &ieq, &nfun, cqra, re4, &dum, ra, &cofit_1.fac4[(*
	    ireg << 5) - 32], ra, &dum, &c__110, &inf);
    rmsrs_(&ieq, re4, ra, &ptfit_1.res4, &ptfit_1.rex4, &inf, &c__4);
    return 0;
} /* rzzfit_ */

#undef cff
#undef ff


/* Subroutine */ int saob_(doublereal *t, doublecomplex *ans)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8, z__9, z__10,
	     z__11;

    /* Builtin functions */
    void z_sqrt(doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *), d_cnjg(
	    doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);

    /* Local variables */
    static doublecomplex b0, xl, b0p, com, dxl, rxl;
    static doublereal xlr;
    static doublecomplex den1, den2, den3, trm1, trm2, trm3, zpgd, cgam1, 
	    cgam2;
    extern /* Subroutine */ int hank12_(doublecomplex *, integer *, 
	    doublecomplex *, doublecomplex *);
    static doublecomplex cexgd, cexzd, cexxm, cexxp;
    extern /* Double Complex */ VOID zzexp_(doublecomplex *, doublecomplex *);
    extern /* Subroutine */ int lambda_(doublereal *, doublecomplex *, 
	    doublecomplex *), bessel_(doublecomplex *, doublecomplex *, 
	    doublecomplex *);

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SAOB COMPUTES THE INTEGRAND FOR EACH OF 6 DERIVATIVES OF THE */
/*     SOMMERFELD INTEGRALS FOR SOURCE BELOW GROUND AND OBSERVER ABOVE. */

    /* Parameter adjustments */
    --ans;

    /* Function Body */
    lambda_(t, &xl, &dxl);
    if (evlcom_2.jh > 0) {
	goto L1;
    }
/*     BESSEL FUNCTION FORM */
    z__1.r = evlcom_2.rho * xl.r, z__1.i = evlcom_2.rho * xl.i;
    bessel_(&z__1, &b0, &b0p);
    z__1.r = b0.r * 2.f, z__1.i = b0.i * 2.f;
    b0.r = z__1.r, b0.i = z__1.i;
    z__2.r = b0p.r * 2.f, z__2.i = b0p.i * 2.f;
    z__1.r = z__2.r * xl.r - z__2.i * xl.i, z__1.i = z__2.r * xl.i + z__2.i * 
	    xl.r;
    b0p.r = z__1.r, b0p.i = z__1.i;
    z__3.r = xl.r * xl.r - xl.i * xl.i, z__3.i = xl.r * xl.i + xl.i * xl.r;
    z__2.r = z__3.r - evlcom_2.ck1sq.r, z__2.i = z__3.i - evlcom_2.ck1sq.i;
    z_sqrt(&z__1, &z__2);
    cgam1.r = z__1.r, cgam1.i = z__1.i;
    z__3.r = xl.r * xl.r - xl.i * xl.i, z__3.i = xl.r * xl.i + xl.i * xl.r;
    z__2.r = z__3.r - evlcom_2.ck2sq.r, z__2.i = z__3.i - evlcom_2.ck2sq.i;
    z_sqrt(&z__1, &z__2);
    cgam2.r = z__1.r, cgam2.i = z__1.i;
    if (cgam1.r == 0.f) {
	d__2 = -(d__1 = d_imag(&cgam1), abs(d__1));
	z__1.r = 0., z__1.i = d__2;
	cgam1.r = z__1.r, cgam1.i = z__1.i;
    }
    if (cgam2.r == 0.f) {
	d__2 = -(d__1 = d_imag(&cgam2), abs(d__1));
	z__1.r = 0., z__1.i = d__2;
	cgam2.r = z__1.r, cgam2.i = z__1.i;
    }
    goto L3;
/*     HANKEL FUNCTION FORM */
L1:
    if (evlcom_2.jh == 1) {
	goto L2;
    }
    z__2.r = xl.r * 0.f - xl.i * 2.f, z__2.i = xl.r * 2.f + xl.i * 0.f;
    z__1.r = z__2.r * dxl.r - z__2.i * dxl.i, z__1.i = z__2.r * dxl.i + 
	    z__2.i * dxl.r;
    dxl.r = z__1.r, dxl.i = z__1.i;
    xlr = xl.r;
    d__1 = evlcom_2.ckbi + xlr * xlr;
    z__1.r = evlcom_2.ckbr, z__1.i = d__1;
    xl.r = z__1.r, xl.i = z__1.i;
L2:
    z__1.r = evlcom_2.rho * xl.r, z__1.i = evlcom_2.rho * xl.i;
    hank12_(&z__1, &c__1, &b0, &b0p);
    z__1.r = b0p.r * xl.r - b0p.i * xl.i, z__1.i = b0p.r * xl.i + b0p.i * 
	    xl.r;
    b0p.r = z__1.r, b0p.i = z__1.i;
    z__1.r = xl.r - evlcom_2.ck2.r, z__1.i = xl.i - evlcom_2.ck2.i;
    com.r = z__1.r, com.i = z__1.i;
    z__3.r = xl.r + evlcom_2.ck2.r, z__3.i = xl.i + evlcom_2.ck2.i;
    z_sqrt(&z__2, &z__3);
    z_sqrt(&z__4, &com);
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    cgam2.r = z__1.r, cgam2.i = z__1.i;
    if (com.r < 0.f && d_imag(&com) >= 0.f) {
	z__1.r = -cgam2.r, z__1.i = -cgam2.i;
	cgam2.r = z__1.r, cgam2.i = z__1.i;
    }
    z__1.r = xl.r - evlcom_2.ck1.r, z__1.i = xl.i - evlcom_2.ck1.i;
    com.r = z__1.r, com.i = z__1.i;
    z__3.r = xl.r + evlcom_2.ck1.r, z__3.i = xl.i + evlcom_2.ck1.i;
    z_sqrt(&z__2, &z__3);
    z_sqrt(&z__4, &com);
    z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r * z__4.i + 
	    z__2.i * z__4.r;
    cgam1.r = z__1.r, cgam1.i = z__1.i;
    if (evlcom_2.jh == 2) {
	goto L9;
    }
    if (com.r < 0.f && d_imag(&com) >= 0.f) {
	z__1.r = -cgam1.r, z__1.i = -cgam1.i;
	cgam1.r = z__1.r, cgam1.i = z__1.i;
    }
L3:
    if (evlcom_2.iqaz != 0) {
	goto L4;
    }
    z__3.r = evlcom_2.zp * cgam1.r, z__3.i = evlcom_2.zp * cgam1.i;
    z__4.r = evlcom_2.zz * cgam2.r, z__4.i = evlcom_2.zz * cgam2.i;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    zzexp_(&z__1, &z__2);
    cexxp.r = z__1.r, cexxp.i = z__1.i;
    z__2.r = cgam2.r + cgam1.r, z__2.i = cgam2.i + cgam1.i;
    z_div(&z__1, &cexxp, &z__2);
    den1.r = z__1.r, den1.i = z__1.i;
    z__3.r = evlcom_2.ck1sq.r * cgam2.r - evlcom_2.ck1sq.i * cgam2.i, z__3.i =
	     evlcom_2.ck1sq.r * cgam2.i + evlcom_2.ck1sq.i * cgam2.r;
    z__4.r = evlcom_2.ck2sq.r * cgam1.r - evlcom_2.ck2sq.i * cgam1.i, z__4.i =
	     evlcom_2.ck2sq.r * cgam1.i + evlcom_2.ck2sq.i * cgam1.r;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z_div(&z__1, &cexxp, &z__2);
    den2.r = z__1.r, den2.i = z__1.i;
    z__1.r = den2.r * cgam1.r - den2.i * cgam1.i, z__1.i = den2.r * cgam1.i + 
	    den2.i * cgam1.r;
    den3.r = z__1.r, den3.i = z__1.i;
    goto L10;
L4:
    z__2.r = cgam1.r - cgam2.r, z__2.i = cgam1.i - cgam2.i;
    z__1.r = evlcom_2.zp * z__2.r, z__1.i = evlcom_2.zp * z__2.i;
    zpgd.r = z__1.r, zpgd.i = z__1.i;
    zzexp_(&z__1, &zpgd);
    cexgd.r = z__1.r, cexgd.i = z__1.i;
    z__3.r = -cgam2.r, z__3.i = -cgam2.i;
    d__1 = evlcom_2.zz - evlcom_2.zp;
    z__2.r = d__1 * z__3.r, z__2.i = d__1 * z__3.i;
    zzexp_(&z__1, &z__2);
    cexzd.r = z__1.r, cexzd.i = z__1.i;
    z__1.r = cexgd.r * cexzd.r - cexgd.i * cexzd.i, z__1.i = cexgd.r * 
	    cexzd.i + cexgd.i * cexzd.r;
    cexxp.r = z__1.r, cexxp.i = z__1.i;
    d_cnjg(&z__2, &xl);
    z__1.r = xl.r * z__2.r - xl.i * z__2.i, z__1.i = xl.r * z__2.i + xl.i * 
	    z__2.r;
    xlr = z__1.r;
    if (xlr < evlcom_2.tsmag) {
	goto L5;
    }
    if (d_imag(&xl) < 0.f) {
	goto L6;
    }
    xlr = xl.r;
    if (xlr < evlcom_2.ckar) {
	goto L7;
    }
    if (xlr > evlcom_2.ckbr) {
	goto L6;
    }

/*     INTEGRAND WITH QUASISTATIC TERMS SUBTRACTED */

L5:
    if (z_abs(&zpgd) > .01f) {
	z__1.r = cexgd.r - 1.f, z__1.i = cexgd.i;
	trm1.r = z__1.r, trm1.i = z__1.i;
    } else {
	z__5.r = zpgd.r / 6.f, z__5.i = zpgd.i / 6.f;
	z__4.r = z__5.r + .5f, z__4.i = z__5.i;
	z__3.r = z__4.r * zpgd.r - z__4.i * zpgd.i, z__3.i = z__4.r * zpgd.i 
		+ z__4.i * zpgd.r;
	z__2.r = z__3.r + 1.f, z__2.i = z__3.i;
	z__1.r = z__2.r * zpgd.r - z__2.i * zpgd.i, z__1.i = z__2.r * zpgd.i 
		+ z__2.i * zpgd.r;
	trm1.r = z__1.r, trm1.i = z__1.i;
    }
    z__2.r = cgam2.r * cexgd.r - cgam2.i * cexgd.i, z__2.i = cgam2.r * 
	    cexgd.i + cgam2.i * cexgd.r;
    z__1.r = z__2.r - cgam1.r, z__1.i = z__2.i - cgam1.i;
    trm2.r = z__1.r, trm2.i = z__1.i;
    z__2.r = cgam1.r * cexgd.r - cgam1.i * cexgd.i, z__2.i = cgam1.r * 
	    cexgd.i + cgam1.i * cexgd.r;
    z__1.r = z__2.r - cgam2.r, z__1.i = z__2.i - cgam2.i;
    trm3.r = z__1.r, trm3.i = z__1.i;
    goto L8;

/*     APPROXIMATION OF ABOVE FOR LARGE XL TO AVOID CANCELLATION. */

L6:
    z_div(&z__1, &c_b336, &xl);
    rxl.r = z__1.r, rxl.i = z__1.i;
    z__9.r = srgam_1.a5.r * rxl.r - srgam_1.a5.i * rxl.i, z__9.i = 
	    srgam_1.a5.r * rxl.i + srgam_1.a5.i * rxl.r;
    z__8.r = z__9.r + srgam_1.a4.r, z__8.i = z__9.i + srgam_1.a4.i;
    z__7.r = z__8.r * rxl.r - z__8.i * rxl.i, z__7.i = z__8.r * rxl.i + 
	    z__8.i * rxl.r;
    z__6.r = z__7.r + srgam_1.a3.r, z__6.i = z__7.i + srgam_1.a3.i;
    z__5.r = z__6.r * rxl.r - z__6.i * rxl.i, z__5.i = z__6.r * rxl.i + 
	    z__6.i * rxl.r;
    z__4.r = z__5.r + srgam_1.a2.r, z__4.i = z__5.i + srgam_1.a2.i;
    z__3.r = z__4.r * rxl.r - z__4.i * rxl.i, z__3.i = z__4.r * rxl.i + 
	    z__4.i * rxl.r;
    z__2.r = z__3.r + srgam_1.a1.r, z__2.i = z__3.i + srgam_1.a1.i;
    z__1.r = z__2.r * rxl.r - z__2.i * rxl.i, z__1.i = z__2.r * rxl.i + 
	    z__2.i * rxl.r;
    trm1.r = z__1.r, trm1.i = z__1.i;
    z__10.r = srgam_1.b5.r * rxl.r - srgam_1.b5.i * rxl.i, z__10.i = 
	    srgam_1.b5.r * rxl.i + srgam_1.b5.i * rxl.r;
    z__9.r = z__10.r + srgam_1.b4.r, z__9.i = z__10.i + srgam_1.b4.i;
    z__8.r = z__9.r * rxl.r - z__9.i * rxl.i, z__8.i = z__9.r * rxl.i + 
	    z__9.i * rxl.r;
    z__7.r = z__8.r + srgam_1.b3.r, z__7.i = z__8.i + srgam_1.b3.i;
    z__6.r = z__7.r * rxl.r - z__7.i * rxl.i, z__6.i = z__7.r * rxl.i + 
	    z__7.i * rxl.r;
    z__5.r = z__6.r + srgam_1.b2.r, z__5.i = z__6.i + srgam_1.b2.i;
    z__4.r = z__5.r * rxl.r - z__5.i * rxl.i, z__4.i = z__5.r * rxl.i + 
	    z__5.i * rxl.r;
    z__3.r = z__4.r + srgam_1.b1.r, z__3.i = z__4.i + srgam_1.b1.i;
    z__2.r = z__3.r * rxl.r - z__3.i * rxl.i, z__2.i = z__3.r * rxl.i + 
	    z__3.i * rxl.r;
    z__1.r = z__2.r + srgam_1.a1.r, z__1.i = z__2.i + srgam_1.a1.i;
    trm2.r = z__1.r, trm2.i = z__1.i;
    z__10.r = srgam_1.c5.r * rxl.r - srgam_1.c5.i * rxl.i, z__10.i = 
	    srgam_1.c5.r * rxl.i + srgam_1.c5.i * rxl.r;
    z__9.r = z__10.r + srgam_1.c4.r, z__9.i = z__10.i + srgam_1.c4.i;
    z__8.r = z__9.r * rxl.r - z__9.i * rxl.i, z__8.i = z__9.r * rxl.i + 
	    z__9.i * rxl.r;
    z__7.r = z__8.r + srgam_1.c3.r, z__7.i = z__8.i + srgam_1.c3.i;
    z__6.r = z__7.r * rxl.r - z__7.i * rxl.i, z__6.i = z__7.r * rxl.i + 
	    z__7.i * rxl.r;
    z__5.r = z__6.r + srgam_1.c2.r, z__5.i = z__6.i + srgam_1.c2.i;
    z__4.r = z__5.r * rxl.r - z__5.i * rxl.i, z__4.i = z__5.r * rxl.i + 
	    z__5.i * rxl.r;
    z__3.r = z__4.r + srgam_1.c1.r, z__3.i = z__4.i + srgam_1.c1.i;
    z__2.r = z__3.r * rxl.r - z__3.i * rxl.i, z__2.i = z__3.r * rxl.i + 
	    z__3.i * rxl.r;
    z__1.r = z__2.r + srgam_1.a1.r, z__1.i = z__2.i + srgam_1.a1.i;
    trm3.r = z__1.r, trm3.i = z__1.i;
    goto L8;
L7:
    z_div(&z__1, &c_b336, &xl);
    rxl.r = z__1.r, rxl.i = z__1.i;
    z__10.r = -srgam_1.a5.r, z__10.i = -srgam_1.a5.i;
    z__9.r = z__10.r * rxl.r - z__10.i * rxl.i, z__9.i = z__10.r * rxl.i + 
	    z__10.i * rxl.r;
    z__8.r = z__9.r + srgam_1.a4.r, z__8.i = z__9.i + srgam_1.a4.i;
    z__7.r = z__8.r * rxl.r - z__8.i * rxl.i, z__7.i = z__8.r * rxl.i + 
	    z__8.i * rxl.r;
    z__6.r = z__7.r - srgam_1.a3.r, z__6.i = z__7.i - srgam_1.a3.i;
    z__5.r = z__6.r * rxl.r - z__6.i * rxl.i, z__5.i = z__6.r * rxl.i + 
	    z__6.i * rxl.r;
    z__4.r = z__5.r + srgam_1.a2.r, z__4.i = z__5.i + srgam_1.a2.i;
    z__3.r = z__4.r * rxl.r - z__4.i * rxl.i, z__3.i = z__4.r * rxl.i + 
	    z__4.i * rxl.r;
    z__2.r = z__3.r - srgam_1.a1.r, z__2.i = z__3.i - srgam_1.a1.i;
    z__1.r = z__2.r * rxl.r - z__2.i * rxl.i, z__1.i = z__2.r * rxl.i + 
	    z__2.i * rxl.r;
    trm1.r = z__1.r, trm1.i = z__1.i;
    z__11.r = -srgam_1.b5.r, z__11.i = -srgam_1.b5.i;
    z__10.r = z__11.r * rxl.r - z__11.i * rxl.i, z__10.i = z__11.r * rxl.i + 
	    z__11.i * rxl.r;
    z__9.r = z__10.r + srgam_1.b4.r, z__9.i = z__10.i + srgam_1.b4.i;
    z__8.r = z__9.r * rxl.r - z__9.i * rxl.i, z__8.i = z__9.r * rxl.i + 
	    z__9.i * rxl.r;
    z__7.r = z__8.r - srgam_1.b3.r, z__7.i = z__8.i - srgam_1.b3.i;
    z__6.r = z__7.r * rxl.r - z__7.i * rxl.i, z__6.i = z__7.r * rxl.i + 
	    z__7.i * rxl.r;
    z__5.r = z__6.r + srgam_1.b2.r, z__5.i = z__6.i + srgam_1.b2.i;
    z__4.r = z__5.r * rxl.r - z__5.i * rxl.i, z__4.i = z__5.r * rxl.i + 
	    z__5.i * rxl.r;
    z__3.r = z__4.r - srgam_1.b1.r, z__3.i = z__4.i - srgam_1.b1.i;
    z__2.r = z__3.r * rxl.r - z__3.i * rxl.i, z__2.i = z__3.r * rxl.i + 
	    z__3.i * rxl.r;
    z__1.r = z__2.r + srgam_1.a1.r, z__1.i = z__2.i + srgam_1.a1.i;
    trm2.r = z__1.r, trm2.i = z__1.i;
    z__11.r = -srgam_1.c5.r, z__11.i = -srgam_1.c5.i;
    z__10.r = z__11.r * rxl.r - z__11.i * rxl.i, z__10.i = z__11.r * rxl.i + 
	    z__11.i * rxl.r;
    z__9.r = z__10.r + srgam_1.c4.r, z__9.i = z__10.i + srgam_1.c4.i;
    z__8.r = z__9.r * rxl.r - z__9.i * rxl.i, z__8.i = z__9.r * rxl.i + 
	    z__9.i * rxl.r;
    z__7.r = z__8.r - srgam_1.c3.r, z__7.i = z__8.i - srgam_1.c3.i;
    z__6.r = z__7.r * rxl.r - z__7.i * rxl.i, z__6.i = z__7.r * rxl.i + 
	    z__7.i * rxl.r;
    z__5.r = z__6.r + srgam_1.c2.r, z__5.i = z__6.i + srgam_1.c2.i;
    z__4.r = z__5.r * rxl.r - z__5.i * rxl.i, z__4.i = z__5.r * rxl.i + 
	    z__5.i * rxl.r;
    z__3.r = z__4.r - srgam_1.c1.r, z__3.i = z__4.i - srgam_1.c1.i;
    z__2.r = z__3.r * rxl.r - z__3.i * rxl.i, z__2.i = z__3.r * rxl.i + 
	    z__3.i * rxl.r;
    z__1.r = z__2.r + srgam_1.a1.r, z__1.i = z__2.i + srgam_1.a1.i;
    trm3.r = z__1.r, trm3.i = z__1.i;
L8:
    z__2.r = cgam2.r + cgam1.r, z__2.i = cgam2.i + cgam1.i;
    z_div(&z__1, &cexxp, &z__2);
    den1.r = z__1.r, den1.i = z__1.i;
    z__4.r = evlcom_2.ck1sq.r * cgam2.r - evlcom_2.ck1sq.i * cgam2.i, z__4.i =
	     evlcom_2.ck1sq.r * cgam2.i + evlcom_2.ck1sq.i * cgam2.r;
    z__5.r = evlcom_2.ck2sq.r * cgam1.r - evlcom_2.ck2sq.i * cgam1.i, z__5.i =
	     evlcom_2.ck2sq.r * cgam1.i + evlcom_2.ck2sq.i * cgam1.r;
    z__3.r = z__4.r + z__5.r, z__3.i = z__4.i + z__5.i;
    z__2.r = evlcom_2.cksm.r * z__3.r - evlcom_2.cksm.i * z__3.i, z__2.i = 
	    evlcom_2.cksm.r * z__3.i + evlcom_2.cksm.i * z__3.r;
    z_div(&z__1, &cexzd, &z__2);
    den3.r = z__1.r, den3.i = z__1.i;
    z__5.r = cgam2.r * evlcom_2.ck1sq.r - cgam2.i * evlcom_2.ck1sq.i, z__5.i =
	     cgam2.r * evlcom_2.ck1sq.i + cgam2.i * evlcom_2.ck1sq.r;
    z__4.r = z__5.r * trm1.r - z__5.i * trm1.i, z__4.i = z__5.r * trm1.i + 
	    z__5.i * trm1.r;
    z__6.r = evlcom_2.ck2sq.r * trm2.r - evlcom_2.ck2sq.i * trm2.i, z__6.i = 
	    evlcom_2.ck2sq.r * trm2.i + evlcom_2.ck2sq.i * trm2.r;
    z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
    z__2.r = z__3.r * den3.r - z__3.i * den3.i, z__2.i = z__3.r * den3.i + 
	    z__3.i * den3.r;
    z_div(&z__1, &z__2, &cgam2);
    den2.r = z__1.r, den2.i = z__1.i;
    z__4.r = cgam1.r * evlcom_2.ck2sq.r - cgam1.i * evlcom_2.ck2sq.i, z__4.i =
	     cgam1.r * evlcom_2.ck2sq.i + cgam1.i * evlcom_2.ck2sq.r;
    z__3.r = z__4.r * trm1.r - z__4.i * trm1.i, z__3.i = z__4.r * trm1.i + 
	    z__4.i * trm1.r;
    z__5.r = evlcom_2.ck1sq.r * trm3.r - evlcom_2.ck1sq.i * trm3.i, z__5.i = 
	    evlcom_2.ck1sq.r * trm3.i + evlcom_2.ck1sq.i * trm3.r;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = z__2.r * den3.r - z__2.i * den3.i, z__1.i = z__2.r * den3.i + 
	    z__2.i * den3.r;
    den3.r = z__1.r, den3.i = z__1.i;
    goto L10;

/*     INTEGRAND ON THE BRANCH CUT FROM K1 */

L9:
    if (d_imag(&com) >= 0.f) {
	z__1.r = -cgam1.r, z__1.i = -cgam1.i;
	cgam1.r = z__1.r, cgam1.i = z__1.i;
    }
    z__3.r = evlcom_2.zp * cgam1.r, z__3.i = evlcom_2.zp * cgam1.i;
    z__4.r = evlcom_2.zz * cgam2.r, z__4.i = evlcom_2.zz * cgam2.i;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    zzexp_(&z__1, &z__2);
    cexxp.r = z__1.r, cexxp.i = z__1.i;
    z__4.r = -cgam1.r, z__4.i = -cgam1.i;
    z__3.r = evlcom_2.zp * z__4.r, z__3.i = evlcom_2.zp * z__4.i;
    z__5.r = evlcom_2.zz * cgam2.r, z__5.i = evlcom_2.zz * cgam2.i;
    z__2.r = z__3.r - z__5.r, z__2.i = z__3.i - z__5.i;
    zzexp_(&z__1, &z__2);
    cexxm.r = z__1.r, cexxm.i = z__1.i;
    z__3.r = cgam2.r - cgam1.r, z__3.i = cgam2.i - cgam1.i;
    z_div(&z__2, &cexxm, &z__3);
    z__5.r = cgam2.r + cgam1.r, z__5.i = cgam2.i + cgam1.i;
    z_div(&z__4, &cexxp, &z__5);
    z__1.r = z__2.r - z__4.r, z__1.i = z__2.i - z__4.i;
    den1.r = z__1.r, den1.i = z__1.i;
    z__3.r = evlcom_2.ck1sq.r * cgam2.r - evlcom_2.ck1sq.i * cgam2.i, z__3.i =
	     evlcom_2.ck1sq.r * cgam2.i + evlcom_2.ck1sq.i * cgam2.r;
    z__4.r = evlcom_2.ck2sq.r * cgam1.r - evlcom_2.ck2sq.i * cgam1.i, z__4.i =
	     evlcom_2.ck2sq.r * cgam1.i + evlcom_2.ck2sq.i * cgam1.r;
    z__2.r = z__3.r - z__4.r, z__2.i = z__3.i - z__4.i;
    z_div(&z__1, &cexxm, &z__2);
    trm1.r = z__1.r, trm1.i = z__1.i;
    z__3.r = evlcom_2.ck1sq.r * cgam2.r - evlcom_2.ck1sq.i * cgam2.i, z__3.i =
	     evlcom_2.ck1sq.r * cgam2.i + evlcom_2.ck1sq.i * cgam2.r;
    z__4.r = evlcom_2.ck2sq.r * cgam1.r - evlcom_2.ck2sq.i * cgam1.i, z__4.i =
	     evlcom_2.ck2sq.r * cgam1.i + evlcom_2.ck2sq.i * cgam1.r;
    z__2.r = z__3.r + z__4.r, z__2.i = z__3.i + z__4.i;
    z_div(&z__1, &cexxp, &z__2);
    trm2.r = z__1.r, trm2.i = z__1.i;
    z__1.r = trm1.r - trm2.r, z__1.i = trm1.i - trm2.i;
    den2.r = z__1.r, den2.i = z__1.i;
    z__2.r = -cgam1.r, z__2.i = -cgam1.i;
    z__3.r = trm1.r + trm2.r, z__3.i = trm1.i + trm2.i;
    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r * z__3.i + 
	    z__2.i * z__3.r;
    den3.r = z__1.r, den3.i = z__1.i;

/*     EVALUATE INTEGRANDS FOR EACH OF THE 6 FUNCTIONS */

L10:
    z__1.r = xl.r * dxl.r - xl.i * dxl.i, z__1.i = xl.r * dxl.i + xl.i * 
	    dxl.r;
    com.r = z__1.r, com.i = z__1.i;
    if (evlcom_2.rho < 1e-20f && evlcom_2.jh == 0) {
	goto L11;
    }
    z__3.r = -den2.r, z__3.i = -den2.i;
    z__5.r = b0p.r / evlcom_2.rho, z__5.i = b0p.i / evlcom_2.rho;
    z__7.r = b0.r * xl.r - b0.i * xl.i, z__7.i = b0.r * xl.i + b0.i * xl.r;
    z__6.r = z__7.r * xl.r - z__7.i * xl.i, z__6.i = z__7.r * xl.i + z__7.i * 
	    xl.r;
    z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i, z__2.i = z__3.r * z__4.i + 
	    z__3.i * z__4.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[3].r = z__1.r, ans[3].i = z__1.i;
    z__3.r = den2.r * b0p.r - den2.i * b0p.i, z__3.i = den2.r * b0p.i + 
	    den2.i * b0p.r;
    z__2.r = z__3.r * com.r - z__3.i * com.i, z__2.i = z__3.r * com.i + 
	    z__3.i * com.r;
    z__1.r = z__2.r / evlcom_2.rho, z__1.i = z__2.i / evlcom_2.rho;
    ans[4].r = z__1.r, ans[4].i = z__1.i;
    goto L12;
L11:
    z__4.r = -den2.r, z__4.i = -den2.i;
    z__3.r = z__4.r * xl.r - z__4.i * xl.i, z__3.i = z__4.r * xl.i + z__4.i * 
	    xl.r;
    z__2.r = z__3.r * xl.r - z__3.i * xl.i, z__2.i = z__3.r * xl.i + z__3.i * 
	    xl.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[3].r = z__1.r, ans[3].i = z__1.i;
    ans[4].r = ans[3].r, ans[4].i = ans[3].i;
L12:
    z__4.r = -den2.r, z__4.i = -den2.i;
    z__3.r = z__4.r * cgam2.r - z__4.i * cgam2.i, z__3.i = z__4.r * cgam2.i + 
	    z__4.i * cgam2.r;
    z__2.r = z__3.r * b0p.r - z__3.i * b0p.i, z__2.i = z__3.r * b0p.i + 
	    z__3.i * b0p.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[1].r = z__1.r, ans[1].i = z__1.i;
    z__4.r = den2.r * b0.r - den2.i * b0.i, z__4.i = den2.r * b0.i + den2.i * 
	    b0.r;
    z__3.r = z__4.r * xl.r - z__4.i * xl.i, z__3.i = z__4.r * xl.i + z__4.i * 
	    xl.r;
    z__2.r = z__3.r * xl.r - z__3.i * xl.i, z__2.i = z__3.r * xl.i + z__3.i * 
	    xl.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[2].r = z__1.r, ans[2].i = z__1.i;
    z__2.r = den3.r * b0p.r - den3.i * b0p.i, z__2.i = den3.r * b0p.i + 
	    den3.i * b0p.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[5].r = z__1.r, ans[5].i = z__1.i;
    z__2.r = den1.r * b0.r - den1.i * b0.i, z__2.i = den1.r * b0.i + den1.i * 
	    b0.r;
    z__1.r = z__2.r * com.r - z__2.i * com.i, z__1.i = z__2.r * com.i + 
	    z__2.i * com.r;
    ans[6].r = z__1.r, ans[6].i = z__1.i;
    return 0;
} /* saob_ */

doublereal scnrm2_(integer *n, doublecomplex *cx, integer *incx)
{
    /* Initialized data */

    static doublereal zero = 0.;
    static doublereal one = 1.;
    static doublereal cutlo = 4.441e-16;
    static doublereal cuthi = 1.304e19;

    /* Format strings */
    static char fmt_2[] = "";
    static char fmt_3[] = "";
    static char fmt_6[] = "";
    static char fmt_11[] = "";
    static char fmt_7[] = "";

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal ret_val, d__1;

    /* Builtin functions */
    double d_imag(doublecomplex *), sqrt(doublereal);

    /* Local variables */
    static integer i__, nn;
    static doublereal sum;
    static logical imag;
    static doublereal absx, xmax;
    static integer next;
    static logical scale;
    static doublereal hitest;

    /* Assigned format variables */
    static char *next_fmt;

/*  ***BEGIN PROLOGUE  SCNRM2 */
/*     REVISION DATE  811015   (YYMMDD) */
/*     CATEGORY NO.  F1A */
/*     KEYWORDS  BLAS,VECTOR,COMPLEX,UNITARY NORM,NORM */
/*     DATE WRITTEN  OCTOBER 1979 */
/*     AUTHOR LAWSON C. (JPL),HANSON R. (SLA), */
/*                            KINCAID D. (U TEXAS), KROGH F. (JPL) */
/*  ***PURPOSE */
/*     UNITARY NORM OF COMPLEX VECTOR */
/*  ***DESCRIPTION */
/*                B L A S  SUBPROGRAM */
/*     DESCRIPTION OF PARAMETERS */

/*     --INPUT-- */
/*        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S) */
/*       CX  COMPLEX VECTOR WITH N ELEMENTS */
/*     INCX  STORAGE SPACING BETWEEN ELEMENTS OF CX */

/*     --OUTPUT-- */
/*     SCNRM2  SINGLE PRECISION RESULT (ZERO IF N.LE.0) */

/*     UNITARY NORM OF THE COMPLEX N-VECTOR STORED IN CX() WITH STORAGE */
/*     INCREMENT INCX . */
/*     IF    N .LE. 0 RETURN WITH RESULT = 0. */
/*     IF N .GE. 1 THEN INCX MUST BE .GE. 1 */

/*           C.L.LAWSON , 1978 JAN 08 */

/*     FOUR PHASE METHOD     USING TWO BUILT-IN CONSTANTS THAT ARE */
/*     HOPEFULLY APPLICABLE TO ALL MACHINES. */
/*         CUTLO = MAXIMUM OF  SQRT(U/EPS)  OVER ALL KNOWN MACHINES. */
/*         CUTHI = MINIMUM OF  SQRT(V)      OVER ALL KNOWN MACHINES. */
/*     WHERE */
/*         EPS = SMALLEST NO. SUCH THAT EPS + 1. .GT. 1. */
/*         U   = SMALLEST POSITIVE NO.   (UNDERFLOW LIMIT) */
/*         V   = LARGEST  NO.            (OVERFLOW  LIMIT) */

/*     BRIEF OUTLINE OF ALGORITHM.. */

/*     PHASE 1    SCANS ZERO COMPONENTS. */
/*     MOVE TO PHASE 2 WHEN A COMPONENT IS NONZERO AND .LE. CUTLO */
/*     MOVE TO PHASE 3 WHEN A COMPONENT IS .GT. CUTLO */
/*     MOVE TO PHASE 4 WHEN A COMPONENT IS .GE. CUTHI/M */
/*     WHERE M = N FOR X() REAL AND M = 2*N FOR COMPLEX. */

/*     VALUES FOR CUTLO AND CUTHI.. */
/*     FROM THE ENVIRONMENTAL PARAMETERS LISTED IN THE IMSL CONVERTER */
/*     DOCUMENT THE LIMITING VALUES ARE AS FOLLOWS.. */
/*     CUTLO, S.P.   U/EPS = 2**(-102) FOR  HONEYWELL.  CLOSE SECONDS ARE */
/*                   UNIVAC AND DEC AT 2**(-103) */
/*                   THUS CUTLO = 2**(-51) = 4.44089E-16 */
/*     CUTHI, S.P.   V = 2**127 FOR UNIVAC, HONEYWELL, AND DEC. */
/*                   THUS CUTHI = 2**(63.5) = 1.30438E19 */
/*     CUTLO, D.P.   U/EPS = 2**(-67) FOR HONEYWELL AND DEC. */
/*                   THUS CUTLO = 2**(-33.5) = 8.23181D-11 */
/*     CUTHI, D.P.   SAME AS S.P.  CUTHI = 1.30438D19 */
/*     DATA CUTLO, CUTHI / 8.232D-11,  1.304D19 / */
/*     DATA CUTLO, CUTHI / 4.441E-16,  1.304E19 / */

/*  ***REFERENCES */
/*     LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T., */
/*     BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*, */
/*     ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL SOFTWARE, */
/*     VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323 */
/*     ROUTINES CALLED  (NONE) */
/*  ***END PROLOGUE  SCNRM2 */
    /* Parameter adjustments */
    --cx;

    /* Function Body */

/*     FIRST EXECUTABLE STATEMENT  SCNRM2 */
    if (*n > 0) {
	goto L1;
    }
    ret_val = zero;
    goto L14;

L1:
    next = 0;
    next_fmt = fmt_2;
    sum = zero;
    nn = *n * *incx;
/*                                                 BEGIN MAIN LOOP */
    i__1 = nn;
    i__2 = *incx;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	i__3 = i__;
	absx = (d__1 = cx[i__3].r, abs(d__1));
	imag = FALSE_;
	switch (next) {
	    case 0: goto L2;
	    case 1: goto L3;
	    case 2: goto L6;
	    case 3: goto L7;
	    case 4: goto L11;
	}
L2:
	if (absx > cutlo) {
	    goto L10;
	}
	next = 1;
	next_fmt = fmt_3;
	scale = FALSE_;

/*                        PHASE 1.  SUM IS ZERO */

L3:
	if (absx == zero) {
	    goto L12;
	}
	if (absx > cutlo) {
	    goto L10;
	}

/*                                PREPARE FOR PHASE 2. */
	next = 2;
	next_fmt = fmt_6;
	goto L5;

/*                                PREPARE FOR PHASE 4. */

L4:
	next = 3;
	next_fmt = fmt_7;
	sum = sum / absx / absx;
L5:
	scale = TRUE_;
	xmax = absx;
	goto L8;

/*                   PHASE 2.  SUM IS SMALL. */
/*                             SCALE TO AVOID DESTRUCTIVE UNDERFLOW. */

L6:
	if (absx > cutlo) {
	    goto L9;
	}

/*                     COMMON CODE FOR PHASES 2 AND 4. */
/*                     IN PHASE 4 SUM IS LARGE.  SCALE TO AVOID OVERFLOW. */

L7:
	if (absx <= xmax) {
	    goto L8;
	}
/* Computing 2nd power */
	d__1 = xmax / absx;
	sum = one + sum * (d__1 * d__1);
	xmax = absx;
	goto L12;

L8:
/* Computing 2nd power */
	d__1 = absx / xmax;
	sum += d__1 * d__1;
	goto L12;


/*                  PREPARE FOR PHASE 3. */

L9:
	sum = sum * xmax * xmax;

L10:
	next = 4;
	next_fmt = fmt_11;
	scale = FALSE_;

/*     FOR REAL OR D.P. SET HITEST = CUTHI/N */
/*     FOR COMPLEX      SET HITEST = CUTHI/(2*N) */

	hitest = cuthi / (real) (*n);

/*                   PHASE 3.  SUM IS MID-RANGE.  NO SCALING. */

L11:
	if (absx >= hitest) {
	    goto L4;
	}
/* Computing 2nd power */
	d__1 = absx;
	sum += d__1 * d__1;
L12:
/*                  CONTROL SELECTION OF REAL AND IMAGINARY PARTS. */

	if (imag) {
	    goto L13;
	}
	absx = (d__1 = d_imag(&cx[i__]), abs(d__1));
	imag = TRUE_;
	switch (next) {
	    case 0: goto L2;
	    case 1: goto L3;
	    case 2: goto L6;
	    case 3: goto L7;
	    case 4: goto L11;
	}

L13:
	;
    }

/*              END OF MAIN LOOP. */
/*              COMPUTE SQUARE ROOT AND ADJUST FOR SCALING. */

    ret_val = sqrt(sum);
    if (scale) {
	ret_val *= xmax;
    }
L14:
    return ret_val;
} /* scnrm2_ */

/* Subroutine */ int somset_(void)
{
    return 0;
} /* somset_ */

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/* Subroutine */ int somlsq_(doublecomplex *epsc, doublereal *elgnd)
{
    /* Initialized data */

    static doublereal rh1a[3] = { 0.,.2,.6 };
    static doublereal drha[3] = { .2,.1,.2 };
    static integer nrha[3] = { 4,5,5 };
    static integer nreg = 3;
    static doublereal zz1a[3] = { .2,0.,0. };
    static doublereal dzza[3] = { .2,.1,.2 };
    static integer nzza[3] = { 4,4,4 };
    static doublereal zp1a[3] = { 0.,0.,0. };
    static doublereal dzpa[3] = { .1,.1,.1 };
    static integer nzpa[3] = { 2,2,2 };
    static doublereal srh1a[3] = { 0.,.2,.6 };
    static integer nsrha[3] = { 5,6,8 };
    static doublereal szz1a[3] = { .2,0.,0. };
    static integer nszza[3] = { 2,2,2 };
    static doublereal szp1a[3] = { 0.,0.,0. };
    static integer nszpa[3] = { 2,3,3 };

    /* Format strings */
    static char fmt_3[] = "(\002 SOMMERFELD GROUND L.S. APPROX:\002,//,\002 "
	    "EPSC=\002,1p2e12.5)";
    static char fmt_4[] = "(//,15x,\002RHO:\002,21x,\002ZZ:\002,22x,\002ZP"
	    ":\002,/,\002 REGION\002,i2,\002:\002,3(2f10.5,5x))";
    static char fmt_5[] = "(\002 PTS. FIT:\002,3(2f10.5,i5))";
    static char fmt_6[] = "(/,\002 NO. FUNCTIONS:\002,2i4,/,\002 RMS RESIDUA"
	    "LS:\002,1p5e11.3)";
    static char fmt_7[] = "(/,\002 FIELD EVALUATION TIME IN SOMLSQ\002,f8.3"
	    ",\002 SECONDS\002)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    double d_imag(doublecomplex *), exp(doublereal);

    /* Local variables */
    static integer ir;
    static doublereal tim, tim1, tim2, dsrha[3];
    static integer ifunc;
    static doublereal dszpa[3], dszza[3];
    extern /* Subroutine */ int second_(doublereal *), rzzfit_(integer *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___3077 = { 0, 3, 0, fmt_3, 0 };
    static cilist io___3083 = { 0, 3, 0, fmt_4, 0 };
    static cilist io___3084 = { 0, 3, 0, fmt_5, 0 };
    static cilist io___3085 = { 0, 3, 0, fmt_5, 0 };
    static cilist io___3086 = { 0, 3, 0, fmt_6, 0 };
    static cilist io___3087 = { 0, 3, 0, fmt_7, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOMLSQ DETERMINES PARAMETERS FOR L.S. APPROXIMATION OF SOMMERFELD */
/*     INTEGRALS.  APPROXIMATIONS ARE DEVELOPED FOR 3 REGIONS.  THE NUM- */
/*     BER OF FITTED POINTS AND THEIR SPACING IS SET IN DATA STATEMENTS. */

    ptfit_1.iqax = 0;
    zz1a[0] = *elgnd;
    dzpa[0] = *elgnd * .4f;
    rh1a[1] = *elgnd;
    drha[1] = (rh1a[2] - rh1a[1]) / (nrha[1] - 1);
    dzza[1] = *elgnd * .5f;
    dzpa[1] = *elgnd * .4f;
    dzpa[2] = *elgnd * .4f;
    dsrha[0] = .025f;
    szz1a[0] = zz1a[0];
    dszza[0] = dzza[0];
    dszpa[0] = dzpa[0];
    srh1a[1] = *elgnd;
    dsrha[1] = *elgnd * .2f;
    dszza[1] = *elgnd * .4f;
    dszpa[1] = *elgnd * .5f;
    dsrha[2] = *elgnd * .2f;
    dszza[2] = *elgnd * .4f;
    dszpa[2] = *elgnd * .5f;
    gregon_1.zza[0] = zz1a[0];
    gregon_1.rhoa[1] = rh1a[1];
    gregon_1.zzb[1] = zz1a[1] + (nzza[1] - 1) * dzza[1];
    if (prntcm_1.ismprt != 0) {
	s_wsfe(&io___3077);
	do_fio(&c__2, (char *)&(*epsc), (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    tim = 0.f;
/*     LOOP OVER REGIONS */
    i__1 = nreg;
    for (ir = 1; ir <= i__1; ++ir) {
	ifunc = 1;
	if (ir == 1) {
	    ifunc = 0;
	}
	ptfit_1.rh1 = rh1a[ir - 1];
	ptfit_1.drh = drha[ir - 1];
	ptfit_1.nrh = nrha[ir - 1];
	ptfit_1.zz1 = zz1a[ir - 1];
	ptfit_1.dzz = dzza[ir - 1];
	ptfit_1.nzz = nzza[ir - 1];
	ptfit_1.zp1 = zp1a[ir - 1];
	ptfit_1.dzp = dzpa[ir - 1];
	ptfit_1.nzp = nzpa[ir - 1];
	ptfit_1.srh1 = srh1a[ir - 1];
	ptfit_1.dsrh = dsrha[ir - 1];
	ptfit_1.nsrh = nsrha[ir - 1];
	ptfit_1.szz1 = szz1a[ir - 1];
	ptfit_1.dszz = dszza[ir - 1];
	ptfit_1.nszz = nszza[ir - 1];
	ptfit_1.szp1 = szp1a[ir - 1];
	ptfit_1.dszp = dszpa[ir - 1];
	ptfit_1.nszp = nszpa[ir - 1];
	if (exp(d_imag(&gparm_1.gck1) * ptfit_1.rh1) < 1e-8f) {
	    ifunc = 0;
	}
	second_(&tim1);
	rzzfit_(&ir, &ifunc);
	second_(&tim2);
	tim = tim + tim2 - tim1;
	if (prntcm_1.ismprt != 0) {
	    s_wsfe(&io___3083);
	    do_fio(&c__1, (char *)&ir, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&gregon_1.rhoa[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gregon_1.rhob[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gregon_1.zza[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gregon_1.zzb[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gregon_1.zpa[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gregon_1.zpb[ir - 1], (ftnlen)sizeof(
		    doublereal));
	    e_wsfe();
	    s_wsfe(&io___3084);
	    do_fio(&c__1, (char *)&ptfit_1.rh1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.drh, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nrh, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&ptfit_1.zz1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.dzz, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nzz, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&ptfit_1.zp1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.dzp, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nzp, (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_wsfe(&io___3085);
	    do_fio(&c__1, (char *)&ptfit_1.srh1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.dsrh, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nsrh, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&ptfit_1.szz1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.dszz, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nszz, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&ptfit_1.szp1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.dszp, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.nszp, (ftnlen)sizeof(integer));
	    e_wsfe();
	    s_wsfe(&io___3086);
	    do_fio(&c__1, (char *)&cofit_1.mfunf[ir - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&cofit_1.mfunc[ir - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&ptfit_1.res1, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.res2, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.res3, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.res4, (ftnlen)sizeof(doublereal));
	    do_fio(&c__1, (char *)&ptfit_1.res5, (ftnlen)sizeof(doublereal));
	    e_wsfe();
	}
/* L2: */
    }
    if (prntcm_1.ismprt != 0) {
	s_wsfe(&io___3087);
	do_fio(&c__1, (char *)&tim, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

} /* somlsq_ */

/* Subroutine */ int somtrp_(doublecomplex *epsc, doublereal *elgnd)
{
    /* Format strings */
    static char fmt_10[] = "(\002 SOMTRP: ERROR - ARRAY OVERFLOW - NPTS=\002"
	    ",i10)";
    static char fmt_11[] = "(\002 FIELD EVALUATION TIME IN SOMTRP\002,f8.3"
	    ",\002 SECONDS\002)";
    static char fmt_12[] = "(//,\002 INTERPOLATION DATA FILE:\002,//,\002 EP"
	    "SC=\002,1p2e12.5,//,\002 GRID\002,5x,\002RHO:\002,27x,\002ZZ:"
	    "\002,27x,\002ZP:\002)";
    static char fmt_13[] = "(i4,3(1x,1p2e12.5,i4,1x))";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6;

    /* Builtin functions */
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double z_abs(doublecomplex *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    double sqrt(doublereal);
    void z_exp(doublecomplex *, doublecomplex *);

    /* Local variables */
    static integer i__, k;
    static doublereal r__, rz;
    static doublecomplex eph, erh;
    static integer irh;
    static doublecomplex ezh, erv;
    static integer izp;
    static doublecomplex ezv, exx;
    static integer izz;
    static doublereal zpx, zzx, tim1, tim2;
    static integer iqax, nrhk, indx;
    static doublereal rhox;
    static integer nzpk, npts, nzzk;
    static doublereal zppx, elmax;
    extern /* Subroutine */ int evlub_(doublereal *, doublereal *, doublereal 
	    *, integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
	    doublecomplex *, doublecomplex *);
    static integer mxdim, indxx;
    extern /* Subroutine */ int second_(doublereal *);

    /* Fortran I/O blocks */
    static cilist io___3092 = { 0, 3, 0, fmt_10, 0 };
    static cilist io___3116 = { 0, 3, 0, fmt_11, 0 };
    static cilist io___3117 = { 0, 3, 0, fmt_12, 0 };
    static cilist io___3119 = { 0, 3, 0, fmt_13, 0 };


/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     SOMTRP FILLS THE INTERPOLATION TABLES FOR 3 REGIONS FOR SMALL RHO */

/*     INPUT: */
/*     EPSC = COMPLEX RELATIVE PERMITTIVITY OF THE GROUND */
/*     ELGND = DISTANCE THAT INTERPOLATION GRID EXTENDS INTO LOWER MEDIUM */

    mxdim = 1200;
    z_div(&z__1, &gparm_1.gck2, &gparm_1.gck1);
    elmax = z_abs(&z__1) * 15.f;
    if (elmax > 1.f) {
	elmax = 1.f;
    }
    gridy_1.drh[0] = *elgnd / (gridy_1.nrh[0] - 1);
    gridy_1.drh[1] = *elgnd / (gridy_1.nrh[1] - 1);
    gridy_1.drh[2] = *elgnd / (gridy_1.nrh[2] - 1);
    gridy_1.dzz[0] = *elgnd / (gridy_1.nzz[0] - 1);
    gridy_1.dzz[1] = *elgnd / (gridy_1.nzz[1] - 1);
    gridy_1.dzz[2] = *elgnd / (gridy_1.nzz[2] - 1);
    gridy_1.dzp[0] = *elgnd / (gridy_1.nzp[0] - 1) * .4f;
    gridy_1.zp1[1] = gridy_1.zp1[0] + gridy_1.dzp[0] * (gridy_1.nzp[0] - 1.3f)
	    ;
    gridy_1.dzp[1] = (*elgnd - gridy_1.zp1[1]) / (gridy_1.nzp[1] - 1);
    gridy_1.zp1[2] = gridy_1.zp1[1] + gridy_1.dzp[1] * (gridy_1.nzp[1] - 1.3f)
	    ;
    gridy_1.dzp[2] = (elmax - gridy_1.zp1[2]) / (gridy_1.nzp[2] - 1);
    npts = 0;
    for (k = 1; k <= 3; ++k) {
	gridy_1.drzzp[k - 1] = gridy_1.drh[k - 1] * gridy_1.dzz[k - 1] * 
		gridy_1.dzp[k - 1];
	gridy_1.npt[k - 1] = gridy_1.nrh[k - 1] * gridy_1.nzz[k - 1] * 
		gridy_1.nzp[k - 1];
/* L1: */
	npts += gridy_1.npt[k - 1];
    }
    if (npts > mxdim) {
	s_wsfe(&io___3092);
	do_fio(&c__1, (char *)&npts, (ftnlen)sizeof(integer));
	e_wsfe();
	s_stop("", (ftnlen)0);
    }
    iqax = 1;
    indxx = 0;
    second_(&tim1);
    for (k = 1; k <= 3; ++k) {
	if (k > 1) {
	    iqax = 0;
	}
	if (k > 1) {
	    indxx += gridy_1.npt[k - 2];
	}
	nrhk = gridy_1.nrh[k - 1];
	nzzk = gridy_1.nzz[k - 1];
	nzpk = gridy_1.nzp[k - 1];
	rhox = gridy_1.rh1[k - 1] - gridy_1.drh[k - 1];
	i__1 = nrhk;
	for (irh = 1; irh <= i__1; ++irh) {
	    rhox += gridy_1.drh[k - 1];
	    zzx = gridy_1.zz1[k - 1] - gridy_1.dzz[k - 1];
	    i__2 = nzzk;
	    for (izz = 1; izz <= i__2; ++izz) {
		zzx += gridy_1.dzz[k - 1];
		zppx = gridy_1.zp1[k - 1] - gridy_1.dzp[k - 1];
		i__3 = nzpk;
		for (izp = 1; izp <= i__3; ++izp) {
		    zppx += gridy_1.dzp[k - 1];
		    zpx = -zppx;
		    evlub_(&rhox, &zzx, &zpx, &iqax, &erv, &ezv, &erh, &eph, &
			    ezh);
		    indx = nrhk * (nzzk * (izp - 1) + izz - 1) + irh + indxx;
/* Computing 2nd power */
		    d__1 = zzx - zpx;
		    r__ = sqrt(rhox * rhox + d__1 * d__1);
/*     EXPONENTIAL FACTORS ARE DIVIDED OUT FOR EACH REGION TO REDUCE */
/*     OSCILLATIONS.  FOR REGIONS 2 AND 3 THE VALUES ARE MULTIPLIED BY R */
/*     HERE.  ANOTHER MULTIPLICATION BY R OCCURS IN EVLUB FOR ALL REGIONS */
		    if (k == 1) {
			z__3.r = gparm_1.gck2.r * -0.f - gparm_1.gck2.i * 
				-1.f, z__3.i = gparm_1.gck2.r * -1.f + 
				gparm_1.gck2.i * -0.f;
			z__2.r = r__ * z__3.r, z__2.i = r__ * z__3.i;
			z_exp(&z__1, &z__2);
			exx.r = z__1.r, exx.i = z__1.i;
		    } else if (k == 2) {
			rz = sqrt(rhox * rhox + zzx * zzx);
			z__5.r = rz * gparm_1.gck2.r, z__5.i = rz * 
				gparm_1.gck2.i;
			z__6.r = zpx * gparm_1.gck1.r, z__6.i = zpx * 
				gparm_1.gck1.i;
			z__4.r = z__5.r - z__6.r, z__4.i = z__5.i - z__6.i;
			z__3.r = z__4.r * -0.f - z__4.i * -1.f, z__3.i = 
				z__4.r * -1.f + z__4.i * -0.f;
			z_exp(&z__2, &z__3);
			z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
			exx.r = z__1.r, exx.i = z__1.i;
		    } else {
			rz = sqrt(rhox * rhox + zpx * zpx);
			z__5.r = zzx * gparm_1.gck2.r, z__5.i = zzx * 
				gparm_1.gck2.i;
			z__6.r = rz * gparm_1.gck1.r, z__6.i = rz * 
				gparm_1.gck1.i;
			z__4.r = z__5.r + z__6.r, z__4.i = z__5.i + z__6.i;
			z__3.r = z__4.r * -0.f - z__4.i * -1.f, z__3.i = 
				z__4.r * -1.f + z__4.i * -0.f;
			z_exp(&z__2, &z__3);
			z__1.r = z__2.r / r__, z__1.i = z__2.i / r__;
			exx.r = z__1.r, exx.i = z__1.i;
		    }
		    i__4 = indx - 1;
		    z_div(&z__1, &erv, &exx);
		    gridy_1.a1[i__4].r = z__1.r, gridy_1.a1[i__4].i = z__1.i;
		    i__4 = indx - 1;
		    z_div(&z__1, &ezv, &exx);
		    gridy_1.a2[i__4].r = z__1.r, gridy_1.a2[i__4].i = z__1.i;
		    i__4 = indx - 1;
		    z_div(&z__1, &erh, &exx);
		    gridy_1.a3[i__4].r = z__1.r, gridy_1.a3[i__4].i = z__1.i;
		    i__4 = indx - 1;
		    z_div(&z__1, &eph, &exx);
		    gridy_1.a4[i__4].r = z__1.r, gridy_1.a4[i__4].i = z__1.i;
		    i__4 = indx - 1;
		    z_div(&z__1, &ezh, &exx);
		    gridy_1.a5[i__4].r = z__1.r, gridy_1.a5[i__4].i = z__1.i;
/* L7: */
		}
	    }
	}
/* L8: */
    }
    second_(&tim2);
    tim2 -= tim1;
    if (prntcm_1.ismprt != 0) {
	s_wsfe(&io___3116);
	do_fio(&c__1, (char *)&tim2, (ftnlen)sizeof(doublereal));
	e_wsfe();
	s_wsfe(&io___3117);
	do_fio(&c__2, (char *)&(*epsc), (ftnlen)sizeof(doublereal));
	e_wsfe();
	for (i__ = 1; i__ <= 3; ++i__) {
/* L9: */
	    s_wsfe(&io___3119);
	    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	    do_fio(&c__1, (char *)&gridy_1.rh1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.drh[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.nrh[i__ - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&gridy_1.zz1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.dzz[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.nzz[i__ - 1], (ftnlen)sizeof(
		    integer));
	    do_fio(&c__1, (char *)&gridy_1.zp1[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.dzp[i__ - 1], (ftnlen)sizeof(
		    doublereal));
	    do_fio(&c__1, (char *)&gridy_1.nzp[i__ - 1], (ftnlen)sizeof(
		    integer));
	    e_wsfe();
	}
    }
    return 0;

} /* somtrp_ */

/* Subroutine */ int testc_(doublecomplex *f1, doublecomplex *f2, 
	doublecomplex *sum, doublereal *tr)
{
    /* System generated locals */
    doublereal d__1, d__2;
    doublecomplex z__1, z__2;

    /* Builtin functions */
    double z_abs(doublecomplex *);
    void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
    double d_imag(doublecomplex *);

    /* Local variables */
    static doublecomplex sx;
    static doublereal den;

/* ======================================================================= */
/*     (C) Copyright 1992 */
/*     The Regents of the University of California.  All rights reserved. */
/* ======================================================================= */

/*     TEST FOR CONVERGENCE IN NUMERICAL INTEGRATION */

    if (z_abs(f2) > 0.f) {
	z__2.r = f2->r - f1->r, z__2.i = f2->i - f1->i;
	z_div(&z__1, &z__2, f2);
	if (z_abs(&z__1) < 1e-7f) {
	    goto L1;
	}
    }
    z__1.r = sum->r + f2->r, z__1.i = sum->i + f2->i;
    sx.r = z__1.r, sx.i = z__1.i;
    den = (d__1 = sx.r, abs(d__1)) + (d__2 = d_imag(&sx), abs(d__2));
    if (den < 1e-18f) {
	goto L1;
    }
    z__1.r = f2->r - f1->r, z__1.i = f2->i - f1->i;
    *tr = z_abs(&z__1) / den;
    return 0;
L1:
    *tr = 0.f;
    return 0;
} /* testc_ */

