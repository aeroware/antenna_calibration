C     MAIN PROGRAM FOR SMITH CHART PROGRAM - Impedances read from 
C     NEC output file.
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER INF*2,COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      IDEV=2
      IDLASR=4
      IDTERM=IDEV
      IDPRNT=IDLASR
      ZNOR=50.
      IVSWR=3
      IPLOT=1
2     NCURVE=0
      FMIN=0.
      FMAX=0.
      CALL READNF(IERR)
      IF(IERR.EQ.0)CALL PLTSWH(IPLOT,IDEV)
1     WRITE(*,90)
      CALL READCM(5,INF,R1,R2,R3,R4,R5,R6,IERROR)
      IF(IERROR.NE.0)GO TO 1
      CALL UPCASE(INF,INF,LENGTH)
      IF(INF.EQ.'NF')THEN
         CALL READNF(IERR)
         IF(IERR.EQ.0)CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'AD')THEN
         CALL READAD(R1)
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'CL')THEN
         GO TO 2
      ELSE IF(INF.EQ.'ER')THEN
         CALL CERASE(R1,IERR)
         IF(IERR.EQ.0)CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'IN')THEN
         CALL YINTRP(R1,R2,R3,R4,IERR)
         IF(IERR.EQ.0)CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'YO')THEN
         CALL YOUT(R1)
      ELSE IF(INF.EQ.'ZO')THEN
         CALL ZOUT(R1)
      ELSE IF(INF.EQ.'YC')THEN
         IPLOT=1
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'YR')THEN
         IPLOT=2
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'YI')THEN
         IPLOT=3
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'ZC')THEN
         IPLOT=4
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'ZR')THEN
         IPLOT=5
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'ZI')THEN
         IPLOT=6
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'SC')THEN
         IPLOT=7
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'PT')THEN
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'PL')THEN
         CALL PLTSWH(IPLOT,IDLASR)
      ELSE IF(INF.EQ.'ZN')THEN
         CALL GETZNO(R1)
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'VC')THEN
         CALL SMITVC(INT(R1+.5))
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'PZ')THEN
         CALL SMITPZ(INT(R1+.5))
      ELSE IF(INF.EQ.'SH')THEN
         CALL SMITSH
      ELSE IF(INF.EQ.'SY')THEN
         CALL SYMBAL(R1,R2)
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'DV')THEN
         CALL CLEARS
         CALL GETDEV(IDEV)
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'FL')THEN
         CALL SETFL(R1,R2)
         CALL PLTSWH(IPLOT,IDEV)
      ELSE IF(INF.EQ.'ID')THEN
         CALL CURVID
      ELSE IF(INF.EQ.'EX')THEN
         CALL CLEARS
         CALL POSTDMP
         STOP
      ELSE
         WRITE(*,*)' INVALID COMMAND'
      END IF
      GO TO 1
C
90    FORMAT(' >',$)
      END
      SUBROUTINE SYMBAL(R1,R2)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      ICURVE=R1+.5
      ISKIP=R2+.5
      IF(ICURVE.LT.1.OR.ICURVE.GT.NCURVE)THEN
1        WRITE(*,90)
         READ(*,*,ERR=1)ICURVE
         IF(ICURVE.LT.1)RETURN
         IF(ICURVE.GT.NCURVE)GO TO 1
      END IF
      ISYM=1
      IF(ISKIP.LT.1)THEN
2        WRITE(*,91)
         READ(*,*,ERR=2)ISKIP
         IF(ISKIP.EQ.0)THEN
            ISKIP=1
            ISYM=0
         END IF
      END IF
      DO 3 I=1,NPTS(ICURVE),ISKIP
      ISYMB(I,ICURVE)=ISYM
3     CONTINUE
      RETURN
C
90    FORMAT(' Enter curve number >',$)
91    FORMAT(' Enter skip interval for labeling points >',$)
      END
      SUBROUTINE CURVID
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      CALL CLEARS
      DO 1 I=1,NCURVE
      WRITE(*,90)I,FDESC(I)(1:16),NPTS(I),FDESC(I)(17:38)
      WRITE(*,91)COML(I)
1     CONTINUE
90    FORMAT(I3,1X,A,'  NPTS=',I6,1X,A)
91    FORMAT(4X,A)
      RETURN
      END
      SUBROUTINE CERASE(R1,IERR)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      IERR=0
      IX=R1+.5
      IF(IX.LT.1)THEN
         WRITE(*,90)
         READ(*,*)IX
      END IF
      IF(IX.LT.1.OR.IX.GT.NCURVE)THEN
         WRITE(*,*)' Illegal curve number'
         IERR=1
         RETURN
      ELSE IF(IX.LT.NCURVE)THEN
         IX=IX+1
         DO 2 IC=IX,NCURVE
         DO 1 I=1,NPTS(IC)
         FREQA(I,IC-1)=FREQA(I,IC)
         YINA(I,IC-1)=YINA(I,IC)
         ISYMB(I,IC-1)=ISYMB(I,IC)
1        CONTINUE
         NPTS(IC-1)=NPTS(IC)
         FDESC(IC-1)=FDESC(IC)
         COML(IC-1)=COML(IC)
2        CONTINUE
      END IF
      NCURVE=NCURVE-1
      RETURN
C
90    FORMAT(' ENTER NUMBER OF CURVE TO BE ERASED >',$)
      END
      SUBROUTINE PLTSWH(IPLOT,IDEV)
      IF(IPLOT.EQ.1)THEN
         CALL YCPLOT(IDEV)
      ELSE IF(IPLOT.EQ.2)THEN
         CALL YRPLOT(IDEV)
      ELSE IF(IPLOT.EQ.3)THEN
         CALL YIPLOT(IDEV)
      ELSE IF(IPLOT.EQ.4)THEN
         CALL ZCPLOT(IDEV)
      ELSE IF(IPLOT.EQ.5)THEN
         CALL ZRPLOT(IDEV)
      ELSE IF(IPLOT.EQ.6)THEN
         CALL ZIPLOT(IDEV)
      ELSE IF(IPLOT.EQ.7)THEN
         CALL SMITHC(IDEV)
      END IF
      RETURN
      END
      SUBROUTINE FMINMX(XMIN,XMAX)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      XMIN=1.E10
      XMAX=-1.E10
      DO 1 IC=1,NCURVE
      FRQ=FREQA(1,IC)
      IF(FRQ.LT.XMIN)XMIN=FRQ
      FRQ=FREQA(NPTS(IC),IC)
      IF(FRQ.GT.XMAX)XMAX=FRQ
1     CONTINUE
      IF(FMAX.GT.0.)THEN
         IF(FMIN.GT.XMIN)XMIN=FMIN
         IF(FMAX.LT.XMAX)XMAX=FMAX
      END IF
      RETURN
      END
      SUBROUTINE YCPLOT(IDEV)
C
C     YCPLOT PLOTS THE COMPLEX ADMITTANCE -- CONDUCTANCE AND SUSCEPTANCE
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      YRPLT(IP,IC)=REAL(YINA(IP,IC))*1.E3
      YIPLT(IP,IC)=AIMAG(YINA(IP,IC))*1.E3
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YRPLT(IP,IC).LT.YMIN)YMIN=YRPLT(IP,IC)
         IF(YRPLT(IP,IC).GT.YMAX)YMAX=YRPLT(IP,IC)
         IF(YIPLT(IP,IC).LT.YMIN)YMIN=YIPLT(IP,IC)
         IF(YIPLT(IP,IC).GT.YMAX)YMAX=YIPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Admittance (mS)'//CHAR(0),
     &'Solid: Conductance     Dashed: Susceptance'//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL TRACEC(FREQA(1,IC),YRPLT(1,IC),NPTS(IC))
      CALL GSLTYP(3)
      CALL TRACEC(FREQA(1,IC),YIPLT(1,IC),NPTS(IC))
      CALL GSLTYP(1)
2     CONTINUE
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE YRPLOT(IDEV)
C
C     YRPLOT PLOTS THE CONDUCTANCE VERSUS FREQUENCY
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      YRPLT(IP,IC)=REAL(YINA(IP,IC))*1.E3
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YRPLT(IP,IC).LT.YMIN)YMIN=YRPLT(IP,IC)
         IF(YRPLT(IP,IC).GT.YMAX)YMAX=YRPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Conductance (mS)'//CHAR(0),' '//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL GSLTYP(IC)
      CALL TRACEC(FREQA(1,IC),YRPLT(1,IC),NPTS(IC))
2     CONTINUE
      CALL GSLTYP(1)
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE YIPLOT(IDEV)
C
C     YIPLOT PLOTS THE SUSCEPTANCE VERSUS FREQUENCY
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      YIPLT(IP,IC)=AIMAG(YINA(IP,IC))*1.E3
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YIPLT(IP,IC).LT.YMIN)YMIN=YIPLT(IP,IC)
         IF(YIPLT(IP,IC).GT.YMAX)YMAX=YIPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Susceptance (mS)'//CHAR(0),' '//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL GSLTYP(IC)
      CALL TRACEC(FREQA(1,IC),YIPLT(1,IC),NPTS(IC))
2     CONTINUE
      CALL GSLTYP(1)
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE ZCPLOT(IDEV)
C
C     ZCPLOT PLOTS THE COMPLEX IMPEDNACE -- RESISTANCE AND REACTANCE
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA,ZIN
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      ZIN=1./YINA(IP,IC)
      YRPLT(IP,IC)=REAL(ZIN)
      YIPLT(IP,IC)=AIMAG(ZIN)
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YRPLT(IP,IC).LT.YMIN)YMIN=YRPLT(IP,IC)
         IF(YRPLT(IP,IC).GT.YMAX)YMAX=YRPLT(IP,IC)
         IF(YIPLT(IP,IC).LT.YMIN)YMIN=YIPLT(IP,IC)
         IF(YIPLT(IP,IC).GT.YMAX)YMAX=YIPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Impedance (ohms)'//CHAR(0),
     &'Solid: Resistance     Dashed: Reactance'//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL TRACEC(FREQA(1,IC),YRPLT(1,IC),NPTS(IC))
      CALL GSLTYP(3)
      CALL TRACEC(FREQA(1,IC),YIPLT(1,IC),NPTS(IC))
      CALL GSLTYP(1)
2     CONTINUE
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE ZRPLOT(IDEV)
C
C     ZRPLOT PLOTS THE RESISTANCE VERSUS FREQUENCY
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      YRPLT(IP,IC)=REAL(1./YINA(IP,IC))
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YRPLT(IP,IC).LT.YMIN)YMIN=YRPLT(IP,IC)
         IF(YRPLT(IP,IC).GT.YMAX)YMAX=YRPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Resistance (ohms)'//CHAR(0),' '//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL GSLTYP(IC)
      CALL TRACEC(FREQA(1,IC),YRPLT(1,IC),NPTS(IC))
2     CONTINUE
      CALL GSLTYP(1)
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE ZIPLOT(IDEV)
C
C     ZIPLOT PLOTS THE REACTANCE VERSUS FREQUENCY
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/PLTDEV/IDTERM,IDPRNT
      CALL FMINMX(XMIN,XMAX)
      YMIN=1.E10
      YMAX=-1.E10
      DO 1 IC=1,NCURVE
      DO 3 IP=1,NPTS(IC)
      YIPLT(IP,IC)=AIMAG(1./YINA(IP,IC))
      IF(FREQA(IP,IC).GE.XMIN.AND.FREQA(IP,IC).LE.XMAX)THEN
         IF(YIPLT(IP,IC).LT.YMIN)YMIN=YIPLT(IP,IC)
         IF(YIPLT(IP,IC).GT.YMAX)YMAX=YIPLT(IP,IC)
      END IF
3     CONTINUE
1     CONTINUE
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      IF(IDEV.EQ.IDTERM)CALL MAPSIZ(5.,95.,5.,90.,0.)
      IF(IDEV.EQ.IDPRNT)CALL MAPSIZ(15.,80.,15.,80.,0.)
      CALL GSETLW(6.)
      CALL MAPIT(XMIN,XMAX,YMIN,YMAX,'F (MHz)'//CHAR(0),
     &'Reactance (ohms)'//CHAR(0),' '//CHAR(0),192)
      CALL GSETLW(3.)
      DO 2 IC=1,NCURVE
      CALL GSLTYP(IC)
      CALL TRACEC(FREQA(1,IC),YIPLT(1,IC),NPTS(IC))
2     CONTINUE
      CALL GSLTYP(1)
      CALL GSETLW(6.)
C
C     WRITE TITLE
C
      CHRSZ=GOODCS(.3)
      CALL GSSETC(CHRSZ,0.)
      CALL GSMOVE(.5,.1)
      CALL GSCSTR(COML(NCURVE))
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE GSCSTR(CSTR)
C
C     GSCSTR writes converts a character string to a zero-delimited
C     byte string and calls GSPSTR to write it to the plot.
      CHARACTER CSTR*(*)
      BYTE BSTR(120)
      LENS=LEN(CSTR)
      IF(LENS.GT.120)LENS=120
      ILAST=1
      DO 1 I=1,LENS
      BSTR(I)=ICHAR(CSTR(I:I))
      IF(CSTR(I:I).NE.' ')ILAST=I
1     CONTINUE
      BSTR(ILAST+1)=0
      CALL GSPSTR(BSTR)
      RETURN
      END
      SUBROUTINE READNF(IERR)
C
C     READNF OPENS A NEW INPUT FILE AND CALLS ROUTINES TO READ IT AS
C     EITHER A NEC OUTPUT FILE OR A COMPRESSED IMPEDANCE FILE.
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER INFILE*80,TEXT*80,COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      DATA INFL/3/
      IERR=0
      IF(NCURVE.GE.MXCRV)THEN
         WRITE(*,91)
         IERR=1
         RETURN
      END IF
      CLOSE(UNIT=INFL,ERR=1)
1     WRITE(*,90)
      READ(*,'(A)')INFILE
      IF(INFILE.EQ.' ')RETURN
      OPEN (UNIT=INFL,FILE=INFILE,STATUS='OLD',ERR=2)
      NCURVE=NCURVE+1
      FDESC(NCURVE)=INFILE(1:16)
      READ(INFL,'(A)')TEXT
      IF(TEXT(1:1).EQ.'1')THEN
         CALL YREADN(INFL,NPTS(NCURVE),FREQA(1,NCURVE),YINA(1,NCURVE),
     &   ISYMB(1,NCURVE),COML(NCURVE))
      ELSE IF(TEXT(1:13).EQ.'*** NEC ADMIT')THEN
         CALL YREADC(INFL,NPTS(NCURVE),FREQA(1,NCURVE),YINA(1,NCURVE),
     &   ISYMB(1,NCURVE),COML(NCURVE))
      ELSE IF(TEXT(1:13).EQ.'*** NEC IMPED')THEN
         CALL ZREADC(INFL,NPTS(NCURVE),FREQA(1,NCURVE),YINA(1,NCURVE),
     &   ISYMB(1,NCURVE),COML(NCURVE))
      ELSE
         WRITE(*,*)' Error: Format of input file is not recognized'
         NCURVE=NCURVE-1
         GO TO 1
      END IF
      RETURN
2     CALL ERROR
      GO TO 1
C
90    FORMAT(' Enter name of input file >',$)
91    FORMAT(' Number of curves exceeds dimension limit')
      END
      SUBROUTINE READAD(R1)
C
C     READAD OPENS A NEW INPUT FILE AND CALLS ROUTINES TO READ IT.
C     THE DATA IS ADDED TO AN EXISTING CURVE.
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER INFILE*80,TEXT*80,COML*80,FDESC*80,COMLX(80)
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      DATA INFL/3/
      ICURVE=R1+.5
      IF(ICURVE.LT.1.OR.ICURVE.GT.NCURVE)THEN
3        WRITE(*,91)
         READ(*,*,ERR=3)ICURVE
         IF(ICURVE.LT.1)RETURN
         IF(ICURVE.GT.NCURVE)GO TO 3
      END IF
      NX=NPTS(ICURVE)+1
      CLOSE(UNIT=INFL,ERR=1)
1     WRITE(*,90)
      READ(*,'(A)')INFILE
      IF(INFILE.EQ.' ')RETURN
      OPEN (UNIT=INFL,FILE=INFILE,STATUS='OLD',ERR=2)
      READ(INFL,'(A)')TEXT
      IF(TEXT(1:1).EQ.'1')THEN
         CALL YREADN(INFL,NPTSX,FREQA(NX,ICURVE),YINA(NX,ICURVE),
     &   ISYMB(NX,ICURVE),COMLX)
      ELSE IF(TEXT(1:13).EQ.'*** NEC ADMIT')THEN
         CALL YREADC(INFL,NPTSX,FREQA(NX,ICURVE),YINA(NX,ICURVE),
     &   ISYMB(NX,ICURVE),COMLX)
      ELSE IF(TEXT(1:13).EQ.'*** NEC IMPED')THEN
         CALL ZREADC(INFL,NPTSX,FREQA(NX,ICURVE),YINA(NX,ICURVE),
     &   ISYMB(NX,ICURVE),COMLX)
      ELSE
         WRITE(*,*)' Error: Format of input file is not recognized'
         GO TO 1
      END IF
      NPTS(ICURVE)=NPTS(ICURVE)+NPTSX
      CALL PTSORT(ICURVE)
      RETURN
2     CALL ERROR
      GO TO 1
C
90    FORMAT(' Enter name of file to add >',$)
91    FORMAT(' Enter number of curve to which data will be added >',$)
      END
      SUBROUTINE PTSORT(ICURVE)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA,YSAVE
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      NPTSX=NPTS(ICURVE)
      NPTSM=NPTSX-1
      DO 2 I=1,NPTSM
      IP=I+1
      DO 1 J=IP,NPTSX
      IF(FREQA(J,ICURVE).LT.FREQA(I,ICURVE))THEN
         FSAVE=FREQA(I,ICURVE)
         YSAVE=YINA(I,ICURVE)
         ISAVE=ISYMB(I,ICURVE)
         FREQA(I,ICURVE)=FREQA(J,ICURVE)
         YINA(I,ICURVE)=YINA(J,ICURVE)
         ISYMB(I,ICURVE)=ISYMB(J,ICURVE)
         FREQA(J,ICURVE)=FSAVE
         YINA(J,ICURVE)=YSAVE
         ISYMB(J,ICURVE)=ISAVE
      END IF
1     CONTINUE
2     CONTINUE
      RETURN
      END
      SUBROUTINE YREADN(INFL,NPTS,FREQA,YINA,ISYMB,COML)
      CHARACTER TEXT*80,COML*(*)
      COMPLEX YINA
      DIMENSION FREQA(*),YINA(*),ISYMB(*)
      NPTSX=0
C
C     SEARCH FOR TITLE
C
4     READ(INFL,90,END=5)TEXT
      IF(TEXT(42:53).EQ.'- - COMMENTS')THEN
         READ(INFL,90,END=5)TEXT
         READ(INFL,90,END=5)TEXT
      ELSE IF(TEXT(21:29).EQ.'  *******')THEN
         READ(INFL,90,END=5)TEXT
      ELSE
         GO TO 4
      END IF
      READ(INFL,'(25X,A)')COML
C
C     SEARCH FOR FREQUENCY
C
1     READ(INFL,90,END=5)TEXT
      IF(TEXT(42:54).NE.'- - FREQUENCY')GO TO 1
      READ(INFL,90)TEXT
      READ(INFL,92)FREQ
C
C     SEARCH FOR INPUT ADMITTANCE
C
2     READ(INFL,90,END=5)TEXT
      IF(TEXT(47:61).NE.'- ANTENNA INPUT')GO TO 2
      DO 3 I=1,3
3     READ(INFL,90)TEXT
      NPTSX=NPTSX+1
      READ(INFL,93)YINA(NPTSX)
      FREQA(NPTSX)=FREQ
      ISYMB(NPTSX)=0
      GO TO 1
5     NPTS=NPTSX
      RETURN
C
90    FORMAT(A)
92    FORMAT(46X,E11.4)
93    FORMAT(84X,2E12.5)
      END
      SUBROUTINE YREADC(INFL,NPTS,FREQA,YINA,ISYMB,COML)
C
C     YREADC READS A COMPRESSED FREQUENCY-ADMITTANCE FILE
C
C     OUTPUT PARAMETERS:
C     NPTS= NUMBER OF FREQUENCIES READ
C     FREQA(I) = FREQUENCY FOR POINT I (MHZ)
C     YINA(I) = IMPEDANCE FOR POINT I (OHMS)
C     ISYMB(I) = 1 TO PLOT SYMBOL AT POINT, = 0 OTHERWISE
C
      CHARACTER TEXT*80,COML*(*)
      COMPLEX YINA(*)
      DIMENSION FREQA(*),ISYMB(*)
      NPTSX=1
      READ(INFL,'(A)')COML
      READ(INFL,91)TEXT
1     READ(INFL,90,END=10)FREQA(NPTSX),YINA(NPTSX),ISYMB(NPTSX)
      NPTSX=NPTSX+1
      GO TO 1
10    NPTS=NPTSX-1
      RETURN
C
90    FORMAT(9X,3E12.5,I5)
91    FORMAT(A)
      END
      SUBROUTINE ZREADC(INFL,NPTS,FREQA,YINA,ISYMB,COML)
C
C     ZREADC READS A NEC FREQUENCY-IMPEDANCE FILE
C
C     OUTPUT PARAMETERS:
C     NPTS(IC) = NUMBER OF FREQUENCIES READ FOR CURVE IC
C     FREQA(I,IC) = FREQUENCY FOR POINT I ON CURVE IC (MHZ)
C     YINA(I,IC) = IMPEDANCE FOR POINT I ON CURVE IC (OHMS)
C     ISYMB(I,IC) = 1 TO PLOT SYMBOL AT POINT, = 0 OTHERWISE
C
      CHARACTER TEXT*80,COML*(*)
      COMPLEX YINA(*),ZIN
      DIMENSION FREQA(*),ISYMB(*)
      NPTSX=1
      READ(INFL,'(A)')COML
      READ(INFL,91)TEXT
1     READ(INFL,90,END=10)FREQA(NPTSX),ZIN,ISYMB(NPTSX)
      YINA(NPTSX)=1./ZIN
      NPTSX=NPTSX+1
      GO TO 1
10    NPTS=NPTSX-1
      RETURN
C
90    FORMAT(9X,3E12.5,I5)
91    FORMAT(A)
      END
      SUBROUTINE GETDEV(IDEV)
      BYTE BNAME(40)
      EXTERNAL LEN
      IDEV = 1
1     CALL GSDNAM(IDEV,BNAME)
      L=LEN(BNAME)
      IF(L.GT.0)THEN
           WRITE(*,90)IDEV,(BNAME(I),I=1,L)
90         FORMAT(' Device ',I2,' is ',40A1)
           IDEV=IDEV+1
           GO TO 1
      END IF
5     WRITE(*,91)
91    FORMAT(' Number of the graphics device to use? ',$)
      READ(*,92,ERR=5)IDEV
92    FORMAT(I5)
      RETURN
      END
      SUBROUTINE SMITZN
C
C     SMITZN COMPUTES IMPEDANCES NORMALIZED BY ZNOR FROM THE ADMITTANCES
C     IN YINA AND STORES THE VALUES IN YRPLT AND YIPLT
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA,ZINN
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      DO 2 IC=1,NCURVE
      DO 1 I=1,NPTS(IC)
      IF(ABS(YINA(I,IC)).LT.1.E-15)THEN
         WRITE(*,90)
         ZINN=1.E-8
      ELSE
         ZINN=1./(YINA(I,IC)*ZNOR)
      END IF
      YRPLT(I,IC)=REAL(ZINN)
      YIPLT(I,IC)=AIMAG(ZINN)
1     CONTINUE
2     CONTINUE
      RETURN
C
90    FORMAT(' SMITZN: ERROR - AN ADMITTANCE VALUE OF ZERO WAS FOUND')
      END
      SUBROUTINE GETZNO(ZNORX)
C
C     GETZNO SETS THE IMPEDANCE NORMALIZATION CONSTANT ZNOR EQUAL TO
C     ZNORX.  IF ZNORX IS ZERO A TABLE OF IMPEDANCES IS DISPLAYED AND
C     A VALUE FOR ZNOR IS REQUESTED.
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      IF(ZNORX.GT.0.)THEN
           ZNOR=ZNORX
      ELSE
2        WRITE(*,92)
         READ(*,*,ERR=2)ZNOR
      END IF
      RETURN
C
92    FORMAT(/,' ENTER IMPEDANCE NORMALIZATION FACTOR >',$)
      END
      SUBROUTINE SMITPZ(ICX)
C
C     SMITPZ DISPLAYS A TABLE OF FREQUENCIES, IMPEDANCES AND NORMALIZED
C     IMPEDANCES
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA,ZIN,ZINN
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      ICURVE=ICX
      IF(ICURVE.LT.1.OR.ICURVE.GT.NCURVE)THEN
2        WRITE(*,93)
         READ(*,*)ICURVE
         IF(ICURVE.LT.1)RETURN
         IF(ICURVE.GT.NCURVE)GO TO 2
      END IF
      CALL CLEARS
      WRITE(*,90)ICURVE,ZNOR
      WRITE(*,91)
      DO 1 I=1,NPTS(ICURVE)
      ZIN=1./YINA(I,ICURVE)
      ZINN=ZIN/ZNOR
      IF(ISYMB(I,ICURVE).EQ.0)THEN
         WRITE(*,92)I,FREQA(I,ICURVE),ZIN,ZINN
      ELSE
         WRITE(*,92)I,FREQA(I,ICURVE),ZIN,ZINN,ISYMB(I,ICURVE)
      END IF
1     CONTINUE
      RETURN
C
90    FORMAT(' CURVE',I5,/,' IMPEDANCE NORMALIZATION FACTOR = ',1P,
     &E12.4,/)
91    FORMAT(9X,'FREQUENCY',11X,'IMPEDANCE',12X,'NORMALIZED IMPEDANCE',
     &/,11X,'(MHZ)',11X,'R',11X,'X',12X,'R',12X,'X',/,24X,'(OHMS)',6X,
     &'(OHMS)')
92    FORMAT(I5,1P,2X,E11.4,2X,2E12.4,2X,2E12.4,I3)
93    FORMAT(' ENTER CURVE NUMBER >',$)
      END
      SUBROUTINE SMITSH
C
C     SMITSH DISPLAYS A TABLE OF COMMANDS FOR THE SMITH CHART PROGRAM
C
      CALL CLEARS
      WRITE(*,90)
90    FORMAT(' Commands for program ZPLOT:',//,
     &' AD ic: Add file to curve ic    SY ic,ns: Put symbols on plot',/,
     &' CL: Erase all curves           SC: Plot Smith chart',/,
     &' DV: Change Terminal type       VC n: Set VSWR circle n:1',/,
     &' ER ic: Erase curve ic          YC: Plot G + jB',/,
     &' EX: Exit from program          YI: Plot susceptance',/,
     &' FL f1,f2: Limit freq. range    YR: Plot conductance',/,
     &' ID: Identify curves            YO: Write Y vs f file',/,
     &' IN ic,npt,nf,ns: Interpolate   ZC: Plot R + jX',/,
     &' NF: Read a file, new curve     ZI: Plot reactance',/,
     &' PL: Send plot to a printer     ZR: Plot resistance',/,
     &' PT: Redraw the plot on screen  ZN z: Set Zo for Smith chart',/,
     &' PZ ic: Display f,Z/Zo          ZO: Write Z vs f file',/,
     &' SH: Show table of commands',/)
      RETURN
      END
      SUBROUTINE SMITVC(IVSWRX)
C
C     SMITVC SETS THE VALUE FOR THE VSWR CIRCLE ON THE SMITH CHART TO
C     IVSWRX.  IF IVSWRX IS .LE. 1 THEN A VALUE IS REQUESTED FROM THE
C     TERMINAL
C 
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      IF(IVSWRX.GT.1)THEN
         IVSWR=IVSWRX
      ELSE
         CALL CLEARS
1        WRITE(*,90)
         READ(*,*,ERR=1)RVSWR
         IVSWR=RVSWR+.5
      END IF
      RETURN
C
90    FORMAT(' TO SHOW R:1 VSWR CIRCLE ON SMITH CHART, ENTER R >',$)
      END
      SUBROUTINE SMITLB
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80,CLAB*44
      BYTE ZNRLAB(44)
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      EQUIVALENCE (CLAB,ZNRLAB)
      CHRSZ=GOODCS(.03)
      CALL GSSETC(CHRSZ,0.)
      WRITE(CLAB,90)ZNOR
C      ENCODE(17,90,ZNRLAB)ZNOR
90    FORMAT('ZNORM =',F8.2)
      ZNRLAB(18)=0
      CALL GSMOVE(-1.2,-1.15)
      CALL GSCSTR(COML(NCURVE))
      CALL GSMOVE(.65,-1.03)
      CALL GSPSTR(ZNRLAB)
      RETURN
      END
      SUBROUTINE SMITHC(IDEV)
      CALL SMITZN
      CALL SMITHP(IDEV)
      RETURN
      END
      SUBROUTINE SMITHP(IDEV)
C
C     SMITHP DRAWS A SMITH CHART AND PLOTS THE DATA POINTS IN ZR,ZIPLT
C
      PARAMETER (MXPTS=5000,MXCRV=6)
      BYTE VSWRLAB(5)
      CHARACTER COML*80,FDESC*80,VSWRCH*5
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      COMMON/YZPLOT/ YRPLT(MXPTS,MXCRV),YIPLT(MXPTS,MXCRV)
      COMMON/SMTCOM/TP,DANG
      EQUIVALENCE (VSWRCH,VSWRLAB)
      TP=8.*ATAN(1.)
      DANG=TP/72.
      CALL DEVSEL(IDEV,4,IERR)
      CALL BGNPLT
      CALL GSETLW(2.)
      XLEN=GSXLCM()
      YLEN=GSYLCM()
      SLEN=AMIN1(XLEN,YLEN-2.)
      SCALE=.5*SLEN
      CALL GSETDP(0.,SCALE,SCALE,.5*XLEN,.5*YLEN+.5)
C
C     DRAW RESISTANCE CIRCLES
C
      CALL RCIRC(10.,1.E3)
      CALL RCIRC(5.,10.)
      CALL RCIRC(2.,5.)
      CALL RCIRC(1.,5.)
      CALL RCIRC(.5,2.)
      CALL RCIRC(.2,2.)
      CALL CIRCLZ(1.)
C
C     DRAW REACTANCE CIRCLES
C
      CALL XCIRC(10.,1.E3)
      CALL XCIRC(5.,10.)
      CALL XCIRC(2.,5.)
      CALL XCIRC(1.,5.)
      CALL XCIRC(.5,2.)
      CALL XCIRC(.2,2.)
      CALL GSMOVE(1.,0.)
      CALL GSDRAW(-1.,0.)
      CALL XCIRC(-.2,2.)
      CALL XCIRC(-.5,2.)
      CALL XCIRC(-1.,5.)
      CALL XCIRC(-2.,5.)
      CALL XCIRC(-5.,10.)
      CALL XCIRC(-10.,1.E3)
C
C     ADD NUMBER LABLES
C
      CHRSZ=GOODCS(.03)
      CALL GSSETC(CHRSZ,0.)
C
C     LABLE RESISTANCE CIRCLES
C
      CALL PLTLAB(-.98,.01,'0.'//CHAR(0))
      CALL PLTLAB(-.65,.01,'.2'//CHAR(0))
      CALL PLTLAB(-.32,.01,'.5'//CHAR(0))
      CALL PLTLAB(.02,.01,'1.'//CHAR(0))
      CALL PLTLAB(.36,.01,'2.'//CHAR(0))
      CALL PLTLAB(.69,.01,'5.'//CHAR(0))
      CALL PLTLAB(.84,.01,'10.'//CHAR(0))
C
C     LABLE REACTANCE CIRCLES
C
      CALL PLTLAB(1.,.18,'10.'//CHAR(0))
      CALL PLTLAB(.94,.37,'5.'//CHAR(0))
      CALL PLTLAB(.59,.74,'2.'//CHAR(0))
      CALL PLTLAB(.02,.95,'1.'//CHAR(0))
      CALL PLTLAB(-.56,.77,'.5'//CHAR(0))
      CALL PLTLAB(-.89,.38,'.2'//CHAR(0))
      CALL PLTLAB(-.9,-.41,'-.2'//CHAR(0))
      CALL PLTLAB(-.57,-.80,'-.5'//CHAR(0))
      CALL PLTLAB(.02,-.97,'-1.'//CHAR(0))
      CALL PLTLAB(.57,-.74,'-2.'//CHAR(0))
      CALL PLTLAB(.93,-.39,'-5.'//CHAR(0))
      CALL PLTLAB(1.,-.2,'-10.'//CHAR(0))
C
C     DRAW VSWR CIRCLE
C
      IF(IVSWR.GT.0)THEN
         CALL ZTOW(FLOAT(IVSWR),0.,U,V)
         CALL GSLTYP(3)
         CALL CIRCLZ(U)
         WRITE(VSWRCH,90)IVSWR
90       FORMAT(I2,':1')
         VSWRLAB(5)=0
         CALL PLTLAB(-.08,U+.01,VSWRLAB)
      END IF
C
C     PLOT DATA LINE
C
      CALL GSCOLR(2,IERR)
      CALL GSETLW(6.)
      DO 2 IC=1,NCURVE
      CALL GSLTYP(IC)
      DO 1 I=1,NPTS(IC)
      R=YRPLT(I,IC)
      X=YIPLT(I,IC)
      CALL ZTOW(R,X,U,V)
      IF(I.EQ.1)CALL GSMOVE(U,V)
      IF(I.GT.1)CALL GSDRAW(U,V)
1     CONTINUE
2     CONTINUE
C
C     PLOT SYMBOLS AT POINTS WITH ISYMB.NE.0
C
      CALL GSLTYP(1)
      CALL GSETLW(3.)
      DO 4 IC=1,NCURVE
      DO 3 I=1,NPTS(IC)
      IF(ISYMB(I,IC).EQ.0)GO TO 3
      R=YRPLT(I,IC)
      X=YIPLT(I,IC)
      CALL ZTOW(R,X,U,V)
      CALL GSMOVE(U,V)
      CALL SYMBOL(1,CHRSZ)
3     CONTINUE
4     CONTINUE
      CALL GSETLW(6.)
      CALL SMITLB
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE ZTOW(R,X,U,V)
C
C     ZTOW CONVERTS THE IMPEDANCE R+J*X TO SMITH CHART COORD. U+J*V
C
      COMPLEX Z
      Z=CMPLX(R,X)
      Z=(Z-1.)/(Z+1.)
      U=REAL(Z)
      V=AIMAG(Z)
      RETURN
      END
      SUBROUTINE RCIRC(R,XLIM)
C
C     RCIRC DRAWS RESISTANCE CIRCLES FOR SMITH CHART STARTING AT
C     REACTANCE VALUE XLIM.
C
      COMMON/SMTCOM/TP,DANG
      RAD=1./(R+1.)
      XCEN=R*RAD
      CALL ZTOW(R,XLIM,XCIR,YCIR)
      XCIR=XCIR-XCEN
      ASTRT=ATAN2(YCIR,XCIR)
      TANGL=TP-2.*ASTRT
      NA=TANGL/DANG+1.
      DA=TANGL/NA
      SDA=SIN(DA)
      CDA=COS(DA)
      CALL GSMOVE(XCIR+XCEN,YCIR)
      DO 1 IA=1,NA
      XSAV=XCIR
      XCIR=XSAV*CDA-YCIR*SDA
      YCIR=XSAV*SDA+YCIR*CDA
1     CALL GSDRAW(XCIR+XCEN,YCIR)
      RETURN
      END
      SUBROUTINE XCIRC(X,RLIM)
C
C     XCIRC DRAWS REACTANCE CIRCLES FOR SMITH CHART STARTING AT
C     RESISTANCE VALUE RLIM.
C
      COMMON/SMTCOM/TP,DANG
      XCEN=1.
      YCEN=1./X
      RAD=ABS(YCEN)
      CALL ZTOW(RLIM,X,XCIR,YCIR)
      XCIR=XCIR-XCEN
      YCIR=YCIR-YCEN
      AEND=ATAN2(YCIR,XCIR)
      IF(AEND.LT.0.)AEND=AEND+TP
      CALL ZTOW(0.,X,XCIR,YCIR)
      XCIR=XCIR-XCEN
      YCIR=YCIR-YCEN
      ASTRT=ATAN2(YCIR,XCIR)
      IF(ASTRT.LT.0.)ASTRT=ASTRT+TP
      TANGL=AEND-ASTRT
      NA=ABS(TANGL)/DANG+1.
      DA=TANGL/NA
      SDA=SIN(DA)
      CDA=COS(DA)
      CALL GSMOVE(XCIR+XCEN,YCIR+YCEN)
      DO 1 IA=1,NA
      XSAV=XCIR
      XCIR=XSAV*CDA-YCIR*SDA
      YCIR=XSAV*SDA+YCIR*CDA
1     CALL GSDRAW(XCIR+XCEN,YCIR+YCEN)
      RETURN
      END
      SUBROUTINE CIRCLZ(R)
C
C     CIRCLZ DRAWS A CIRCLE WITH CENTER AT ORIGIN AND RADIUS R.
C
      COMMON/SMTCOM/TP,DANG
      NA=TP/DANG+1.
      DA=TP/NA
      SDA=SIN(DA)
      CDA=COS(DA)
      X=R
      Y=0.
      CALL GSMOVE(X,Y)
      DO 1 IA=1,NA
      XSAV=X
      X=XSAV*CDA-Y*SDA
      Y=XSAV*SDA+Y*CDA
1     CALL GSDRAW(X,Y)
      RETURN
      END
      SUBROUTINE PLTLAB(X,Y,LAB)
      BYTE LAB(10)
      CALL GSMOVE(X,Y)
      CALL GSPSTR(LAB)
      RETURN
      END
      SUBROUTINE READCM(INUNIT,CODE,F1,F2,F3,F4,F5,F6,IERROR)
C
C     Purpose:
C     READCM calls PARSIT to read an input command
C
      CHARACTER*(*) CODE
      DIMENSION INTVAL(1),REAVAL(6)
C
C  Call the routine to read the record and parse it.
C
      CALL PARSIT(INUNIT,0,6,CODE,INTVAL,REAVAL,IERROR)
C
C  Set the return variables to the buffer array elements.
C
      F1=REAVAL(1)
      F2=REAVAL(2)
      F3=REAVAL(3)
      F4=REAVAL(4)
      F5=REAVAL(5)
      F6=REAVAL(6)
      RETURN
      END
      SUBROUTINE PARSIT(INUNIT,MAXINT,MAXREA,CMND,INTFLD,REAFLD,IERROR)
C
C     PARSIT reads an input record and parses it.
C
C     OUTPUT:
C     MAXINT     total number of integers in record
C     MAXREA     total number of real values in record
C     CMND       two letter mnemonic code
C     INTFLD     integer values from record
C     REAFLD     real values from record

C  *****  Internal Variables
C     BGNFLD     list of starting indices
C     BUFFER     text buffer
C     ENDFLD     list of ending indices
C     FLDTRM     flag to indicate that pointer is in field position
C     REC        input line as read
C     TOTCOL     total number of columns in REC
C     TOTFLD     number of numeric fields
      CHARACTER  CMND*2, BUFFER*20, REC*80
      INTEGER    INTFLD(*)
      INTEGER    BGNFLD(12), ENDFLD(12), TOTCOL, TOTFLD
      REAL       REAFLD(*)
      LOGICAL    FLDTRM
C
      READ(INUNIT, 8000, IOSTAT=IERROR) REC
      IF(IERROR.LT.0)RETURN
      CALL UPCASE( REC, REC, TOTCOL )
C
C  Store opcode and clear field arrays.
C
      CMND= REC(1:2)
      DO 3000 I=1,MAXINT
           INTFLD(I)= 0
 3000 CONTINUE
      DO 3010 I=1,MAXREA
           REAFLD(I)= 0.0
 3010 CONTINUE
      DO 3020 I=1,12
           BGNFLD(I)= 0
           ENDFLD(I)= 0
 3020 CONTINUE
C
C  Find the beginning and ending of each field as well as the total number of
C  fields.
C
      TOTFLD= 0
      FLDTRM= .FALSE.
      LAST= MAXREA + MAXINT
      DO 4000 J=3,TOTCOL
           K= ICHAR( REC(J:J) )
C
C  Check for end of line comment (`!').  This is a new modification to allow
C  VAX-like comments at the end of data records, i.e.
C       GW 1 7 0 0 0 0 0 .5 .0001 ! DIPOLE WIRE
C       GE ! END OF GEOMETRY
C
      IF (K .EQ. 33) THEN
         IF (FLDTRM) ENDFLD(TOTFLD)= J - 1
         GO TO 5000
C
C  Set the ending index when the character is a comma or space and the pointer
C  is in a field position (FLDTRM = .TRUE.).
C
          ELSE IF (K .EQ. 32  .OR.  K .EQ. 44) THEN
             IF (FLDTRM) THEN
                ENDFLD(TOTFLD)= J - 1
                FLDTRM= .FALSE.
             ENDIF
C
C  Set the beginning index when the character is not a comma or space and the
C  pointer is not currently in a field position (FLDTRM = .FALSE).
C
          ELSE IF (.NOT. FLDTRM) THEN
              TOTFLD= TOTFLD + 1
              FLDTRM= .TRUE.
              BGNFLD(TOTFLD)= J
          ENDIF
 4000   CONTINUE
        IF (FLDTRM) ENDFLD(TOTFLD)= TOLCOL

C  Check to see if the total number of value fields is within the precribed
C  limits.

 5000   IF (TOTFLD .EQ. 0) THEN
             RETURN
        ELSE IF (TOTFLD .GT. LAST) THEN
             WRITE( *, 8001 )
             GOTO 9010
        ENDIF
        J= MIN( TOTFLD, MAXINT )

C  Parse out integer values and store into integer buffer array.

        DO 5090 I=1,J
             LENGTH= ENDFLD(I) - BGNFLD(I) + 1
             BUFFER= REC(BGNFLD(I):ENDFLD(I))
             IND= INDEX( BUFFER(1:LENGTH), '.' )
             IF (IND .GT. 0  .AND.  IND .LT. LENGTH) GO TO 9000
             IF (IND .EQ. LENGTH) LENGTH= LENGTH - 1
             READ( BUFFER(1:LENGTH), *, ERR=9000 ) INTFLD(I)
 5090   CONTINUE

C  Parse out real values and store into real buffer array.

        IF (TOTFLD .GT. MAXINT) THEN
             J= MAXINT + 1
             DO 6000 I=J,TOTFLD
                  LENGTH= ENDFLD(I) - BGNFLD(I) + 1
                  BUFFER= REC(BGNFLD(I):ENDFLD(I))
                  IND= INDEX( BUFFER(1:LENGTH), '.' )
                  IF (IND .EQ. 0) THEN
                       INDE= INDEX( BUFFER(1:LENGTH), 'E' )
                       LENGTH= LENGTH + 1
                       IF (INDE .EQ. 0) THEN
                            BUFFER(LENGTH:LENGTH)= '.'
                       ELSE
                            BUFFER= BUFFER(1:INDE-1)//'.'//
     &                               BUFFER(INDE:LENGTH-1)
                       ENDIF
                  ENDIF
                  READ( BUFFER(1:LENGTH), *, ERR=9000 ) REAFLD(I-MAXINT)
 6000        CONTINUE
        ENDIF
        RETURN

C  Print out text of record line when error occurs.

 9000   IF (I .LE. MAXINT) THEN
             WRITE( *, 8002 ) I
        ELSE
             I= I - MAXINT
             WRITE( *, 8003 ) I
        ENDIF
 9010   WRITE( *, 8004 ) REC
        IERROR=1
        RETURN
C
C  Input formats and output messages.
C
 8000   FORMAT (A80)
 8001   FORMAT (//,' ***** CARD ERROR - TOO MANY FIELDS IN RECORD')
 8002   FORMAT (//,' ***** CARD ERROR - INVALID NUMBER AT INTEGER',
     &          ' POSITION ',I1)
 8003   FORMAT (//,' ***** CARD ERROR - INVALID NUMBER AT REAL',
     &          ' POSITION ',I1)
 8004   FORMAT (' ***** TEXT -->  ',A80)
        END
      SUBROUTINE UPCASE( INTEXT, OUTTXT, LENGTH )
C
C     UPCASE finds the length of INTEXT and converts it to upper case.
C
      CHARACTER *(*) INTEXT, OUTTXT
C
C
      LENGTH=LEN( INTEXT )
      DO 3000 I=1,LENGTH
         J=ICHAR( INTEXT(I:I) )
         IF (J .GE. 96) J=J - 32
         OUTTXT(I:I)=CHAR( J )
3000  CONTINUE
      RETURN
      END
      SUBROUTINE YOUT(R1)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80,ZINFIL*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      ICURVE=R1+.5
      IF(ICURVE.LT.1.OR.ICURVE.GT.NCURVE)THEN
3        WRITE(*,90)
         READ(*,*,ERR=3)ICURVE
         IF(ICURVE.LT.1)RETURN
         IF(ICURVE.GT.NCURVE)GO TO 3
      END IF
1     WRITE(*,91)
      READ(*,'(A)')ZINFIL
      IF(ZINFIL.EQ.' ')RETURN
      OPEN (UNIT=25,FILE=ZINFIL,STATUS='NEW',ERR=1)
      WRITE(25,'(A)')'*** NEC ADMITTANCE FILE'
      WRITE(25,'(A)')COML(ICURVE)
      WRITE(25,*)'           F (MHz)        ZR          ZI'
      DO 2 I=1,NPTS(ICURVE)
      IF(ISYMB(I,ICURVE).EQ.0)THEN
         WRITE(25,92)I,FREQA(I,ICURVE),YINA(I,ICURVE)
      ELSE
         WRITE(25,92)I,FREQA(I,ICURVE),YINA(I,ICURVE),ISYMB(I,ICURVE)
      END IF
2     CONTINUE
      CLOSE(25)
      RETURN
C
90    FORMAT(' Enter curve number >',$)
91    FORMAT(' Enter name for the admittance file >',$)
92    FORMAT(1X,I7,1X,1P,3E12.5,I5)
      END
      SUBROUTINE ZOUT(R1)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80,ZINFIL*80
      COMPLEX YINA,ZIN
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      ICURVE=R1+.5
      IF(ICURVE.LT.1.OR.ICURVE.GT.NCURVE)THEN
3        WRITE(*,90)
         READ(*,*,ERR=3)ICURVE
         IF(ICURVE.LT.1)RETURN
         IF(ICURVE.GT.NCURVE)GO TO 3
      END IF
1     WRITE(*,91)
      READ(*,'(A)')ZINFIL
      IF(ZINFIL.EQ.' ')RETURN
      OPEN (UNIT=25,FILE=ZINFIL,STATUS='NEW',ERR=1)
      WRITE(25,'(A)')'*** NEC IMPEDANCE FILE'
      WRITE(25,'(A)')COML(ICURVE)
      WRITE(25,*)'           F (MHz)        ZR          ZI'
      DO 2 I=1,NPTS(ICURVE)
      ZIN=1./YINA(I,ICURVE)
      IF(ISYMB(I,ICURVE).EQ.0)THEN
         WRITE(25,92)I,FREQA(I,ICURVE),ZIN
      ELSE
         WRITE(25,92)I,FREQA(I,ICURVE),ZIN,ISYMB(I,ICURVE)
      END IF
2     CONTINUE
      CLOSE(25)
      RETURN
C
90    FORMAT(' Enter curve number >',$)
91    FORMAT(' Enter name for the impedance file >',$)
92    FORMAT(1X,I7,1X,1P,3E12.5,I5)
      END
      SUBROUTINE YINTRP(R1,R2,R3,R4,IERR)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      IERR=0
      IF(NCURVE.GE.MXCRV)THEN
         WRITE(*,91)
         IERR=1
         RETURN
      END IF
      ICURVE=R1+.5
      NEVAL=R2+.5
      NFIT=R3+.5
      NSLIDE=R4+.5
      IF(ICURVE.GT.NCURVE)THEN
1        WRITE(*,93)
         READ(*,*)ICURVE
         IF(ICURVE.GT.NCURVE)GO TO 1
      END IF
      IF(ICURVE.EQ.0)ICURVE=NCURVE
      IF(NEVAL.EQ.0)NEVAL=200
      IF(NFIT.EQ.0)NFIT=7
      IF(NFIT.GT.NPTS(ICURVE))NFIT=NPTS(ICURVE)
      IF(NSLIDE.EQ.0)NSLIDE=1
      IF(NEVAL.GT.MXPTS)THEN
         WRITE(*,92)MXPTS
         IERR=1
         RETURN
      END IF
      CALL YTRP(ICURVE,NFIT,NSLIDE,NEVAL)
      FDESC(NCURVE)=FDESC(ICURVE)
      WRITE(FDESC(NCURVE)(17:38),90)NFIT,NSLIDE
      COML(NCURVE)=COML(ICURVE)
      RETURN
C
90    FORMAT('  NFIT=',I3,'  NSLIDE=',I3)
91    FORMAT(' Number of curves exceeds dimension limit')
92    FORMAT(' Number of points exceeds dimension limit of',I6)
93    FORMAT(' Enter curve number >',$)
      END
      SUBROUTINE YTRP(ICURVE,NFIT,NSLIDX,NEVAL)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA,YFIT,CN,CD
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      DIMENSION FFIT(50),YFIT(50),CN(0:50),CD(0:50)
      NCURVE=NCURVE+1
      NPTI=NPTS(ICURVE)
      NSLIDE=NSLIDX
      IF(NSLIDE.LT.1)NSLIDE=1
      IFMAX=(NFIT+NSLIDE-1)/2
      NPTS(NCURVE)=NEVAL
      FRQ=FREQA(1,ICURVE)
      DFRQ=(FREQA(NPTI,ICURVE)-FRQ)/(NEVAL-1.)
      FRQ=FRQ-DFRQ
      IFIT1=1
      FLIM=FREQA(IFIT1+IFMAX,ICURVE)
      DO 2 IPT=1,NEVAL
      FRQ=FRQ+DFRQ
      IF(IPT.EQ.1.OR.FRQ.GT.FLIM)THEN
         IF((IFIT1+NFIT.GT.NPTI).AND.IPT.GT.1)GO TO 3
         IF(IPT.GT.1)IFIT1=IFIT1+NSLIDE
         IF(IFIT1+NFIT-1.GT.NPTI)IFIT1=NPTI-NFIT+1
         FLIM=FREQA(IFIT1+IFMAX,ICURVE)
         IFIT=IFIT1-1
         DO 1 IPF=1,NFIT
         IFIT=IFIT+1
         FFIT(IPF)=FREQA(IFIT,ICURVE)
         YFIT(IPF)=YINA(IFIT,ICURVE)
1        CONTINUE
         CALL XFIT(NFIT,FFIT,YFIT,NN,ND,CN,CD)
      END IF
3     CALL RATEVL(FRQ,ND,NN,CD,CN,YINA(IPT,NCURVE))
      FREQA(IPT,NCURVE)=FRQ
      ISYMB(IPT,NCURVE)=0
2     CONTINUE
      RETURN
      END
      SUBROUTINE RATEVL(X,ND,NN,CD,CN,FX)
      COMPLEX CD,CN,FX,TOP,BOT
      DIMENSION CD(0:*),CN(0:*)
      DO 1 I=0,NN
      IF(I.EQ.0)THEN
         TOP=CN(NN)
      ELSE
         TOP=TOP*X+CN(NN-I)
      END IF
1     CONTINUE
      DO 2 I=0,ND
      IF(I.EQ.0)THEN
         BOT=CD(ND)
      ELSE
         BOT=BOT*X+CD(ND-I)
      END IF
2     CONTINUE
      FX=TOP/BOT
      RETURN
      END
      SUBROUTINE XFIT(NP,XA,FA,NN,ND,CN,CD)
      COMPLEX FA,CN,CD,CMAT,RHS,XP
      DIMENSION XA(*),FA(*),CN(0:*),CD(0:*)
      DIMENSION CMAT(50,50),RHS(50),IPV(50)
      DATA FNORM/1.E3/
      NN=NP/2
      ND=NP-1-NN
      DO 1 I=1,NP
      XI=XA(I)
      XP=FA(I)
      DO 2 J=1,ND
      XP=XP*XI
2     CMAT(J,I)=XP*FNORM
      XP=1.
      DO 3 J=0,NN
      IF(J.GT.0)XP=XP*XI
3     CMAT(J+ND+1,I)=-XP*FNORM
1     RHS(I)=-FA(I)*FNORM
      CALL FACTR(NP,CMAT,IPV,50)
      CALL SOLVE(NP,CMAT,IPV,RHS,50)
      CD(0)=1.
      DO 15 I=1,ND
15    CD(I)=RHS(I)
      DO 16 I=0,NN
16    CN(I)=RHS(ND+I+1)
      RETURN
      END
      SUBROUTINE FACTR (N,A,IP,NDIM)
C
C     SUBROUTINE TO FACTOR A MATRIX INTO A UNIT LOWER TRIANGULAR MATRIX
C     AND AN UPPER TRIANGULAR MATRIX USING THE GAUSS-DOOLITTLE ALGORITHM
C     PRESENTED ON PAGES 411-416 OF A. RALSTON--A FIRST COURSE IN
C     NUMERICAL ANALYSIS.  COMMENTS BELOW REFER TO COMMENTS IN RALSTONS
C     TEXT.    (MATRIX TRANSPOSED.
C
      COMPLEX A,D,ARJ
      DIMENSION A(NDIM,NDIM), IP(NDIM)
      COMMON /SCRATM/ D(600)
      INTEGER R,RM1,RP1,PJ,PR
      IFLG=0
      DO 9 R=1,N
C
C     STEP 1
C
      DO 1 K=1,N
      D(K)=A(R,K)
1     CONTINUE
C
C     STEPS 2 AND 3
C
      RM1=R-1
      IF (RM1.LT.1) GO TO 4
      DO 3 J=1,RM1
      PJ=IP(J)
      ARJ=D(PJ)
      A(R,J)=ARJ
      D(PJ)=D(J)
      JP1=J+1
      DO 2 I=JP1,N
      D(I)=D(I)-A(J,I)*ARJ
2     CONTINUE
3     CONTINUE
4     CONTINUE
C
C     STEP 4
C
      DMAX=REAL(D(R)*CONJG(D(R)))
      IP(R)=R
      RP1=R+1
      IF (RP1.GT.N) GO TO 6
      DO 5 I=RP1,N
      ELMAG=REAL(D(I)*CONJG(D(I)))
      IF (ELMAG.LT.DMAX) GO TO 5
      DMAX=ELMAG
      IP(R)=I
5     CONTINUE
6     CONTINUE
      IF (DMAX.LT.1.E-10) IFLG=1
      PR=IP(R)
      A(R,R)=D(PR)
      D(PR)=D(R)
C
C     STEP 5
C
      IF (RP1.GT.N) GO TO 8
      ARJ=1./A(R,R)
      DO 7 I=RP1,N
      A(R,I)=D(I)*ARJ
7     CONTINUE
8     CONTINUE
      IF (IFLG.EQ.0) GO TO 9
      WRITE( *,10) R,DMAX
      IFLG=0
9     CONTINUE
      RETURN
C
10    FORMAT (1H ,6HPIVOT(,I3,2H)=,1PE16.8)
      END
      SUBROUTINE SOLVE (N,A,IP,B,NDIM)
C
C     SUBROUTINE TO SOLVE THE MATRIX EQUATION LU*X=B WHERE L IS A UNIT
C     LOWER TRIANGULAR MATRIX AND U IS AN UPPER TRIANGULAR MATRIX BOTH
C     OF WHICH ARE STORED IN A.  THE RHS VECTOR B IS INPUT AND THE
C     SOLUTION IS RETURNED THROUGH VECTOR B.    (MATRIX TRANSPOSED.
C
      COMPLEX A,B,Y,SUM
      INTEGER PI
      COMMON /SCRATM/ Y(600)
      DIMENSION A(NDIM,NDIM), IP(NDIM), B(NDIM)
C
C     FORWARD SUBSTITUTION
C
      DO 3 I=1,N
      PI=IP(I)
      Y(I)=B(PI)
      B(PI)=B(I)
      IP1=I+1
      IF (IP1.GT.N) GO TO 2
      DO 1 J=IP1,N
      B(J)=B(J)-A(I,J)*Y(I)
1     CONTINUE
2     CONTINUE
3     CONTINUE
C
C     BACKWARD SUBSTITUTION
C
      DO 6 K=1,N
      I=N-K+1
      SUM=(0.,0.)
      IP1=I+1
      IF (IP1.GT.N) GO TO 5
      DO 4 J=IP1,N
      SUM=SUM+A(J,I)*B(J)
4     CONTINUE
5     CONTINUE
      B(I)=(Y(I)-SUM)/A(I,I)
6     CONTINUE
      RETURN
      END
      SUBROUTINE SETFL(F1,F2)
      PARAMETER (MXPTS=5000,MXCRV=6)
      CHARACTER COML*80,FDESC*80
      COMPLEX YINA
      COMMON/YINDAT/YINA(MXPTS,MXCRV),NCURVE,NPTS(MXCRV),FREQA(MXPTS,
     &MXCRV),ZNOR,IVSWR,FMIN,FMAX,ISYMB(MXPTS,MXCRV),COML(MXCRV),
     &FDESC(MXCRV)
      FMIN=F1
      FMAX=F2
      RETURN
      END
      SUBROUTINE ERROR
C
C     Error gets the reason for an I/O error on VAX/VMS.
C
C      IMPLICIT INTEGER (A-Z)
C      CHARACTER MSG*80
C      CALL ERRSNS(FNUM,RMSSTS,RMSSTV,IUNIT,CONDVAL)
C      CALL SYS$GETMSG(%VAL(RMSSTS),MSGLEN,MSG,,,)
C      CALL STR$UPCASE(MSG,MSG)
C      IND=INDEX(MSG,',')
C      TYPE 1,MSG(IND+2:MSGLEN)
C1     FORMAT(//,'  ****  ERROR  ****   ',//,5X,A,//)
      WRITE(*,*)' FILE I/O ERROR'
      RETURN
      END
      SUBROUTINE CLEARS
C
C     CLEARS CLEARS THE SCREEN OF A DEC VT100 TERMINAL
C
c      BYTE GS,FF,ESC,GG,Q,Z
c      CHARACTER*1 CGS,CFF,CESC,CQ,CZ,CGG
c      EQUIVALENCE (CGS,GS),(CFF,FF),(CESC,ESC),(CQ,Q),(CZ,Z),(CGG,GG)
c      DATA GS/29/,FF/12/,ESC/27/,Q/34/,Z/48/,GG/103/
cc      CLOSE(6)
c      WRITE(*,90) CGS,CESC,CFF,CESC,CQ,CZ,CGG
cc90    FORMAT('+',A1,$)
c90    FORMAT(7A1,$)
cc      CLOSE(6)
C
C     MACINTOSH:
C      CALL GDMACSE(2,XA,YA)
      RETURN
      END
      SUBROUTINE GDPST(IFXN,XA,YA)
      DIMENSION XA(8), YA(3)
C
C     POST SCRIPT DRIVER - HARD COPY DEVICE HAS 300 DOTS/INCH
      PARAMETER (DPI = 300.0)
C   *******  MODIFIED FOR DELAYED RELEASE TO PRINTER ************
C   *******  MUST CALL POSTDMP TO SEND PLOTS TO PRINTER ********
C
C-----------------------------------------------------------------------
C
C     DECLARE VARS NEED FOR DRIVER OPERATION
C
      LOGICAL LNOPLT, LWIDE
      CHARACTER*16 COORD
      CHARACTER*8 CTIME
      CHARACTER*80 FNAME
      CHARACTER*120 COMAND
C
      DIMENSION DCHAR(8)
      COMMON/POSTDCM/LUNPOS,INITPOST,LNOPLT,FNAME
C
C     MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C      ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
      EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
C
C     PAPER DEFINITIONS (INCHES)
C
c     PARAMETER (PSRES = 72.0)
      REAL*4 LMARGN
      PARAMETER (LMARGN = 0.5)
      PARAMETER (RMARGN = 0.25)
      PARAMETER (TMARGN = 0.5)
      PARAMETER (BMARGN = 0.25)
      PARAMETER (PAPERH = 11.0)
      PARAMETER (PAPERW = 8.5)
C           DERIVED PARAMETERS
      PARAMETER (UWD = PAPERW-LMARGN-RMARGN)
      PARAMETER (UHT = PAPERH-TMARGN-BMARGN)
      PARAMETER (WDCM = 2.54*UWD)
      PARAMETER (HTCM = 2.54*UHT)
      PARAMETER (RESOLUTION = DPI/2.54)
c     PARAMETER (PSRESCM = PSRES/2.54)
      PARAMETER (XOFF = DPI*LMARGN)
      PARAMETER (YOFF = DPI*BMARGN)
C
      PARAMETER (MAXPTS = 900)
C
C     UNIX routine for getting process id (so we can have a unique
C        file name for the scratch file).
      integer*4 getpid, fputc
      external getpid, fputc
C
      CHARACTER*1 EOF
C
C     DIGLIB DEVICE CHARACTERISTICS WORDS
C
      DATA DCHAR /910.0, WDCM, HTCM, RESOLUTION,
     &   RESOLUTION, 1.0, 27.0, 2.0/
C
      LWIDE = .FALSE.
10    CONTINUE
C
C*****************
C
C     FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
      IF (IFXN .LE. 0 .OR. IFXN .GT. 7) RETURN
C
C     NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
      GO TO (100,200,300,400,500,600,700) IFXN
C
C     *********************
C     INITIALIZE THE DEVICE
C     *********************
C
100   CONTINUE
C     CALL IDATE(IM,ID,IY)
C      CALL TIME(CTIME)
C     IF (ID .GT. 26) ID = ID-26 + (48-64)
      write(fname,101) mod(getpid(),100000)
101   format('/tmp/diglib_',i5.5,'.ps')
      FNAME(21:21)=char(0)
      IF(INITPOST.EQ.0)THEN
            INITPOST=1
            LUN = XA(1)
            LUNPOS=LUN
            OPEN(UNIT=LUN,FILE=FNAME,STATUS='NEW',ERR=9000)
C     FNAME = 'SYS$SCRATCH:POSTSCRIPT.DIG'//CHAR(IM+64)//CHAR(ID+64)
C    &   //CTIME(1:2)//CTIME(4:5)//CTIME(7:8)
C     OPEN (UNIT=LUN,NAME=FNAME,TYPE='NEW',
C    &   FORM='UNFORMATTED',CARRIAGECONTROL='NONE',RECORDTYPE='VARIABLE',
C    &   INITIALSIZE = 50, EXTENDSIZE = 50,
C    &   ERR=9000)
C
C        SHOW INITIALIZATION WORKED, I.E. WE OPENED THE FILE.
C
         EOF = char(4)
         YA(1) = 0.0
         CALL GDPSOP(LUN)
C         CALL GDPSIN(EOF)
         CALL GDPSIN('%! DIGLIB PLOT'//char(0))
         CALL GDPSDU
         CALL GDPSIN('/m {moveto} def /l {lineto} def '//char(0))
         call gdpsse(DPI)
         CALL GDPSDU
         LNOPLT = .TRUE.
         NPTS = 0
      END IF
      RETURN
C
C     **************************
C     GET FRESH PLOTTING SURFACE
C     **************************
C
200   CONTINUE
      IF (.NOT. LNOPLT) THEN
C           CALL GDPSDU
            CALL GDPSIN('stroke showpage '//char(0))
      ENDIF
      CALL GDPSDU
        call gdpsse(DPI)
      CALL GDPSIN('newpath '//char(0))
      LNOPLT = .TRUE.
      NPTS = 0
      RETURN
C
C     ****
C     MOVE
C     ****
C
300   CONTINUE
C
C     ****
C     DRAW
C     ****
C
400   CONTINUE
      NPTS = NPTS + 1
      IF (NPTS .GT. MAXPTS) THEN
            CALL GDPSDU
            CALL GDPSIN('stroke newpath '//char(0))
            IF (IFXN .EQ. 4) THEN
                  CALL GDPSIN(COORD)
                  CALL GDPSIN('m '//char(0))
            ENDIF
            NPTS = 1
      ENDIF
      IF (LWIDE) THEN
            ix = RESOLUTION*YA(1)+XOFF
            iy = RESOLUTION*(HTCM-XA(1))+YOFF
          ELSE
            ix = RESOLUTION*XA(1)+XOFF
            iy = RESOLUTION*YA(1)+YOFF
      ENDIF
      WRITE(COORD,451) ix,iy
 451    FORMAT(i4,1X,i4,1X)
      COORD(11:11) = char(0)
      CALL GDPSIN(COORD)
      IF (IFXN .EQ. 3) THEN
            CALL GDPSIN('m '//char(0))
          ELSE
            CALL GDPSIN('l '//char(0))
      ENDIF
      LNOPLT = .FALSE.
      RETURN
C
C     *****************************
C     FLUSH GRAPHICS COMMAND BUFFER
C     *****************************
C
C           !DONE BY BGNPLT WHEN NECESSARY.
500   CONTINUE
      RETURN
C
C     ******************
C     RELEASE THE DEVICE  ** MODIFIED FOR SEPARATE CALL TO RELEASE
C     ******************
C
600   CONTINUE
C      IF (.NOT. LNOPLT) THEN
C            CALL GDPSDU
C            CALL GDPSIN('stroke showpage '//char(0))
C            CALL GDPSDU
C            CALL GDPSIN(EOF)
C            CALL GDPSDU
C      ENDIF
C      CLOSE (UNIT=LUN)
C      COMAND = 'lpr -r '//FNAME
C      ISTATUS = system(COMAND)
      RETURN
C
C     *****************************
C     RETURN DEVICE CHARACTERISTICS
C     *****************************
C
700   CONTINUE
      DO 720 I=1,8
      XA(I) = DCHAR(I)
720   CONTINUE
      IF (LWIDE) THEN
            XA(2) = DCHAR(3)
            XA(3) = DCHAR(2)
      ENDIF
      RETURN
C
C     HANDLE FILE OPEN ERROR
C
9000  CONTINUE
      YA(1) = 3.0
      RETURN
C
C     ***********************************************************
C
      ENTRY GDPSW(IFXN,XA,YA)
      LWIDE = .TRUE.
      GO TO 10
      END


        subroutine gdpsse(dpi)
        character*16 dpistr
      call gdpsin('initgraphics 1 setlinecap 1 setlinejoin '//char(0))
      call gdpsdu
        call gdpsin('72 '//char(0))
      write(dpistr,181) dpi
 181    format(g14.7)
        dpistr(15:15) = char(0)
        call gdpsin(dpistr)
        call gdpsin(' div dup scale 3 setlinewidth'//char(0))
      call gdpsdu
        return
        end


      SUBROUTINE GDPSOP(LUN)
C
      PARAMETER (IBUFSZ = 80)
      LOGICAL LNOPLT
      CHARACTER BUFFER*1,FNAME*80
      COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
      COMMON/POSTDCM/LUNPOS,INITPOST,LNOPLT,FNAME
C
      LUNOUT = LUN
      NXTCHR = 1
      RETURN
      END


      SUBROUTINE GDPSIT
C
      PARAMETER (IBUFSZ = 80)
      CHARACTER*1 BUFFER
      COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
      NXTCHR = 1
      RETURN
      END


      SUBROUTINE GDPSIN(STRING)
      CHARACTER*1 STRING(*)
C
      PARAMETER (IBUFSZ = 80)
      CHARACTER*1 BUFFER
      COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
      EXTERNAL LEN
C
      L = LEN(STRING)
      IF ((NXTCHR+L) .GT. IBUFSZ) CALL GDPSDU
            DO 100 I = 1, L
            BUFFER(NXTCHR) = STRING(I)
            NXTCHR = NXTCHR + 1
100         CONTINUE
      RETURN
      END

      SUBROUTINE GDPSDU
C
      PARAMETER (IBUFSZ = 80)
      CHARACTER*1 BUFFER
      COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
      IF (NXTCHR .EQ. 1) RETURN
      WRITE (LUNOUT,111) (BUFFER(I), I=1,NXTCHR-1)
 111    format(80a1)
      NXTCHR = 1
      RETURN
      END
      SUBROUTINE POSTDMP
      CHARACTER COMAND*120,FNAME*80,EOF*1
      LOGICAL LNOPLT
      COMMON/POSTDCM/LUNPOS,INITPOST,LNOPLT,FNAME
      EOF=CHAR(4)
      IF(INITPOST.EQ.0)RETURN
      IF (.NOT. LNOPLT) THEN
         CALL GDPSDU
         CALL GDPSIN('stroke showpage '//CHAR(0))
         CALL GDPSDU
c         CALL GDPSIN(EOF) 
         CALL GDPSDU
      ENDIF
      CLOSE (UNIT=LUNPOS)
c      COMAND = 'lpr -r '//FNAME
      COMAND = 'lpr '//FNAME
      ISTATUS = system(COMAND)
      INITPOST=0
      RETURN
      END
      SUBROUTINE GSETLW(XLW)
C
C     GSETLW sets the line width for PostScript plots
C
      COMMON /GCDSEL/ IDEV
      CHARACTER CLW*28
      IF(IDEV.EQ.3.OR.IDEV.EQ.4)THEN
         WRITE(CLW,90)XLW
90       FORMAT(' stroke ',F5.2,' setlinewidth ')
         CLW(28:28)=CHAR(0)
         CALL GDPSIN(CLW)
      END IF
      RETURN
      END
