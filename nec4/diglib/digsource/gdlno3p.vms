	SUBROUTINE GDLN03P_WIDE(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	DEC LN03-PLUS LASER PRINTER DRIVER
C
C-----------------------------------------------------------------------
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	LOGICAL GDLN03_TEST_FLUSH
	LOGICAL*1 L_WIDE, LVECTOR_GOING
	BYTE ESC, GS, FF
	PARAMETER (ESC=27)
	PARAMETER (GS=29)
	PARAMETER (FF=12)
	BYTE GSSTR(2), PAGESTR(3)
	DATA GSSTR /GS,0/
	DATA PAGESTR /ESC,FF,0/
C
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
	DATA DCHAR /3.0, 25.9842, 19.4818, 157.48, 157.48, 1.0, 27.0, 3.0/
C
	L_WIDE = .TRUE.
10	CONTINUE
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 7) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
	LUN = XA(1)
	OPEN (UNIT=LUN,NAME='SYS$LOGIN:LN03TEKPLOT.DIG',TYPE='NEW',
	1   CARRIAGECONTROL='LIST',ERR=9000)
C
C	SHOW INITIALIZATION WORKED, I.E. WE OPENED THE FILE.
C
	YA(1) = 0.0
	WRITE (LUN,101), ESC
101	FORMAT(A1,'[?38h')
190	CONTINUE
	CALL GDLN03_OPEN_BUFR(LUN)
	L_NOTHING_PLOTTED = .TRUE.
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	IF (L_NOTHING_PLOTTED) RETURN
	LDUMMY = GDLN03_TEST_FLUSH(2)
	CALL GDLN03_INSERT(PAGESTR)
	CALL GDLN03_DUMP_BUFR
	LVECTOR_GOING = .FALSE.
	GO TO 190
C
C	****
C	MOVE
C	****
C
300	CONTINUE
	IF (L_WIDE) THEN
		IXPOSN = XGUPCM*XA(1) + 0.5
		IYPOSN = YGUPCM*YA(1) + 0.5
	    ELSE
		IXPOSN = XGUPCM*YA(1) + 0.5
		IYPOSN = (DCHAR(3)-XA(1))*YGUPCM + 0.5
	ENDIF
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	IF (L_WIDE) THEN
		IX = XGUPCM*XA(1) + 0.5
		IY = YGUPCM*YA(1) + 0.5
	    ELSE
		IX = XGUPCM*YA(1) + 0.5
		IY = (DCHAR(3)-XA(1))*YGUPCM + 0.5
	ENDIF
	LVECTOR_GOING = LVECTOR_GOING .AND. (.NOT. GDLN03_TEST_FLUSH(5))
	IF (.NOT. LVECTOR_GOING) THEN
		LDUMMY = GDLN03_TEST_FLUSH(11)
		LVECTOR_GOING = .TRUE.
		CALL GDLN03_INSERT(GSSTR)
		CALL GDLN03_CONVERT(IXPOSN,IYPOSN)
	ENDIF
	CALL GDLN03_CONVERT(IX,IY)
	IXPOSN = IX
	IYPOSN = IY
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	RETURN		!DONE BY BGNPLT WHEN NECESSARY.
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	CALL GDLN03_DUMP_BUFR
	IF (.NOT. L_NOTHING_PLOTTED) THEN
		LDUMMY = GDLN03_TEST_FLUSH(2)
		CALL GDLN03_INSERT(PAGESTR)
		CALL GDLN03_DUMP_BUFR
	ENDIF
601	FORMAT(A2)
	WRITE (LUN,602) ESC
602	FORMAT(A1,'[?38l')
	CLOSE (UNIT=LUN)
	ISTATUS = LIB$SPAWN('$ DIGLN03POUT SYS$LOGIN:LN03TEKPLOT.DIG')
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	IF (.NOT. L_WIDE) THEN
		XA(2) = DCHAR(3)
		XA(3) = DCHAR(2)
	ENDIF
	RETURN
C
C	HANDLE FILE OPEN ERROR
C
9000	CONTINUE
	YA(1) = 3.0
	RETURN
C
C	***********************************************************
C
	ENTRY GDLN03P_TALL(IFXN,XA,YA)
	L_WIDE = .FALSE.
	GO TO 10
	END


	SUBROUTINE GDLN03_OPEN_BUFR(LUN)
C
	PARAMETER (IBUFR_SIZE = 120)
	BYTE BUFFER
	COMMON /GDLN03/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	LUNOUT = LUN
	NXTCHR = 1
	CALL GDLN03_CONVERT_RESET
	RETURN
	END


	SUBROUTINE GDLN03_INIT_BUFR
C
	PARAMETER (IBUFR_SIZE = 120)
	BYTE BUFFER
	COMMON /GDLN03/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	NXTCHR = 1
	RETURN
	END


	SUBROUTINE GDLN03_INSERT(STRING)
	BYTE STRING(2)
C
	PARAMETER (IBUFR_SIZE = 120)
	BYTE BUFFER
	COMMON /GDLN03/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	EXTERNAL LEN
C
	L = LEN(STRING)
	IF ((NXTCHR+L) .GT. IBUFR_SIZE) CALL GDLN03_DUMP_BUFR
		DO 100 I = 1, L
		BUFFER(NXTCHR) = STRING(I)
		NXTCHR = NXTCHR + 1
100		CONTINUE
	RETURN
	END

	FUNCTION GDLN03_TEST_FLUSH(NCHARS)
	LOGICAL GDLN03_TEST_FLUSH
C
	PARAMETER (IBUFR_SIZE = 120)
	BYTE BUFFER
	COMMON /GDLN03/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	IF (NXTCHR+NCHARS .GE. IBUFR_SIZE) THEN
		CALL GDLN03_DUMP_BUFR
		GDLN03_TEST_FLUSH = .TRUE.
	    ELSE
		GDLN03_TEST_FLUSH = .FALSE.
	ENDIF
	RETURN
	END

	SUBROUTINE GDLN03_DUMP_BUFR
C
	PARAMETER (IBUFR_SIZE = 120)
	BYTE BUFFER
	COMMON /GDLN03/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	IF (NXTCHR .EQ. 1) RETURN
	WRITE (LUNOUT,11) (BUFFER(I), I=1,NXTCHR-1)
11	FORMAT(132A1)
	NXTCHR = 1
	CALL GDLN03_CONVERT_RESET
	RETURN
	END

	SUBROUTINE GDLN03_CONVERT(IX,IY)
C
C	CONVERTS (IX,IY) TO THE 4014 12-BIT FORMAT AND PLACES THE
C	CHARACTERS INTO THE BUFFER.   OPTIMIZED FOR MINIMUM CHARS TO BE
C	TRANSMITTED.
C
	COMMON /GDLN03_STATE_MEM/ IOLD_HIY, IOLD_EX, IOLD_LOY, IOLD_HIX
	BYTE TEKCODE(6)
C
	IHIY = 32+IY/128
	IEX = 96+4*IAND(IY,3)+IAND(IX,3)
	ILOY = 96+IAND(IY/4,31)
	IHIX = 32+IX/128
	INXT = 1
C
C	HI-Y ONLY NEEDS BE SENT WHEN IT CHANGES
C
	IF (IHIY .NE. IOLD_HIY) THEN
		IOLD_HIY = IHIY
		TEKCODE(INXT) = IHIY
		INXT = INXT + 1
	ENDIF
C
C	EXTRA-BITS ONLY NEEDS BE SENT WHEN IT CHANGES, BUT IF SENT, THEN
C	LO-Y MUST BE SENT EVEN IF IT DIDN'T CHANGE.
C
	IF (IEX .NE. IOLD_EX) THEN
		IOLD_EX = IEX
		TEKCODE(INXT) = IEX
		TEKCODE(INXT+1) = ILOY
		INXT = INXT + 2
		IOLD_LOY = ILOY
	    ELSE
C
C		SEND LO-Y IF IT CHANGED OR IF WE NEED TO SEND A HI-X
C
		IF (ILOY .NE. IOLD_LOY .OR.
	1	   IHIX .NE. IOLD_HIX) THEN
			IOLD_LOY = ILOY
			TEKCODE(INXT) = ILOY
			INXT = INXT + 1
		ENDIF
	ENDIF
C
C	HI-X CAN ONLY BE SENT IF PRECEEDED BY LO-Y --> THIS IS HANDLED
C	PREVIOUSLY.
C
	IF (IHIX .NE. IOLD_HIX) THEN
		IOLD_HIX = IHIX
		TEKCODE(INXT) = IHIX
		INXT = INXT + 1
	ENDIF
C
C	LO-X MUST ALWAYS BE SENT
C
	TEKCODE(INXT) = 64+IAND(IX/4,31)
	TEKCODE(INXT+1) = 0
	CALL GDLN03_INSERT(TEKCODE)
	RETURN
	END

	SUBROUTINE GDLN03_CONVERT_RESET
	COMMON /GDLN03_STATE_MEM/ IOLD_HIY, IOLD_EX, IOLD_LOY, IOLD_HIX
	IOLD_HIY = -1
	IOLD_EX = -1
	IOLD_LOY = -1
	IOLD_HIX = -1
	RETURN
	END
