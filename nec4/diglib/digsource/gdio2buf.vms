	SUBROUTINE GB_INITIALIZE(TERMIN,ENDSTR,TTNAME,IERR)
	CHARACTER*(*) TTNAME
	BYTE ENDSTR(2), TERMIN
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE INITIALIZES THE GRAPHICS DRIVERS BUFFERING
C	 SUBROUTINES FOR DOUBLE BUFFERING
C	DOUBLE BUFFERING ADDED 18-OCT-1984
C
	INCLUDE 'GBCOMMON2.CMN'
C
	INTEGER*4 SYS$ASSIGN, SYS$SETEF, LIB$GET_EF
	EXTERNAL LEN
C
C	ASSIGN A CHANNEL TO THE DEVICE OUTPUT DEVICE
C
	ISTAT = SYS$ASSIGN(TTNAME,IOCHAN,,)
	IF (.NOT. ISTAT) THEN
		IERR = 1
		RETURN
	ENDIF
C
C	GET TWO FREE EVENT FLAGS, 1 FOR EACH BUFFER
C
	ISTAT = LIB$GET_EF(IFLAG(1))
D	TYPE *,'EVENT FLAG 1 IS ',IFLAG(1)
	IF (.NOT. ISTAT) THEN
		IERR = 1
		RETURN
	ENDIF
	ISTAT = LIB$GET_EF(IFLAG(2))
D	TYPE *,'EVENT FLAG 2 IS ',IFLAG(2)
	IF (.NOT. ISTAT) THEN
		IERR = 1
		RETURN
	    ELSE
		IERR = 0
	ENDIF
	IACTIVE_BUFFER = 1
	ISTAT = SYS$SETEF(%VAL(IFLAG(1)))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	ISTAT = SYS$SETEF(%VAL(IFLAG(2)))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
C
	CALL SCOPY(ENDSTR,END_STRING)
	IEND_LENGTH = LEN(END_STRING)
	BEGIN_STRING(1) = 0
	IBEGIN_LENGTH = 0
C
	TERM_CHAR = TERMIN
C
	CALL GB_INIT_BUFFER
	RETURN
	END


	SUBROUTINE GB_BEGIN_STRING(STRING)
C
C	THIS SUBROUTINE SETS THE "BEGINNING OF EACH BUFFER STRING"
C	 IT SHOULD BE CALLED ONCE IMMEDIATELY AFTER CALLING GB_INITIALIZE
C
	INCLUDE 'GBCOMMON2.CMN'
c
	EXTERNAL LEN
C
	CALL SCOPY(STRING,BEGIN_STRING)
	IBEGIN_LENGTH = LEN(BEGIN_STRING)
	CALL GB_INIT_BUFFER
	RETURN
	END



	SUBROUTINE GB_NEW_BUFFER
C
C	SUBROUTINE TO INITIALIZE THE GRAPHIC COMMAND BUFFER
C
	INCLUDE 'GBCOMMON2.CMN'
C
	INTEGER*4 SYS$WAITFR
C
	IACTIVE_BUFFER = IACTIVE_BUFFER+1
	IF (IACTIVE_BUFFER .GT. 2) IACTIVE_BUFFER = 1
D	TYPE *,'IACTIVE_BUFFER IS ',IACTIVE_BUFFER
D	TYPE *,'THAT FLAG IS ',IFLAG(IACTIVE_BUFFER)
C
C	MAKE SURE THIS NEW BUFFER IS EMPTY, IF NOT, WAIT FOR IT
C	TO EMPTY
C
	ISTAT = SYS$WAITFR(%VAL(IFLAG(IACTIVE_BUFFER)))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	GO TO 100
C
	ENTRY GB_INIT_BUFFER()
C
100	CALL SCOPY(BEGIN_STRING,BUFFER(1,IACTIVE_BUFFER))
	IBFPTR = IBEGIN_LENGTH + 1
	L_USE_TERMINATOR = .FALSE.
	RETURN
	END



	FUNCTION GB_TEST_FLUSH(NUMCHR)
	LOGICAL GB_TEST_FLUSH
C
C	THIS SUBROUTINE CHECKS TO MAKE SURE THERE IS ENOUGH ROOM IN
C	THE BUFFER FOR "NUMCHR" MORE CHARACTERS, IF NOT, IF MAKES ROOM BY
C	EMPTYING THE BUFFER.
C
	INCLUDE 'GBCOMMON2.CMN'
C
	IF (IBFPTR+NUMCHR+IEND_LENGTH .GE. IBFSIZ) THEN
		CALL GB_EMPTY
		GB_TEST_FLUSH = .TRUE.
	    ELSE
		GB_TEST_FLUSH = .FALSE.
	    ENDIF
	RETURN
	END



	SUBROUTINE GB_USE_TERMINATOR
C
C	THIS SUBROUTINE SETS THE "USE TERMINATOR" FLAG TO TRUE.
C	THE FLAG IS SET TO FALSE BY CALLING GB_NO_TERMINATOR OR BY
C	EMPTYING/CLEARING THE BUFFER.
C
	INCLUDE 'GBCOMMON2.CMN'
C
	L_USE_TERMINATOR = .TRUE.
	RETURN
	END



	SUBROUTINE GB_NO_TERMINATOR
C
C	THIS SUBROUTINE CLEARS THE "USE TERMINATOR" FLAG TO FALSE.
C
	INCLUDE 'GBCOMMON2.CMN'
C
	L_USE_TERMINATOR = .FALSE.
	RETURN
	END



	SUBROUTINE GB_EMPTY
C
C	THIS SUBROUTINE EMPTYS THE BUFFER IF IT HAS ANYTHING
C
	INCLUDE 'GBCOMMON2.CMN'
	INTEGER*2 IOSB(4,2)
C
C
	IF (IBFPTR-1 .LE. IBEGIN_LENGTH) THEN
		CALL GB_INIT_BUFFER
		RETURN
	ENDIF
	IF (L_USE_TERMINATOR) CALL GB_INSERT(TERM_CHAR)
	IF (IEND_LENGTH .NE. 0) CALL GB_IN_STRING(END_STRING)
	IF (IBFPTR .GT. IBFSIZ+1) STOP 'BUFFERING ERROR - BUFFER OVERFLOWED'
C
C	SEND TO TTY
C
	CALL GB_SEND_TTY(BUFFER(1,IACTIVE_BUFFER),
	1   IBFPTR-1,IFLAG(IACTIVE_BUFFER),IOSB(1,IACTIVE_BUFFER))
	CALL GB_NEW_BUFFER
	RETURN
	END



	SUBROUTINE GB_SEND_CHARS(STRING,LENGTH)
	BYTE STRING(LENGTH)
C
	INTEGER*2 IOSB(4)
C
	CALL GB_SEND_TTY(STRING,LENGTH,0,IOSB)
	RETURN
	END



	SUBROUTINE GB_SEND_TTY(TTY_BUFFER,IBUFR_LEN,IEVFLAG,IOSB)
	BYTE TTY_BUFFER(IBUFR_LEN)
	INTEGER*2 IOSB(4)
C
C	*** VMS SPECIFIC ***
C	NOTE: FOR INTERNAL USE ONLY.   NO DRIVERS SHOULD CALL THIS ROUTINE.
C	DRIVERS SHOULD USE GB_SEND_CHARS INSTEAD.
C
C	THIS SUBROUTINE EMPTYS THE BUFFER IF IT HAS ANYTHING
C
	INCLUDE '($IODEF)'
C	PARAMETER (IO_WRITEV = '00000130'X)	!IO$_WRITEVBLK+IO$M_NOFORMAT
	INCLUDE '($SSDEF)'
	INCLUDE 'GBCOMMON2.CMN'
C
	INTEGER*4 CR_CONTROL
	PARAMETER (CR_CONTROL = 0)
C
	INTEGER*4 SYS$QIO
C
C	DO THE QIO TO THE OUTPUT DEVICE
C
10	CONTINUE
	ISTAT = SYS$QIO(%VAL(IEVFLAG),%VAL(IOCHAN),
	1   %VAL(IO$_WRITEVBLK+IO$M_NOFORMAT),
	2   IOSB, , ,
	3   TTY_BUFFER,%VAL(IBUFR_LEN), ,%VAL(CR_CONTROL), , )
	IF (.NOT. ISTAT) then
		type 999, istat
999		format(' QIOW to terminal failed, status was ',i9)
	ENDIF
	RETURN
	END



	SUBROUTINE GB_INSERT(BCHAR)
	BYTE BCHAR
C
C	THIS SUBROUTINE INSERTS A CHARACTER INTO THE BUFFER
C
	INCLUDE 'GBCOMMON2.CMN'
C
	BUFFER(IBFPTR,IACTIVE_BUFFER) = BCHAR
	IBFPTR = IBFPTR + 1
	RETURN
	END


	SUBROUTINE GB_IN_STRING(STRING)
	BYTE STRING(80)
C
C	THIS SUBROUTINE INSERTS THE STRING INTO THE GRAPHICS BUFFER
C
	EXTERNAL LEN
C
	DO 100 I=1, LEN(STRING)
	  CALL GB_INSERT(STRING(I))
100	  CONTINUE
	RETURN
	END


	SUBROUTINE GB_FINISH(RELEASE_STRING)
	BYTE RELEASE_STRING(2)
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE RELEASES THE I/O CHANNAL TO THE OUTPUT DEVICE
C
	INCLUDE 'GBCOMMON2.CMN'
C
	INTEGER*4 SYS$DASSGN, SYS$WAITFR
	EXTERNAL LEN
C
	IF (LEN(RELEASE_STRING) .NE. 0) THEN
	    CALL GB_EMPTY
	    CALL GB_IN_STRING(RELEASE_STRING)
	    CALL GB_EMPTY
	  ENDIF
	ISTAT = SYS$WAITFR(%VAL(IFLAG(1)))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	ISTAT = SYS$WAITFR(%VAL(IFLAG(2)))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	ISTAT = SYS$DASSGN(%VAL(IOCHAN))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	ISTAT = LIB$FREE_EF(IFLAG(1))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	ISTAT = LIB$FREE_EF(IFLAG(2))
D	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	RETURN
	END


	SUBROUTINE GB_GIN(PROMPT,IGIN_CHARS_MAX,L_TERMS_OK,GINBUFR)
	BYTE GINBUFR(2), PROMPT(2)
	LOGICAL*1 L_TERMS_OK
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE DOES A GIN OPERATION VIA A "READ-AFTER-PROMPT"
C	QIOW.
C
	INCLUDE 'GBCOMMON2.CMN'
C
C	PARAMETER (IO_READ_PROMPT = '877'X)
C	PARAMETER (IO_READ_NOECHO = '71'X)
	INCLUDE '($IODEF)'
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
	EXTERNAL LEN
C
	IPRLEN = LEN(PROMPT)
	IF (IPRLEN .EQ. 0) THEN
		IFXN = IO$_READVBLK + IO$M_NOECHO
	    ELSE
		IFXN = IO$_READPROMPT + IO$M_PURGE + IO$M_NOECHO
	ENDIF
	II = 1
	NUMBER_TO_GET = IGIN_CHARS_MAX
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IFXN),
	1   IOSB, , ,GINBUFR(II),%VAL(NUMBER_TO_GET),%VAL(0), ,
	2   PROMPT,%VAL(IPRLEN))
	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	IF (.NOT. L_TERMS_OK) GO TO 800
100	CONTINUE
	NUMBER_GOT = IOSB(2)+IOSB(4)
D	TYPE 9999, NUMBER_GOT, (GINBUFR(I), I=1,NUMBER_GOT+II-1)
D9999	FORMAT(/' GB_GIN just got ',I2,' characters.'
D	1   /' The characters buffered so far are:'
D	2   /,20(1X,I3))
	IF (NUMBER_GOT .GE. NUMBER_TO_GET) GOTO 800
	NUMBER_TO_GET = NUMBER_TO_GET - NUMBER_GOT
	II = NUMBER_GOT + II
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_READVBLK+IO$M_NOECHO),
	1   IOSB, , ,GINBUFR(II),%VAL(NUMBER_TO_GET), , , , )
	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	GO TO 100
800	RETURN
	END



	SUBROUTINE GB_INTERLOCK(PROMPT,IN_BUFFER,IN_CHAR_COUNT)
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE IS USED BY THOSE DRIVERS THAT MUST USE AN INTERLOCKING
C	  WITH THE TERMINAL SO THAT BUFFER OVERFLOW DOES NOT OCCUR IN THE
C	  TERMINAL.   MOSTLY, THIS IS CAUSED BY HP TERMINALS.   IT SEEMS
C	  THAT HP NEVER HAS UNDERSTOOD THE USEFULNESS OF XON/XOFF!
C
	INCLUDE 'GBCOMMON2.CMN'
C
	INCLUDE '($IODEF)'
C	PARAMETER (IO_READ_PROMPT = '877'X)
C		IO$_READPROMPT + IO$M_PURGE + IO$M_NOECHO
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
	EXTERNAL LEN
C
	IPRLEN = LEN(PROMPT)
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_READPROMPT+IO$M_NOECHO+IO$M_PURGE),
	2   IOSB, , ,IN_BUFFER,%VAL(IN_CHAR_COUNT),%VAL(0),%VAL(0),
	3   PROMPT,%VAL(IPRLEN))
	IF (.NOT. ISTAT) STOP 'INTERLOCK QIOW FAILED'
	RETURN
	END



	SUBROUTINE GB_OUTPUT_BUFFER(BUFFER,IBUFLEN)
	BYTE BUFFER(IBUFLEN)
C
C	SUBROUTINE TO OUTPUT A BUFFER
C
	INTEGER*2 IOSB(4)
	INTEGER*4 LIB$GET_EF, SYS$WAITFR
C
	DATA IEVFLAG /-1/
C
	IF (IEVFLAG .LT. 0) THEN
		ISTAT = LIB$GET_EF(IEVFLAG)
	ENDIF
	CALL GB_SEND_TTY(BUFFER,IBUFLEN,IEVFLAG,IOSB)
CCCC	ISTAT = SYS$WAITFR(%VAL(IEVFLAG))
	RETURN
	END



	SUBROUTINE GB_INPUT_BUFFER(PROMPT,IPRLEN,
	1   IN_BUFFER,IN_CHAR_COUNT,IGOT)
C
C	*** VMS SPECIFIC ***
C
C	SUBROUTINE TO READ IN A BUFFER AFTER ISSUING A PROMPT
C
	INCLUDE '($IODEF)'
C	PARAMETER (IO_READ_PROMPT = '877'X)
C		IO$_READPROMPT + IO$M_PURGE + IO$M_NOECHO
C
	INCLUDE 'GBCOMMON2.CMN'
C
	INTEGER*4 SYS$QIOW, IOTERMS(2)
	INTEGER*2 IOSB(4)
C
	DATA IOTERMS /0,'2000'X/ !<CR> IS ONLY TERMINATOR
C
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_READPROMPT+IO$M_NOECHO+IO$M_PURGE),
	2   IOSB, , ,IN_BUFFER,%VAL(IN_CHAR_COUNT),%VAL(0),IOTERMS,
	3   PROMPT,%VAL(IPRLEN))
	IF (.NOT. ISTAT) CALL LIB$STOP(%VAL(ISTAT))
	IGOT = IOSB(2)
	RETURN
	END
