	SUBROUTINE GDVT125(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	VT125 DRIVER FOR DIGLIB/VAX
C		Modified for DIGLIB V3 by Hal Brand 8-Feb-1985.
C
C	Opinion of Hal Brand:
C		It is completely misleading to even think of VT125 as graphics
C		devices.   DEC does not know the first thing about making
C		graphics terminals, and by their track record (VT240/241)
C		probably never will.   You will probably be very disappointed
C		if you use this driver for two reasons: 1) The driver may not
C		work well (and I don't really care cause of the above), and
C		2) The truth in the opinions above.
C
C---------------------------------------------------------------------------
C
	BYTE ESC
	PARAMETER (ESC=27)
	CHARACTER*(*) TERMINAL
	PARAMETER (TERMINAL='TT')
C
C	DEFINITIONS FOR DEVICE CONTROL
C
	BYTE STR_END(4)
	BYTE STR_INIT(39)
	BYTE STR_BEGIN_PLOT(16)
	BYTE STR_COLOR_SET(10)
	BYTE STR_PREFACE(4)
	BYTE GINBUFR(14)
	BYTE PROMPT(7)
	BYTE STR_COORD(10)
	BYTE BEGIN_CHAR, CHAR_P, CHAR_V
	DATA CHAR_LEFT_BRACKET /'['/
	DATA CHAR_RIGHT_BRACKET /']'/
	DATA CHAR_V /'V'/
	DATA CHAR_P /'P'/
	BYTE COLOR(8)
	DATA COLOR /'D','W','R','G','B','Y','M','C'/
C
C	THE VT125 DRIVER USES THE DIGLIB/VAX STANDARD TERMINAL BUFFERING
C	 SUBROUTINES.   GRAPHIC COMMANDS ARE BUFFERED BY THESE SUBROUTINES
C	 AND SENT TO THE USERS TERMINAL UNDER PROGRAM CONTROL.
C
C	***
C	STR_END CONTAINS THE STRING WHICH IS APPENDED TO THE COMMAND BUFFER
C	 JUST BEFORE IT IS SENT TO THE TERMINAL.   THIS ELIMINATES THE NEED
C	 TO CONSTANTLY REMEMBER TO APPEND THIS STRING JUST BEFORE FLUSHING
C	 THE BUFFER.
C	***
	DATA STR_END /ESC,'\',0,0/
C
C	***
C	STR_INIT CONTAINS THE STRING TO INITIALIZE THE VT125.   THIS STRING
C	 IS ONLY SENT WHEN WHEN IFXN=1 (I.E. AT "DEVSEL" TIME).
C	***
	DATA STR_INIT /
	1   ESC,'[','H',			!HOME ALPHA CURSOR
	2   ESC,'[','J',			!ERASE ALPHA TO END OF SCREEN
	3   ESC,'P','p',			!ENTER ReGIS
	4   'S','(','I','D',			!SET SCREEN MODE dark
	5   'A','[','0',',','4','7','9',']',	!SET ADDRESS TRANSLATION
	6   '[','7','6','7',',','0',']',')',	!so origin is lower left
	5   'W','(','I','W','R','P','1',')',	!SET WRITING MODE
	6   0,0/
C
C	***
C	STR_BEGIN_PLOT CONTAINS THE STRING TO "GET A FRESH PLOTTING SURFACE"
C	 AND TO MAKE SURE THE DEVICE IS IN "NORMAL" MODE, READY TO PLOT.
C	***
	DATA STR_BEGIN_PLOT /
	1   ESC,'P','p',			!ENTER ReGIS
	2   'S','(','I','D','E',')',		!SET BKGD DARK & ERASE SCREEN
	3   'W','(','I','W','R',')',0/		!WRITE IN WHITE
C
C	***
C	STR_COLOR_SET CONTAINS THE STRING TO SELECT A NEW COLOR.
C	 THIS STRINGS CONTAINS A DUMMY ARGUMENT THAT IS MODIFIED AT RUN TIME
C	 TO BE THE COLOR SELECTED.
C	ICOLOR_BYTE IS THE SUBSCRIPT OF THE BYTE TO BE MODIFIED IN THE
C	 SET COLOR COMMAND.
C	***
	DATA STR_COLOR_SET /
	1   ESC,'P','p',			!ENTER ReGIS
	2   'W','(','I','W',')',0,0/		!WRITE IN COLOR or MONO
	DATA ICOLOR_BYTE /7/
C
C	***
C	STR_PREFACE CONTAINS THE ReGIS ENTRY STRING.
C	***
	DATA STR_PREFACE / ESC,'P','p',0/
C
C	***
C	PROMPT IS STRING SENT TO VT125 TO REQUEST IT DISPLAY THE GRAPHICS
C	 CURSOR, WAIT TILL USER HITS A KEY, THEN RETURN THE GRAPHICS CURSOR
C	 POSITION ALONG WITH THE KEY THE USER HIT.
C	***
	DATA PROMPT /
	1   ESC,'P','p',			!ENTER ReGIS
	2   'R','(','P',')'/
C
C	***
C	IGIN_IN_CHARACTERS IS THE EXPECTED NUMBER OF CHARACTERS RETURNED
C	 BY THE VT125 IN RESPONSE TO "PROMPT".
C	***
	DATA IGIN_IN_CHARS /12/
C
C	***
C****************************************************************************
C
C	DECLARE BUFFERING FUNCTION
C
	LOGICAL GB_TEST_FLUSH
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	LOGICAL L_PREFACED, LDUMMY
	DIMENSION DCHAR(7)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
C
C	FOR DESCRIPTION OF DCHAR, SEE "DEVICE CHARACTERISTICS" RETURNED
C	 BY DRIVER WHEN IFXN=7 (I.E. GET DEVICE CHARACTERISTICS)
C
	DATA DCHAR /125.0, 25.583, 15.933, 30.0, 15.0, 3.0, 5.0, 1.0/
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 9) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700,800,900) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
C
C	FIRST, INITIALIZE THE BUFFER SUBROUTINES
C
	CALL GB_INITIALIZE(13,STR_END,TERMINAL,IERR)
	YA(1) = IERR
	IF (IERR .NE. 0) RETURN
C
C	THEN, INITIALIZE THE VT125
C
	CALL GB_IN_STRING(STR_INIT)
	GO TO 290
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	CALL GB_NEW_BUFFER
	CALL GB_IN_STRING(STR_BEGIN_PLOT)
290	CALL GB_EMPTY
	L_PREFACED = .FALSE.
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
	BEGIN_CHAR = CHAR_P
	GO TO 420
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	BEGIN_CHAR = CHAR_V
C
420	CONTINUE
C
C	CONVERT CM TO VT125 GRAPHICS UNITS
C
	IX = XGUPCM*XA(1)+0.5
	IY = 2*INT(YGUPCM*YA(1)+0.5)
C
C	SEE IF ENOUGH ROOM IN BUFFER FOR THIS COMMAND
C	 WE NEED 10 CHARACTERS OF ROOM, SO BE SAFE AS MAKE SURE 12 LEFT.
C
	L_PREFACED = L_PREFACED .AND. (.NOT. GB_TEST_FLUSH(12))
	IF (.NOT. L_PREFACED) CALL GB_IN_STRING(STR_PREFACE)
C
C	INSERT THE ReGIS COMMAND TO MOVE/DRAW
	CALL GB_INSERT(BEGIN_CHAR)
	ENCODE (9,431,STR_COORD) IX,IY
431	FORMAT('[',I3,',',I3,']')
	STR_COORD(10) = 0
	CALL GB_IN_STRING(STR_COORD)
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	CALL GB_EMPTY
	L_PREFACED = .FALSE.
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
C
C	DO NOTHING - LET USER KILL PICTURE
C
	CALL GB_EMPTY
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	RETURN
C
C	****************************
C	SELECT CURRENT DRAWING COLOR
C	****************************
C
800	CONTINUE
	CALL GB_EMPTY
	ICOLOR = XA(1) + 1
	IF (ICOLOR .LT. 1 .OR. ICOLOR .GT. 8) RETURN
	STR_COLOR_SET(ICOLOR_BYTE) = COLOR(ICOLOR)
	CALL GB_IN_STRING(STR_COLOR_SET)
	L_PREFACED = .TRUE.
	RETURN
C
C	**********************
C	PERFORM GRAPHICS INPUT
C	**********************
C
900	CONTINUE
	CALL GB_EMPTY
	L_PREFACED = .FALSE.
C
C	ASK FOR 1 GIN INPUT
C
	CALL GB_GIN(PROMPT,-IGIN_IN_CHARS,.TRUE.,GINBUFR)
	TYPE 992,GINBUFR
992	FORMAT(' Ginbufr',14O4)
C
C	GET KEY PRESSED
C
c	I = 3
c	XA(1) = GINBUFR(1)
c	IF (GINBUFR(1) .EQ. CHAR_LEFT_BRACKET) THEN
c		XA(1) = 13
c		I = 2
c	ENDIF
C
C	GET X,Y
C
c	DECODE (11,991,GINBUFR(I)) XA(2), XA(3)
991	FORMAT(F3.0,1X,F3.0)
c	XA(2) = XA(2)/XGUPCM
c	XA(3) = 0.5*XA(3)/YGUPCM
	RETURN
	END
