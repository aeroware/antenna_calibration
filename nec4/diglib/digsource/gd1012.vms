	SUBROUTINE GD1012_LONG(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	CalComp 1012 plotter driver for VMS
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	PLOTTER COMMANDS, ETC.
C
C
	INTEGER CMD_INIT_PLOTTER_SIZE, CMD_PEN_UP_SIZE,
	1   CMD_INDEX_PLOTTER_SIZE, CMD_PEN_DOWN_SIZE, CMD_SELECT_PEN_SIZE,
	2   CMD_MAX_DELTA_SIZE
	PARAMETER (CMD_INIT_PLOTTER_SIZE = 32)
	PARAMETER (CMD_PEN_UP_SIZE = 1)
	PARAMETER (CMD_INDEX_PLOTTER_SIZE = 3)
	PARAMETER (CMD_PEN_DOWN_SIZE = 1)
	PARAMETER (CMD_SELECT_PEN_SIZE = 2)
	PARAMETER (IPEN_NUMBER_POSITION = 2)
	PARAMETER (CMD_MAX_DELTA_SIZE = 7)
	BYTE RESPONSE_CHARACTER, RC1, RC2
	PARAMETER (RESPONSE_CHARACTER = '&')
	PARAMETER (RC1 = RESPONSE_CHARACTER/16)
	PARAMETER (RC2 = RESPONSE_CHARACTER-16*RC1)
	BYTE CMD_INIT_PLOTTER(CMD_INIT_PLOTTER_SIZE+1),
	1   CMD_PEN_UP(CMD_PEN_UP_SIZE+1),
	2   CMD_INDEX_PLOTTER(CMD_INDEX_PLOTTER_SIZE+1),
	3   CMD_PEN_DOWN(CMD_PEN_DOWN_SIZE+1),
	4   CMD_SELECT_PEN(CMD_SELECT_PEN_SIZE+1)
	DATA CMD_INIT_PLOTTER /
	1   7,63,		!RADIX 64
	2   8,1,		!ENABLE DOUBLE BUFFERING IN PLOTTER
	3   8,2,0,		!RESPONSE SUFFIX LENGTH IS 0
	4   8,3,0,		!TURN-AROUND DELAY IS 0
	5   8,4,1,3,0,		!PACKET ACCEPTED RESPONSE IS '0'
	6   8,5,1,3,1,		!PACKET REJECTED RESPONSE IS '1'
	7   8,6,1,RC1,RC2,	!RESPONSE REQUEST CHARACTER
	9   4,1,		!SELECT PEN 1
	1   9,1,		!SCALE FACTOR IS 1
	2   11,0,6,-1/		!INDEX THE PLOTTER
	DATA CMD_PEN_UP / 3,-1/	!PEN UP COMMAND
	DATA CMD_INDEX_PLOTTER /
	1   11,0,6,-1/		!INDEX THE PLOTTER
	DATA CMD_PEN_DOWN /
	1   2,-1/		!PEN UP COMANND
	DATA CMD_SELECT_PEN /
	1   4, 1,-1/		!SELECT PEN COMMAND
C
	LOGICAL LONG, LFRESH_PAGE
C
C	STANDARD DEVICE DRIVER STUFF
C
	DIMENSION DCHAR(8)
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
C	Note: Table is set up for TALL mode.
	DATA DCHAR /1012.0, 21.0, 27.3, 200.0, 200.0, 4.0, 24.0, 40.0/
C
C	DECLARE BUFFERING FUNCTION
C
	LOGICAL GH_TEST_FLUSH
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	LONG = .TRUE.
	GO TO 10
	ENTRY GD1012_TALL(IFXN,XA,YA)
	LONG = .FALSE.
10	CONTINUE
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 8) RETURN
	GO TO (100,200,300,400,500,600,700,800) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
C
C	FIRST, INITIALIZE THE BUFFER SUBROUTINES
C
	CALL GH_INITIALIZE(IERR)
	YA(1) = IERR
	IF (IERR .NE. 0) RETURN
	CALL GH_TIMED
	CALL GH_IN_BIASED(CMD_INIT_PLOTTER)
	CALL GH_EMPTY
	CALL GH_NO_TIMED
	GO TO 280
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	CALL GH_NEW_BUFFER
	CMD_SELECT_PEN(IPEN_NUMBER_POSITION) = 1
	CALL GH_IN_BIASED(CMD_SELECT_PEN)
	IF (.NOT. LFRESH_PAGE) THEN
		CALL GD1012_CONVERT(4200-IXPOSN,0-IYPOSN)
	ENDIF
	LFRESH_PAGE = .TRUE.
	CALL GH_IN_BIASED(CMD_INDEX_PLOTTER)
280	CONTINUE
	LFRESH_PAGE = .TRUE.
	LPEN_DOWN = .FALSE.	!RAISED BY SELECT PEN
	IXPOSN = 25
	IYPOSN = -25
	IPEN = 1
	CALL GH_EMPTY
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
	CALL GH_TEST_FLUSH(CMD_MAX_DELTA_SIZE+CMD_PEN_UP_SIZE)
	IF (LPEN_DOWN) THEN
		CALL GH_IN_BIASED(CMD_PEN_UP)
		LPEN_DOWN = .FALSE.
	ENDIF
	GO TO 420
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	CALL GH_TEST_FLUSH(CMD_MAX_DELTA_SIZE+CMD_PEN_DOWN_SIZE)
	IF (.NOT. LPEN_DOWN) THEN
		CALL GH_IN_BIASED(CMD_PEN_DOWN)
		LPEN_DOWN = .TRUE.
	ENDIF
	LFRESH_PAGE = .FALSE.
420	CONTINUE
	IX = XGUPCM*XA(1)+0.5
	IY = YGUPCM*YA(1)+0.5
	IF (LONG) THEN
		ITEMP = IX
		IX = IY
		IY = 5462-ITEMP
	ENDIF
	CALL GD1012_CONVERT(IX-IXPOSN,IY-IYPOSN)
	IXPOSN = IX
	IYPOSN = IY
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	CALL GH_EMPTY
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	CMD_SELECT_PEN(IPEN_NUMBER_POSITION) = 1
	CALL GH_IN_BIASED(CMD_SELECT_PEN)
	CALL GD1012_CONVERT(4200-IXPOSN,0-IYPOSN)
	CALL GH_IN_BIASED(CMD_INDEX_PLOTTER)
	CALL GH_EMPTY
	CALL GH_FINISH
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	IF (LONG) THEN
		XA(2) = DCHAR(3)
		XA(3) = DCHAR(2)
		XA(1) = XA(1) + 0.5
	ENDIF
	RETURN
C
C	****************************
C	SELECT CURRENT DRAWING COLOR
C	****************************
C
800	CONTINUE
	CALL GH_TEST_FLUSH(CMD_SELECT_PEN_SIZE)
	ICOLOR = XA(1)
	IF (ICOLOR .LE. 0 .OR. ICOLOR .GT. 4) RETURN
	IF (ICOLOR .NE. IPEN) THEN
		CMD_SELECT_PEN(IPEN_NUMBER_POSITION) = ICOLOR
		CALL GH_IN_BIASED(CMD_SELECT_PEN)
		IPEN = ICOLOR
	ENDIF
	RETURN
	END

	SUBROUTINE GD1012_CONVERT(IDX,IDY)
C
C	THIS SUBROUTINE CONVERTS AND INSERTS THE DELTA WITH THE
C	 PROPER DELTA CODE.
C
	PARAMETER (IRADIX = 64)
	BYTE RBUFR(8), BDELTAS(7,7)
	DATA RBUFR(8) /-1/
	DATA BDELTAS / 19,43,47,31,46,42,18,
	2   51,23,59,35,58,22,50,
	3   55,63,27,39,26,62,54,
	4   29,33,37,-1,38,34,30,
	5   53,61,25,36,24,60,52,
	6   49,21,57,32,56,20,48,
	7   17,41,45,28,44,40,16/
C
	IF (IDX .EQ. 0 .AND. IDY .EQ. 0) RETURN
	I = 7
	ICOORD = IABS(IDY)
	DO 200 J=1,2
		ISTART = I
100			CONTINUE
			IF (ICOORD .EQ. 0) GO TO 190
			RBUFR(I) = ICOORD .AND. (IRADIX-1)
			I = I-1
			ICOORD = ICOORD/IRADIX
			GO TO 100
190		CONTINUE
		IF (J .EQ. 1) THEN
			NY = 4 + ISIGN(1,IDY)*(ISTART-I)
			ICOORD = IABS(IDX)
		ENDIF
200		CONTINUE
	RBUFR(I) = BDELTAS(4+ISIGN(1,IDX)*(ISTART-I),NY)
D	type 9999, idx,idy, (rbufr(j), j=i,8)
D9999	format(' The delta command for (',i5,',',i5,') is:'/2x,8i8)
D	type 9998
D9998	format(/)
	CALL GH_IN_BIASED(RBUFR(I))
	RETURN
	END


	SUBROUTINE GH_INITIALIZE(IERR)
C
	BYTE BIAS, STMSG, RESPONSE_CHARACTER, PACKET_ACCEPTED_CHAR
	PARAMETER (BIAS	= 32)
	PARAMETER (STMSG = 2)
	PARAMETER (RESPONSE_CHARACTER = '&')
	PARAMETER (PACKET_ACCEPTED_CHAR = '0')
C
	INCLUDE '($SSDEF)'
	INCLUDE 'GD1012.CMN'
C
	CHARACTER*(*) DEVICE_NAME
	PARAMETER (DEVICE_NAME='CALCOMP_TERM')
	INTEGER*4 SYS$ASSIGN
C
C	ASSIGN A CHANNEL TO THE DEVICE OUTPUT DEVICE
C
10	continue
	ISTAT = SYS$ASSIGN(DEVICE_NAME,IOCHAN,,)
	if (istat .eq. ss$_devalloc) then
		type 11
11		format(' Waiting 10 seconds for plotter to become free.')
		call lib$wait(10.0)
		goto 10
	endif
	IF (.NOT. ISTAT) THEN
		IERR = 1
		RETURN
	    ELSE
		IERR = 0
	ENDIF
C
C	PLACED FIXED START OF PACKET FOR PLOTTER
C
	BIASCHAR = BIAS
	RESPCHAR = RESPONSE_CHARACTER
	GOODCHAR = PACKET_ACCEPTED_CHAR
	BUFFER(1) = STMSG
	BUFFER(2) = BIASCHAR
	CALL GH_NEW_BUFFER
	RETURN
	END



	SUBROUTINE GH_NEW_BUFFER
C
C	SUBROUTINE TO INITIALIZE THE GRAPHIC COMMAND BUFFER
C
C
	INCLUDE 'GD1012.CMN'
C
C
	IBUFPTR = 3
	ICHECK_SUM = 0
	RETURN
	END



	FUNCTION GH_TEST_FLUSH(NUMCHR)
	LOGICAL GH_TEST_FLUSH
C
C	THIS SUBROUTINE CHECKS TO MAKE SURE THERE IS ENOUGH ROOM IN
C	THE BUFFER FOR "NUMCHR" MORE CHARACTERS, IF NOT, IF MAKES ROOM BY
C	EMPTYING THE BUFFER.
C
	PARAMETER (IEND_LENGTH = 3)
C
C
	INCLUDE 'GD1012.CMN'
C
C
	IF (IBUFPTR+NUMCHR+IEND_LENGTH .GE. IBUFSIZ) THEN
		CALL GH_EMPTY
		GH_TEST_FLUSH = .TRUE.
	    ELSE
		GH_TEST_FLUSH = .FALSE.
	    ENDIF
	RETURN
	END



	SUBROUTINE GH_EMPTY
C
C	THIS SUBROUTINE EMPTYS THE BUFFER IF IT HAS ANYTHING
C
	BYTE EOMSG, CR
	PARAMETER (EOMSG = 3)
	PARAMETER (CR = 13)
C
C
	INCLUDE 'GD1012.CMN'
C
C
	IF (IBUFPTR .LE. 3) GO TO 900
	CALL GH_INSERT(96-(ICHECK_SUM .AND. 31))
	CALL GH_INSERT(EOMSG)
	CALL GH_INSERT(CR)
	IF (IBUFPTR .GT. IBUFSIZ+1) STOP 'BUFFERING ERROR - BUFFER OVERFLOWED'
C
C	SEND TO PLOTTER
C
	CALL GH_SEND
900	CALL GH_NEW_BUFFER
	RETURN
	END



	SUBROUTINE GH_SEND
C
C	*** VMS SPECIFIC ***
C
	INCLUDE '($IODEF)'
	INCLUDE '($SSDEF)'
C
	INCLUDE 'GD1012.CMN'
C
	INTEGER*4 CR_CONTROL
	PARAMETER (CR_CONTROL = 0)
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
	BYTE INBUF
C
C	DO THE QIOW TO THE OUTPUT DEVICE
C
10	CONTINUE
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_WRITEVBLK+IO$M_NOFORMAT),IOSB, , ,
	2   BUFFER,%VAL(IBUFPTR-1),5,%VAL(CR_CONTROL), , )
	IF (.NOT. ISTAT) then
		type 999, istat
999		format(' Write QIOW to CalComp failed, status was ',i9)
		stop
	ENDIF
	IFXN = IO$_READPROMPT+IO$M_NOECHO+IO$M_PURGE
	IF (LTIMED) IFXN = IFXN + IO$M_TIMED
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IFXN),IOSB, , ,
	2   INBUF,%VAL(1),%VAL(2), ,RESPCHAR,%VAL(1))
	IF (ISTAT .EQ. SS$_TIMEOUT) THEN
		TYPE 901
901		FORMAT(/'$Please make the CalComp ready, then hit RETURN')
		ACCEPT 902, I
902		FORMAT(A1)
		GO TO 10
	ENDIF
	IF (.NOT. ISTAT) then
		type 998, istat
998		format(' ReadPrompt QIOW to CalComp failed, status was ',i9)
		call lib$stop(%val(istat))
	ENDIF
	IF (INBUF .NE. GOODCHAR) THEN
		type 997
997		format(' DIGLIB - informative: CalComp transmission error')
D		type 9999, INBUF
D9999		format(' The bad character is decimal ',I4/
D	1	'$Hit return to try again')
D		ACCEPT 9998, INBUF
D9998		FORMAT(A1)
		GO TO 10
	ENDIF
	RETURN
	END


	SUBROUTINE GH_TIMED
C
	INCLUDE 'GD1012.CMN'
C
	LTIMED = .TRUE.
	RETURN
	END


	SUBROUTINE GH_NO_TIMED
C
	INCLUDE 'GD1012.CMN'
C
	LTIMED = .FALSE.
	RETURN
	END


	SUBROUTINE GH_INSERT(BCHAR)
	BYTE BCHAR
C
C	THIS SUBROUTINE INSERTS A CHARACTER INTO THE BUFFER
C
C
	INCLUDE 'GD1012.CMN'
C
C
	BUFFER(IBUFPTR) = BCHAR
	ICHECK_SUM = ICHECK_SUM + BCHAR
	IBUFPTR = IBUFPTR + 1
	RETURN
	END


	SUBROUTINE GH_IN_BIASED(STRING)
	BYTE STRING(2)
C
C	THIS SUBROUTINE INSERTS THE STRING INTO THE GRAPHICS BUFFER
C
C
	INCLUDE 'GD1012.CMN'
C
	I = 1
100		CONTINUE
		IF (STRING(I) .EQ. -1) RETURN
		CALL GH_INSERT(STRING(I)+BIASCHAR)
		I = I + 1
		GO TO 100
	END


	SUBROUTINE GH_FINISH()
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE RELEASES THE I/O CHANNAL TO THE PLOTTER
C
C
	INCLUDE 'GD1012.CMN'
C
C
	INTEGER*4 SYS$DASSGN
C
	ISTAT = SYS$DASSGN(%VAL(IOCHAN))
	RETURN
	END
