	PARAMETER (X_RES = (X_DOTS-1.0)/SCREEN_WIDTH_CM)
	PARAMETER (Y_RES = (Y_DOTS-1.0)/SCREEN_HEIGHT_CM)
	PARAMETER (RESOLUTION = (X_RES+Y_RES)/2.0)
	PARAMETER (XLENGTH = (X_DOTS-1.0)/RESOLUTION)
	PARAMETER (YLENGTH = (Y_DOTS-1.0)/RESOLUTION)
	PARAMETER (COLORS_FG = NUMBER_FG_COLORS)
	PARAMETER (IX_CENTER = RESOLUTION*XLENGTH/2.0)
	PARAMETER (IY_CENTER = RESOLUTION*YLENGTH/2.0)
	PARAMETER (MAXCOL=100)
	BYTE ESC,CSUB,GS,CR,FF,US
	PARAMETER (ESC=27, CSUB=26, GS=29, CR=13, FF=12, US=31)
	CHARACTER*(*) TERMINAL
	PARAMETER (TERMINAL='TT')
C
C	DEFINITIONS FOR DEVICE CONTROL
C
	BYTE STR_BEGIN(6), STR_END(6), STR_INIT_DEV(28), STR_WINDOW(4)
	BYTE STR_BEGIN_PLOT(6), STR_COLOR_SET(6)
	BYTE STR_END_PLOT(2), STR_RLS_DEV(6)
	BYTE STR_BEGIN_POLY(4), STR_END_POLY(6)
	BYTE STR_FILL_PATRN(6)
	BYTE SET_SURFACE_COLOR_MAP(6)
	DATA STR_BEGIN /ESC,'%','!','0',0,0/	!CODE TEK
	DATA STR_END /US,ESC,'%','!','1',0/	!CODE ANSI
	DATA STR_INIT_DEV/
	2   ESC,'K','A','1',		!DAENABLE YES
	3   ESC,'L','M','0',		!DAMODE REPLACE
	4   ESC,'M','L','1',		!LINEINDEX 1 (COLOR 1)
	5   ESC,'N','U',':',		!BYPASS CANCEL CHARACTER (LF)
	6   ESC,'N','T','1','=',	!EOL STRING <CR> <NULL>
	7   ESC,'T','M','1','1','1',0/	!SET RGB COLOR MODE
	DATA STR_WINDOW / ESC,'R','W',0/
	DATA STR_BEGIN_PLOT/
	1   ESC,'L','Z',ESC,FF,0/			!ERASE SCREEN
	DATA STR_COLOR_SET /
	1   ESC,'M','L','1',0,0/	!LINEINDEX 1 (COLOR N)
	DATA STR_RLS_DEV /
	1   ESC,'%','!','1',0,0/	!CODE ANSI
	DATA SET_SURFACE_COLOR_MAP /ESC, 'T', 'G', '!', '4', 0/
	DATA STR_BEGIN_POLY / ESC,'L','P',0/
	DATA STR_END_POLY / US,ESC,'L','E',2*0/
	DATA STR_FILL_PATRN /ESC,'M','P',' ',2*0/
C
C	DEFINITIONS FOR GIN
C
	BYTE GINBUFR(8), PROMPT(8), STR_END_GIN(2), STR_MOVE_GIN_CURSOR(6)
	DATA PROMPT /ESC,'%','!','0',ESC, CSUB, 0, 0/
	DATA IGIN_IN_CHARS /6/
	DATA STR_END_GIN /10,0/
	DATA STR_MOVE_GIN_CURSOR / ESC, 'S', 'X', '0', 0,0/
	DATA IX_GIN_CURSOR, IY_GIN_CURSOR / IX_CENTER, IY_CENTER /
C
C	DECLARE BUFFERING FUNCTION
C
	LOGICAL GB_TEST_FLUSH
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	LOGICAL LVECTOR_GOING, LDUMMY
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
	DATA DCHAR / TERM_NUMBER, XLENGTH, YLENGTH, RESOLUTION,
	1   RESOLUTION, COLORS_FG, 453.0, 1.0/
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .GT. 1026) GOTO 20000
	IF (IFXN .LE. 0 .OR. IFXN .GT. 10) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700,800,900,1000) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
C
C	FIRST, INITIALIZE THE BUFFER SUBROUTINES
C
	CALL GB_INITIALIZE(0,STR_END,TERMINAL,IERR)
	YA(1) = IERR
	IF (IERR .NE. 0) RETURN
	CALL GB_BEGIN_STRING(STR_BEGIN)
C
C	INITIALIZE THE 4105
C
	CALL GB_IN_STRING(STR_INIT_DEV)
	CALL GB_IN_STRING(STR_WINDOW)
	CALL GD_4010_CONVERT(0,0)
	IX = INT(DCHAR(2)*XGUPCM+0.5)
	IY = INT(DCHAR(3)*YGUPCM+0.5)
	CALL GD_4010_CONVERT(IX,IY)
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	CALL GB_IN_STRING(STR_BEGIN_PLOT)
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
C	CONVERT CM. TO GRAPHICS UNITS ROUNDED
	IXPOSN = XGUPCM*XA(1)+0.5
	IYPOSN = YGUPCM*YA(1)+0.5
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	IX = XGUPCM*XA(1)+0.5
	IY = YGUPCM*YA(1)+0.5
	LVECTOR_GOING = LVECTOR_GOING .AND. (.NOT. GB_TEST_FLUSH(4))
	IF (LVECTOR_GOING) GO TO 410
	LDUMMY = GB_TEST_FLUSH(9)
	LVECTOR_GOING = .TRUE.
	CALL GB_INSERT(GS)
	CALL GD_4010_CONVERT(IXPOSN,IYPOSN)
410	CALL GD_4010_CONVERT(IX,IY)
	IXPOSN = IX
	IYPOSN = IY
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
C
C	DE-ASSIGN THE CHANNAL
C
	CALL GB_EMPTY
	CALL GB_IN_STRING(STR_WINDOW)
	CALL GD_4010_CONVERT(0,0)
	CALL GD_4010_CONVERT(1023,767)
	CALL GB_FINISH(STR_RLS_DEV)
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	RETURN
C
C	****************************
C	SELECT CURRENT DRAWING COLOR
C	****************************
C
800	CONTINUE
	LDUMMY = GB_TEST_FLUSH(6)
	ICOLOR = XA(1)
	IF (ICOLOR .LT. 0 .OR. ICOLOR .GT. NUMBER_FG_COLORS) RETURN
	STR_COLOR_SET(4) = 48+ICOLOR	!MAKE ASCII CHARACTER
	CALL GB_IN_STRING(STR_COLOR_SET)
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	**********************
C	PERFORM GRAPHICS INPUT
C	**********************
C
900	CONTINUE
C
C	POSITION CURSOR TO ITS LAST GIN POSITION (ELSE MIDDLE OF SCREEN)
C
	CALL GB_TEST_FLUSH(10)
	CALL GB_IN_STRING(STR_MOVE_GIN_CURSOR)
	CALL GD_4010_CONVERT(IX_GIN_CURSOR,IY_GIN_CURSOR)
	CALL GB_EMPTY
C
	CALL GB_GIN(PROMPT,IGIN_IN_CHARS,.TRUE.,GINBUFR)
C
	ICHAR = GINBUFR(1)
	IX1 = GINBUFR(2)
	IX2 = GINBUFR(3)
	IY1 = GINBUFR(4)
	IY2 = GINBUFR(5)
C
	XA(1) = IAND(ICHAR,127)		!PICK CHARACTER
	IX_GIN_CURSOR = 32*IAND(IX1,31)+IAND(IX2,31)
	XA(2) = IX_GIN_CURSOR/XGUPCM
	IY_GIN_CURSOR = 32*IAND(IY1,31)+IAND(IY2,31)
	XA(3) = IY_GIN_CURSOR/YGUPCM
C
	CALL GB_IN_STRING(STR_END_GIN)
	CALL GB_EMPTY
	RETURN
C
C	*******************
C	SET COLOR USING RGB
C	*******************
C
1000	CONTINUE
	CALL GB_TEST_FLUSH(20)
	CALL GB_IN_STRING(SET_SURFACE_COLOR_MAP)
	CALL GD_41XX_INT(INT(XA(1)))
	CALL GD_41XX_INT(MAX(0,MIN(MAXCOL,INT(YA(1)+0.5))))
	CALL GD_41XX_INT(MAX(0,MIN(MAXCOL,INT(YA(2)+0.5))))
	CALL GD_41XX_INT(MAX(0,MIN(MAXCOL,INT(YA(3)+0.5))))
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	*******************
C	DRAW FILLED POLYGON
C	*******************
C
20000	CONTINUE
	NPTS = IFXN - 1024
	IX = XGUPCM*XA(1)+0.5
	IY = YGUPCM*YA(1)+0.5
	LVECTOR_GOING = LVECTOR_GOING .AND. (.NOT. GB_TEST_FLUSH(26))
	IF (LVECTOR_GOING) THEN
		CALL GB_INSERT(US)
		LVECTOR_GOING = .FALSE.
	ENDIF
	STR_FILL_PATRN(4) = 32 + ICOLOR
	IF (ICOLOR .EQ. 0) STR_FILL_PATRN(4) = 80
	CALL GB_IN_STRING(STR_FILL_PATRN)
	CALL GB_IN_STRING(STR_BEGIN_POLY)
	CALL GD_4010_CONVERT(IX,IY)
	CALL GD_41XX_INT(1)
C
C	DO VERTICES 2 THRU N.   NOTE: WE START WITH A <GS> SINCE
C	 LVECTOR_GOING IS "FALSE"
C
		DO 20010 I = 2, NPTS
C		MAKE SURE 10 CHARS (4 FOR X,Y AND 6 FOR END POLYGON)
		LVECTOR_GOING = LVECTOR_GOING .AND. (.NOT. GB_TEST_FLUSH(10))
		IF (.NOT. LVECTOR_GOING) CALL GB_INSERT(GS)
		CALL GD_4010_CONVERT(INT(XGUPCM*XA(I)+0.5),
	1		INT(YGUPCM*YA(I)+0.5))
20010		CONTINUE
	CALL GB_IN_STRING(STR_END_POLY)
	LVECTOR_GOING = .FALSE.
	RETURN
	END
