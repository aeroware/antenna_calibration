	SUBROUTINE GDPRNTX_WIDE(IFXN,XA,YA)
C
	DIMENSION XA(8), YA(3)
C
C	PRINTRONIX  DIGLIB GRAPHICS DEVICE DRIVER WITH EMBEDDED RASTERIZER
C
C-----------------------------------------------------------------------
C
C AGRUMENTS:
C
C   INPUT
C
C	IFXN		* TYPE: INTEGER CONSTANT OR VARIABLE.
C			* THE GRAPHICS FUNCTION TO PERFORM:
C			    1 ==> INITIALIZE THE GRAPHICS DEVICE TO PREPARE IT
C				   FOR GRAPHICS (AND ON MULTIUSER SYSTEMS, TAKE
C				   EXCLUSIVE CONTROL OF THE DEVICE.)
C			    2 ==> OBTAIN A FRESH PLOTTING SURFACE ON THE
C				   GRAPHICS DEVICE.
C			    3 ==> MOVE TO A NEW POSITION (X,Y), WHERE THE UNITS
C				   OF BOTH X AND Y ARE IN CENTIMETERS.
C			    4 ==> DRAW A LINE TO THE POSITION (X,Y), WHERE THE
C				   UNITS OF X AND Y ARE IN CENTIMETERS.
C			    5 ==> TRANSMIT ANY BUFFERED GRAPHICS COMMANDS THAT
C				   HAVE NOT YET BEEN TRANSMITTED TO THE
C				   GRAPHICS DEVICE.
C			    6 ==> RELEASE CONTROL OF THE GRAPHICS DEVICE.
C			    7 ==> RETURN TO THE CALLER THE DEVICE
C				   CHARACTERISTICS OF THIS DEVICE.
C			    8 ==> SET THE CURRENT DRAWING COLOR.
C			    9 ==> PERFORM A GRAPHICS INPUT WITH PICK CHARACTER
C				   OPERATION, RETURNING THE USER SELECTED
C				   LOCATION (X,Y) WITH X AND Y SPECIFIED IN
C				   CENTIMETERS.
C			   10 ==> SET THE VISUAL COLOR ASSOCIATED WITH A
C				   SPECIFIED COLOR NUMBER TO THE RGB VALUE
C				   PROVIDED.
C			   11 ==> SET THE VISUAL COLOR ASSOCIATED WITH A
C				   SPECIFIED COLOR NUMBER TO THE HLS VALUE
C				   PROVIDED.
C
C	XA		* TYPE: REAL ARRAY.
C			* DEPENDANT OF THE GRAPHICS FUNCTION GIVEN BY "IFXN".
C			    1 ==> XA(1) IS RT-11 CHANNAL NUMBER ON WHICH
C				   TO PERFORM I/O, OR RSX-11M LOGICAL UNIT
C				   NUMBER ON WHICH TO PERFORM I/O.
C				  XA(2) --> XA(7) UNUSED.
C			    2 ==> XA(1) --> XA(7) UNUSED.
C			    3 ==> XA(1) IS THE X COORDINATE IN CM. FOR THE
C				   MOVE OPERATION.
C				  XA(2) --> XA(7) UNUSED.
C			    4 ==> XA(1) IS THE X COORDINATE IN CM. FOR THE
C				   DRAW OPERATION.
C				  XA(2) --> XA(7) UNUSED.
C			    5 ==> XA(1) --> XA(7) UNUSED.
C			    6 ==> XA(1) --> XA(7) UNUSED.
C			    7 ==> XA(1) --> XA(7) UNUSED.
C			    8 ==> XA(1) IS COLOR FOR SUBSEQUENT LINES.
C				  XA(2) --> XA(7) UNUSED.
C			    9 ==> XA(1) --> XA(7) UNUSED.
C			   10 ==> XA(1) IS THE COLOR TO DEFINE.
C			   11 ==> XA(1) IS THE COLOR TO DEFINE.
C
C	YA		* TYPE: REAL ARRAY
C			* DEPENDANT OF THE GRAPHICS FUNCTION GIVEN BY "IFXN".
C			    1 ==> YA(1) --> YA(3) UNUSED.
C			    2 ==> YA(1) --> YA(3) UNUSED.
C			    3 ==> YA(1) IS THE Y COORDINATE IN CM. FOR THE
C				   MOVE OPERATION.
C				  YA(2) --> YA(3) UNUSED.
C			    4 ==> YA(1) IS THE Y COORDINATE IN CM. FOR THE
C				   DRAW OPERATION.
C				  YA(2) --> YA(3) UNUSED.
C			    5 ==> YA(1) --> YA(3) UNUSED.
C			    6 ==> YA(1) --> YA(3) UNUSED.
C			    7 ==> YA(1) --> YA(3) UNUSED.
C			    8 ==> YA(1) --> YA(3) UNUSED.
C			    9 ==> YA(1) --> YA(3) UNUSED.
C			   10 ==> YA(1) IS % RED COMPONENT OF COLOR.
C				  YA(2) IS % GREEN COMPONENT OF COLOR.
C				  YA(3) IS % BLUE COMPONENT OF COLOR.
C			   11 ==> YA(1) IS THE HUE (0-360).
C				  YA(2) IS THE LIGHTNESS (0-100).
C				  YA(3) IS THE SATURATION (0-100).
C
C  OUTPUT
C
C	XA		* TYPE: REAL ARRAY.
C			* DEPENDANT OF THE GRAPHICS FUNCTION GIVEN BY "IFXN".
C			    1 ==> XA(1) --> XA(7) UNUSED.
C			    2 ==> XA(1) --> XA(7) UNUSED.
C			    3 ==> XA(1) --> XA(7) UNUSED.
C			    4 ==> XA(1) --> XA(7) UNUSED.
C			    5 ==> XA(1) --> XA(7) UNUSED.
C			    6 ==> XA(1) --> XA(7) UNUSED.
C			    7 ==> XA(1) --> XA(7) ARE SET TO THIS DEVICES
C				   CHARACTERISTIC WORDS:
C				   XA(1) = DEVICE ID. (A UNIQUE DEVICE NUMBER
C					   OBTAINED FROM HAL BRAND X26312.
C				   XA(2) = X AXIS LENGTH OF THIS DEVICE IN CM.
C				   XA(3) = Y AXIS LENGTH IN CM.
C				   XA(4) = X AXIS RESOLUTION IN GRAPHICS UNITS
C					   (GU) PER CENTIMETER.
C				   XA(5) = Y AXIS RESOLUTION IN GU/CM.
C				   XA(6) = NUMBER OF AVAILABLE FOREGROUND
C					   COLORS ON THIS DEVICE.
C				   XA(7) = DEVICE CHARACTERISTICS BITS.
C					   THE SUM OF:
C					      0 IF STROKE (PLOTTER) DEVICE.
C					      1 IF RASTER DEVICE.
C					      2 IF DVST (STORAGE TUBE)
C					      3 PRINTER/PLOTTER
C					      4 IF DRAWING IN THE BACKGROUND
C						 COLOR (COLOR 0) IS AVAILABLE.
C					      8	IF DEVICE IS A HARDCOPY DEVICE.
C					     16	IF DEVICE IS A SHAREABLE
C						 DEVICE.
C					     32	DEVICE'S COLORS ARE HLS
C						 SELECTABLE.
C					     64	DEVICE'S COLORS ARE RGB
C						 SELECTABLE.
C					    128	GRAPHICS INPUT IS AVAILABLE.
C					    256	DRIVER HANDLES HARDWARE
C						 POLYGON FILL.   QUALIFIED BY:
C					    512	ONLY CONVEX NON-INTERSECTING
C						 POLYGONS CAN BE FILLED BY
C						 HARDWARE.
C				  XA(8) = THE NUMBER OF LINES TO SKIP PLUS 1
C					   WHEN DOING A SOFTWARE FILL.   THIS
C					   CHARACTERISTIC ACCOUNTS FOR PEN
C					   WIDTH.
C			    8 ==> XA(1) = PICK CHARACTER FROM GRAPHICS DEVICE
C					   OR FROM TERMINAL.
C				  XA(2) = X COORDINATE SELECTED IN CM.
C				  XA(3) = Y COORDINATE SELECTED IN CM.
C				  XA(4) --> XA(7) UNUSED.
C			    9 ==> XA(1) --> XA(7) UNUSED.
C			   10 ==> XA(1) --> XA(7) UNUSED.
C			   11 ==> XA(1) --> XA(7) UNUSED.
C
C
	INCLUDE 'PRINTRONIX.INC/LIST'
C
C
	INTEGER CURX,CURY,IX,IY
C
C
C
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
	DATA DCHAR / 99.0,   33.528,      27.94, 
     &                       23.62205, 28.34646, 1.0, 11.0, 1.0 /
C
C
C
C
C	WIDE IS THE NORMAL MODE
	LWIDE = .TRUE.
C
C
C
C NOW CHECK TO SEE IF IT IS A "REGULAR" FUNCTION WE CAN DEAL WITH.
C
10	IF (IFXN .LE. 0 .OR. IFXN .GT. 7) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
	CALL RASTER_INIT
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
        CALL RASTER_CLEAR
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
        IF (LWIDE) THEN
		CURX = XGUPCM*XA(1)+0.5	! CONVERT CM. TO GRAPHICS UNITS ROUNDED
		CURY = YGUPCM*YA(1)+0.5
		CURY = Y_RESOLUTION - CURY	! NORMALIZE DEVICE COORDINATE TO LOWER LEFT.
	ELSE
		CURX = XGUPCM*YA(1)+0.5	! CONVERT CM. TO GRAPHICS UNITS ROUNDED
		CURY = YGUPCM*XA(1)+0.5
        ENDIF
c
	RETURN
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	IF (LWIDE) THEN
		IX = XGUPCM*XA(1)+0.5	! CONVERT CM. TO GRAPHICS UNITS ROUNDED
		IY = YGUPCM*YA(1)+0.5
		IY = Y_RESOLUTION - IY		! NORMALIZE DEVICE COORDINATE TO LOWER LEFT.
	ELSE
		IX = XGUPCM*YA(1)+0.5	! CONVERT CM. TO GRAPHICS UNITS ROUNDED
		IY = YGUPCM*XA(1)+0.5
	ENDIF
C
	CALL RASTERIZE(CURX,CURY,IX,IY)
C
        CURX = IX 
	CURY = IY
C
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	CALL RASTER_DUMP
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	CALL RASTER_DONE
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	   XA(I) = DCHAR(I)
720	CONTINUE
        IF (LWIDE) RETURN
        XA(2) = DCHAR(3)
        XA(3) = DCHAR(2)
        XA(4) = DCHAR(5)
	XA(5) = DCHAR(4)
	RETURN
C
C
C
C
C	ALTERNATE ENTRY POINT FOR TALL PLOTTING AREA
	ENTRY GDPRNTX_TALL(IFXN,XA,YA)
	LWIDE = .FALSE.
	GO TO 10
	END
C
	SUBROUTINE RASTERIZE(FROMX,FROMY,TOX,TOY)
C
C
C	FROMX,FROMY AND TOX,TOY ARE IN DEVICE GRAPHIC UNITS (DOTS)
	INTEGER FROMX,FROMY,TOX,TOY
	INTEGER I,LENGTH
	REAL X,Y,XINCREMENT,YINCREMENT
C
	LENGTH = IABS(TOX-FROMX)
	IF (IABS(TOY-FROMY) .GT. LENGTH) LENGTH = IABS(TOY-FROMY)
	IF ( LENGTH .EQ. 0) THEN
		CALL RASTER_DOT(FROMX,FROMY)
		RETURN
	ELSE
		XINCREMENT = REAL(TOX-FROMX)/REAL(LENGTH)
		YINCREMENT = REAL(TOY-FROMY)/REAL(LENGTH)
		X = REAL(FROMX)+0.5
		Y = REAL(FROMY)+0.5
		DO 100 I = 1 , LENGTH
			CALL RASTER_DOT(IFIX(X),IFIX(Y))
			X = X+XINCREMENT
			Y = Y+YINCREMENT
100		CONTINUE
	ENDIF
C
	RETURN
	END
C
	SUBROUTINE RASTER_DOT(X,Y)
C
C
	INCLUDE 'PRINTRONIX.INC/LIST'
C
C
	INTEGER X,Y
C
	IF ( X .LT. 0 ) RETURN
	IF ( X .GE. X_RESOLUTION ) RETURN
	IF ( Y .LT. 0 ) RETURN
	IF ( Y .GE. Y_RESOLUTION ) RETURN
	BUFFER(WORD(X+1),Y+1) = IOR(BUFFER(WORD(X+1),Y+1) , VALUE(X+1))
C
	RETURN
	END
C
	SUBROUTINE RASTER_INIT
C
C
C	PRINTRONIX RASTERIZING PACKAGE - OPEN OUTPUT FILE AND CLEAR BUFFER
C
C
	INCLUDE 'PRINTRONIX.INC/LIST'
C
C
	INTEGER WORDCNT,WORDVALUE,VALUEVAL
	OPEN(UNIT=10,FILE='SYS$LOGIN:PRINTRONIX.DIG',STATUS='NEW',
     &		  CARRIAGECONTROL='NONE',RECL=134)
C
	CALL RASTER_CLEAR
C
C	AND NOW INITIALIZE THE HORIZONTAL INDEX'S
C	GIVEN A HORIZONTAL VALUE, WORD TELLS WHICH WORD TO STORE THE VALUE IN
C	AN VALUE TELLS WHAT VALUE TO OR INTO THAT WORD.
C	VERTICAL POSITION JUST MAPS DIRECTLY INTO THE VERTICAL DIMENSION
	WORDVALUE = 1
	WORDCNT = 1
	VALUEVAL =1
	DO 100 I = 1,X_RESOLUTION
		WORD(I) = WORDVALUE
		WORDCNT = WORDCNT+1
		IF (WORDCNT .EQ. 33 ) THEN
			WORDCNT = 1
			WORDVALUE = WORDVALUE+1
		ENDIF
C
C
		VALUE(I) = VALUEVAL
		VALUEVAL = JISHFT(VALUEVAL,1)
		IF (VALUEVAL .EQ. 0) VALUEVAL = 1
C
100	CONTINUE
C
               
	RETURN
	END
C
	SUBROUTINE RASTER_CLEAR
C
C
C	PRINTRONIX RASTERIZING PACKAGE - CLEAR OUT THE DATA BUFFER
C
C
	INCLUDE 'PRINTRONIX.INC/LIST'
C
C
	DO 100 I = 1,Y_PACK
		DO 100 J=1,X_PACK
			BUFFER(J,I) = 0
100	CONTINUE
C
	RETURN
	END
C
	SUBROUTINE RASTER_DONE
C
C
C	PRINTRONIX RASTERIZING PACKAGE - CLOSE THE FILE AND PRINT IT
	CLOSE(10)
	ISTATS=LIB$SPAWN(
     &	' $ PRINT/FORM=NONE/NOFEED/DELETE SYS$LOGIN:PRINTRONIX.DIG')
C
	RETURN
	END
C
	SUBROUTINE RASTER_DUMP
C
C
C	PRINTRONIX RASTERIZING PACKAGE - PRINT OUT THE CURRENT IMAGE
C
	INCLUDE 'PRINTRONIX.INC/LIST'
C
	INTEGER Y,INDEX
C
C
	BYTE LINE(132)
	DO 100 Y=1,Y_PACK
		DO 200 I=1,132
			INDEX = ((I-1)*6)+1
			LINE(I)=64
	IF ( IAND(BUFFER(WORD(INDEX+0),Y) , VALUE(INDEX+0)) .NE. 0) 
     &			LINE(I)=LINE(I)+1
	IF ( IAND(BUFFER(WORD(INDEX+1),Y) , VALUE(INDEX+1)) .NE. 0) 
     &			LINE(I)=LINE(I)+2
	IF ( IAND(BUFFER(WORD(INDEX+2),Y) , VALUE(INDEX+2)) .NE. 0) 
     &			LINE(I)=LINE(I)+4
	IF ( IAND(BUFFER(WORD(INDEX+3),Y) , VALUE(INDEX+3)) .NE. 0) 
     &			LINE(I)=LINE(I)+8
	IF ( IAND(BUFFER(WORD(INDEX+4),Y) , VALUE(INDEX+4)) .NE. 0) 
     &			LINE(I)=LINE(I)+16
	IF ( IAND(BUFFER(WORD(INDEX+5),Y) , VALUE(INDEX+5)) .NE. 0) 
     &			LINE(I)=LINE(I)+32
200		CONTINUE
		WRITE(10,99) LINE,5,10
99		FORMAT(132A1,1A1,1A1)
100	CONTINUE
C
	RETURN
	END
