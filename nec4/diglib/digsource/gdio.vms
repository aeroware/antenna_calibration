	SUBROUTINE GB_INITIALIZE(TERMIN,ENDSTR,TTNAME,IERR)
	CHARACTER*(*) TTNAME
	BYTE ENDSTR(2), TERMIN
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE INITIALIZES THE GRAPHICS DRIVERS BUFFERING
C	 SUBROUTINES
C
	INCLUDE 'GBCOMMON.CMN'
C
	INTEGER*4 SYS$ASSIGN
	EXTERNAL LEN
C
C	ASSIGN A CHANNEL TO THE DEVICE OUTPUT DEVICE
C
	ISTAT = SYS$ASSIGN(TTNAME,IOCHAN,,)
	IF (.NOT. ISTAT) THEN
		IERR = 1
		RETURN
	    ELSE
		IERR = 0
	ENDIF
C
	CALL SCOPY(ENDSTR,END_STRING)
	IEND_LENGTH = LEN(END_STRING)
	BEGIN_STRING(1) = 0
	IBEGIN_LENGTH = 0
C
	TERM_CHAR = TERMIN
C
	CALL GB_NEW_BUFFER
	RETURN
	END


	SUBROUTINE GB_BEGIN_STRING(STRING)
C
C	SUBROUTINE TO SET THE "BEGINNING OF EACH BUFFER STRING"
C	 THIS SUBROUTINE SHOULD BE CALLED IMMEDIATELY AFTER CALLING
C	 GB_INITIALIZE.   THE FUNCTION PERFORMED HERE SHOULD ACTUALLY
C	 BE A PART OF GB_INITIALIZE, BUT THEN ALL DRIVERS WOULD HAVE
C	 TO BE CHANGED, SO IT IS DONE THIS WAY.
C
	INCLUDE 'GBCOMMON.CMN'
c
	EXTERNAL LEN
C
	CALL SCOPY(STRING,BEGIN_STRING)
	IBEGIN_LENGTH = LEN(BEGIN_STRING)
	CALL GB_NEW_BUFFER
	RETURN
	END



	SUBROUTINE GB_NEW_BUFFER
C
C	SUBROUTINE TO INITIALIZE THE GRAPHIC COMMAND BUFFER
C
	INCLUDE 'GBCOMMON.CMN'
C
	CALL SCOPY(BEGIN_STRING,BUFFER)
	IBFPTR = IBEGIN_LENGTH + 1
	L_USE_TERMINATOR = .FALSE.
	RETURN
	END



	FUNCTION GB_TEST_FLUSH(NUMCHR)
	LOGICAL GB_TEST_FLUSH
C
C	THIS SUBROUTINE CHECKS TO MAKE SURE THERE IS ENOUGH ROOM IN
C	THE BUFFER FOR "NUMCHR" MORE CHARACTERS, IF NOT, IF MAKES ROOM BY
C	EMPTYING THE BUFFER.
C
	INCLUDE 'GBCOMMON.CMN'
C
	IF (IBFPTR+NUMCHR+IEND_LENGTH .GE. IBFSIZ) THEN
		CALL GB_EMPTY
		GB_TEST_FLUSH = .TRUE.
	    ELSE
		GB_TEST_FLUSH = .FALSE.
	    ENDIF
	RETURN
	END



	SUBROUTINE GB_USE_TERMINATOR
C
C	THIS SUBROUTINE SETS THE "USE TERMINATOR" FLAG TO TRUE.
C	THE FLAG IS SET TO FALSE BY CALLING GB_NO_TERMINATOR OR BY
C	EMPTYING/CLEARING THE BUFFER.
C
	INCLUDE 'GBCOMMON.CMN'
C
	L_USE_TERMINATOR = .TRUE.
	RETURN
	END



	SUBROUTINE GB_NO_TERMINATOR
C
C	THIS SUBROUTINE CLEARS THE "USE TERMINATOR" FLAG TO FALSE.
C
	INCLUDE 'GBCOMMON.CMN'
C
	L_USE_TERMINATOR = .FALSE.
	RETURN
	END



	SUBROUTINE GB_EMPTY
C
C	THIS SUBROUTINE EMPTYS THE BUFFER IF IT HAS ANYTHING
C
	INCLUDE 'GBCOMMON.CMN'
C
C
	IF (IBFPTR-1 .LE. IBEGIN_STRING) GO TO 900
	IF (L_USE_TERMINATOR) CALL GB_INSERT(TERM_CHAR)
	IF (IEND_LENGTH .NE. 0) CALL GB_IN_STRING(END_STRING)
	IF (IBFPTR .GT. IBFSIZ+1) STOP 'BUFFERING ERROR - BUFFER OVERFLOWED'
C
C	SEND TO TTY
C
	CALL GB_SEND_TTY(BUFFER,IBFPTR-1)
900	CALL GB_NEW_BUFFER
	RETURN
	END



	SUBROUTINE GB_SEND_TTY(TTY_BUFFER,IBUFR_LEN)
	BYTE TTY_BUFFER(IBUFR_LEN)
C
C	*** VMS SPECIFIC ***
C	NOTE: FOR INTERNAL USE ONLY - NO DRIVERS SHOULD CALL THIS ROUTINE!
C	DRIVERS SHOULD CALL GB_SEND_CHARS INSTEAD.
C
C	THIS SUBROUTINE EMPTYS THE BUFFER IF IT HAS ANYTHING
C
	INCLUDE '($IODEF)'
C	PARAMETER (IO_WRITEV = '00000130'X)	!IO$_WRITEVBLK+IO$M_NOFORMAT
	INCLUDE '($SSDEF)'
	INCLUDE 'GBCOMMON.CMN'
C
	INTEGER*4 CR_CONTROL
	PARAMETER (CR_CONTROL = 0)
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
C
C	DO THE QIOW TO THE OUTPUT DEVICE
C
10	CONTINUE
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_WRITEVBLK+IO$M_NOFORMAT),
	2   IOSB, , ,
	3   TTY_BUFFER,%VAL(IBUFR_LEN), ,%VAL(CR_CONTROL), , )
	IF (.NOT. ISTAT) then
		type 999, istat
999		format(' QIOW to terminal failed, status was ',i9)
	ENDIF
	RETURN
	END


	SUBROUTINE GB_SEND_CHARS(TTY_BUFFER,IBUFR_LEN)
C
C	THIS SUBROUTINE NECESSARY FOR COMPATIBILITY WITH GDIO2BUF.FOR
C	 AND THE WAY IT WORKS
C
	CALL GB_SEND_TTY(TTY_BUFFER,IBUFR_LEN)
	RETURN
	END


	SUBROUTINE GB_INSERT(BCHAR)
	BYTE BCHAR
C
C	THIS SUBROUTINE INSERTS A CHARACTER INTO THE BUFFER
C
	INCLUDE 'GBCOMMON.CMN'
C
	BUFFER(IBFPTR) = BCHAR
	IBFPTR = IBFPTR + 1
	RETURN
	END


	SUBROUTINE GB_IN_STRING(STRING)
	BYTE STRING(2)
C
C	THIS SUBROUTINE INSERTS THE STRING INTO THE GRAPHICS BUFFER
C
	EXTERNAL LEN
C
	DO 100 I=1, LEN(STRING)
	  CALL GB_INSERT(STRING(I))
100	  CONTINUE
	RETURN
	END


	SUBROUTINE GB_FINISH(RELEASE_STRING)
	BYTE RELEASE_STRING(2)
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE RELEASES THE I/O CHANNAL TO THE OUTPUT DEVICE
C
	INCLUDE 'GBCOMMON.CMN'
C
	INTEGER*4 SYS$DASSGN
	EXTERNAL LEN
C
	IF (LEN(RELEASE_STRING) .NE. 0) THEN
	    CALL GB_EMPTY
	    CALL GB_IN_STRING(RELEASE_STRING)
	    CALL GB_EMPTY
	  ENDIF
	ISTAT = SYS$DASSGN(%VAL(IOCHAN))
	RETURN
	END


	SUBROUTINE GB_GIN(PROMPT,IGIN_CHARS_MAX,L_TERMS_OK,GINBUFR)
	BYTE GINBUFR(2), PROMPT(2)
	LOGICAL*1 L_TERMS_OK
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE DOES A GIN OPERATION VIA A "READ-AFTER-PROMPT"
C	QIOW.
C
	INCLUDE 'GBCOMMON.CMN'
C
C	PARAMETER (IO_READ_PROMPT = '877'X)
C	PARAMETER (IO_READ_NOECHO = '71'X)
	INCLUDE '($IODEF)'
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
	EXTERNAL LEN
C
	IPRLEN = LEN(PROMPT)
	IF (IPRLEN .EQ. 0) THEN
		IFXN = IO$_READVBLK + IO$M_NOECHO
	    ELSE
		IFXN = IO$_READPROMPT + IO$M_PURGE + IO$M_NOECHO
	ENDIF
	II = 1
	NUMBER_TO_GET = IGIN_CHARS_MAX
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IFXN),
	1   IOSB, , ,GINBUFR(II),%VAL(NUMBER_TO_GET),%VAL(0), ,
	2   PROMPT,%VAL(IPRLEN))
	IF (.NOT. ISTAT) STOP 'GIN QIOW FAILED'
	IF (.NOT. L_TERMS_OK) GO TO 800
100	CONTINUE
	NUMBER_GOT = IOSB(2)+IOSB(4)
D	TYPE 9999, NUMBER_GOT, (GINBUFR(I), I=1,NUMBER_GOT+II-1)
D9999	FORMAT(/' GB_GIN just got ',I2,' characters.'
D	1   /' The characters buffered so far are:'
D	2   /,20(1X,I3))
	IF (NUMBER_GOT .GE. NUMBER_TO_GET) GOTO 800
	NUMBER_TO_GET = NUMBER_TO_GET - NUMBER_GOT
	II = NUMBER_GOT + II
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),
	1   %VAL(IO$_READVBLK+IO$M_NOECHO),
	1   IOSB, , ,GINBUFR(II),%VAL(NUMBER_TO_GET), , , , )
	IF (.NOT. ISTAT) STOP 'GIN QIOW FAILED'
	GO TO 100
800	RETURN
	END



	SUBROUTINE GB_INTERLOCK(PROMPT,IN_BUFFER,IN_CHAR_COUNT)
C
C	*** VMS SPECIFIC ***
C
C	THIS SUBROUTINE IS USED BY THOSE DRIVERS THAT MUST USE AN INTERLOCKING
C	  WITH THE TERMINAL SO THAT BUFFER OVERFLOW DOES NOT OCCUR IN THE
C	  TERMINAL.   MOSTLY, THIS IS CAUSED BY HP TERMINALS.   IT SEEMS
C	  THAT HP NEVER HAS UNDERSTOOD THE USEFULNESS OF XON/XOFF!
C
	INCLUDE 'GBCOMMON.CMN'
C
	PARAMETER (IO_READ_PROMPT = '877'X)
C		IO$_READPROMPT + IO$M_PURGE + IO$M_NOECHO
C
	INTEGER*4 SYS$QIOW
	INTEGER*2 IOSB(4)
	EXTERNAL LEN
C
	IPRLEN = LEN(PROMPT)
	ISTAT = SYS$QIOW(%VAL(0),%VAL(IOCHAN),%VAL(IO_READ_PROMPT),
	1   IOSB, , ,IN_BUFFER,%VAL(IN_CHAR_COUNT),%VAL(0),%VAL(0),
	2   PROMPT,%VAL(IPRLEN))
	IF (.NOT. ISTAT) STOP 'INTERLOCK QIOW FAILED'
	RETURN
	END
