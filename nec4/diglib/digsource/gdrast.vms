	SUBROUTINE GDRASTECH(IFXN,XA,YA)
C
C	RASTER TECHNOLOGIES MODEL ONE DIGLIB DRIVER 9/17/85
C	( 512 X 512 RESOLUTION )
C
C	JOHN C PETERSON
C	TRW/MED INC. MS RC2/2639
C	ONE RANCHO CARMEL
C	SAN DIEGO, CA 92128
C
	DIMENSION XA(1),YA(1)
C
C	VARIABLE DECLARATIONS FOR DEVICE CONTROL
C
	CHARACTER*(*) TERMINAL
	PARAMETER ( TERMINAL='TT' )
C
	BYTE STR_GRAPHICS_MODE(1)
	BYTE STR_COLD_START(1)
	BYTE STR_INIT_DEV(32)
	BYTE STR_BEGIN_PLOT(10)
	BYTE STR_MOVE(1)
	BYTE STR_DRAW(1)
	BYTE STR_SET_COLOR(1)
	BYTE STR_POLY(2)
	BYTE STR_XHAIR(3)
	BYTE STR_PROMPT(2)
	BYTE STR_FLUSH(1)
	BYTE STR_READ_BUTTON(3)
	BYTE STR_READ_REGISTER(2)
	BYTE STR_GIN_BUFFER(16)
	BYTE STR_ACKNOWLEDGE(1)
	BYTE STR_END_PLOT(1)
	BYTE STR_DEBUG(5)
	BYTE STR_END(2)
C
C	DATA LOAD DEVICE CONTROL VARIABLES
C
	DATA STR_GRAPHICS_MODE /'84'X /			!ENTER GRAPHICS MODE
	DATA STR_COLD_START /	'FD'X /			!COLD START
	DATA STR_INIT_DEV /	'84'X,			!ENTER GRAPHICS MODE
	1			'37'X,			!RESET COORDINATE ORIGIN
	2			0,0,0,0,		!HIX,LOX,HIY,LOY BYTES
	3			'36'X,			!RESET SCREEN ORIGIN
	4			0,0,0,0,		!HIX,LOX,HIY,LOY BYTES
	5			'3A'X,			!RESET WINDOW
	6			0,0,0,0,		!HIX,LOX,HIY,LOY BYTES
	7			0,0,0,0,		!HIX,LOX,HIY,LOY BYTES
	8			'1F'X,1,		!POLYGONS ARE FILLED
	9			'8B'X,0,		!DEFINE MACRO TO MAKE
	1			'A1'X,5,2,		! THE CROSS HAIR FOLLOW
	2			'0C'X,			! THE DIGITIZER MOUSE
	3			'AA'X,0,0,		!EXECUTE 1/30 SEC INT
	4			'FF'X /			!EXIT GRAPHICS MODE
	DATA STR_BEGIN_PLOT /	'84'X,
	1			'06'X,			!SET PIXEL VALUES
	2			0,0,0,			!RED, GREEN, BLUE
	3			'07'X,			!FLOOD THE SCREEN
	4			'06'X,			!SET PIXEL VALUES
	5			255,255,255 /		!RED, GREEN, BLUE
	DATA STR_MOVE /		'01'X /			!MOVE ABSOLUTE CODE
	DATA STR_DRAW /		'81'X /			!DRAW ABSOLUTE CODE
	DATA STR_SET_COLOR /	'06'X /			!SET PIXEL VALUES
	DATA STR_POLY /		'12'X,1 /		!DRAW ONE POLYGON CODE
	DATA STR_XHAIR /	'9C'X,0,0 /		!CURSOR VISIBILITY CODE
	DATA STR_PROMPT /	'?',0 /			!PROMPT USER FOR PICK
	DATA STR_FLUSH /	'15'X /			!EMPTY BUTTON QUEUE
	DATA STR_READ_REGISTER /'98'X,2 /		!READ TABLET REGISTER
	DATA STR_READ_BUTTON /	'9A'X,1,1 /		!READ MOUSE BUTTON VALUE
	DATA STR_ACKNOWLEDGE /	'86'X /			!ACKNOWLEDGE RECEPTION
	DATA STR_END_PLOT /	'FF'X /			!EXIT GRAPHICS MODE
	DATA STR_DEBUG /	'84'X,'A8'X,1,'FF'X,0 /	!******DEBUG MODE******
	DATA STR_END /		0,0 /
C
C	INTEGER*2 COORDINATE VARIABLES
C
	INTEGER*2 ICORORG,ISCRORG,IWINDOW
C
	DATA ICORORG /-256 /	!THESE VALUES DEPENDENT ON RESOLUTION
	DATA ISCRORG / 256 /
	DATA IWINDOW / 511 /
C
	INTEGER*2 IXMOVE,IYMOVE,IXDRAW,IYDRAW
	INTEGER*2 IXCURP,IYCURP,IXVERT,IYVERT
C
	BYTE STR_CORORG(2)
	BYTE STR_SCRORG(2)
	BYTE STR_WINDOW(2)
	BYTE STR_XMOVE(2)
	BYTE STR_YMOVE(2)
	BYTE STR_XDRAW(2)
	BYTE STR_YDRAW(2)
	BYTE STR_NVERT(2)
	BYTE STR_XVERT(2)
	BYTE STR_YVERT(2)
C
C	COLOR MAP TABLE
C
	BYTE COLOR_MAP(3,0:7)
C
	DATA COLOR_MAP /  0,  0,  0,	!BLACK
	1		255,255,255,	!WHITE
	2		255,  0,  0,	!RED
	3		  0,255,  0,    !GREEN
	4		  0,  0,255,	!BLUE
	5		255,255,  0,	!YELLOW
	6		255,  0,255,	!MAGENTA
	7		  0,255,255 /	!CYAN
C
C	VARIABLE TO RECIEVE USER "PICK" CHARACTER
C
	BYTE IPICK
C
C	DECLARE FUNCTIONS AND VARIABLES NEED FOR DRIVER OPERATION
C
	LOGICAL GB_TEST_FLUSH,LVECTOR_DRAWING,LDUMMY
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C	("YGUPCM" IS Y GRAPHICS UNITS PER CENTIMETER)
C
	DIMENSION DCHAR(8)
C
	EQUIVALENCE (DCHAR(4),XGUPCM)
	EQUIVALENCE (DCHAR(5),YGUPCM)
C
	DATA DCHAR /	9999.0,		!DIGLIB DEVICE NUMBER
	1		32.803, 26.232,	!X,Y SCREEN DIMENSIONS (CM)
	2		15.608, 19.518,	!XGUPCM, YGUPCM
	3		7.0,		!NUMBER OF FOREGROUND COLORS
	4		1411.0,		!DEVICE CHARACTERISTICS MASK
	5		1.0 /		!NUMBER OF SCAN LINES TO SKIP
C
C	*********************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN.GT.1024) GOTO 1300
C
	IF (IFXN.LE.0.OR.IFXN.GT.12) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700,800,900,1000,1100,1200) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
C
C	FIRST INITIALIZE THE DIGLIB BUFFER SUBROUTINES
C
	CALL GB_INITIALIZE(0,STR_END,TERMINAL,IERR)
	YA(1)= IERR
	IF (IERR.NE.0) RETURN
C
C	NOW COLD START THE MODEL ONE
C
	CALL GB_INSERT(STR_GRAPHICS_MODE(1))
	CALL GB_INSERT(STR_COLD_START(1))
	CALL GB_EMPTY
C
C	WAIT 10 SECONDS FOR COLD START TO COMPLETE BEFORE GOING ON
C
	CALL GDWAIT(10000)
C
C	FINISH WITH INITIALIZATION
C
	CALL RASTER_TECH_CONVERT(ICORORG,STR_CORORG)
	STR_INIT_DEV( 3)= STR_CORORG(1)
	STR_INIT_DEV( 4)= STR_CORORG(2)
	STR_INIT_DEV( 5)= STR_CORORG(1)
	STR_INIT_DEV( 6)= STR_CORORG(2)
C
	CALL RASTER_TECH_CONVERT(ISCRORG,STR_SCRORG)
	STR_INIT_DEV( 8)= STR_SCRORG(1)
	STR_INIT_DEV( 9)= STR_SCRORG(2)
	STR_INIT_DEV(10)= STR_SCRORG(1)
	STR_INIT_DEV(11)= STR_SCRORG(2)
C
	CALL RASTER_TECH_CONVERT(IWINDOW,STR_WINDOW)
	STR_INIT_DEV(17)= STR_WINDOW(1)
	STR_INIT_DEV(18)= STR_WINDOW(2)
	STR_INIT_DEV(19)= STR_WINDOW(1)
	STR_INIT_DEV(20)= STR_WINDOW(2)
C
C	CALL GB_IN_STRING(STR_DEBUG)	!******DEBUG******
C	CALL GB_EMPTY			!******DEBUG******
C
	DO N= 1,32
	  CALL GB_INSERT(STR_INIT_DEV(N))
	ENDDO
C
	IXMOVE= 0
	IYMOVE= 0
	CALL GB_INSERT(STR_MOVE)
	CALL RASTER_TECH_CONVERT(IXMOVE,STR_XMOVE)
	CALL RASTER_TECH_CONVERT(IYMOVE,STR_YMOVE)
	CALL GB_INSERT(STR_XMOVE(1))
	CALL GB_INSERT(STR_XMOVE(2))
	CALL GB_INSERT(STR_YMOVE(1))
	CALL GB_INSERT(STR_YMOVE(2))
	LVECTOR_DRAWING= .FALSE.
	IXCURP= IXMOVE
	IYCURP= IYMOVE
C
	CALL GB_EMPTY
C
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
C
	CALL GB_NEW_BUFFER
C
	DO N= 1,10
	  CALL GB_INSERT(STR_BEGIN_PLOT(N))
	ENDDO
C
	IXMOVE= 0
	IYMOVE= 0
	CALL GB_INSERT(STR_MOVE)
	CALL RASTER_TECH_CONVERT(IXMOVE,STR_XMOVE)
	CALL RASTER_TECH_CONVERT(IYMOVE,STR_YMOVE)
	CALL GB_INSERT(STR_XMOVE(1))
	CALL GB_INSERT(STR_XMOVE(2))
	CALL GB_INSERT(STR_YMOVE(1))
	CALL GB_INSERT(STR_YMOVE(2))
	LVECTOR_DRAWING= .FALSE.
	IXCURP= IXMOVE
	IYCURP= IYMOVE
C
	ICOLOR = 1
	CALL GB_INSERT(STR_SET_COLOR(1))
	DO N=1,3
	  CALL GB_INSERT(COLOR_MAP(N,ICOLOR))
	ENDDO
C
	CALL GB_EMPTY
C
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
	IXMOVE= XGUPCM*XA(1)+0.5
	IYMOVE= YGUPCM*YA(1)+0.5
	LVECTOR_DRAWING= .FALSE.
	RETURN
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	IXDRAW= XGUPCM*XA(1)+0.5
	IYDRAW= YGUPCM*YA(1)+0.5
	IF (LVECTOR_DRAWING) GO TO 450
	LDUMMY= GB_TEST_FLUSH(5)
	CALL GB_INSERT(STR_MOVE)
	CALL RASTER_TECH_CONVERT(IXMOVE,STR_XMOVE)
	CALL RASTER_TECH_CONVERT(IYMOVE,STR_YMOVE)
	CALL GB_INSERT(STR_XMOVE(1))
	CALL GB_INSERT(STR_XMOVE(2))
	CALL GB_INSERT(STR_YMOVE(1))
	CALL GB_INSERT(STR_YMOVE(2))
	LVECTOR_DRAWING= .TRUE.
C
450	CONTINUE
	LDUMMY= GB_TEST_FLUSH(5)
	CALL GB_INSERT(STR_DRAW)
	CALL RASTER_TECH_CONVERT(IXDRAW,STR_XDRAW)
	CALL RASTER_TECH_CONVERT(IYDRAW,STR_YDRAW)
	CALL GB_INSERT(STR_XDRAW(1))
	CALL GB_INSERT(STR_XDRAW(2))
	CALL GB_INSERT(STR_YDRAW(1))
	CALL GB_INSERT(STR_YDRAW(2))
	IXMOVE= IXDRAW
	IYMOVE= IYDRAW
	IXCURP= IXDRAW
	IYCURP= IYDRAW
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	LVECTOR_DRAWING= .FALSE.
	LDUMMY= GB_TEST_FLUSH(1)
	CALL GB_INSERT(STR_END_PLOT(1))
	CALL GB_EMPTY
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	CALL GB_FINISH(STR_END)
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 750 I= 1,8
	  XA(I)= DCHAR(I)
750	CONTINUE
	RETURN
C
C	****************************
C	SELECT CURRENT DRAWING COLOR
C	****************************
C
800	CONTINUE
	ICOLOR= IFIX( XA(1) )
	IF (ICOLOR.LT.0 .OR. ICOLOR.GT.7) RETURN
C
	LDUMMY= GB_TEST_FLUSH(4)
	CALL GB_INSERT(STR_SET_COLOR(1))
	CALL GB_INSERT(COLOR_MAP(1,ICOLOR))
	CALL GB_INSERT(COLOR_MAP(2,ICOLOR))
	CALL GB_INSERT(COLOR_MAP(3,ICOLOR))
	RETURN
C
C	******************************************
C	PERFORM GRAPHICS INPUT WITH PICK CHARACTER
C	******************************************
C
900	CONTINUE
C
	STR_XHAIR(3)= 1
	LDUMMY= GB_TEST_FLUSH(4)
	CALL GB_INSERT(STR_XHAIR(1))		!MAKE CURSOR VISIBLE
	CALL GB_INSERT(STR_XHAIR(2))
	CALL GB_INSERT(STR_XHAIR(3))
	CALL GB_INSERT(STR_END_PLOT(1))		!GET READY FOR PICK CHARACTER
	CALL GB_EMPTY
C
	CALL GB_GIN(STR_PROMPT,1,.TRUE.,IPICK)
C
	LDUMMY= GB_TEST_FLUSH(3)
	CALL GB_INSERT(STR_GRAPHICS_MODE(1))
	CALL GB_INSERT(STR_READ_REGISTER(1))
	CALL GB_INSERT(STR_READ_REGISTER(2))
	CALL GB_EMPTY
C
	CALL GB_GIN(STR_PROMPT,12,.TRUE.,STR_GIN_BUFFER)!TERMINAL IGNORES PROMPT
C
	DECODE (12,950,STR_GIN_BUFFER) IX_GIN,IY_GIN
950	FORMAT(I6,I6)
C
	XA(1)= IPICK
	XA(2)= IX_GIN/XGUPCM
	XA(3)= IY_GIN/YGUPCM
C
	STR_XHAIR(3)= 0
	LDUMMY= GB_TEST_FLUSH(4)
	CALL GB_INSERT(STR_ACKNOWLEDGE(1))
	CALL GB_INSERT(STR_XHAIR(1))		!MAKE CURSOR INVISIBLE
	CALL GB_INSERT(STR_XHAIR(2))
	CALL GB_INSERT(STR_XHAIR(3))
C
	RETURN
C
C	**********************
C	DEFINE COLOR USING RGB
C	**********************
C
1000	CONTINUE
C
	RETURN
C
C	**********************
C	DEFINE COLOR USING HLB
C	**********************
C
1100	CONTINUE
C
	RETURN
C
C	***********************************
C	PERFORM GRAPHICS INPUT WITH BUTTONS
C	***********************************
C
1200	CONTINUE
C
	STR_XHAIR(3)= 1
	LDUMMY= GB_TEST_FLUSH(7)
	CALL GB_INSERT(STR_FLUSH(1))
	CALL GB_INSERT(STR_XHAIR(1))		!MAKE CROSS HAIR VISIBLE
	CALL GB_INSERT(STR_XHAIR(2))
	CALL GB_INSERT(STR_XHAIR(3))
	CALL GB_INSERT(STR_READ_BUTTON(1))	!WAIT FOR NEXT MOUSE BUTTON
	CALL GB_INSERT(STR_READ_BUTTON(2))
	CALL GB_INSERT(STR_READ_BUTTON(3))
	CALL GB_EMPTY
C
	CALL GB_GIN(0,15,.TRUE.,STR_GIN_BUFFER)	!IMPORTANT: SEND NO PROMPTS
C
	DECODE (15,1250,STR_GIN_BUFFER) IB_GIN,IX_GIN,IY_GIN
1250	FORMAT(I3,I6,I6)
C
	XA(1)= 2**(IB_GIN-1)
	XA(2)= IX_GIN/XGUPCM
	XA(3)= IY_GIN/YGUPCM
C
	STR_XHAIR(3)= 0
	LDUMMY= GB_TEST_FLUSH(4)
	CALL GB_INSERT(STR_ACKNOWLEDGE(1))
	CALL GB_INSERT(STR_XHAIR(1))		!MAKE CURSOR INVISIBLE
	CALL GB_INSERT(STR_XHAIR(2))
	CALL GB_INSERT(STR_XHAIR(3))
C
	RETURN
C
C	*******************
C	DRAW FILLED POLYGON
C	*******************
C
1300	CONTINUE
	NVERT= IFXN-1024
	LVECTOR_DRAWING= .FALSE.
	IF (NVERT.LT.3) RETURN
C
	IF (IXCURP.NE.0 .OR. IYCURP.NE.0) THEN
	LDUMMY= GB_TEST_FLUSH(5)
	CALL GB_INSERT(STR_MOVE)
	IXCURP= 0
	IYCURP= 0
	CALL RASTER_TECH_CONVERT(IXCURP,STR_XMOVE)
	CALL RASTER_TECH_CONVERT(IYCURP,STR_YMOVE)
	CALL GB_INSERT(STR_XMOVE(1))
	CALL GB_INSERT(STR_XMOVE(2))
	CALL GB_INSERT(STR_YMOVE(1))
	CALL GB_INSERT(STR_YMOVE(2))
	ENDIF
C
	LDUMMY= GB_TEST_FLUSH( 4*(NVERT+1) )
	CALL GB_INSERT(STR_POLY(1))
	CALL GB_INSERT(STR_POLY(2))
	CALL RASTER_TECH_CONVERT(NVERT,STR_NVERT)
	CALL GB_INSERT(STR_NVERT(1))
	CALL GB_INSERT(STR_NVERT(2))
C
	DO 1350 N= 1,NVERT
	IXVERT= XGUPCM*XA(N)+0.5
	IYVERT= YGUPCM*YA(N)+0.5
	CALL RASTER_TECH_CONVERT(IXVERT,STR_XVERT)
	CALL RASTER_TECH_CONVERT(IYVERT,STR_YVERT)
	CALL GB_INSERT(STR_XVERT(1))
	CALL GB_INSERT(STR_XVERT(2))
	CALL GB_INSERT(STR_YVERT(1))
	CALL GB_INSERT(STR_YVERT(2))
1350	CONTINUE
C
	RETURN
C
	END
	SUBROUTINE RASTER_TECH_CONVERT(N,STR_N)
C
C	THIS ROUTINE CONVERTS INTEGER*2 TO RASTER TECHNOLOGY HI-LO BYTE
C
	INTEGER*2 N, NPOS, HIBYTE, LOBYTE
C
	BYTE STR_N(2), STR_BYTE(2)
C
	EQUIVALENCE (STR_BYTE(1),HIBYTE)
	EQUIVALENCE (STR_BYTE(2),LOBYTE)
C
	LOGICAL CARRY
C
	NPOS= IABS(N)
C
	HIBYTE= NPOS/256
	LOBYTE= MOD(NPOS,256)
C
	IF (N.GE.0) GO TO 100
C
	CARRY= (LOBYTE.EQ.0)
	HIBYTE= INOT(HIBYTE)		!NEXT FOUR LINES VAX/VHS SPECIFIC
	LOBYTE= INOT(LOBYTE) + 1
	HIBYTE= IIAND(255,HIBYTE)
	LOBYTE= IIAND(255,LOBYTE)
C
	IF (CARRY) HIBYTE= HIBYTE + 1
C
100	CONTINUE
	STR_N(1)= STR_BYTE(1)
	STR_N(2)= STR_BYTE(2)
C
	RETURN
C
	END
