	SUBROUTINE GDPST(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	POST SCRIPT DRIVER - HARD COPY DEVICE HAS 300 DOTS/INCH
	PARAMETER (DPI = 300.0)
C
C-----------------------------------------------------------------------
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	LOGICAL LNOPLT, LWIDE
	CHARACTER*16 COORD
	CHARACTER*8 CTIME
	CHARACTER*80 FNAME
	CHARACTER*120 COMAND
C
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
C
C	PAPER DEFINITIONS (INCHES)
C
c	PARAMETER (PSRES = 72.0)
	REAL*4 LMARGN
	PARAMETER (LMARGN = 0.5)
	PARAMETER (RMARGN = 0.25)
	PARAMETER (TMARGN = 0.5)
	PARAMETER (BMARGN = 0.25)
	PARAMETER (PAPERH = 11.0)
	PARAMETER (PAPERW = 8.5)
C		DERIVED PARAMETERS
	PARAMETER (UWD = PAPERW-LMARGN-RMARGN)
	PARAMETER (UHT = PAPERH-TMARGN-BMARGN)
	PARAMETER (WDCM = 2.54*UWD)
	PARAMETER (HTCM = 2.54*UHT)
	PARAMETER (RESOLUTION = DPI/2.54)
c	PARAMETER (PSRESCM = PSRES/2.54)
	PARAMETER (XOFF = DPI*LMARGN)
	PARAMETER (YOFF = DPI*BMARGN)
C
	PARAMETER (MAXPTS = 900)
C
C	UNIX routine for getting process id (so we can have a unique
C	   file name for the scratch file).
	integer*4 getpid, fputc
	external getpid, fputc
C
	CHARACTER*1 EOF
C
C	DIGLIB DEVICE CHARACTERISTICS WORDS
C
	DATA DCHAR /910.0, WDCM, HTCM, RESOLUTION,
     1   RESOLUTION, 1.0, 27.0, 2.0/
C
	LWIDE = .FALSE.
10	CONTINUE
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 7) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
	LUN = XA(1)
C	CALL IDATE(IM,ID,IY)
	CALL TIME(CTIME)
C	IF (ID .GT. 26) ID = ID-26 + (48-64)
	write(fname,101) mod(getpid(),100000)
101	format('/tmp/diglib_',i5.5,'.ps')
	OPEN(UNIT=LUN,FILE=FNAME,STATUS='NEW',ERR=9000)
C	FNAME = 'SYS$SCRATCH:POSTSCRIPT.DIG'//CHAR(IM+64)//CHAR(ID+64)
C     1   //CTIME(1:2)//CTIME(4:5)//CTIME(7:8)
C	OPEN (UNIT=LUN,NAME=FNAME,TYPE='NEW',
C     1   FORM='UNFORMATTED',CARRIAGECONTROL='NONE',RECORDTYPE='VARIABLE',
C     2   INITIALSIZE = 50, EXTENDSIZE = 50,
C     3   ERR=9000)
C
C	SHOW INITIALIZATION WORKED, I.E. WE OPENED THE FILE.
C
	EOF = char(4)
	YA(1) = 0.0
	CALL GDPSOP(LUN)
C	CALL GDPSIN(EOF)
	CALL GDPSIN('%! DIGLIB PLOT'//char(0))
	CALL GDPSDU
	CALL GDPSIN('/m {moveto} def /l {lineto} def '//char(0))
        call gdpsse(DPI)
	CALL GDPSDU
190	CONTINUE
	LNOPLT = .TRUE.
	NPTS = 0
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	IF (.NOT. LNOPLT) THEN
C		CALL GDPSDU
		CALL GDPSIN('stroke showpage '//char(0))
	ENDIF
	CALL GDPSDU
        call gdpsse(DPI)
	CALL GDPSIN('newpath '//char(0))
	GO TO 190
C
C	****
C	MOVE
C	****
C
300	CONTINUE
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	NPTS = NPTS + 1
	IF (NPTS .GT. MAXPTS) THEN
		CALL GDPSDU
		CALL GDPSIN('stroke newpath '//char(0))
		IF (IFXN .EQ. 4) THEN
			CALL GDPSIN(COORD)
			CALL GDPSIN('m '//char(0))
		ENDIF
		NPTS = 1
	ENDIF
	IF (LWIDE) THEN
		ix = RESOLUTION*YA(1)+XOFF
		iy = RESOLUTION*(HTCM-XA(1))+YOFF
	    ELSE
		ix = RESOLUTION*XA(1)+XOFF
		iy = RESOLUTION*YA(1)+YOFF
	ENDIF
	WRITE(COORD,451) ix,iy
 451    FORMAT(i4,1X,i4,1X)
	COORD(11:11) = char(0)
	CALL GDPSIN(COORD)
	IF (IFXN .EQ. 3) THEN
		CALL GDPSIN('m '//char(0))
	    ELSE
		CALL GDPSIN('l '//char(0))
	ENDIF
	LNOPLT = .FALSE.
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
C		!DONE BY BGNPLT WHEN NECESSARY.
500	CONTINUE
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	IF (.NOT. LNOPLT) THEN
		CALL GDPSDU
		CALL GDPSIN('stroke showpage '//char(0))
		CALL GDPSDU
C		CALL GDPSIN(EOF)
		CALL GDPSDU
	ENDIF
	CLOSE (UNIT=LUN)
	COMAND = 'lpr -r '//FNAME
	ISTATUS = system(COMAND)
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	IF (LWIDE) THEN
		XA(2) = DCHAR(3)
		XA(3) = DCHAR(2)
	ENDIF
	RETURN
C
C	HANDLE FILE OPEN ERROR
C
9000	CONTINUE
	YA(1) = 3.0
	RETURN
C
C	***********************************************************
C
	ENTRY GDPSW(IFXN,XA,YA)
	LWIDE = .TRUE.
	GO TO 10
	END


        subroutine gdpsse(dpi)
        character*16 dpistr
	call gdpsin('initgraphics 1 setlinecap 1 setlinejoin '//char(0))
	call gdpsdu
        call gdpsin('72 '//char(0))
	write(dpistr,181) dpi
 181    format(g14.7)
        dpistr(15:15) = char(0)
        call gdpsin(dpistr)
        call gdpsin(' div dup scale 3 setlinewidth'//char(0))
	call gdpsdu
        return
        end


	SUBROUTINE GDPSOP(LUN)
C
	PARAMETER (IBUFSZ = 80)
	CHARACTER*1 BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
	LUNOUT = LUN
	NXTCHR = 1
	RETURN
	END


	SUBROUTINE GDPSIT
C
	PARAMETER (IBUFSZ = 80)
	CHARACTER*1 BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
	NXTCHR = 1
	RETURN
	END


	SUBROUTINE GDPSIN(STRING)
	CHARACTER*1 STRING(2)
C
	PARAMETER (IBUFSZ = 80)
	CHARACTER*1 BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
	EXTERNAL LEN
C
	L = LEN(STRING)
	IF ((NXTCHR+L) .GT. IBUFSZ) CALL GDPSDU
		DO 100 I = 1, L
		BUFFER(NXTCHR) = STRING(I)
		NXTCHR = NXTCHR + 1
100		CONTINUE
	RETURN
	END

	SUBROUTINE GDPSDU
C
	PARAMETER (IBUFSZ = 80)
	CHARACTER*1 BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFSZ)
C
	IF (NXTCHR .EQ. 1) RETURN
	WRITE (LUNOUT,111) (BUFFER(I), I=1,NXTCHR-1)
 111    format(80a1)
	NXTCHR = 1
	RETURN
	END
