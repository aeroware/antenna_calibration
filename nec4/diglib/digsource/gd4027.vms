	SUBROUTINE GD4027(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	TEKTRONIX 4027 DRIVER FOR DIGLIB/VAX
C		UNTESTED but derived from the 4025 driver, so it should
C			mostly work
C
C-----------------------------------------------------------------------
C
	BYTE CSUB, US, GS, CR, FF, ESC
	PARAMETER (CSUB=26, US=31, GS=29, CR=13, FF=12, ESC=27)
	CHARACTER*(*) TERMINAL, LOG_CC, LOG_COM
	PARAMETER (TERMINAL='TT')
	PARAMETER (LOG_CC='TEK_4025CC')
	PARAMETER (LOG_COM = 'TEK_4025COM')
C
C	DEFINITIONS FOR DEVICE CONTROL
C
	CHARACTER*1 NEW_CC
	CHARACTER*80 NEW_COM
	BYTE CMD, BCHAR
	BYTE STR_END(2)
	BYTE ASCIID, ASCIIA, ASCIIT
	BYTE BCOLOR_MAP(8)
C
	DATA CMD /33/
	DATA ASCIID, ASCIIA, ASCIIT /'D','A','T'/
	DATA STR_END /13,0/
	DATA BCOLOR_MAP / '7', '0', '1', '2', '3', '4', '5', '6' /
C
C	DEFINITIONS FOR GIN
C
	BYTE GINBUFR(28), PROMPT(8)
C
	DATA PROMPT /
	1   0,'E','N','A',' ','1',CR,0/
	DATA IGIN_IN_CHARS /27/
C
C	DECLARE BUFFERING FUNCTION
C
	LOGICAL GB_TEST_FLUSH
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	INTEGER*4 SYS$TRNLOG, STR$UPCASE
	LOGICAL LVECTOR_GOING, LDUMMY
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
	DATA DCHAR /4027.0, 24.706, 16.2, 25.864, 25.864, 7.0, 229.0, 1.0/
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 11) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700,800,900,1000,1100) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
C
C	FIRST, INITIALIZE THE BUFFER SUBROUTINES
C
	CALL GB_INITIALIZE(US,STR_END,TERMINAL,IERR)
	YA(1) = IERR
	IF (IERR .NE. 0) RETURN
	LVECTOR_GOING = .FALSE.
C
C	SEE IF USER DEFINED COMMAND CHARACTER
C
	ISTATUS = SYS$TRNLOG(LOG_CC,ILENCC,NEW_CC, , , )
	IF (ISTATUS) THEN
		CMD = ICHAR(NEW_CC)
	ENDIF
C
C	EXIT ANSI MODE (JUST INCASE TERMINAL IS IN ANSI MODE)
C
	CALL GB_INSERT(ESC)
	CALL GB_IN_STRING('[~')
C
C	CREATE WORKSPACE AND GRAPHICS AREA
C
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('WOR 30')
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('GRA 1,30')
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('JUM 1,1')
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('LIN 1')
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('COL C0')
	CALL GB_EMPTY
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	CALL GB_EMPTY
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('ERA G')
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('COL C0')
	CALL GB_EMPTY
C
C	COMMENT OUT THE FOLLOWING IF YOU DON'T WANT YOUR 4027s COLORS
C	CHANGED TO "NORMAL" BY DIGLIB
C
	CALL GD4027_MIX(CMD,0,0,0,0)
	CALL GD4027_MIX(CMD,1,100,100,100)
	CALL GD4027_MIX(CMD,2,100,0,0)
	CALL GD4027_MIX(CMD,3,0,100,0)
	CALL GB_EMPTY
	CALL GD4027_MIX(CMD,4,0,0,100)
	CALL GD4027_MIX(CMD,5,100,100,0)
	CALL GD4027_MIX(CMD,6,100,0,100)
	CALL GD4027_MIX(CMD,7,0,100,100)
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	****
C	MOVE
C	****
C
300	CONTINUE
C	CONVERT CM. TO GRAPHICS UNITS ROUNDED
	IXPOSN = XGUPCM*XA(1)+0.5
	IYPOSN = YGUPCM*YA(1)+0.5
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	IX = XGUPCM*XA(1)+0.5
	IY = YGUPCM*YA(1)+0.5
	LVECTOR_GOING = LVECTOR_GOING .AND. (.NOT. GB_TEST_FLUSH(4))
	IF (LVECTOR_GOING) GO TO 410
	LDUMMY = GB_TEST_FLUSH(9)
	LVECTOR_GOING =  .TRUE.
	CALL GB_INSERT(GS)
	CALL GB_USE_TERMINATOR
	CALL GD_4010_CONVERT(IXPOSN,IYPOSN)
410	IF (IX .NE. IXPOSN .OR. IY .NE. IYPOSN) THEN
		CALL GD_4010_CONVERT(IX,IY)
		IXPOSN = IX
		IYPOSN = IY
	ENDIF
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
C
C	SEE IF USER WANTS ANYTHING DONE, IF SO, DO IT
C
	ISTATUS = SYS$TRNLOG(LOG_COM,ILENCOM,NEW_COM, , , )
	IF (ISTATUS) THEN
		ISTATUS = STR$UPCASE(NEW_COM,NEW_COM)
		IF (NEW_COM(1:4) .EQ. 'ANSI') THEN
			TYPE 601
601			FORMAT('$Hit return to return terminal to ANSI mode.')
			ACCEPT 602, ISTATUS
602			FORMAT(A1)
		ENDIF
		CALL GB_EMPTY
		CALL GB_INSERT(CMD)
		DO 610 I=1,ILENCOM
			BCHAR = ICHAR(NEW_COM(I:I))
			CALL GB_INSERT(BCHAR)
610			CONTINUE
	ENDIF
	CALL GB_EMPTY
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	RETURN
C
C	****************************
C	SELECT CURRENT DRAWING COLOR
C	****************************
C
800	CONTINUE
	CALL GB_EMPTY
	ICOLOR = XA(1)
	IF (ICOLOR .LT. 0 .OR. ICOLOR .GT. 7) RETURN
	CALL GB_INSERT(CMD)
	CALL GB_IN_STRING('COL C')
	CALL GB_INSERT(BCOLOR_MAP(ICOLOR+1))
	LVECTOR_GOING = .FALSE.
	RETURN
C
C	**********************
C	PERFORM GRAPHICS INPUT
C	**********************
C
900	CONTINUE
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
C
C	ASK FOR 1 GIN INPUT
C
920	CONTINUE
	PROMPT(1) = CMD
	CALL GB_GIN(PROMPT,IGIN_IN_CHARS,.FALSE.,GINBUFR)
	IF ((GINBUFR(2) .NE. ASCIID) .OR. (GINBUFR(3) .NE. ASCIIA) .OR.
	1   (GINBUFR(4) .NE. ASCIIT)) GOTO 920
C
C	GET KEY PRESSED, X AND Y
C
C	KEY IS AT 9, X IS AT 13, AND Y IS AT 17
C
	DECODE (11,911,GINBUFR(9)) XA(1), XA(2), XA(3)
911	FORMAT(F3.0,1X,F3.0,1X,F3.0)
	XA(2) = XA(2)/XGUPCM
	XA(3) = XA(3)/YGUPCM
	RETURN
C
C	DEFINE COLOR VIA RGB
C
1000	CONTINUE
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	CALL GD4027_MIX(CMD,INT(XA(1)),INT(YA(1)),INT(YA(2)),INT(YA(3)))
	RETURN
C
C	DEFINE COLOR VIA HLS
C
1100	CONTINUE
	CALL GB_EMPTY
	LVECTOR_GOING = .FALSE.
	CALL GD4027_MAP(CMD,INT(XA(1)),INT(YA(1)),INT(YA(2)),INT(YA(3)))
	RETURN
	END
