      USE MSFLIB
C      PROGRAM NECPLT4
      CALL DAPLOT2
      END
      SUBROUTINE DAPLOT2
C
C     DAPLOT2 WILL READ A NEC INPUT OR OUTPUT FILE AND PLOT AN ISOMETRIC
C     PROJECTION OF THE WIRE AND PATCH STRUCTURE FROM ANY VIEWING ANGLE.
C     CURRENTS FROM AN OUTPUT FILE CAN ALSO BE DISPLAYED AS ARROWS ON
C     WIRES AND PATCHES.
C
C     REVISED 9/30/91 TO PLOT PATCHES WITH RECTANGULAR, TRIANGULAR OR
C     QUADRILATERAL SHAPES AND ALSO PLOT PATCH CURRENTS FROM AN OUTPUT
C     FILE.
C
C     THIS PROGRAM MUST BE LINKED WITH THE DIGLIB GRAPHICS LIBRARY.
C     DIGLIB IS AVAILABLE FROM LAWRENCE LIVERMORE LAB.
C
      CHARACTER*80 INFILE
      CHARACTER*2 AIN
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
C
C     IDEV IS THE DIGLIB NUMBER OF THE TERMINAL GRAPHICS DEVICE.
C     THE DEFAULT IS SET BELOW.  A TEMPORARY CHANGE CAN BE MADE BY USING
C     THE DV COMMAND.  IDLASR IS A HARD COPY GRAPHICS DEVICE.
C
      IDEV=1
      IDLASR=4
C
C     DISPLAY ABSOFT MESSAGE AND DELAY FOR A WHILE
C
C      WRITE(*,92)
C92    FORMAT(///////,15X,' Portions of this program include material',
C     &/,15X,' copyrighted © by Absoft Corp 1988')
C      R1=1.
C      DO 11 I=1,4000
C11    R1=COS(R1/I)+SIN(R1)
      GO TO 12
100   WRITE(*,900)
900   FORMAT(' >',$)
      CALL READVAX(5,AIN,R1,R2,R3,IERROR)
C      READ(*,901,ERR=100)AIN,R1,R2,R3
901   FORMAT(A2,4E12.5)
      IF(IERROR.NE.0)GO TO 100
      IF(AIN.EQ.'NF')GO TO 10
      IF(AIN.EQ.'RF')GO TO 15
      IF(AIN.EQ.'VA')GO TO 20
      IF(AIN.EQ.'SC')GO TO 30
      IF(AIN.EQ.'ZX')GO TO 40
      IF(AIN.EQ.'PT')GO TO 50
      IF(AIN.EQ.'PL')GO TO 60
      IF(AIN.EQ.'PH')GO TO 61
      IF(AIN.EQ.'PS')GO TO 62
      IF(AIN.EQ.'SH')GO TO 70
      IF(AIN.EQ.'EX')GO TO 90
      IF(AIN.EQ.'DV')GO TO 110
      IF(AIN.EQ.'SE')GO TO 120
      IF(AIN.EQ.'AR')GO TO 130
      IF(AIN.EQ.'AI')GO TO 130
      IF(AIN.EQ.'FE')GO TO 140
      IF(AIN.EQ.'SP')GO TO 150
      IF(AIN.EQ.'RW')GO TO 160
      IF(AIN.EQ.'RB')GO TO 170
1     WRITE(*,902)
902   FORMAT(' ERROR - INVALID COMMAND')
      GO TO 100
10    CALL CLEARS
12    CALL NEWINF
      CALL DATCON
      CALL INITLP
      CALL PROJCT
      CALL PLOTVU(IDEV)
      GO TO 100
15    CALL REDINF
      CALL DATCON
      CALL PROJCT
      CALL PLOTVU(IDEV)
      GO TO 100
20    CALL PQVECT(R1,R2,R3)
      CALL PROJCT
      CALL PLOTVU(IDEV)
      GO TO 100
30    ICSEG=R1+.5
      CALL PLOTVU(IDEV)
      GO TO 100
40    ZXFAC=R1
      IF(R1.EQ.0.)ZXFAC=1.
      CALL PLOTVU(IDEV)
      GO TO 100
50    CALL PLOTVU(IDEV)
      GO TO 100
60    CALL PLOTVU(IDLASR)
      GO TO 100
61    CALL PLOTVU(2)
      GO TO 100
62    CALL PLOTVU(4)
      GO TO 100
70    CALL SHOWP
      GO TO 100
90    CALL CLEARS
      CALL POSTDMP
      STOP
110   CALL CLEARS
      CALL GETDEV(IDEV)
      CALL PLOTVU(IDEV)
      GO TO 100
120   IENDSY=1
      IF(R1.NE.0.)IENDSY=0
      CALL PLOTVU(IDEV)
      GO TO 100
130   IF(ICURNT.EQ.0)GO TO 1
      IAROW=1
      IF(AIN.EQ.'AI')IAROW=2
      IF(R1.NE.0)IAROW=0
      CALL PLOTVU(IDEV)
      GO TO 100
140   IDOTEN=1
      IF(R1.NE.0)IDOTEN=0
      CALL PLOTVU(IDEV)
      GO TO 100
150   SCALEF=R1
      IF(R1.LE.0.)SCALEF=1.
      SCAROW=R2*.04
      IF(R2.LE.0.)SCAROW=.04
      CALL PLOTVU(IDEV)
      GO TO 100
160   REWIND 2
      NPLOT=0
      GO TO 15
170   CALL GSBKRV
      CALL PLOTVU(IDEV)
      GO TO 100
      END
      SUBROUTINE READVAX(INUNIT,CODE,F1,F2,F3,IERROR)
C
C  READVAX reads a control record and parses it.
C
      CHARACTER CODE*(*), RECDAT*78, FNAME*80
      DIMENSION INTVAL(4),REAVAL(6)
C
C  Call the routine to read the record and parse it.
C
      CALL PARSIT(INUNIT,0,3,CODE,RECDAT,INTVAL,REAVAL,FNAME,IERROR)
C
C  Set the return variables to the buffer array elements.
      F1=REAVAL(1)
      F2=REAVAL(2)
      F3=REAVAL(3)
      RETURN
      END
      SUBROUTINE NEWINF
C
C     NEWINF INITIATES READING OF A DATA FILE.  IF THE FILE IS A NEC
C     INPUT FILE IT MUST BEGIN WITH A CM OR CE CARD.  THE CM AND CE
C     CARDS ARE THEN READ, AND SUBROUTINE DATAGN IS CALLED TO READ THE
C     STRUCTURE DATA.  IF THE FILE BEGINS WITH A ONE IN COLUMN ONE
C     (TOP-OF-FORM) THEN SUBROUTINE REDOUT IS CALLED TO READ IT AS A
C     NEC OUTPUT FILE.
C
      USE DFLIB
      USE MSFLIB
      INCLUDE 'NECPAR.INC'
      CHARACTER INFILE*80,AIN*2,DUMXX
	CHARACTER DRIVE*10,DIR*80,FNAME*30,EXT*30
C      BYTE COM
      LOGICAL LDIR
      INTEGER*1 COM
      COMMON/PATDAT/NPAT,XPAT(MAXSEG),YPAT(MAXSEG),ZPAT(MAXSEG),
     &PNX(MAXSEG),PNY(MAXSEG),PNZ(MAXSEG),APAT(MAXSEG),PCURXR(MAXSEG),
     &PCURXI(MAXSEG),PCURYR(MAXSEG),PCURYI(MAXSEG),PCURZR(MAXSEG),
     &PCURZI(MAXSEG)
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/COMTXT/KCOM,COM(5,81)
      NPAT=0
      NPLOT=NPLOT+1
      FRQMHZ=0.
      CLOSE(UNIT=2,ERR=703)
C
C     READ FILE NAME (VAX)
C703   WRITE(*,700)
C700   FORMAT(' ENTER NAME OF NEC INPUT OR OUTPUT FILE >',$)
C      READ(*,701,ERR=702) INFILE
C701   FORMAT(A)
C      OPEN (UNIT=2,FILE=INFILE,STATUS='OLD',ERR=702)
C
C     DIALOG BOX FOR MAC
C
C*** Windows 95
703   CALL SETMESSAGEQQ("Open NEC output file , *.*",
     & QWIN$MSG_FILEOPENDLG)
      OPEN (UNIT=2,FILE="",STATUS='OLD',ACTION='READ',ERR=703)
      INQUIRE(UNIT=2,NAME=INFILE)
	LENDIR=SPLITPATHQQ(INFILE,DRIVE,DIR,FNAME,EXT)
	LDIR=CHANGEDIRQQ(DIR)
	GO TO 1
7033  WRITE(*,*)' ERROR OPENING FILE'
      READ(*,*)
	GO TO 703
1     ICURNT=0
C
C     READ COMMENT CARDS FROM NEC INPUT FILE
C
      KCOM=0
2     KCOM=KCOM+1
      IF (KCOM.GT.5) KCOM=5
      DO 3 K=1,81
3     COM(KCOM,K)=0
      NCOM=80
      NRTRY=0
      READ(2,125)AIN,(COM(KCOM,K),K=1,NCOM)
125   FORMAT(A2,80A1)
      IF (AIN.EQ.'CM') GO TO 2
      IF (AIN.EQ.'CE') THEN
           CALL DATAGN
           INFIO=0
           RETURN
      ELSE
4        IF(AIN.EQ.'1 ')THEN
           CALL REDOUT
           INFIO=1
           RETURN
         END IF
         NRTRY=NRTRY+1
         IF(NRTRY.GT.200)THEN
           WRITE(*,90)
90         FORMAT(' ERROR - FILE DOES NOT HAVE THE FORMAT OF A NEC INPUT
     &     OR OUTPUT FILE')
	     READ(*,'(A)')DUMXX
           GO TO 703
         END IF
        READ(2,'(A)')AIN
        GO TO 4
      END IF
      RETURN
      END
      SUBROUTINE REDINF
C
C     REDINF CONTINUES READING OF A DATA FILE STARTED BY NEWINF.
C
      INCLUDE 'NECPAR.INC'
      CHARACTER INFILE*80,AIN*2
C      BYTE COM
      INTEGER*1 COM
      COMMON/PATDAT/NPAT,XPAT(MAXSEG),YPAT(MAXSEG),ZPAT(MAXSEG),
     &PNX(MAXSEG),PNY(MAXSEG),PNZ(MAXSEG),APAT(MAXSEG),PCURXR(MAXSEG),
     &PCURXI(MAXSEG),PCURYR(MAXSEG),PCURYI(MAXSEG),PCURZR(MAXSEG),
     &PCURZI(MAXSEG)
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/COMTXT/KCOM,COM(5,81)
      NPAT=0
      NPLOT=NPLOT+1
      CALL CLEARS
      IF(INFIO.EQ.1)THEN
           CALL REDOUT
           RETURN
      END IF
C
C     READ COMMENT CARDS FROM NEC INPUT FILE
C
1     KCOM=0
2     KCOM=KCOM+1
      IF (KCOM.GT.5) KCOM=5
      NCOM=80
      READ(2,125,END=3)AIN,(COM(KCOM,K),K=1,NCOM)
125   FORMAT(A2,80A1)
      COM(KCOM,NCOM+1)=0
      IF (AIN.EQ.'CM') GO TO 2
      IF (AIN.EQ.'CE') THEN
           CALL DATAGN
           RETURN
      ELSE
           GO TO 1
      END IF
3     WRITE(*,90)
90         FORMAT(' ERROR - END OF FILE ENCOUNTERED READING NEC INPUT FI
     &LE')
      CALL CLEARS
      CALL POSTDMP
      STOP
      END
      SUBROUTINE REDOUT
      INCLUDE 'NECPAR.INC'
      CHARACTER INFILE*80,TEXT*80,TEXT1*4
C      BYTE COM
      INTEGER*1 COM
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/PATDAT/NPAT,XPAT(MAXSEG),YPAT(MAXSEG),ZPAT(MAXSEG),
     &PNX(MAXSEG),PNY(MAXSEG),PNZ(MAXSEG),APAT(MAXSEG),PCURXR(MAXSEG),
     &PCURXI(MAXSEG),PCURYR(MAXSEG),PCURYI(MAXSEG),PCURZR(MAXSEG),
     &PCURZI(MAXSEG)
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/CURR/CR(2*MAXSEG),CI(2*MAXSEG)
      COMMON/COMTXT/KCOM,COM(5,81)
      DATA TA/.01745329252/
      NFLOW=0
1     READ(2,90,END=100)TEXT
90    FORMAT(A)
      IF(TEXT(3:14).EQ.'SEG.   COORD')GO TO 2
      IF(TEXT(44:54).EQ.'- FREQUENCY')GO TO 3
      IF(TEXT(3:11).EQ.'SEG.  TAG')GO TO 4
      IF(TEXT(2:14).EQ.'PATCH     COO')GO TO 11
      IF(TEXT(7:18).EQ.'PATCH CENTER')GO TO 13
      IF(TEXT(33:40).EQ.' *******')GO TO 6
      IF(TEXT(38:47).EQ.'BEFORE STR')GO TO 17
      GO TO 1
C
C     FIND "SEG.   COO" IN SEGMENT DATA TABLE
C          "NO. "
C     AND READ SEGMENT DATA TABLE
C
2     READ(2,90,END=100)TEXT
      IF(TEXT(3:6).NE.'NO. ')GO TO 1
      N=0
      NPAT=0
      NFLOW=1
5     READ(2,92)ISEG,XS,YS,ZS,DELS,ALPS,BETS,RADS,IC1,I,IC2,ITAGS
92    FORMAT(1X,I5,4F10.5,1X,3F10.5,1X,3I5,2X,I5)
      IF(ISEG.EQ.0)GO TO 1
      N=N+1
      X(N)=XS
      Y(N)=YS
      Z(N)=ZS
      SI(N)=DELS
      COSALF=COS(ALPS*TA)
      ALP(N)=COSALF*COS(BETS*TA)
      BET(N)=COSALF*SIN(BETS*TA)
      SALP(N)=SIN(ALPS*TA)
      ICON1(N)=IC1
      ICON2(N)=IC2
      GO TO 5
C
C     FIND 'ATCH     C' IN PATCH DATA TABLE AND READ X,Y,Z
11    NPAT=0
      IF(NFLOW.EQ.0)N=0
      READ(2,90)TEXT
12    READ(2,95)IPAT,XPATX,YPATX,ZPATX,PNXX,PNYX,PNZX,APATX
95    FORMAT(I5,3F10.5,1X,3F8.4,F10.5)
      IF(IPAT.EQ.0)GO TO 1
      NPAT=NPAT+1
      XPAT(NPAT)=XPATX
      YPAT(NPAT)=YPATX
      ZPAT(NPAT)=ZPATX
      PNX(NPAT)=PNXX
      PNY(NPAT)=PNYX
      PNZ(NPAT)=PNZX
      APAT(NPAT)=APATX
      GO TO 12
17    CALL PATRED
      GO TO 1
C
C     READ PATCH CURRENTS
13    READ(2,90)TEXT
      DO 14 I=1,NPAT
      READ(2,90)TEXT
      READ(2,97)XCURXR,XCURXI,XCURYR,XCURYI,XCURZR,XCURZI
97    FORMAT(61X,6E10.2)
      SQAREA=SQRT(APAT(I))
      SQAREA=1.
      PCURXR(I)=XCURXR*SQAREA
      PCURXI(I)=XCURXI*SQAREA
      PCURYR(I)=XCURYR*SQAREA
      PCURYI(I)=XCURYI*SQAREA
      PCURZR(I)=XCURZR*SQAREA
14    PCURZI(I)=XCURZI*SQAREA
      ICURNT=1
      GO TO 15
C
C     FIND "- FREQUE" TO GET FREQUENCY
C
3     READ(2,90)TEXT
      READ(2,93)TEXT1,FRQMHX
93    FORMAT(36X,A4,6X,E11.4)
      IF(TEXT1.EQ.'FREQ')FRQMHZ=FRQMHX
      GO TO 1
C
C     READ CM AND CE TEXT
C
6     DO 7 I=1,4
7     READ(2,90)TEXT
      IF(TEXT(33:36).NE.' ***')GO TO 1
      DO 8 I=1,5
8     READ(2,90)TEXT
      IF(TEXT(22:25).NE.' ***')READ(2,90)TEXT
      READ(2,90)TEXT
      DO 9 I=1,2
      READ(2,94)(COM(I,J),J=1,80)
94    FORMAT(25X,80A1)
9     COM(I,81)=0
      KCOM=2
C
C     FIND "SEG.  TAG " FOR START OF WIRE CURRENT TABLE
C
4     IF(N.EQ.0)GO TO 1
      READ(2,90,END=100)TEXT
      IF(TEXT(3:6).NE.'NO. ')GO TO 1
      ICURNT=1
      DO I=1,N
C      READ(2,96)CR(I),CI(I)
C96    FORMAT(48X,2E12.5)
         READ(2,*)ISX,ITX,XXX,YYY,ZZZ,ELLL,CR(I),CI(I)
      END DO
      IF(NPAT.GT.0)GO TO 1
C
C     FIND MAXIMUM AND MINIMUM OF CURRENT
C
15    CRMAX=0.
      CIMAX=0.
      IF(N.GT.0)THEN
         CALL MINMAX(CR,N,AMIN,AMAX)
         CRMAX=AMAX1(ABS(AMIN),AMAX)
         CALL MINMAX(CI,N,AMIN,AMAX)
         CIMAX=AMAX1(ABS(AMIN),AMAX)
      END IF
      DO 16 I=1,NPAT
      CURXR=SQRT(PCURXR(I)**2+PCURYR(I)**2+PCURZR(I)**2)*SQRT(APAT(I))
      CURXI=SQRT(PCURXI(I)**2+PCURYI(I)**2+PCURZI(I)**2)*SQRT(APAT(I))
      IF(CURXR.GT.CRMAX)CRMAX=CURXR
      IF(CURXI.GT.CIMAX)CIMAX=CURXI
16    CONTINUE
      CRIMAX=AMAX1(CRMAX,CIMAX)
      IF(CRIMAX.LT.1.E-20)CRIMAX=1.E-20
      RETURN
100   WRITE(*,99)
99    FORMAT(' END OF FILE ENCOUNTERED ON NEC OUTPUT FILE')
      CALL CLEARS
      CALL POSTDMP
      STOP
      END
      SUBROUTINE PATRED
C
C     READ AND STORE PATCH DATA FROM COMMANDS IN OUTPUT FILE DEFINING
C     PATCH SHAPE
C
      INCLUDE 'NECPAR.INC'
      CHARACTER TEXT*99,PCHAR*1,PCHAX*1
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      DO 18 I=1,4
18    READ(2,90)TEXT
      NPATPL=0
19    READ(2,90,END=100)TEXT
90    FORMAT(A)
      IF(TEXT.EQ.'')RETURN
      IF(TEXT(17:25).EQ.'SCALED BY')THEN
         READ(TEXT(33:42),192)SCAFAC
192      FORMAT(F10.5)
         CALL PSCALE(SCAFAC)
      ELSE IF(TEXT(25:36).EQ.'ABOUT Z-AXIS')THEN
         READ(TEXT(37:39),193)IRZ
193      FORMAT(I3)
         CALL PROTAT(IRZ)
      ELSE IF(TEXT(25:34).EQ.'BEEN MOVED')THEN
         READ(2,194)NRPT,ROX,ROY,ROZ,XS,YS,ZS
194      FORMAT(9X,I5,6F10.5)
         CALL PMOVE(ROX,ROY,ROZ,XS,YS,ZS,NRPT)
      ELSE IF(TEXT(17:31).EQ.'REFLECTED ALONG')THEN
         IRX=0
         IRY=0
         IRZ=0
         IF(TEXT(42:42).EQ.'X')IRX=1
         IF(TEXT(44:44).EQ.'Y')IRY=1
         IF(TEXT(46:46).EQ.'Z')IRZ=1
         CALL PREFLX(IRX,IRY,IRZ)
      ELSE IF(TEXT(7:7).EQ.'R'.OR.TEXT(7:7).EQ.'Q'.OR.TEXT(7:7).EQ.'T')
     &THEN
         READ(TEXT,190)IPXX,PCHAR,XSPAT1,YSPAT1,ZSPAT1,XSPAT2,YSPAT2,
     &   ZSPAT2
190      FORMAT(I6,A,F10.5,1X,F10.5,1X,F10.5,2X,F10.5,1X,F10.5,1X,F10.5)
         READ(2,190)IPXX,PCHAX,XSPAT3,YSPAT3,ZSPAT3,XSPAT4,YSPAT4,ZSPAT4
         IF(TEXT(79:87).EQ.'SURFACE -')THEN
            READ(TEXT(89:97),191)NS1,NS2
191         FORMAT(I3,3X,I3)
         ELSE
            NS1=1
            NS2=1
         END IF
         CALL PATSET(PCHAR,XSPAT1,YSPAT1,ZSPAT1,XSPAT2,YSPAT2,ZSPAT2,
     &   XSPAT3,YSPAT3,ZSPAT3,XSPAT4,YSPAT4,ZSPAT4,NS1,NS2)
      END IF
      GO TO 19
100   WRITE(*,*)' END OF FILE READ IN SUBROUTINE PATRED'
      CALL CLEARS
      CALL POSTDMP
      STOP
      END
      SUBROUTINE PREFLX(IRX,IRY,IRZ)
C
C     SUBROUTINE PREFLX REFLECTS THE PATCH OUTLINES IN THE COORDINATE
C     PLANES.
C
      INCLUDE 'NECPAR.INC'
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
C
C     REFLECT ALONG Z AXIS
C
      IF(IRZ.NE.0)THEN
         DO 1 I=1,NPATPL
         K=I+NPATPL
         XPAT1(K)=XPAT2(I)
         YPAT1(K)=YPAT2(I)
         ZPAT1(K)=-ZPAT2(I)
         XPAT2(K)=XPAT1(I)
         YPAT2(K)=YPAT1(I)
         ZPAT2(K)=-ZPAT1(I)
         XPAT3(K)=XPAT4(I)
         YPAT3(K)=YPAT4(I)
         ZPAT3(K)=-ZPAT4(I)
         XPAT4(K)=XPAT3(I)
         YPAT4(K)=YPAT3(I)
         ZPAT4(K)=-ZPAT3(I)
1        CONTINUE
         NPATPL=2*NPATPL
      END IF
C
C     REFLECT ALONG Y AXIS
C
      IF(IRY.NE.0)THEN
         DO 2 I=1,NPATPL
         K=I+NPATPL
         XPAT1(K)=XPAT2(I)
         YPAT1(K)=-YPAT2(I)
         ZPAT1(K)=ZPAT2(I)
         XPAT2(K)=XPAT1(I)
         YPAT2(K)=-YPAT1(I)
         ZPAT2(K)=ZPAT1(I)
         XPAT3(K)=XPAT4(I)
         YPAT3(K)=-YPAT4(I)
         ZPAT3(K)=ZPAT4(I)
         XPAT4(K)=XPAT3(I)
         YPAT4(K)=-YPAT3(I)
         ZPAT4(K)=ZPAT3(I)
2        CONTINUE
         NPATPL=2*NPATPL
      END IF
C
C     REFLECT ALONG X AXIS
C
      IF(IRX.NE.0)THEN
         DO 3 I=1,NPATPL
         K=I+NPATPL
         XPAT1(K)=-XPAT2(I)
         YPAT1(K)=YPAT2(I)
         ZPAT1(K)=ZPAT2(I)
         XPAT2(K)=-XPAT1(I)
         YPAT2(K)=YPAT1(I)
         ZPAT2(K)=ZPAT1(I)
         XPAT3(K)=-XPAT4(I)
         YPAT3(K)=YPAT4(I)
         ZPAT3(K)=ZPAT4(I)
         XPAT4(K)=-XPAT3(I)
         YPAT4(K)=YPAT3(I)
         ZPAT4(K)=ZPAT3(I)
3        CONTINUE
         NPATPL=2*NPATPL
      END IF
      RETURN
      END
      SUBROUTINE PMOVE (ROX,ROY,ROZ,XS,YS,ZS,NRPT)
C
C     SUBROUTINE PMOVE MOVES THE PATCH OUTLINES AS IS DONE BY SUBROUTINE
C     MOVE.
C
      INCLUDE 'NECPAR.INC'
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      DATA TA/0.01745329252/
      SPS=SIN(ROX*TA)
      CPS=COS(ROX*TA)
      STH=SIN(ROY*TA)
      CTH=COS(ROY*TA)
      SPH=SIN(ROZ*TA)
      CPH=COS(ROZ*TA)
      XX=CPH*CTH
      XY=CPH*STH*SPS-SPH*CPS
      XZ=CPH*STH*CPS+SPH*SPS
      YX=SPH*CTH
      YY=SPH*STH*SPS+CPH*CPS
      YZ=SPH*STH*CPS-CPH*SPS
      ZX=-STH
      ZY=CTH*SPS
      ZZ=CTH*CPS
      IF (NRPT.EQ.0)THEN
         NRP=1
         NPATS=0
      ELSE
         NRP=NRPT
         NPATS=NPATPL
      END IF
      I1=1
      DO 2 IR=1,NRP
      I1=I1+NPATS
      NPATPL=NPATPL+NPATS
      DO 1 K=I1,NPATPL
      I=K-NPATS
      XI=XPAT1(I)
      YI=YPAT1(I)
      ZI=ZPAT1(I)
      XPAT1(K)=XI*XX+YI*XY+ZI*XZ+XS
      YPAT1(K)=XI*YX+YI*YY+ZI*YZ+YS
      ZPAT1(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
      XI=XPAT2(I)
      YI=YPAT2(I)
      ZI=ZPAT2(I)
      XPAT2(K)=XI*XX+YI*XY+ZI*XZ+XS
      YPAT2(K)=XI*YX+YI*YY+ZI*YZ+YS
      ZPAT2(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
      XI=XPAT3(I)
      YI=YPAT3(I)
      ZI=ZPAT3(I)
      XPAT3(K)=XI*XX+YI*XY+ZI*XZ+XS
      YPAT3(K)=XI*YX+YI*YY+ZI*YZ+YS
      ZPAT3(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
      XI=XPAT4(I)
      YI=YPAT4(I)
      ZI=ZPAT4(I)
      XPAT4(K)=XI*XX+YI*XY+ZI*XZ+XS
      YPAT4(K)=XI*YX+YI*YY+ZI*YZ+YS
      ZPAT4(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
1     CONTINUE
2     CONTINUE
      RETURN
      END
      SUBROUTINE PROTAT(IRZ)
C
C     REFLC REFLECTS PARTIAL STRUCTURE ALONG X,Y, OR Z AXES OR ROTATES
C     STRUCTURE TO COMPLETE A SYMMETRIC STRUCTURE.
C
      INCLUDE 'NECPAR.INC'
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
C
C     REPRODUCE STRUCTURE WITH ROTATION TO FORM CYLINDRICAL STRUCTURE
C
      SAM=6.283185308/IRZ
      CS=COS(SAM)
      SS=SIN(SAM)
      NPATS=NPATPL
      NP1=1
      DO 1 IR=1,IRZ
      NP1=NP1+NPATS
      NPATPL=NPATPL+NPATS
      DO 1 I=NP1,NPATPL
      K=I-NPATS
      XSAV=XPAT1(K)
      XPAT1(I)=XSAV*CS-YPAT1(K)*SS
      YPAT1(I)=XSAV*SS+YPAT1(K)*CS
      ZPAT1(I)=ZPAT1(K)
      XSAV=XPAT2(K)
      XPAT2(I)=XSAV*CS-YPAT2(K)*SS
      YPAT2(I)=XSAV*SS+YPAT2(K)*CS
      ZPAT2(I)=ZPAT2(K)
      XSAV=XPAT3(K)
      XPAT3(I)=XSAV*CS-YPAT3(K)*SS
      YPAT3(I)=XSAV*SS+YPAT3(K)*CS
      ZPAT3(I)=ZPAT3(K)
      XSAV=XPAT4(K)
      XPAT4(I)=XSAV*CS-YPAT4(K)*SS
      YPAT4(I)=XSAV*SS+YPAT4(K)*CS
      ZPAT4(I)=ZPAT4(K)
1     CONTINUE
      RETURN
      END
      SUBROUTINE PSCALE(SCAFAC)
      INCLUDE 'NECPAR.INC'
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      DO 1 I=1,NPATPL
      XPAT1(I)=XPAT1(I)*SCAFAC
      YPAT1(I)=YPAT1(I)*SCAFAC
      ZPAT1(I)=ZPAT1(I)*SCAFAC
      XPAT2(I)=XPAT2(I)*SCAFAC
      YPAT2(I)=YPAT2(I)*SCAFAC
      ZPAT2(I)=ZPAT2(I)*SCAFAC
      XPAT3(I)=XPAT3(I)*SCAFAC
      YPAT3(I)=YPAT3(I)*SCAFAC
      ZPAT3(I)=ZPAT3(I)*SCAFAC
      XPAT4(I)=XPAT4(I)*SCAFAC
      YPAT4(I)=YPAT4(I)*SCAFAC
      ZPAT4(I)=ZPAT4(I)*SCAFAC
1     CONTINUE
      RETURN
      END
      SUBROUTINE PATSET(PCHAR,XSPAT1,YSPAT1,ZSPAT1,XSPAT2,YSPAT2,
     &   ZSPAT2,XSPAT3,YSPAT3,ZSPAT3,XSPAT4,YSPAT4,ZSPAT4,NS1,NS2)
      INCLUDE 'NECPAR.INC'
      CHARACTER PCHAR*1
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      IF(NS1.EQ.1.AND.NS2.EQ.1)THEN
         NPATPL=NPATPL+1
         XPAT1(NPATPL)=XSPAT1
         YPAT1(NPATPL)=YSPAT1
         ZPAT1(NPATPL)=ZSPAT1
         XPAT2(NPATPL)=XSPAT2
         YPAT2(NPATPL)=YSPAT2
         ZPAT2(NPATPL)=ZSPAT2
         XPAT3(NPATPL)=XSPAT3
         YPAT3(NPATPL)=YSPAT3
         ZPAT3(NPATPL)=ZSPAT3
         IF(PCHAR.EQ.'T')THEN
            XPAT4(NPATPL)=XSPAT3
            YPAT4(NPATPL)=YSPAT3
            ZPAT4(NPATPL)=ZSPAT3
         ELSE
            XPAT4(NPATPL)=XSPAT4
            YPAT4(NPATPL)=YSPAT4
            ZPAT4(NPATPL)=ZSPAT4
         END IF
         RETURN
      END IF
      V1X=(XSPAT2-XSPAT1)/NS1
      V1Y=(YSPAT2-YSPAT1)/NS1
      V1Z=(ZSPAT2-ZSPAT1)/NS1
      V2X=(XSPAT3-XSPAT2)/NS2
      V2Y=(YSPAT3-YSPAT2)/NS2
      V2Z=(ZSPAT3-ZSPAT2)/NS2
      XSP1=XSPAT1
      YSP1=YSPAT1
      ZSP1=ZSPAT1
      DO 1 I1=1,NS1
      IF(I1.GT.1)THEN
         XSP1=XSP1+V1X
         YSP1=YSP1+V1Y
         ZSP1=ZSP1+V1Z
      END IF
      XSP12=XSP1
      YSP12=YSP1
      ZSP12=ZSP1
      DO 1 I2=1,NS2
      IF(I2.GT.1)THEN
         XSP12=XSP12+V2X
         YSP12=YSP12+V2Y
         ZSP12=ZSP12+V2Z
      END IF
      NPATPL=NPATPL+1
      XPAT1(NPATPL)=XSP12
      YPAT1(NPATPL)=YSP12
      ZPAT1(NPATPL)=ZSP12
      XPAT2(NPATPL)=XSP12+V1X
      YPAT2(NPATPL)=YSP12+V1Y
      ZPAT2(NPATPL)=ZSP12+V1Z
      XPAT3(NPATPL)=XSP12+V1X+V2X
      YPAT3(NPATPL)=YSP12+V1Y+V2Y
      ZPAT3(NPATPL)=ZSP12+V1Z+V2Z
      XPAT4(NPATPL)=XSP12+V2X
      YPAT4(NPATPL)=YSP12+V2Y
      ZPAT4(NPATPL)=ZSP12+V2Z
1     CONTINUE
      RETURN
      END
      SUBROUTINE DATCON
C
C     DATCON CONVERTS SEGMENT DATA FROM CENTER, LENGTH AND DIRECTION
C     TO END COORDINATES
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/SEGD/NDAT,X1(MAXSEG),Y1(MAXSEG),Z1(MAXSEG),X2(MAXSEG),
     &Y2(MAXSEG),Z2(MAXSEG)
      NDAT=N
      DO 1 I=1,N
      DL=.5*SI(I)
      X1(I)=X(I)-ALP(I)*DL
      Y1(I)=Y(I)-BET(I)*DL
      Z1(I)=Z(I)-SALP(I)*DL
      X2(I)=X(I)+ALP(I)*DL
      Y2(I)=Y(I)+BET(I)*DL
1     Z2(I)=Z(I)+SALP(I)*DL
      RETURN
      END
      SUBROUTINE PQVECT(THETD,PHID,ETAD)
C
C     PQVECT COMPUTES THE X,Y,Z COMPONENTS OF 2 ORTHOGONAL UNIT VECTORS
C     (P AND Q) IN THE PROJECTION PLANE.  THESE BECOME THE X AND Y AXES
C     IN THE PROJECTION PLOT.    (VECTOR P) X (VECTOR Q) = (VECTOR W)
C
      CHARACTER*80 INFILE
      COMMON/PQWCOM/PX,PY,PZ,QX,QY,QZ,WX,WY,WZ
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      DATA TA/.01745329252/
      VTHET=THETD
      VPHI=PHID
      VETA=ETAD
      THET=THETD*TA
      PHI=PHID*TA
      ET=(ETAD+90.)*TA
      STH=SIN(THET)
      CTH=COS(THET)
      SPH=SIN(PHI)
      CPH=COS(PHI)
      SET=SIN(ET)
      CET=COS(ET)
      PX=(CTH*CPH*CET-SPH*SET)
      PY=(CTH*SPH*CET+CPH*SET)
      PZ=-STH*CET
      WX=STH*CPH
      WY=STH*SPH
      WZ=CTH
      QX=-(PY*WZ-PZ*WY)
      QY=-(PZ*WX-PX*WZ)
      QZ=-(PX*WY-PY*WX)
      RETURN
      END
      SUBROUTINE PROJCT
C
C     PROJCT COMPUTES THE COORDINATES OF THE SEGMENT ENDS IN THE
C     PROJECTION PLANE
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
      COMMON/SEGD/NDAT,X1(MAXSEG),Y1(MAXSEG),Z1(MAXSEG),X2(MAXSEG),
     &Y2(MAXSEG),Z2(MAXSEG)
      COMMON/PATDAT/NPAT,XPAT(MAXSEG),YPAT(MAXSEG),ZPAT(MAXSEG),
     &PNX(MAXSEG),PNY(MAXSEG),PNZ(MAXSEG),APAT(MAXSEG),PCURXR(MAXSEG),
     &PCURXI(MAXSEG),PCURYR(MAXSEG),PCURYI(MAXSEG),PCURZR(MAXSEG),
     &PCURZI(MAXSEG)
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      COMMON/PLOTB/NPATPX,XPLT1(MAXSEG),YPLT1(MAXSEG),XPLT2(MAXSEG),
     &YPLT2(MAXSEG),XPLT3(MAXSEG),YPLT3(MAXSEG),XPLT4(MAXSEG),
     &YPLT4(MAXSEG)
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/PQWCOM/PX,PY,PZ,QX,QY,QZ,WX,WY,WZ
      NPT=NDAT
      XMIN=1.E10
      YMIN=1.E10
      XMAX=-1.E10
      YMAX=-1.E10
      DO 2 I=1,NDAT
      XP1(I)=PX*X1(I)+PY*Y1(I)+PZ*Z1(I)
      YP1(I)=QX*X1(I)+QY*Y1(I)+QZ*Z1(I)
      XP2(I)=PX*X2(I)+PY*Y2(I)+PZ*Z2(I)
      YP2(I)=QX*X2(I)+QY*Y2(I)+QZ*Z2(I)
      IF(XP1(I).GT.XMAX)XMAX=XP1(I)
      IF(XP2(I).GT.XMAX)XMAX=XP2(I)
      IF(XP1(I).LT.XMIN)XMIN=XP1(I)
      IF(XP2(I).LT.XMIN)XMIN=XP2(I)
      IF(YP1(I).GT.YMAX)YMAX=YP1(I)
      IF(YP2(I).GT.YMAX)YMAX=YP2(I)
      IF(YP1(I).LT.YMIN)YMIN=YP1(I)
      IF(YP2(I).LT.YMIN)YMIN=YP2(I)
2     CONTINUE
      NPATPX=NPATPL
      DO 3 I=1,NPATPL
      XPLT1(I)=PX*XPAT1(I)+PY*YPAT1(I)+PZ*ZPAT1(I)
      YPLT1(I)=QX*XPAT1(I)+QY*YPAT1(I)+QZ*ZPAT1(I)
      XPLT2(I)=PX*XPAT2(I)+PY*YPAT2(I)+PZ*ZPAT2(I)
      YPLT2(I)=QX*XPAT2(I)+QY*YPAT2(I)+QZ*ZPAT2(I)
      XPLT3(I)=PX*XPAT3(I)+PY*YPAT3(I)+PZ*ZPAT3(I)
      YPLT3(I)=QX*XPAT3(I)+QY*YPAT3(I)+QZ*ZPAT3(I)
      XPLT4(I)=PX*XPAT4(I)+PY*YPAT4(I)+PZ*ZPAT4(I)
      YPLT4(I)=QX*XPAT4(I)+QY*YPAT4(I)+QZ*ZPAT4(I)
      IF(XPLT1(I).GT.XMAX)XMAX=XPLT1(I)
      IF(XPLT1(I).LT.XMIN)XMIN=XPLT1(I)
      IF(YPLT1(I).GT.YMAX)YMAX=YPLT1(I)
      IF(YPLT1(I).LT.YMIN)YMIN=YPLT1(I)
      IF(XPLT2(I).GT.XMAX)XMAX=XPLT2(I)
      IF(XPLT2(I).LT.XMIN)XMIN=XPLT2(I)
      IF(YPLT2(I).GT.YMAX)YMAX=YPLT2(I)
      IF(YPLT2(I).LT.YMIN)YMIN=YPLT2(I)
      IF(XPLT3(I).GT.XMAX)XMAX=XPLT3(I)
      IF(XPLT3(I).LT.XMIN)XMIN=XPLT3(I)
      IF(YPLT3(I).GT.YMAX)YMAX=YPLT3(I)
      IF(YPLT3(I).LT.YMIN)YMIN=YPLT3(I)
      IF(XPLT4(I).GT.XMAX)XMAX=XPLT4(I)
      IF(XPLT4(I).LT.XMIN)XMIN=XPLT4(I)
      IF(YPLT4(I).GT.YMAX)YMAX=YPLT4(I)
      IF(YPLT4(I).LT.YMIN)YMIN=YPLT4(I)
3     CONTINUE
      DO 4 I=1,NPAT
      XPATCN=PX*XPAT(I)+PY*YPAT(I)+PZ*ZPAT(I)
      YPATCN=QX*XPAT(I)+QY*YPAT(I)+QZ*ZPAT(I)
      IF(XPATCN.GT.XMAX)XMAX=XPATCN
      IF(XPATCN.LT.XMIN)XMIN=XPATCN
      IF(YPATCN.GT.YMAX)YMAX=YPATCN
      IF(YPATCN.LT.YMIN)YMIN=YPATCN
4     CONTINUE
      XMAX=XMAX+0.05*(XMAX-XMIN)
      XMIN=XMIN-0.05*(XMAX-XMIN)
      YMAX=YMAX+0.05*(YMAX-YMIN)
      YMIN=YMIN-0.05*(YMAX-YMIN)
      RETURN
      END
      SUBROUTINE PLOTVU(IDEV)
C
C     PLOTVU DISPLAYS THE PLOT ON DEVICE NUMBER "IDEV"
C
      INCLUDE 'NECPAR.INC'
C      BYTE NPLOTL(8)
      INTEGER*1 NPLOTL(8)
      CHARACTER INFILE*80,NPLOTLC*8
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      COMMON/PQWCOM/PX,PY,PZ,QX,QY,QZ,WX,WY,WZ
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      COMMON/PLOTB/NPATPX,XPLT1(MAXSEG),YPLT1(MAXSEG),XPLT2(MAXSEG),
     &YPLT2(MAXSEG),XPLT3(MAXSEG),YPLT3(MAXSEG),XPLT4(MAXSEG),
     &YPLT4(MAXSEG)
      COMMON/CURR/CR(2*MAXSEG),CI(2*MAXSEG)
      EQUIVALENCE (NPLOTL,NPLOTLC)
      CALL DEVSEL(IDEV,4,IERR)
      IF(IERR.EQ.0)GO TO 10
      WRITE(*,90)IERR
90    FORMAT(' DEVSEL ERROR NO.',I6)
10    CALL BGNPLT
c
c     GSETLW sets the line width for the plot
c
      CALL GSETLW(.25)
      CALL SCLSET
      DO 1 I=1,NPT
      CALL SCALEN(XP1(I),YP1(I),XPL1,YPL1)
      CALL SCALEN(XP2(I),YP2(I),XPL2,YPL2)
      IF(IDOTEN.NE.0.AND.(ICON1(I).EQ.0.OR.ICON2(I).EQ.0))THEN
           CALL GSLTYP(3)
           IDASH=1
      END IF
      IF(I.EQ.1)GO TO 2
      XDIF=XPL1-XL1
      YDIF=YPL1-YL1
      RDIF=XDIF*XDIF+YDIF*YDIF
      XDIF=XPL2-XPL1
      YDIF=YPL2-YPL1
      DDIF=XDIF*XDIF+YDIF*YDIF
      IF(DDIF.LT.1.E-20)GO TO 2
      RDIF=RDIF/DDIF
      IF(RDIF.GT.1.E-6)GO TO 2
      CALL GSDRAW(XPL2,YPL2)
      GO TO 3
2     CALL GSMOVE(XPL1,YPL1)
      CALL GSDRAW(XPL2,YPL2)
3     XL1=XPL2
      YL1=YPL2
      IF(IDASH.NE.0)THEN
           CALL GSLTYP(1)
           IDASH=0
      END IF
1     CONTINUE
C
C     PLOT PATCH OUTLINES
C
      DO 4 I=1,NPATPL
C
C     PATCH SEEN FROM BACK?  CHECK VECTOR NORMAL TO THE PATCH 
C
      XVNOR=(YPAT3(I)-YPAT2(I))*(ZPAT1(I)-ZPAT2(I))-(ZPAT3(I)-ZPAT2(I))*
     &(YPAT1(I)-YPAT2(I))
      YVNOR=(ZPAT3(I)-ZPAT2(I))*(XPAT1(I)-XPAT2(I))-(XPAT3(I)-XPAT2(I))*
     &(ZPAT1(I)-ZPAT2(I))
      ZVNOR=(XPAT3(I)-XPAT2(I))*(YPAT1(I)-YPAT2(I))-(YPAT3(I)-YPAT2(I))*
     &(XPAT1(I)-XPAT2(I))
      IF(XVNOR*WX+YVNOR*WY+ZVNOR*WZ.LT.1.E-6)GO TO 4
C
C     PLOT PATCH
C
      XSP1=XPLT1(I)
      YSP1=YPLT1(I)
      XSP2=XPLT2(I)
      YSP2=YPLT2(I)
      XSP3=XPLT3(I)
      YSP3=YPLT3(I)
      XSP4=XPLT4(I)
      YSP4=YPLT4(I)
      CALL SCALEN(XSP1,YSP1,XSP1,YSP1)
      CALL SCALEN(XSP2,YSP2,XSP2,YSP2)
      CALL SCALEN(XSP3,YSP3,XSP3,YSP3)
      CALL SCALEN(XSP4,YSP4,XSP4,YSP4)
      CALL GSMOVE(XSP1,YSP1)
      CALL GSDRAW(XSP2,YSP2)
      CALL GSDRAW(XSP3,YSP3)
      CALL GSDRAW(XSP4,YSP4)
      CALL GSDRAW(XSP1,YSP1)
4     CONTINUE
      IF(IENDSY.EQ.1)CALL ENDSYM
      IF(IAROW.EQ.1)CALL AROWS(CR,CRIMAX)
      IF(IAROW.EQ.2)CALL AROWS(CI,CRIMAX)
C
C     WRITE PLOT NUMBER
C
      CHRSZ=GOODCS(.2*SCALZ)
      CALL GSSETC(CHRSZ,0.)
      WRITE(NPLOTLC,91)NPLOT
91    FORMAT('PLOT',I3)
      NPLOTL(8)=0
      CALL GSMOVE(XMN+.01*SCALZ,YMN+.01*SCALZ)
      CALL GSPSTR(NPLOTL)
      CALL ENDPLT
      CALL RLSDEV
      RETURN
      END
      SUBROUTINE AROWS(A,AMAX)
C
C     AROWS DRAWS ARROWS ON THE PROJECTED SEGMENTS TO SHOW CURRENT
C     A = CURRENT ARRAY (REAL OR IMAGINARY)
C     AMAX = MAXIMUM VALUE OF CURRENT FOR NORMALIZATION
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/SEGD/NDAT,X1(MAXSEG),Y1(MAXSEG),Z1(MAXSEG),X2(MAXSEG),
     &Y2(MAXSEG),Z2(MAXSEG)
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      DIMENSION AP(3),ST(3),A(1)
      DATA AP/.2,.4,.6/,ST/0.,.07,.14/,SI/.04/
      SI=SCAROW
      SCALA=SI*YPLEN*SCALZ
      DO 20 IA=1,3
      IF(IA.EQ.1)CALL GSCOLR(3,IERR)
      IF(IA.EQ.2)CALL GSCOLR(4,IERR)
      IF(IA.EQ.3)CALL GSCOLR(2,IERR)
      DO 10 IP=1,NDAT
      APT=A(IP)/AMAX
      AS=SIGN(1.,APT)
      AA=ABS(APT)
      IF(AA.LT.1.E-10)AA=1.E-10
      AL=ALOG10(AA)+4.-IA
      IF(AL.LE.0.)GO TO 10
      IF(AL.GT.1.)AL=1.
      XT=XP2(IP)-XP1(IP)
      YT=YP2(IP)-YP1(IP)
      EL=SQRT(XT*XT+YT*YT)
      IF(EL.LT.1.E-10)GO TO 10
      XT=AS*SCALA*XT/EL
      YT=AS*SCALA*YT/EL
      XP=-YT
      YP=XT
      XV=.5*(XP1(IP)+XP2(IP))
      YV=.5*(YP1(IP)+YP2(IP))
      XV=XV+XT*ST(IA)
      YV=YV+YT*ST(IA)
      XA1=XV-(XT-XP*AP(IA))*AL
      YA1=YV-(YT-YP*AP(IA))*AL
      XA2=XV-(XT+XP*AP(IA))*AL
      YA2=YV-(YT+YP*AP(IA))*AL
      CALL SCALEN(XV,YV,XV,YV)
      CALL SCALEN(XA1,YA1,XA1,YA1)
      CALL SCALEN(XA2,YA2,XA2,YA2)
      CALL GSMOVE(XV,YV)
      CALL GSDRAW(XA1,YA1)
      CALL GSMOVE(XV,YV)
      CALL GSDRAW(XA2,YA2)
10    CONTINUE
      CALL AROWP(IA)
20    CONTINUE
      CALL GSCOLR(1,IERR)
      RETURN
      END
      SUBROUTINE AROWP(IA)
C
C     AROWS DRAWS ARROWS ON THE PROJECTED PATCHES TO SHOW CURRENT
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      COMMON/PATDAT/NPAT,XPAT(MAXSEG),YPAT(MAXSEG),ZPAT(MAXSEG),
     &PNX(MAXSEG),PNY(MAXSEG),PNZ(MAXSEG),APAT(MAXSEG),PCURXR(MAXSEG),
     &PCURXI(MAXSEG),PCURYR(MAXSEG),PCURYI(MAXSEG),PCURZR(MAXSEG),
     &PCURZI(MAXSEG)
      COMMON/PQWCOM/PX,PY,PZ,QX,QY,QZ,WX,WY,WZ
      DIMENSION AP(3),ST(3)
      DATA AP/.2,.4,.6/,ST/0.,.07,.14/,SI/.04/
      SI=SCAROW
      SCALA=SI*YPLEN*SCALZ
      DO 10 IP=1,NPAT
      IF(WX*PNX(IP)+WY*PNY(IP)+WZ*PNZ(IP) .LT. 1.E-4)GO TO 10
      IF(IAROW.EQ.1)THEN
         APT=SQRT(PCURXR(IP)**2+PCURYR(IP)**2+PCURZR(IP)**2)
         DIRX=PCURXR(IP)/APT
         DIRY=PCURYR(IP)/APT
         DIRZ=PCURZR(IP)/APT
      ELSE
         APT=SQRT(PCURXI(IP)**2+PCURYI(IP)**2+PCURZI(IP)**2)
         DIRX=PCURXI(IP)/APT
         DIRY=PCURYI(IP)/APT
         DIRZ=PCURZI(IP)/APT
      END IF
      APT=APT*SQRT(APAT(IP))/CRIMAX
      AA=APT
      IF(AA.LT.1.E-10)AA=1.E-10
      AL=ALOG10(AA)+4.-IA
      IF(AL.LE.0.)GO TO 10
      IF(AL.GT.1.)AL=1.
      DNORX=PNY(IP)*DIRZ-PNZ(IP)*DIRY
      DNORY=PNZ(IP)*DIRX-PNX(IP)*DIRZ
      DNORZ=PNX(IP)*DIRY-PNY(IP)*DIRX
      XXV=XPAT(IP)+DIRX*ST(IA)*SCALA
      YYV=YPAT(IP)+DIRY*ST(IA)*SCALA
      ZZV=ZPAT(IP)+DIRZ*ST(IA)*SCALA
      AL=AL*SCALA
      XAR1=XXV-(DIRX+DNORX*AP(IA))*AL
      YAR1=YYV-(DIRY+DNORY*AP(IA))*AL
      ZAR1=ZZV-(DIRZ+DNORZ*AP(IA))*AL
      XAR2=XXV-(DIRX-DNORX*AP(IA))*AL
      YAR2=YYV-(DIRY-DNORY*AP(IA))*AL
      ZAR2=ZZV-(DIRZ-DNORZ*AP(IA))*AL
      XV=XXV*PX+YYV*PY+ZZV*PZ
      YV=XXV*QX+YYV*QY+ZZV*QZ
      XA1=XAR1*PX+YAR1*PY+ZAR1*PZ
      YA1=XAR1*QX+YAR1*QY+ZAR1*QZ
      XA2=XAR2*PX+YAR2*PY+ZAR2*PZ
      YA2=XAR2*QX+YAR2*QY+ZAR2*QZ
      CALL SCALEN(XV,YV,XV,YV)
      CALL SCALEN(XA1,YA1,XA1,YA1)
      CALL SCALEN(XA2,YA2,XA2,YA2)
      CALL GSMOVE(XV,YV)
      CALL GSDRAW(XA1,YA1)
      CALL GSMOVE(XV,YV)
      CALL GSDRAW(XA2,YA2)
10    CONTINUE
      RETURN
      END
      SUBROUTINE ENDSYM
C
C     ENDSYM DRAWS SYMBOLS ON THE ENDS OF SEGMENTS
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/SEGD/NDAT,X1(MAXSEG),Y1(MAXSEG),Z1(MAXSEG),X2(MAXSEG),
     &Y2(MAXSEG),Z2(MAXSEG)
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      DATA SLENC/.008/,SLENO/.02/
      SCALC=SLENC*YPLEN*SCALZ
      SCALO=SLENO*YPLEN*SCALZ
      DO 10 IP=1,NPT
      XDIR=XP2(IP)-XP1(IP)
      YDIR=YP2(IP)-YP1(IP)
      EL=SQRT(XDIR*XDIR+YDIR*YDIR)
      IF(EL.LT.1.E-10)GO TO 10
      IF(ICON1(IP).EQ.0)THEN
      CALL GSCOLR(2,IERR)
           XT=SCALO*XDIR/EL
           YT=SCALO*YDIR/EL
      ELSE
      CALL GSCOLR(1,IERR)
           XT=SCALC*XDIR/EL
           YT=SCALC*YDIR/EL
      END IF
      XP=-YT
      YP=XT
      XTIK1=XP1(IP)-XP
      XTIK2=XP1(IP)+XP
      YTIK1=YP1(IP)-YP
      YTIK2=YP1(IP)+YP
      CALL SCALEN(XTIK1,YTIK1,XTIK1,YTIK1)
      CALL SCALEN(XTIK2,YTIK2,XTIK2,YTIK2)
      CALL GSMOVE(XTIK1,YTIK1)
      CALL GSDRAW(XTIK2,YTIK2)
      IF(ICON2(IP).EQ.0)THEN
      CALL GSCOLR(2,IERR)
           XT=SCALO*XDIR/EL
           YT=SCALO*YDIR/EL
      ELSE
      CALL GSCOLR(1,IERR)
           XT=SCALC*XDIR/EL
           YT=SCALC*YDIR/EL
      END IF
      XP=-YT
      YP=XT
      XTIK1=XP2(IP)-XP
      XTIK2=XP2(IP)+XP
      YTIK1=YP2(IP)-YP
      YTIK2=YP2(IP)+YP
      CALL SCALEN(XTIK1,YTIK1,XTIK1,YTIK1)
      CALL SCALEN(XTIK2,YTIK2,XTIK2,YTIK2)
      CALL GSMOVE(XTIK1,YTIK1)
      CALL GSDRAW(XTIK2,YTIK2)
10    CONTINUE
      CALL GSCOLR(1,IERR)
      RETURN
      END
      SUBROUTINE SCALEN(X,Y,XP,YP)
C
C     SCALEN SCALES THE POINT (X,Y) TO THE PLOTTER COORDINATES (XP,YP)
C
      CHARACTER*80 INFILE
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      XP=(X-XCEN)*ZXFAC
      YP=(Y-YCEN)*ZXFAC
      RETURN
      END
      SUBROUTINE INITLP
C
C     INITLP SETS DEFAULT VALUES FOR PLOT
C     VIEWING ANGLES = (45.,45.,0.)  CENTER PLOT ON SCREEN, NO CURRENTS
C
      CHARACTER*80 INFILE
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      CALL PQVECT(45.,45.,0.)
      ZXFAC=1.
      ICSEG=0
      IENDSY=0
      IAROW=0
      IDOTEN=0
      SCALEF=1.
      SCAROW=.04
      NPLOT=1
      RETURN
      END
      SUBROUTINE SCLSET
C
C     SCLSET COMPUTES SCALE PARAMETERS FOR THE PLOT AND SETS THE WINDOW.
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/PLOTA/NPT,XP1(MAXSEG),YP1(MAXSEG),XP2(MAXSEG),YP2(MAXSEG),
     &XMIN,XMAX,YMIN,YMAX
      IF(ICSEG.GT.0)GO TO 3
C     XCEN YCEN TO CENTER PLOT ON SCREEN
      XCEN=.5*(XMIN+XMAX)
      YCEN=.5*(YMIN+YMAX)
      GO TO 4
C     XCEN,YCEN TO PUT SEGMENT ICSEG IN CENTER OF SCREEN
3     XCEN=.5*(XP1(ICSEG)+XP2(ICSEG))
      YCEN=.5*(YP1(ICSEG)+YP2(ICSEG))
4     XPLEN=GSXLCM()*SCALEF
      YPLEN=GSYLCM()*SCALEF
      XD=(XMAX-XMIN)*1.02
      YD=(YMAX-YMIN)*1.02
      IF(YD/YPLEN.GT.XD/XPLEN)GO TO 1
C     SCALE DETERMINED BY X DIMENSION
      IF(XD.LT.1.E-6)XD=1.E-6
      XMX=.5*XD
      XMN=-XMX
      YMX=XMX*YPLEN/XPLEN
      YMN=-YMX
      SCALZ=.5*XD/XPLEN
      GO TO 2
C     SCALE DETERMINED BY Y DIMENSION
1     IF(YD.LT.1.E-6)YD=1.E-6
      YMX=.5*YD
      YMN=-YMX
      XMX=YMX*XPLEN/YPLEN
      XMN=-XMX
      SCALZ=.5*YD/YPLEN
2     CALL GSWNDO(XMN,XMX,YMN,YMX,0.,0.,XPLEN,YPLEN)
      RETURN
      END
      SUBROUTINE SHOWP
C
C     SHOWP DISPLAYS THE LIST OF COMMANDS AND PRESENTLY SET PARAMETERS.
C
      INCLUDE 'NECPAR.INC'
      CHARACTER*80 INFILE
C      BYTE COM
      INTEGER*1 COM
      COMMON/PLTPRMN/XPLEN,YPLEN,SCALZ,VTHET,VPHI,VETA,XCEN,YCEN,ZXFAC,
     &CRMAX,CIMAX,CRIMAX,FRQMHZ,SCALEF,SCAROW,XMN,YMN,ICSEG,ICURNT,
     &IENDSY,IAROW,INFIO,IDOTEN,NPLOT,INFILE
      COMMON/SEGD/NDAT,X1(MAXSEG),Y1(MAXSEG),Z1(MAXSEG),X2(MAXSEG),
     &Y2(MAXSEG),Z2(MAXSEG)
      COMMON/COMTXT/KCOM,COM(5,81)
      CALL CLEARS
      WRITE(*,90)
90    FORMAT(' COMMANDS - -',/,
     &' VA thet,phi,eta: VIEWING ANGLES',15X,'ZX f: ZOOM BY FACTOR f',/,
     &' SC i: CENTER ON SEGMENT i',21X,'DV: SET GRAPHICS DEVICE',/,
     &' PT: DISPLAY PLOT ON TERMINAL',18X,'SE: MARK SEGMENT ENDS',/,
     &' PL: SEND PLOT TO LASER PRINTER',16X,'FE: SHOW FREE ENDS',/,
     &' NF: READ NEW INPUT FILE',23X,'EX: EXIT',/,
     &' RF: CONTINUE READING INPUT FILE',15X,'SH: SHOW COMMANDS',/
     &' SP f1,f2: SCALE PLOT AND ARROWS BY f1, SCALE ARROWS ONLY BY f2')
      IF(ICURNT.EQ.1)WRITE(*,91)
91    FORMAT(' AR: DISPLAY ARROWS FOR REAL PART OF CURRENT',/,
     &' AI: DISPLAY ARROWS FOR IMAGINARY PART OF CURRENT')
      WRITE(*,900)VTHET,VPHI,VETA
      WRITE(*,901)ICSEG,ZXFAC
      IF(IAROW.EQ.1)WRITE(*,902)
      IF(IAROW.EQ.2)WRITE(*,903)
      IF(IAROW.GT.0)WRITE(*,92)CRIMAX
      WRITE(*,904)INFILE
      WRITE(*,905)NDAT
      IF(FRQMHZ.GT.0.)WRITE(*,906)FRQMHZ
      DO 1 I=1,KCOM
1     WRITE(*,907)(COM(I,J),J=1,79)
900   FORMAT(/,' VA: ',3F10.3)
901   FORMAT(' SC: ',I5,10X,'ZX: ',F8.2)
902   FORMAT(' CURRENT ARROWS: REAL')
903   FORMAT(' CURRENT ARROWS: IMAGINARY')
92    FORMAT(' CURRENT NORMALIZATION FACTOR = ',1P,E12.5)
904   FORMAT(/,' FILE: ',A)
905   FORMAT(' NUMBER OF SEGMENTS = ',I6)
906   FORMAT(' FREQUENCY = ',1P,E12.5,' MHZ')
907   FORMAT(1X,79A1)
      RETURN
      END
      SUBROUTINE GETDEV(IDEV)
C      BYTE BNAME(40)
      INTEGER*1 BNAME(40)
      IDEV = 1
1     CALL GSDNAM(IDEV,BNAME)
      L=LENB(BNAME)
      IF(L.GT.0)THEN
           WRITE(*,90)IDEV,(BNAME(I),I=1,L)
90         FORMAT(' Device ',I2,' is ',40A1)
           IDEV=IDEV+1
           GO TO 1
      END IF
5     WRITE(*,91)
91    FORMAT(' Number of the graphics device to use? ',$)
      READ(*,92,ERR=5)IDEV
92    FORMAT(I5)
      RETURN
      END
      SUBROUTINE CLEARS
C
C     CLEARS CLEARS THE SCREEN OF A DEC VT100 TERMINAL
C
      USE MSFLIB
C      BYTE GS,FF,ESC,GG,Q,Z
C      CHARACTER*1 CGS,CFF,CESC,CQ,CZ,CGG
C      EQUIVALENCE (CGS,GS),(CFF,FF),(CESC,ESC),(CQ,Q),(CZ,Z),(CGG,GG)
C      DATA GS/29/,FF/12/,ESC/27/,Q/34/,Z/48/,GG/103/
Cc      CLOSE(6)
C      WRITE(*,90) CGS,CESC,CFF,CESC,CQ,CZ,CGG
Cc90    FORMAT('+',A1,$)
C90    FORMAT(7A1,$)
Cc      CLOSE(6)
C
C     MACINTOSH:
C      CALL GDMACSE(2,XA,YA)
C
C     Windows 95
      CALL CLEARSCREEN($GCLEARSCREEN)
      RETURN
      END
      SUBROUTINE ERROR
C     VAX:
C      IMPLICIT INTEGER (A-Z)
C      CHARACTER MSG*80
C      CALL ERRSNS(FNUM,RMSSTS,RMSSTV,IUNIT,CONDVAL)
C      CALL SYS$GETMSG(%VAL(RMSSTS),MSGLEN,MSG,,,)
C      CALL STR$UPCASE(MSG,MSG)
C      IND=INDEX(MSG,',')
C      WRITE(*,1)MSG(IND+2:MSGLEN)
C1     FORMAT(//,'  ****  ERROR  ****   ',//,5X,A,//)
      WRITE(*,*)' INPUT ERROR'
      RETURN
      END
      FUNCTION ATGN2 (X,Y)
C
C     ATGN2 is arctangent function modified to return 0. when X=Y=0.
C
      IF (X) 3,1,3
1     IF (Y) 3,2,3
2     ATGN2=0.
      RETURN
3     ATGN2=ATAN2(X,Y)
      RETURN
      END
      SUBROUTINE COMOUT(RECDAT,ICMBLK)
C
C     Purpose:
C     COMOUT prints text lines from the input file for title and
C     information.  The first 4 lines and the last line are saved.
C
C     INPUT:
C     RECDAT = CHARACTER STRING TO BE PRINTED
C     ICMBLK = 0 TO START A TEXT BLOCK, 1 TO CONTINUE A TEXT BLOCK
C              OR 2 TO PRINT THE TERMINATING BORDER.
C
      CHARACTER RECDAT*78,COMIN*78,INFILE*80,OUTFILE*80
      COMMON/NINFO/KCOM,COMIN(5),INFILE,OUTFILE
      IF(ICMBLK.EQ.2)THEN
C         WRITE(*,90)
         ICMBLK=0
         RETURN
      ELSE IF(ICMBLK.EQ.0)THEN
C         WRITE(*,91)
         ICMBLK=1
      END IF
      KCOM=KCOM+1
      IF (KCOM.GT.5) KCOM=5
      COMIN(KCOM)=RECDAT
C      WRITE(*,92) RECDAT
      RETURN
C
90    FORMAT(/,22X,58('*'),//)
91    FORMAT(//,22X,58('*'),/)
92    FORMAT (25X,A)
      END
      SUBROUTINE GFIL (IPRT,FILNAM)
C
C     GFIL reads the N.G.F. file written by a previous solution.
C
      INCLUDE 'NECPAR.INC'
      CHARACTER NGFFIL*80,FILNAM*(*)
      COMPLEX ZARRAY,CEINS
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/ZLOAD/ ZARRAY(MAXSEG),NLOAD,NLODF,LDTYP(LOADMX),
     &LDTAG(LOADMX),LDTAGF(LOADMX),LDTAGT(LOADMX),ZLR(LOADMX),
     &ZLI(LOADMX),ZLC(LOADMX)
      COMMON/INSCOM/CEINS(MAXSEG),BRINS(MAXSEG),NINS,NINSF,INTAG(MAXIS),
     &INTAGF(MAXIS),INTAGT(MAXIS),EPSIN(MAXIS),SIGIN(MAXIS),RADIN(MAXIS)
      DATA IGFL/20/
      NGFFIL=FILNAM
      IF(FILNAM.EQ.'')NGFFIL='NGFS.NEC'
      OPEN(UNIT=IGFL,FILE=NGFFIL,FORM='UNFORMATTED',STATUS='OLD')
      REWIND IGFL
      READ (IGFL) N1,NP,M1,MP,FMHZS,IPSYM,KSYMP,IPERF,NRADL,GEPS,GSIG,
     &UEPS,USIG,SCNRAD,SCNWRD,NLODF,NINSF,KCOM
      N=N1
      M=M1
      N2=N1+1
      M2=M1+1
      IF (N1.GT.0)THEN
C
C        READ SEG. DATA AND CONVERT BACK TO END COORD.
         READ (IGFL) (X(I),I=1,N1),(Y(I),I=1,N1),(Z(I),I=1,N1)
         READ (IGFL) (SI(I),I=1,N1),(BI(I),I=1,N1),(ALP(I),I=1,N1)
         READ (IGFL) (BET(I),I=1,N1),(SALP(I),I=1,N1)
         READ (IGFL) (ICON1(I),I=1,N1),(ICON2(I),I=1,N1)
         READ (IGFL) (ITAG(I),I=1,N1)
         IF (NLODF.NE.0) READ (IGFL) (ZARRAY(I),I=1,N1)
         IF (NINSF.NE.0) READ (IGFL) (CEINS(I),BRINS(I),I=1,N1)
         DO 1 I=1,N1
         XI=X(I)
         YI=Y(I)
         ZI=Z(I)
         DX=SI(I)*.5
         X(I)=XI-ALP(I)*DX
         Y(I)=YI-BET(I)*DX
         Z(I)=ZI-SALP(I)*DX
         SI(I)=XI+ALP(I)*DX
         ALP(I)=YI+BET(I)*DX
         BET(I)=ZI+SALP(I)*DX
1        CONTINUE
      END IF
      IF (M1.GT.0)THEN
         J=LD-M1+1
C
C        READ PATCH DATA
         READ (IGFL) (X(I),I=J,LD),(Y(I),I=J,LD),(Z(I),I=J,LD)
         READ (IGFL) (SI(I),I=J,LD),(BI(I),I=J,LD),(ALP(I),I=J,LD)
         READ (IGFL) (BET(I),I=J,LD),(SALP(I),I=J,LD)
         READ (IGFL) (T2X(I),I=J,LD),(T2Y(I),I=J,LD)
         READ (IGFL) (T2Z(I),I=J,LD)
      END IF
      RETURN
C
14    FORMAT (5X,'**************************************************',
     &'**********************************')
15    FORMAT (5X,'** ',A,' **')
16    FORMAT (////)
17    FORMAT (5X,'**',80X,'**')
18    FORMAT (5X,'** NUMERICAL GREEN''S FUNCTION FILE ',A,'**',/,5X,
     &'** NO. SEGMENTS =',I4,10X,'NO. PATCHES =',I4,34X,'**')
19    FORMAT (5X,'** NO. SYMMETRIC SECTIONS =',I4,51X,'**')
20    FORMAT (5X,'** N.G.F. MATRIX -  CORE STORAGE =',I7,
     &' COMPLEX NUMBERS,  CASE',I2,16X,'**')
21    FORMAT (5X,'**',19X,'MATRIX SIZE =',I7,' COMPLEX NUMBERS',25X,'**'
     &)
22    FORMAT (5X,'** FREQUENCY =',1PE12.5,' MHZ.',51X,'**')
23    FORMAT (5X,'** PERFECT GROUND',65X,'**')
24    FORMAT (5X,'** GROUND PARAMETERS - DIELECTRIC CONSTANT =',
     &1PE12.5,26X,'**',/,5X,'**',21X,'CONDUCTIVITY =',E12.5,' MHOS/M.',
     &25X,'**')
25    FORMAT (39X,'NUMERICAL GREEN''S FUNCTION DATA',/,41X,'COORDINAT',
     &'ES OF SEGMENT ENDS',/,51X,'(METERS)',/,5X,'SEG.',11X,
     &'- - - END ONE - - -',26X,'- - - END TWO - - -',/,6X,'NO.',6X,'X',
     &14X,'Y',14X,'Z',14X,'X',14X,'Y',14X,'Z')
26    FORMAT (1X,I7,1P6E15.6)
27    FORMAT (5X,'** FINITE GROUND.  REFLECTION COEFFICIENT APPROXIMATIO
     &N',27X,'**')
28    FORMAT (5X,'** FINITE GROUND.  SOMMERFELD SOLUTION',44X,'**')
      END
      SUBROUTINE CATNRY(XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,ICT,RHMP,ZMP,NS,ITG)
C
C     Purpose:
C     CATNRY generates segment geometry data for a wire with NS segments
C     in the shape of a catenary.
C
C     INPUT:
C     XW1,YW1,ZW1 = starting point of the catenary
C     XW2,YW2,ZW2 = final point of the catenary
C     RAD = wire radius
C     ICT = flag to set method of determining the catenary shape
C     RHMP = horizontal distance from (XW1,YW1,ZW1) to a point along
C            the catenary for ICT=1 or 2; catenary length for ICT=3.
C     ZMP = height of the catenary at the distance RHMP for ICT=1 or 2.
C     NS = number of segments along the catenary
C     ITG = tag number for segments
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION X2(1), Y2(1), Z2(1)
      EQUIVALENCE (X2(1),SI(1)), (Y2(1),ALP(1)), (Z2(1),BET(1))
      IST=N+1
      N=N+NS
      NP=N
      MP=M
      IPSYM=0
      IF (NS.LT.1) RETURN
      X(IST)=XW1
      Y(IST)=YW1
      Z(IST)=ZW1
      BI(IST)=RAD
      ITAG(IST)=ITG
      X2(N)=XW2
      Y2(N)=YW2
      Z2(N)=ZW2
      XD=XW2-XW1
      YD=YW2-YW1
      ZD=ZW2-ZW1
      RHD=SQRT(XD**2+YD**2)
      IF(RHD.LT.1.E-20)THEN
         WRITE(*,90)
         STOP
      END IF
      XD=XD/RHD
      YD=YD/RHD
      IF(ICT.EQ.1)THEN
         ZHGT=ZMP-ZW1
      ELSE IF(ICT.EQ.2)THEN
         ZHGT=ZD*RHMP/RHD-ZMP
      END IF
      CALL CATSOL(RHD,ZD,RHMP,ZHGT,C1,RH,ICT-2)
      CALL CATEXP(RHD,RH,EX2,EXRP,EXRM,EXRS)
      CLEN=.5*(EXRP*C1-EXRM/C1)
      CSEGL=CLEN/NS
      CFAC=.5*(C1-1./C1)
      CLENX=0.
      XLENX=0.
      SLEN=0.
      IST=IST+1
      DO 1 I=IST,N
      IF(RH.GT.1.E-20)THEN
         CLENX=CLENX+CSEGL
         AA=RH*CLENX+CFAC
         XLENX=ALOG((AA+SQRT(AA**2+1.))/C1)/RH
      ELSE
         XLENX=XLENX+RHD/NS
      END IF
      CALL CATEXP(XLENX,RH,EX2,EXRP,EXRM,EXRS)
      X(I)=XW1+XLENX*XD
      Y(I)=YW1+XLENX*YD
      Z(I)=ZW1+.5*(EXRP*C1+EXRM/C1)
      BI(I)=RAD
      ITAG(I)=ITG
      X2(I-1)=X(I)
      Y2(I-1)=Y(I)
      Z2(I-1)=Z(I)
      SLEN=SLEN+SQRT((X2(I-1)-X(I-1))**2+(Y2(I-1)-Y(I-1))**2+(Z2(I-1)-
     &Z(I-1))**2)
1     CONTINUE
      SLEN=SLEN+SQRT((X2(N)-X(N))**2+(Y2(N)-Y(N))**2+(Z2(N)-Z(N))**2)
C      WRITE(*,91)CLEN,SLEN
      RETURN
C
90    FORMAT(' CATNRY: ERROR - INCORRECT PARAMETERS RECEIVED')
91    FORMAT(10X,'Catenary length =',1PE12.5,4X,
     &'Total segment length =',E12.5)
      END
      SUBROUTINE CATEXP(X,RH,EXR,EXRP,EXRM,EXRS)
C
C     CATEXP evaluates exponential terms for a catenary
C
      XR=X*RH
      EXR=EXP(XR)
      IF(ABS(XR).GT.0.1)THEN
         EXRP=(EXR-1.)/RH
         EXRM=(1./EXR-1.)/RH
         EXRS=(EXRM+EXRP)/RH
      ELSE
         EXRP=X*((((8.333333E-3*XR+.04166667)*XR+.1666667)*XR+.5)*XR+1.)
         EXRM=X*((((-8.333333E-3*XR+.04166667)*XR-.1666667)*XR+.5)*XR-
     &1.)
         EXRS=X**2*(1.+.08333333*XR**2)
      END IF
      RETURN
      END
      SUBROUTINE CATSOL(X2,Y2,XMX,YMX,C1,RH,ICAT)
C
C     CATSOL solves for the constants C1 and RH for a catenary
C     Y=((EXP(RH*X)-1.)*C1 + (EXP(-RH*X)-1.)/C1)/(2.*RH).  The catenary
C     passes through the points (0,0) and (X2,Y2).  For ICAT=0 the
C     the catenary passes through the point (XMX,YMX).  For ICAT=1 the
C     XMX is the total length of the catenary.
C
C     OUTPUT: C1, RH = constants for the catenary.
C
      DATA MAXITR/51/
      IF(ICAT.EQ.1)THEN
         XM=X2
         YM=XMX
         IF(YM.LE.SQRT(X2**2+Y2**2))THEN
            RH=0.
            C1=(Y2+SQRT(X2**2+Y2**2))/X2
            RETURN
         END IF
      ELSE
         XM=XMX
         YM=YMX
      END IF
      RH=1./X2
      RHDIF=1.
      DO 1 I=1,MAXITR
      CALL CATEXP(X2,RH,EXRX,EXRP,EXRM,EXRS)
      SQFAC=SQRT(Y2**2+EXRS)
      IF(X2.LT.0.)SQFAC=-SQFAC
      C1=(Y2+SQFAC)/EXRP
C
C     EXIT IF ITERATION HAS CONVERGED OR LIMIT HAS BEEN REACHED.
C
      IF(ABS(RHDIF/RH).LT.1.E-5)GO TO 2
      IF(I.GE.MAXITR)THEN
         WRITE(*,90)
         GO TO 2
      END IF
C
      CP=(Y2+.5*(X2*(EXRP-EXRM)+2.*Y2**2)/SQFAC)/EXRP - X2*EXRX*(Y2+
     &SQFAC)/EXRP**2
      IF(ICAT.EQ.1)THEN
         EXRM=-EXRM
         RXRX=-1./EXRX
      ELSE
         CALL CATEXP(XM,RH,EXRX,EXRP,EXRM,EXRS)
         RXRX=1./EXRX
      END IF
      YF=.5*(EXRP*C1+EXRM/C1)
      DYF=(-YF+.5*(XM*(EXRX*C1-RXRX/C1)+CP*(EXRP-EXRM/C1**2)))/RH
      RHDIF=(YF-YM)/DYF
      RH=RH-RHDIF
      IF(RH*X2.GT.50.)RH=50./X2
1     CONTINUE
2     RETURN
C
90    FORMAT(' CATSOL: SOLUTION DID NOT CONVERGE')
      END
      SUBROUTINE ARCNEC (ITG,NS,RADA,ANG1,ANG2,RAD)
C
C     ARCNEC generates segment geometry data for an arc of NS segments.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION X2(1), Y2(1), Z2(1)
      EQUIVALENCE (X2,SI), (Y2,ALP), (Z2,BET)
      DATA TA/.01745329252/
      IST=N+1
      N=N+NS
      NP=N
      MP=M
      IPSYM=0
      IF (NS.LT.1) RETURN
      IF (ABS(ANG2-ANG1).LT.360.00001) GO TO 1
      WRITE(*,3)
      STOP
1     ANG=ANG1*TA
      DANG=(ANG2-ANG1)*TA/NS
      XS1=RADA*COS(ANG)
      ZS1=RADA*SIN(ANG)
      DO 2 I=IST,N
      ANG=ANG+DANG
      XS2=RADA*COS(ANG)
      ZS2=RADA*SIN(ANG)
      X(I)=XS1
      Y(I)=0.
      Z(I)=ZS1
      X2(I)=XS2
      Y2(I)=0.
      Z2(I)=ZS2
      XS1=XS2
      ZS1=ZS2
      BI(I)=RAD
2     ITAG(I)=ITG
      RETURN
C
3     FORMAT (' ARCNEC: ERROR - ARC ANGLE EXCEEDS 360. DEGREES')
      END
      SUBROUTINE CONECT (IGND,ICHK)
C
C     CONECT sets up segment connection data in arrays ICON1 and ICON2
C     by searching for segment ends that are in contact.
C
      INCLUDE 'NECPAR.INC'
      COMPLEX AX,BX,CX
	CHARACTER CRIN*1
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON /SEGJ/ AX(NSJMAX),BX(NSJMAX),CX(NSJMAX),JCO(NSJMAX),JSNO,
     &ISCON(NSCNGF),NSCON,IPCON(NSPNGF),NPCON
      DIMENSION X2(1), Y2(1), Z2(1)
      EQUIVALENCE (X2,SI), (Y2,ALP), (Z2,BET)
      DATA SMIN/1.E-3/
      NSCON=0
      NPCON=0
      IF (IGND.EQ.0) GO TO 3
C      WRITE(*,54)
C      IF (IGND.GT.0) WRITE(*,55)
      IF (IPSYM.NE.2) GO TO 1
      NP=2*NP
      MP=2*MP
1     IF (IABS(IPSYM).LE.2) GO TO 2
      NP=N
      MP=M
2     IF (NP.GT.N) STOP
      IF (NP.EQ.N.AND.MP.EQ.M) IPSYM=0
3     IF (N.EQ.0) GO TO 26
      DO 15 I=1,N
      ICONX(I)=0
      XI1=X(I)
      YI1=Y(I)
      ZI1=Z(I)
      XI2=X2(I)
      YI2=Y2(I)
      ZI2=Z2(I)
      SLEN=SQRT((XI2-XI1)**2+(YI2-YI1)**2+(ZI2-ZI1)**2)*SMIN
C
C     DETERMINE CONNECTION DATA FOR END 1 OF SEGMENT.
C
      IF (IGND.LT.1) GO TO 5
      IF (ZI1.GT.-SLEN) GO TO 4
      WRITE(*,56) I
      STOP
4     IF (ZI1.GT.SLEN) GO TO 5
      ICON1(I)=I
      Z(I)=0.
      GO TO 9
5     IC=I
      DO 7 J=2,N
      IC=IC+1
      IF (IC.GT.N) IC=1
      SEP=ABS(XI1-X(IC))+ABS(YI1-Y(IC))+ABS(ZI1-Z(IC))
      IF (SEP.GT.SLEN) GO TO 6
      ICON1(I)=-IC
      GO TO 8
6     SEP=ABS(XI1-X2(IC))+ABS(YI1-Y2(IC))+ABS(ZI1-Z2(IC))
      IF (SEP.GT.SLEN) GO TO 7
      ICON1(I)=IC
      GO TO 8
7     CONTINUE
      IF (I.LT.N2.AND.ICON1(I).GT.10000) GO TO 8
      ICON1(I)=0
C
C     DETERMINE CONNECTION DATA FOR END 2 OF SEGMENT.
C
8     IF (IGND.LT.1) GO TO 12
9     IF (ZI2.GT.-SLEN) GO TO 10
      WRITE(*,56) I
      STOP
10    IF (ZI2.GT.SLEN) GO TO 12
      IF (ICON1(I).NE.I) GO TO 11
      WRITE(*,57) I
      STOP
11    ICON2(I)=I
      Z2(I)=0.
      GO TO 15
12    IC=I
      DO 14 J=2,N
      IC=IC+1
      IF (IC.GT.N) IC=1
      SEP=ABS(XI2-X(IC))+ABS(YI2-Y(IC))+ABS(ZI2-Z(IC))
      IF (SEP.GT.SLEN) GO TO 13
      ICON2(I)=IC
      GO TO 15
13    SEP=ABS(XI2-X2(IC))+ABS(YI2-Y2(IC))+ABS(ZI2-Z2(IC))
      IF (SEP.GT.SLEN) GO TO 14
      ICON2(I)=-IC
      GO TO 15
14    CONTINUE
      IF (I.LT.N2.AND.ICON2(I).GT.10000) GO TO 15
      ICON2(I)=0
15    CONTINUE
      IF (M.EQ.0) GO TO 26
C     FIND WIRE-SURFACE CONNECTIONS FOR NEW PATCHES
      IX=LD+1-M1
      I=M2
16    IF (I.GT.M) GO TO 20
      IX=IX-1
      XS=X(IX)
      YS=Y(IX)
      ZS=Z(IX)
      DO 18 ISEG=1,N
      XI1=X(ISEG)
      YI1=Y(ISEG)
      ZI1=Z(ISEG)
      XI2=X2(ISEG)
      YI2=Y2(ISEG)
      ZI2=Z2(ISEG)
      SLEN=(ABS(XI2-XI1)+ABS(YI2-YI1)+ABS(ZI2-ZI1))*SMIN
C     FOR FIRST END OF SEGMENT
      SEP=ABS(XI1-XS)+ABS(YI1-YS)+ABS(ZI1-ZS)
      IF (SEP.GT.SLEN) GO TO 17
C     CONNECTION - DIVIDE PATCH INTO 4 PATCHES AT PRESENT ARRAY LOC.
      ICON1(ISEG)=10000+I
      IC=0
      CALL SUBPH (I,IC,XI1,YI1,ZI1,XI2,YI2,ZI2,XA,YA,ZA,XS,YS,ZS)
      GO TO 19
17    SEP=ABS(XI2-XS)+ABS(YI2-YS)+ABS(ZI2-ZS)
      IF (SEP.GT.SLEN) GO TO 18
      ICON2(ISEG)=10000+I
      IC=0
      CALL SUBPH (I,IC,XI1,YI1,ZI1,XI2,YI2,ZI2,XA,YA,ZA,XS,YS,ZS)
      GO TO 19
18    CONTINUE
19    I=I+1
      GO TO 16
C     REPEAT SEARCH FOR NEW SEGMENTS CONNECTED TO NGF PATCHES.
20    IF (M1.EQ.0.OR.N2.GT.N) GO TO 26
      IX=LD+1
      I=1
21    IF (I.GT.M1) GO TO 25
      IX=IX-1
      XS=X(IX)
      YS=Y(IX)
      ZS=Z(IX)
      DO 23 ISEG=N2,N
      XI1=X(ISEG)
      YI1=Y(ISEG)
      ZI1=Z(ISEG)
      XI2=X2(ISEG)
      YI2=Y2(ISEG)
      ZI2=Z2(ISEG)
      SLEN=(ABS(XI2-XI1)+ABS(YI2-YI1)+ABS(ZI2-ZI1))*SMIN
      SEP=ABS(XI1-XS)+ABS(YI1-YS)+ABS(ZI1-ZS)
      IF (SEP.GT.SLEN) GO TO 22
      ICON1(ISEG)=10001+M
      IC=1
      NPCON=NPCON+1
      IPCON(NPCON)=I
      CALL SUBPH (I,IC,XI1,YI1,ZI1,XI2,YI2,ZI2,XA,YA,ZA,XS,YS,ZS)
      GO TO 24
22    SEP=ABS(XI2-XS)+ABS(YI2-YS)+ABS(ZI2-ZS)
      IF (SEP.GT.SLEN) GO TO 23
      ICON2(ISEG)=10001+M
      IC=1
      NPCON=NPCON+1
      IPCON(NPCON)=I
      CALL SUBPH (I,IC,XI1,YI1,ZI1,XI2,YI2,ZI2,XA,YA,ZA,XS,YS,ZS)
      GO TO 24
23    CONTINUE
24    I=I+1
      GO TO 21
25    IF (NPCON.LE.NSPNGF) GO TO 26
      WRITE(*,62) NSPNGF
      STOP
26    WRITE(*,58) N,NP,IPSYM
      IF (M.GT.0) WRITE(*,61) M,MP
      ISEG=(N+M)/(NP+MP)
      IF (ISEG.EQ.1) GO TO 30
      IF (IPSYM) 28,27,29
27    STOP
28    WRITE(*,59) ISEG
      GO TO 30
29    IC=ISEG/2
      IF (ISEG.EQ.8) IC=3
      WRITE(*,60) IC
30    IF (N.EQ.0) GO TO 48
      WRITE(*,50)
      ISEG=0
C     ADJUST CONNECTED SEG. ENDS TO EXACTLY COINCIDE.  PRINT JUNCTIONS
C     OF 3 OR MORE SEG.  ALSO FIND OLD SEG. CONNECTING TO NEW SEG.
      DO 44 J=1,N
      IEND=-1
      JEND=-1
      IX=ICON1(J)
      IC=1
      JCO(1)=-J
      XA=X(J)
      YA=Y(J)
      ZA=Z(J)
31    IF (IX.EQ.0) GO TO 43
      IF (IX.EQ.J) GO TO 43
      IF (IX.GT.10000) GO TO 43
      NSFLG=0
32    IF (IX) 33,49,34
33    IX=-IX
      GO TO 35
34    JEND=-JEND
35    IF (IX.EQ.J) GO TO 37
      IF (IX.LT.J) GO TO 43
      IC=IC+1
      IF (IC.GT.NSJMAX) GO TO 49
      JCO(IC)=IX*JEND
      IF (IX.GT.N1) NSFLG=1
      IF (JEND.EQ.1) GO TO 36
      XA=XA+X(IX)
      YA=YA+Y(IX)
      ZA=ZA+Z(IX)
      IX=ICON1(IX)
      GO TO 32
36    XA=XA+X2(IX)
      YA=YA+Y2(IX)
      ZA=ZA+Z2(IX)
      IX=ICON2(IX)
      GO TO 32
37    SEP=IC
      XA=XA/SEP
      YA=YA/SEP
      ZA=ZA/SEP
      DO 39 I=1,IC
      IX=JCO(I)
      IF (IX.GT.0) GO TO 38
      IX=-IX
      X(IX)=XA
      Y(IX)=YA
      Z(IX)=ZA
      GO TO 39
38    X2(IX)=XA
      Y2(IX)=YA
      Z2(IX)=ZA
39    CONTINUE
      IF (N1.EQ.0) GO TO 42
      IF (NSFLG.EQ.0) GO TO 42
      DO 41 I=1,IC
      IX=IABS(JCO(I))
      IF (IX.GT.N1) GO TO 41
      IF (ICONX(IX).NE.0) GO TO 41
      NSCON=NSCON+1
      IF (NSCON.LE.NSCNGF) GO TO 40
      WRITE(*,63) NSCNGF
      STOP
40    ISCON(NSCON)=IX
      ICONX(IX)=NSCON
41    CONTINUE
42    IF (IC.LT.3) GO TO 43
      ISEG=ISEG+1
      WRITE(*,51) ISEG,(JCO(I),I=1,IC)
43    IF (IEND.EQ.1) GO TO 44
      IEND=1
      JEND=1
      IX=ICON2(J)
      IC=1
      JCO(1)=J
      XA=X2(J)
      YA=Y2(J)
      ZA=Z2(J)
      GO TO 31
44    CONTINUE
      IF (ISEG.EQ.0) WRITE(*,52)
      IF (N1.EQ.0.OR.M1.EQ.M) GO TO 48
C     FIND OLD SEGMENTS THAT CONNECT TO NEW PATCHES
      DO 47 J=1,N1
      IX=ICON1(J)
      IF (IX.LT.10000) GO TO 45
      IX=IX-10000
      IF (IX.GT.M1) GO TO 46
45    IX=ICON2(J)
      IF (IX.LT.10000) GO TO 47
      IX=IX-10000
      IF (IX.LT.M2) GO TO 47
46    IF (ICONX(J).NE.0) GO TO 47
      NSCON=NSCON+1
      ISCON(NSCON)=J
      ICONX(J)=NSCON
47    CONTINUE
48    CONTINUE
      IF(ICHK.GE.0)THEN
         CALL SEGCHK(IERROR,IWARN)
C         IF(ICHK.EQ.0.AND.IERROR.NE.0)STOP
C         IF(ICHK.EQ.1.AND.(IERROR.NE.0.OR.IWARN.NE.0))STOP
          IF(IERROR.NE.0.OR.IWARN.NE.0)THEN
	       WRITE(*,'('' Geometry error check: '')')
	       WRITE(*,'(5X,I5,'' errors'')')IERROR
	       WRITE(*,'(5X,I5,'' warnings'')')IWARN
	       WRITE(*,'('' Enter C to continue, RETURN to end >'',$)')
	       READ(*,'(A)')CRIN
	       IF(.NOT.(CRIN.EQ.'C'.OR.CRIN.EQ.'c'))STOP
 	    END IF
      END IF
      RETURN
49    WRITE(*,53) IX
      STOP
C
50    FORMAT (//,9X,'- MULTIPLE WIRE JUNCTIONS -',/,1X,'JUNCTION',4X,
     &'SEGMENTS  (- FOR END 1, + FOR END 2)')
51    FORMAT (1X,I5,5X,20I5,/,(11X,20I5))
52    FORMAT (2X,'NONE')
53    FORMAT (' CONNECT: SEGMENT CONNECTION ERROR FOR SEGMENT',I5)
54    FORMAT (/,3X,'GROUND PLANE SPECIFIED.')
55    FORMAT (/,3X,'WHERE WIRE ENDS TOUCH GROUND, CURRENT WILL BE INTERP
     &OLATED TO IMAGE IN GROUND PLANE.',/)
56    FORMAT (' CONECT: ERROR - SEGMENT',I5,' EXTENDS BELOW GROUND')
57    FORMAT (' CONECT: ERROR - SEGMENT',I5,' LIES IN GROUND PLANE')
58    FORMAT (/,3X,'TOTAL SEGMENTS USED=',I5,5X,'NO. SEG. IN ',
     &'A SYMMETRIC CELL=',I5,5X,'SYMMETRY FLAG=',I3)
59    FORMAT (' STRUCTURE HAS',I4,' FOLD ROTATIONAL SYMMETRY',/)
60    FORMAT (' STRUCTURE HAS',I2,' PLANES OF SYMMETRY',/)
61    FORMAT (3X,'TOTAL PATCHES USED=',I5,6X,'NO. PATCHES IN A SYMMETRIC
     & CELL=',I5)
62    FORMAT (' CONECT: ERROR - NO. NGF PATCHES CONNECTING TO NEW',
     &' SEGMENTS EXCEEDS LIMIT OF',I5)
63    FORMAT (' CONECT: ERROR - NO. NGF SEGMENTS CONNECTING TO NEW',
     &' SEGMENTS EXCEEDS LIMIT OF',I5)
      END
      SUBROUTINE SEGCHK(IERROR,IWARN)
C
C     SEGCHK calls SEGXCT to check for illegally intersecting segments
C     or violations of the thin-wire approximation, and prints error and
C     warning messages.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION X2(MAXSEG), Y2(MAXSEG), Z2(MAXSEG)
      EQUIVALENCE (X2(1),SI(1)), (Y2(1),ALP(1)), (Z2(1),BET(1))
      IERROR=0
      IWARN=0
      NM=N-1
      DO 1 I=1,NM
      IP=I+1
      DO 1 J=IP,N
      CALL SEGXCT(X(I),Y(I),Z(I),X2(I),Y2(I),Z2(I),X(J),Y(J),Z(J),X2(J),
     &Y2(J),Z2(J),BI(I),BI(J),ICHK,INRAD1,INRAD2)
      IF(ICHK.EQ.1)THEN
         IERROR=1
         WRITE(*,90)I,J
      ELSE IF(ICHK.EQ.2)THEN
         IWARN=1
         WRITE(*,91)I,J
      ELSE IF(ICHK.EQ.3)THEN
         IERROR=1
         WRITE(*,92)I,J
      ELSE IF(ICHK.EQ.4)THEN
         IWARN=1
         WRITE(*,93)I,J
      END IF
      IF(INRAD1.NE.0)THEN
         IWARN=1
         WRITE(*,94)I,J
      END IF
      IF(INRAD2.NE.0)THEN
         IWARN=1
         WRITE(*,94)J,I
      END IF
1     CONTINUE
      RETURN
C
90    FORMAT(/,' SEGCHK: ERROR - SEGMENTS',I4,' AND',I4,' ARE PARALLEL',
     &' AND OVERLAPPING')
91    FORMAT(/,' SEGCHK: WARNING - SEGMENTS',I4,' AND',I4,' ARE',
     &' PARALLEL AND SEPARATED BY LESS THAN THE SUM OF THEIR RADII')
92    FORMAT(/,' SEGCHK: ERROR - SEGMENTS',I4,' AND',I4,' INTERSECT',
     &' AT A MIDPOINT')
93    FORMAT(/,' SEGCHK: WARNING - SEGMENTS',I4,' AND',I4,' CROSS AT A',
     &' MIDPOINT WITH SEPARATION LESS THAN THE SUM OF THEIR RADII')
94    FORMAT(/,' SEGCHK: WARNING - THE CENTER OF SEGMENT',I4,' IS',
     &' WITHIN THE VOLUME OF SEGMENT',I4)
      END
      SUBROUTINE SEGXCT(S1X,S1Y,S1Z,S2X,S2Y,S2Z,T1X,T1Y,T1Z,T2X,T2Y,T2Z,
     &SRAD,TRAD,ISGCHK,INRAD1,INRAD2)
C
C     SEGXCT tests a pair of segments to find intersections at 
C     midpoints, parallel overlapping segments or the center of a
C     segment buried within an adjacent segment.
C
C     INPUT:
C     S1X,S1Y,S1Z,S2X,S2Y,S2Z = first and second end of first segment
C     T1X,T1Y,T1Z,T2X,T2Y,T2Z = first and second end of second segment
C     SRAD = radius of first segment
C     TRAD = radius of second segment
C
C     OUTPUT:
C     ISGCHK = 1 if segments are parallel and overlapping
C              2 if parallel and separated by less than sum of radii
C              3 if intersecting at a midpoint
C              4 if crossing at a midpoint with separation less than
C                the sum of the radii
C     INRAD1 = 1 if the center of segment 1 is within segment 2
C     INRAD2 = 1 if the center of segment 2 is within segment 1
C
      REAL*8 DSX,DSY,DSZ,SLEN,DTX,DTY,DTZ,TLEN,TOL,SDTS,TDTS,SDOTT,DEN,
     &       SXX,TXX,SDX,SDY,SDZ,TDX,TDY,TDZ,DMINS
      ISGCHK=0
      INRAD1=0
      INRAD2=0
      RADTST=(SRAD+TRAD)**2
      DSX=S2X-S1X
      DSY=S2Y-S1Y
      DSZ=S2Z-S1Z
      SLEN=SQRT(DSX**2+DSY**2+DSZ**2)
      DSX=DSX/SLEN
      DSY=DSY/SLEN
      DSZ=DSZ/SLEN
      DTX=T2X-T1X
      DTY=T2Y-T1Y
      DTZ=T2Z-T1Z
      TLEN=SQRT(DTX**2+DTY**2+DTZ**2)
      DTX=DTX/TLEN
      DTY=DTY/TLEN
      DTZ=DTZ/TLEN
      CSEP=.25*((S1X+S2X-T1X-T2X)**2+(S1Y+S2Y-T1Y-T2Y)**2+(S1Z+S2Z-T1Z-
     &T2Z)**2)
      IF(CSEP.GT.1.2*(SLEN+TLEN)**2.AND.CSEP.GT.RADTST)RETURN
      IF(SLEN.LT.TLEN)THEN
         TOL=1.E-3*SLEN
      ELSE
         TOL=1.E-3*TLEN
      END IF
      SDTS=DSX*(S1X-T1X)+DSY*(S1Y-T1Y)+DSZ*(S1Z-T1Z)
      TDTS=DTX*(S1X-T1X)+DTY*(S1Y-T1Y)+DTZ*(S1Z-T1Z)
      SDOTT=DSX*DTX+DSY*DTY+DSZ*DTZ
      DEN=1.-SDOTT**2
      IF(DEN.LT.1.E-6)THEN
C
C     PARALLEL SEGMENTS.  TEST FOR OVERLAP
C
         IF(SDOTT.GT.0.)THEN
            IF(SDTS.LT.-SLEN+TOL.OR.SDTS.GT.TLEN-TOL)GO TO 1
         ELSE
            IF(SDTS.GT.-TOL.OR.SDTS.LT.TOL-(SLEN+TLEN))GO TO 1
         END IF
         TXX=TDTS
         TDX=T1X+TXX*DTX
         TDY=T1Y+TXX*DTY
         TDZ=T1Z+TXX*DTZ
         DMINS=(TDX-S1X)**2+(TDY-S1Y)**2+(TDZ-S1Z)**2
         IF(DMINS.LT.TOL**2)THEN
            ISGCHK=1
         ELSE IF(DMINS.LT.RADTST)THEN
            ISGCHK=2
         END IF
      ELSE
C
C     TEST FOR INTERSECTION AT A MIDPOINT
C
         SXX=(SDOTT*TDTS-SDTS)/DEN
         TXX=(TDTS-SDOTT*SDTS)/DEN
         IF(SXX.LT.-TOL.OR.SXX.GT.SLEN+TOL)GO TO 1
         IF(TXX.LT.-TOL.OR.TXX.GT.TLEN+TOL)GO TO 1
         IF((SXX.LT.TOL.OR.SXX.GT.SLEN-TOL).AND.(TXX.LT.TOL.OR.TXX.GT.
     &   TLEN-TOL))GO TO 1
         SDX=S1X+SXX*DSX
         SDY=S1Y+SXX*DSY
         SDZ=S1Z+SXX*DSZ
         TDX=T1X+TXX*DTX
         TDY=T1Y+TXX*DTY
         TDZ=T1Z+TXX*DTZ
         DMINS=(TDX-SDX)**2+(TDY-SDY)**2+(TDZ-SDZ)**2
         IF(DMINS.LT.TOL**2)THEN
            ISGCHK=3
         ELSE IF(DMINS.LT.RADTST)THEN
            ISGCHK=4
         END IF
      END IF
C
C     TEST FOR THE CENTER OF ONE SEGMENT WITHIN THE OTHER SEGMENT.
C
1     SXX=.5*SLEN
      TXX=SXX*SDOTT+TDTS
      IF(TXX.GT.0..AND.TXX.LT.TLEN)THEN
         SDX=S1X+SXX*DSX
         SDY=S1Y+SXX*DSY
         SDZ=S1Z+SXX*DSZ
         TDX=T1X+TXX*DTX
         TDY=T1Y+TXX*DTY
         TDZ=T1Z+TXX*DTZ
         DMINS=(TDX-SDX)**2+(TDY-SDY)**2+(TDZ-SDZ)**2
         IF(DMINS.LT.TRAD**2)INRAD1=1
      END IF
      TXX=.5*TLEN
      SXX=TXX*SDOTT-SDTS
      IF(SXX.GT.0..AND.SXX.LT.SLEN)THEN
         SDX=S1X+SXX*DSX
         SDY=S1Y+SXX*DSY
         SDZ=S1Z+SXX*DSZ
         TDX=T1X+TXX*DTX
         TDY=T1Y+TXX*DTY
         TDZ=T1Z+TXX*DTZ
         DMINS=(TDX-SDX)**2+(TDY-SDY)**2+(TDZ-SDZ)**2
         IF(DMINS.LT.SRAD**2)INRAD2=1
      END IF
      RETURN
      END
      SUBROUTINE DATAGN
C
C     DATAGN is the main routine for input of geometry data.
C     THIS DATAGN HAS BEEN MODIFIED FOR USE IN A DATA CHECKING PROGRAM.
C     DO NOT USE WITH NEC.
C
      INCLUDE 'NECPAR.INC'
      CHARACTER GM*2,IFX(2)*1,IFY(2)*1,IFZ(2)*2,IPT(4)*1,FILNAM*80,
     &PCHAR*1
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      COMMON/POUTPLT/NPATPL,XPAT1(MAXSEG),YPAT1(MAXSEG),ZPAT1(MAXSEG),
     &XPAT2(MAXSEG),YPAT2(MAXSEG),ZPAT2(MAXSEG),XPAT3(MAXSEG),
     &YPAT3(MAXSEG),ZPAT3(MAXSEG),XPAT4(MAXSEG),YPAT4(MAXSEG),
     &ZPAT4(MAXSEG)
      DIMENSION X2(1),Y2(1),Z2(1),T1X(1),T1Y(1),T1Z(1),CAB(1),SAB(1)
      EQUIVALENCE (T1X,SI),(T1Y,ALP),(T1Z,BET),(X2,SI),(Y2,ALP),
     &(Z2,BET),(CAB,ALP),(SAB,BET)
      DATA IFX/' ','X'/,IFY/' ','Y'/,IFZ/' ','Z'/
      DATA TA/0.01745329252/,TD/57.29577951/,IPT/'P','R','T','Q'/
C
      NPATPL=0
      LD=MAXSEG
      IPSYM=0
      NWIRE=0
      N=0
      NP=0
      M=0
      MP=0
      N1=0
      N2=1
      M1=0
      M2=1
      ISCT=0
      IPHD=0
C
C     READ GEOMETRY DATA COMMAND AND BRANCH TO SECTION FOR OPERATION
C     REQUESTED
C
1     CALL READGM(2,GM,ITG,NS,XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,F8,F9,F10,
     &FILNAM)
C***
      IF (N+M.GT.LD) GO TO 37
      IF (GM.EQ.'GF') GO TO 27
C      IF (IPHD.EQ.1) GO TO 2
C      WRITE(*,40)
C      WRITE(*,41)
C      IPHD=1
2     IF (GM.EQ.'SC') GO TO 10
      ISCT=0
      IF (GM.EQ.'GW') GO TO 3
      IF (GM.EQ.'CW') GO TO 4
      IF (GM.EQ.'GX') GO TO 18
      IF (GM.EQ.'GR') GO TO 19
      IF (GM.EQ.'GS') GO TO 21
      IF (GM.EQ.'SP') GO TO 9
      IF (GM.EQ.'SM') GO TO 13
      IF (GM.EQ.'GE') GO TO 29
      IF (GM.EQ.'GM') GO TO 26
      IF (GM.EQ.'GA') GO TO 8
      IF (GM.EQ.'GH') GO TO 123
      WRITE(*,48)
      WRITE(*,49) GM,ITG,NS,XW1,YW1,ZW1,XW2,YW2,ZW2,RAD
      STOP
C
C     GENERATE SEGMENT DATA FOR STRAIGHT WIRE.
C
3     NWIRE=NWIRE+1
      I1=N+1
      I2=N+NS
C      WRITE(*,43) NWIRE,XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,NS,I1,I2,ITG
      IF (RAD.NE.0.)THEN
         XS1=1.
         YS1=1.
      ELSE
         CALL READGM(2,GM,IX,IY,XS1,YS1,ZS1,DUMMY,DUMMY,DUMMY,DUMMY,
     &   DUMMY,DUMMY,DUMMY,FILNAM)
         IF (GM.NE.'GC')THEN
            WRITE(*,48)
            STOP
         END IF
         IF(IX.EQ.0)THEN
C            WRITE(*,61) XS1,YS1,ZS1
         ELSE
            SEGL1=XS1
            CALL RDLSOL(NS,XW1,YW1,ZW1,XW2,YW2,ZW2,XS1,XS1)
C            WRITE(*,62) SEGL1,XS1,YS1,ZS1
         END IF
         IF (YS1.EQ.0.OR.ZS1.EQ.0)THEN
            WRITE(*,48)
            STOP
         END IF
         RAD=YS1
         YS1=(ZS1/YS1)**(1./(NS-1.))
      END IF
      CALL WIRE (XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,XS1,YS1,NS,ITG)
      GO TO 1
C
C     GENERATE SEGMENT DATA FOR WIRE ARC
C
8     NWIRE=NWIRE+1
      I1=N+1
      I2=N+NS
C      WRITE(*,38) NWIRE,XW1,YW1,ZW1,XW2,NS,I1,I2,ITG
      CALL ARCNEC (ITG,NS,XW1,YW1,ZW1,XW2)
      GO TO 1
C
C     GENERATE SEGMENT DATA FOR A CATENARY WIRE
C
4     NWIRE=NWIRE+1
      I1=N+1
      I2=N+NS
      ICAT=F8+.5
C      WRITE(*,63) ICAT,F9,F10
C63    FORMAT(10X,'THE FOLLOWING WIRE IS A CATENARY,',I5,1P2E12.5)
      CALL CATNRY(XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,ICAT,F9,F10,NS,ITG)
C      WRITE(*,43) NWIRE,XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,NS,I1,I2,ITG
      GO TO 1
C***
C
C     GENERATE HELIX
C
123   NWIRE=NWIRE+1
      I1=N+1
      I2=N+NS
      IHELIX=RAD+.5
      IF(XW2.EQ.0.)XW2=ZW1
      IF(ZW2.EQ.0.)ZW2=YW2
C      IF(IHELIX.EQ.0)WRITE(*,64)NWIRE,NS,I1,I2,ITG
C      IF(IHELIX.NE.0)WRITE(*,65)NWIRE,NS,I1,I2,ITG
C      WRITE(*,66)XW1,YW1,ZW1,XW2,YW2,ZW2
      CALL HELIX(IHELIX,XW1,YW1,ZW1,XW2,YW2,ZW2,NS,ITG)
      GO TO 1
C
C     GENERATE SINGLE NEW PATCH
C
9     I1=M+1
      NS=NS+1
      IF (ITG.NE.0) GO TO 17
C      WRITE(*,51) I1,IPT(NS),XW1,YW1,ZW1,XW2,YW2,ZW2
      IF (NS.EQ.2.OR.NS.EQ.4) ISCT=1
      IF (NS.GT.1) GO TO 14
      XW2=XW2*TA
      YW2=YW2*TA
      GO TO 16
10    IF (ISCT.EQ.0) GO TO 17
      I1=M+1
      NS=NS+1
      IF (ITG.NE.0) GO TO 17
      IF (NS.NE.2.AND.NS.NE.4) GO TO 17
      XS1=X4
      YS1=Y4
      ZS1=Z4
      XS2=X3
      YS2=Y3
      ZS2=Z3
      X3=XW1
      Y3=YW1
      Z3=ZW1
      IF (NS.NE.4) GO TO 11
      X4=XW2
      Y4=YW2
      Z4=ZW2
11    XW1=XS1
      YW1=YS1
      ZW1=ZS1
      XW2=XS2
      YW2=YS2
      ZW2=ZS2
      IF (NS.EQ.4) GO TO 12
      X4=XW1+X3-XW2
      Y4=YW1+Y3-YW2
      Z4=ZW1+Z3-ZW2
12    CONTINUE
C12    WRITE(*,51) I1,IPT(NS),XW1,YW1,ZW1,XW2,YW2,ZW2
C      WRITE(*,39) X3,Y3,Z3,X4,Y4,Z4
      GO TO 16
C
C     GENERATE MULTIPLE-PATCH SURFACE
C
13    I1=M+1
C      WRITE(*,59) I1,IPT(2),XW1,YW1,ZW1,XW2,YW2,ZW2,ITG,NS
      IF (ITG.LT.1.OR.NS.LT.1) GO TO 17
14    CALL READGM(2,GM,IX,IY,X3,Y3,Z3,X4,Y4,Z4,DUMMY,DUMMY,DUMMY,DUMMY,
     &FILNAM)
C
      IF (NS.NE.2.AND.ITG.LT.1) GO TO 15
      X4=XW1+X3-XW2
      Y4=YW1+Y3-YW2
      Z4=ZW1+Z3-ZW2
15    CONTINUE
C15    WRITE(*,39) X3,Y3,Z3,X4,Y4,Z4
      IF (GM.NE.'SC') GO TO 17
16    CALL PATCH (ITG,NS,XW1,YW1,ZW1,XW2,YW2,ZW2,X3,Y3,Z3,X4,Y4,Z4)
      PCHAR=' '
      IF(ITG.GT.0.AND.NS.GT.0)THEN
         NNNX=ITG
         NNNY=NS
      ELSE IF(ITG.EQ.0.AND.NS.GT.1)THEN
         NNNX=1
         NNNY=1
         IF(NS.EQ.3)PCHAR='T'
      ELSE
         GO TO 1
      END IF
      CALL PATSET(PCHAR,XW1,YW1,ZW1,XW2,YW2,ZW2,X3,Y3,Z3,X4,Y4,Z4,NNNX,
     &NNNY)
      GO TO 1
17    WRITE(*,60)
      STOP
C
C     REFLECT STRUCTURE ALONG X,Y, OR Z AXES OR ROTATE TO FORM CYLINDER.
C
18    IY=NS/10
      IZ=NS-IY*10
      IX=IY/10
      IY=IY-IX*10
      IF (IX.NE.0) IX=1
      IF (IY.NE.0) IY=1
      IF (IZ.NE.0) IZ=1
      CALL PREFLX(IX,IY,IZ)
C      WRITE(*,44) IFX(IX+1),IFY(IY+1),IFZ(IZ+1),ITG
      GO TO 20
19    CONTINUE
C19    WRITE(*,45) NS,ITG
      IX=-1
      CALL PROTAT(NS)
20    CALL REFLC (IX,IY,IZ,ITG,NS)
      GO TO 1
C
C     SCALE STRUCTURE DIMENSIONS BY FACTOR XW1.
C
21    IF (N.LT.N2) GO TO 23
      DO 22 I=N2,N
      X(I)=X(I)*XW1
      Y(I)=Y(I)*XW1
      Z(I)=Z(I)*XW1
      X2(I)=X2(I)*XW1
      Y2(I)=Y2(I)*XW1
      Z2(I)=Z2(I)*XW1
22    BI(I)=BI(I)*XW1
23    IF (M.LT.M2) GO TO 25
      YW1=XW1*XW1
      IX=LD+1-M
      IY=LD-M1
      DO 24 I=IX,IY
      X(I)=X(I)*XW1
      Y(I)=Y(I)*XW1
      Z(I)=Z(I)*XW1
24    BI(I)=BI(I)*YW1
25    CONTINUE
C25    WRITE(*,46) XW1
      CALL PSCALE(XW1)
      GO TO 1
C
C     MOVE STRUCTURE OR REPRODUCE ORIGINAL STRUCTURE IN NEW POSITIONS.
C
26    ITG1=RAD+.5
      ISG1=F8+.5
      ITG2=F9+.5
      ISG2=F10+.5
      IF(ISG1.EQ.0)ISG1=1
      IF(ITG2.EQ.0.AND.ISG2.EQ.0)ISG2=N
      IF(ISG2.EQ.0)ISG2=1
C      WRITE(*,47) ITG,NS,XW1,YW1,ZW1,XW2,YW2,ZW2,ITG1,ISG1,ITG2,ISG2
      XW1=XW1*TA
      YW1=YW1*TA
      ZW1=ZW1*TA
      CALL MOVE (XW1,YW1,ZW1,XW2,YW2,ZW2,NS,ITG,ITG1,ISG1,ITG2,ISG2)
      CALL PMOVE(XW1/TA,YW1/TA,ZW1/TA,XW2,YW2,ZW2,NS)
      GO TO 1
C
C     READ NUMERICAL GREEN'S FUNCTION TAPE
C
27    IF (N+M.EQ.0) GO TO 28
      WRITE(*,52)
      STOP
28    CALL GFIL (ITG,FILNAM)
      NPSAV=NP
      MPSAV=MP
      IPSAV=IPSYM
      GO TO 1
C
C     TERMINATE STRUCTURE GEOMETRY INPUT.
C
29    IX=N1+M1
      IF (IX.EQ.0) GO TO 30
      NP=N
      MP=M
      IPSYM=0
30    CALL CONECT (ITG,NS)
      IF (IX.EQ.0) GO TO 31
      NP=NPSAV
      MP=MPSAV
      IPSYM=IPSAV
31    IF (N+M.GT.LD) GO TO 37
      IF (N.EQ.0) GO TO 33
C      WRITE(*,53)
C      WRITE(*,54)
      DO 32 I=1,N
      XW1=X2(I)-X(I)
      YW1=Y2(I)-Y(I)
      ZW1=Z2(I)-Z(I)
      X(I)=(X(I)+X2(I))*.5
      Y(I)=(Y(I)+Y2(I))*.5
      Z(I)=(Z(I)+Z2(I))*.5
      XW2=XW1*XW1+YW1*YW1+ZW1*ZW1
      YW2=SQRT(XW2)
      YW2=(XW2/YW2+YW2)*.5
      SI(I)=YW2
      CAB(I)=XW1/YW2
      SAB(I)=YW1/YW2
      XW2=ZW1/YW2
      IF (XW2.GT.1.) XW2=1.
      IF (XW2.LT.-1.) XW2=-1.
      SALP(I)=XW2
C      XW2=ASIN(XW2)*TD
C      YW2=ATGN2(YW1,XW1)*TD
C      WRITE(*,55) I,X(I),Y(I),Z(I),SI(I),XW2,YW2,BI(I),ICON1(I),I,
C     &ICON2(I),ITAG(I)
      IF (SI(I).GT.1.E-20.AND.BI(I).GT.1.E-20) GO TO 32
      WRITE(*,56)
      STOP
32    CONTINUE
33    IF (M.EQ.0) GO TO 35
C      WRITE(*,57)
C      J=LD+1
C      DO 34 I=1,M
C      J=J-1
C      XW1=(T1Y(J)*T2Z(J)-T1Z(J)*T2Y(J))*SALP(J)
C      YW1=(T1Z(J)*T2X(J)-T1X(J)*T2Z(J))*SALP(J)
C      ZW1=(T1X(J)*T2Y(J)-T1Y(J)*T2X(J))*SALP(J)
C      WRITE(*,58) I,X(J),Y(J),Z(J),XW1,YW1,ZW1,BI(J),T1X(J),T1Y(J)
C     &,T1Z(J),T2X(J),T2Y(J),T2Z(J)
C34    CONTINUE
35    RETURN
37    WRITE(*,50)
      STOP
C
38    FORMAT (1X,I5,2X,'ARC RADIUS =',F9.5,2X,'FROM',F8.3,' TO',F8.3,
     &' DEGREES',11X,F11.5,2X,I5,4X,I5,1X,I5,3X,I5)
39    FORMAT (6X,3F11.5,1X,3F11.5)
40    FORMAT (///,33X,'- - - STRUCTURE SPECIFICATION - - -',//,37X,
     &'COORDINATES MUST BE INPUT IN',/,37X,'METERS OR BE SCALED TO METER
     &S',/,37X,'BEFORE STRUCTURE INPUT IS ENDED',//)
41    FORMAT (2X,'WIRE',79X,'NO. OF',4X,'FIRST',2X,'LAST',5X,'TAG',/,2X,
     &'NO.',8X,'X1',9X,'Y1',9X,'Z1',10X,'X2',9X,'Y2',9X,'Z2',6X,'RADIUS'
     &,3X,'SEG.',5X,'SEG.',3X,'SEG.',5X,'NO.')
43    FORMAT (1X,I5,3F11.5,1X,4F11.5,2X,I5,4X,I5,1X,I5,3X,I5)
44    FORMAT (6X,'STRUCTURE REFLECTED ALONG THE AXES',3(1X,A1),
     &'.  TAGS INCREMENTED BY',I5)
45    FORMAT (6X,'STRUCTURE ROTATED ABOUT Z-AXIS',I3,
     &' TIMES.  LABELS INCREMENTED BY',I5)
46    FORMAT (6X,'STRUCTURE SCALED BY FACTOR',F10.5)
47    FORMAT (6X,'THE STRUCTURE HAS BEEN MOVED, GM COMMAND DATA IS -',/,
     &6X,I3,I5,6F10.5,4I5)
48    FORMAT (' DATAGN: STRUCTURE GEOMETRY DATA ERROR')
49    FORMAT (1X,A2,I3,I5,7F10.5)
50    FORMAT (' DATAGN: NUMBER OF WIRE SEGMENTS AND SURFACE PATCHES',
     &' EXCEEDS DIMENSION LIMIT.')
51    FORMAT (1X,I5,A1,F10.5,2F11.5,1X,3F11.5)
52    FORMAT (' DATAGN: ERROR - GF MUST BE FIRST COMMAND IN GEOMETRY',
     &' DATA SECTION')
53    FORMAT (////,33X,'- - - - SEGMENTATION DATA - - - -',//,40X,'COORD
     &INATES IN METERS',//,25X,'I+ AND I- INDICATE THE SEGMENTS BEFORE A
     &ND AFTER I',//)
54    FORMAT (2X,'SEG.',3X,'COORDINATES OF SEG. CENTER',5X,'SEG.',5X,
     &'ORIENTATION ANGLES',4X,'WIRE',4X,'CONNECTION DATA',3X,'TAG',/,2X,
     &'NO.',7X,'X',9X,'Y',9X,'Z',7X,'LENGTH',5X,'ALPHA',5X,'BETA',6X,
     &'RADIUS',4X,'I-',3X,'I',4X,'I+',4X,'NO.')
55    FORMAT (1X,I5,4F10.5,1X,3F10.5,1X,3I5,2X,I5)
56    FORMAT (' DATAGN: SEGMENT DATA ERROR')
57    FORMAT (////,44X,'- - - SURFACE PATCH DATA - - -',//,49X,'COORDINA
     &TES IN METERS',//,1X,'PATCH',5X,'COORD. OF PATCH CENTER',7X,
     &'UNIT NORMAL VECTOR',6X,'PATCH',12X,'COMPONENTS OF UNIT TANGENT VE
     &CTORS',/,2X,'NO.',6X,'X',9X,'Y',9X,'Z',9X,'X',7X,'Y',7X,'Z',7X,
     &'AREA',7X,'X1',6X,'Y1',6X,'Z1',7X,'X2',6X,'Y2',6X,'Z2')
58    FORMAT (1X,I4,3F10.5,1X,3F8.4,F10.5,1X,3F8.4,1X,3F8.4)
59    FORMAT (1X,I5,A1,F10.5,2F11.5,1X,3F11.5,5X,'SURFACE -',I4,' BY',I3
     &,' PATCHES')
60    FORMAT (' DATAGN: PATCH DATA ERROR')
61    FORMAT (9X,'ABOVE WIRE IS TAPERED.  SEG. LENGTH RATIO =',F9.5,/,
     &33X,'RADIUS FROM',F9.5,' TO',F9.5)
62    FORMAT (9X,'ABOVE WIRE IS TAPERED.  INITIAL SEG. LENGTH =',F9.5,
     &'   LENGTH RATIO =',F9.5,/,33X,'RADIUS FROM',F9.5,' TO',F9.5)
64    FORMAT(1X,I5,6X,'THIS WIRE IS A LOG-SPIRAL OR HELIX',40X,I5,4X,
     &I5,1X,I5,3X,I5)
65    FORMAT(1X,I5,6X,'THIS WIRE IS AN ARCHIMEDES SPIRAL OR HELIX',32X,
     &I5,4X,I5,1X,I5,3X,I5)
66    FORMAT(10X,'SPIRAL DATA: TURNS=',F10.4,'  LENGTH=',1PE12.4,
     &'  H.RAD=',2E12.4,'  W.RAD=',2E12.4)
      END
      SUBROUTINE RDLSOL(NSEG,X1,Y1,Z1,X2,Y2,Z2,DEL1,RDELX)
C
C     RDLSOL SOLVES FOR THE LENGTH RATIO FOR TAPERED SEGMENT LENGTHS
C
C     INPUT:
C     NSEG = NUMBER OF SEGMENTS
C     X1,Y1,Z1 = FIRST END OF THE WIRE
C     X2,Y2,Z2 = SECOND END OF THE WIRE
C     DEL1 = LENGTH OF THE FIRST SEGMENT
C
C     OUTPUT:
C     RDELX = RATIO OF LENGTH OF SEGMENT I+1 TO SEGMENT I
C
      ELEN=SQRT((X2-X1)**2+(Y2-Y1)**2+(Z2-Z1)**2)
      IF(DEL1.GE.ELEN.OR.DEL1.LE.0..OR.NSEG.LE.1)THEN
         WRITE(*,90)
         STOP
      END IF
      DNEWT0=2.*(NSEG*DEL1-ELEN)/(DEL1*NSEG*(NSEG-1.))
      DNEWT1=(4.*ELEN*(2.-NSEG)+DEL1*NSEG*(NSEG-5.))/(3.*DEL1*NSEG*
     &(1.-NSEG))
      RMAX=(ELEN/DEL1)**(1./(NSEG-1.))
      RDEL=1.
      NXSTOP=0
      DO 1 ITR=1,200
      IF(RDEL.GT.RMAX)RDEL=RMAX
      DN=RDEL**NSEG
      IF(ABS(DN-1.).GT.0.1)THEN
         OMR=1.-RDEL
         DNEWT=-OMR*(ELEN*OMR-DEL1*(1.-DN))/(DEL1*(1.-DN-DN*NSEG*OMR/
     &   RDEL))
      ELSE
         DNEWT=DNEWT0+DNEWT1*(RDEL-1.)
      END IF
      RDEL=RDEL-DNEWT
      IF(NXSTOP.EQ.1)GO TO 2
      IF(ABS(DNEWT/RDEL).LT.1.E-5)NXSTOP=1
1     CONTINUE
      WRITE(*,91)
2     RDELX=RDEL
      RETURN
C
90    FORMAT(' RDLSOL: ERROR - ILLEGAL STARTING SEGMENT LENGTH')
91    FORMAT(' RDLSOL: SOLUTION DID NOT CONVERGE')
      END
      SUBROUTINE HELIX(IHLX,TURNS,ZLEN,HRAD1,HRAD2,WRAD1,WRAD2,NS,ITG)
C
C     Purpose:
C     HELIX generates segment geometry data for a helix, log spiral or
C     Archimedes spiral.  The spiral starts on the x axis at y=z=0 and
C     has its axis along the z axis.
C
C     INPUT:
C     IHLX = 0 for a log spiral, 1 for an Archimedes spiral.
C     TURNS = number of turns (may be fractional), positive for a
C             right-hand spiral relative to the positive z axis,
C             negative for left-hand.
C     ZLEN = length of the helix or spiral along the z axis.
C     HRAD1 = starting radius of the spiral.  Starting point is X=HRAD1.
C     HRAD2 = final radius of the spiral.
C     WRAD1, WRAD2 = starting and final segment radius.
C     NS = number of segments.
C     ITG = tag number assigned to all segments.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION X2(1), Y2(1), Z2(1)
      EQUIVALENCE (X2(1),SI(1)), (Y2(1),ALP(1)), (Z2(1),BET(1))
      DATA TP/6.28318531/
      IST=N+1
      N=N+NS
      NP=N
      MP=M
      IPSYM=0
      IF (NS.LT.1) RETURN
      RADRAT=(WRAD2/WRAD1)**(1./(NS-1.))
      THMAX=TP*ABS(TURNS)
      IF (IHLX.EQ.0)THEN
         AHLX=(HRAD2/HRAD1)**(1./THMAX)
         IF(ABS(AHLX-1.).GT.0.02)THEN
            ISMALL=0
            HFAC=ZLEN/(HRAD2/HRAD1-1.)
         ELSE
            ISMALL=1
         END IF
      ELSE
         AHLX=(HRAD2-HRAD1)/THMAX
      END IF
      SUM=0.
      TINC=THMAX/NS
      THET=0. 
      DO 1 I=IST,N
      THET=THET+TINC
      ITAG(I)=ITG
      IF(I.EQ.IST)THEN
         X(I)=HRAD1
         Y(I)=0.
         Z(I)=0.
         BI(I)=WRAD1
      ELSE
         X(I)=X2(I-1)
         Y(I)=Y2(I-1)
         Z(I)=Z2(I-1)
         BI(I)=BI(I-1)*RADRAT
      END IF
      IF(I.EQ.N)THEN
         HRAD=HRAD2
         ZHLX=ZLEN
      ELSE
C
C     LOG SPIRAL - RADIUS AND POSITION ALONG Z AXIS
C
         IF(IHLX.EQ.0)THEN
            HRAD=HRAD1*AHLX**THET
            IF(ISMALL.EQ.0)THEN
               ZHLX=HFAC*(AHLX**THET-1.)
            ELSE
               ZHLX=ZLEN*(THET/THMAX)*(1.+.5*(AHLX-1.)*(THET-THMAX))
            END IF
         ELSE
C
C     ARCHIMEDES SPIRAL
C
            HRAD=HRAD1+AHLX*THET
            ZHLX=ZLEN*THET/THMAX
         END IF
      END IF
      X2(I)=HRAD*COS(THET)
      Y2(I)=HRAD*SIN(THET)
      IF(TURNS.LT.0.)Y2(I)=-Y2(I)
      Z2(I)=ZHLX
      SUM=SUM+SQRT((X2(I)-X(I))**2+(Y2(I)-Y(I))**2+(Z2(I)-Z(I))**2)
1     CONTINUE
      WRITE(*,90)SUM
90    FORMAT(10X,'TOTAL LENGTH OF WIRE IN THE SPIRAL = ',1PE12.5)
      RETURN
      END
      FUNCTION ISEGNO (ITAGI,MX)
C
C     Purpose:
C     ISEGNO returns the segment number of the Mth segment having the
C     tag number ITAGI.  If ITAGI=0 segment number M is returned.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      IF (MX.EQ.0) THEN
         WRITE(*,6)
         STOP
      END IF
      IF (ITAGI.EQ.0) THEN
         ISEGNO=MX
         RETURN
      END IF
      IF (N.GE.1) THEN
         ICNT=0
         DO 3 I=1,N
         IF (ITAG(I).EQ.ITAGI) THEN
            ICNT=ICNT+1
            IF (ICNT.EQ.MX) THEN
               ISEGNO=I
               RETURN
            END IF
         END IF
3        CONTINUE
      END IF
      WRITE(*,7) ITAGI,MX
      STOP
C
6     FORMAT (4X,'ISEGNO: ERROR - PARAMETER SPECIFYING SEGMENT POSITIO',
     &'N IN A GROUP OF EQUAL TAGS MUST NOT BE ZERO')
7     FORMAT (///,10X,'ISEGNO: ERROR - NO SEGMENT HAS A TAG-SEGMENT',
     &' REFERENCE OF',2I7)
      END
      SUBROUTINE MOVE (ROX,ROY,ROZ,XS,YS,ZS,NRPT,ITGI,IT1,IS1,IT2,IS2)
C
C     MOVE moves the structure with respect to its coordinate system or
C     reproduces the structure in new positions.  The structure is 
C     rotated about X,Y,Z axes by ROX,ROY,ROZ respectively, then
C     shifted by XS,YS,ZS.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION T1X(1),T1Y(1),T1Z(1),X2(1),Y2(1),Z2(1)
      EQUIVALENCE (X2(1),SI(1)), (Y2(1),ALP(1)), (Z2(1),BET(1))
      EQUIVALENCE (T1X,SI), (T1Y,ALP), (T1Z,BET)
      IF (ABS(ROX)+ABS(ROY).GT.1.E-10) IPSYM=IPSYM*3
      SPS=SIN(ROX)
      CPS=COS(ROX)
      STH=SIN(ROY)
      CTH=COS(ROY)
      SPH=SIN(ROZ)
      CPH=COS(ROZ)
      XX=CPH*CTH
      XY=CPH*STH*SPS-SPH*CPS
      XZ=CPH*STH*CPS+SPH*SPS
      YX=SPH*CTH
      YY=SPH*STH*SPS+CPH*CPS
      YZ=SPH*STH*CPS-CPH*SPS
      ZX=-STH
      ZY=CTH*SPS
      ZZ=CTH*CPS
      NRP=NRPT
      IF (NRPT.EQ.0) NRP=1
      IX=1
      IF (N.GE.N2) THEN
         I1=ISEGNO(IT1,IS1)
         I2=ISEGNO(IT2,IS2)
         IF (I1.LT.N2) I1=N2
         IF (I2.LT.N2)THEN
            WRITE(*,90)
            STOP
         END IF
         IF(I1.NE.1.OR.I2.NE.N)IX=2
         K=N
         IF (NRPT.EQ.0) K=I1-1
         DO 2 IR=1,NRP
         DO 1 I=I1,I2
         K=K+1
         XI=X(I)
         YI=Y(I)
         ZI=Z(I)
         X(K)=XI*XX+YI*XY+ZI*XZ+XS
         Y(K)=XI*YX+YI*YY+ZI*YZ+YS
         Z(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
         XI=X2(I)
         YI=Y2(I)
         ZI=Z2(I)
         X2(K)=XI*XX+YI*XY+ZI*XZ+XS
         Y2(K)=XI*YX+YI*YY+ZI*YZ+YS
         Z2(K)=XI*ZX+YI*ZY+ZI*ZZ+ZS
         BI(K)=BI(I)
         ITAG(K)=ITAG(I)
         IF (ITAG(I).NE.0) ITAG(K)=ITAG(I)+ITGI
1        CONTINUE
         I1=N+1
         I2=K
         IF(NRPT.GT.0)N=K
2        CONTINUE
      END IF
      IF (M.GE.M2) THEN
         I1=M2
         K=M
         LDI=LD+1
         IF (NRPT.EQ.0) K=M1
         DO 5 II=1,NRP
         DO 4 I=I1,M
         K=K+1
         IR=LDI-I
         KR=LDI-K
         XI=X(IR)
         YI=Y(IR)
         ZI=Z(IR)
         X(KR)=XI*XX+YI*XY+ZI*XZ+XS
         Y(KR)=XI*YX+YI*YY+ZI*YZ+YS
         Z(KR)=XI*ZX+YI*ZY+ZI*ZZ+ZS
         XI=T1X(IR)
         YI=T1Y(IR)
         ZI=T1Z(IR)
         T1X(KR)=XI*XX+YI*XY+ZI*XZ
         T1Y(KR)=XI*YX+YI*YY+ZI*YZ
         T1Z(KR)=XI*ZX+YI*ZY+ZI*ZZ
         XI=T2X(IR)
         YI=T2Y(IR)
         ZI=T2Z(IR)
         T2X(KR)=XI*XX+YI*XY+ZI*XZ
         T2Y(KR)=XI*YX+YI*YY+ZI*YZ
         T2Z(KR)=XI*ZX+YI*ZY+ZI*ZZ
         SALP(KR)=SALP(IR)
         BI(KR)=BI(IR)
4        CONTINUE
         I1=M+1
         M=K
5        CONTINUE
      END IF
      IF ((NRPT.EQ.0).AND.(IX.EQ.1)) RETURN
      NP=N
      MP=M
      IPSYM=0
      RETURN
C
90    FORMAT(/,' MOVE: ERROR - SEGMENTS FROM AN NGF FILE CAN NOT BE',
     &' MOVED')
      END
      SUBROUTINE PATCH (NX,NY,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4)
C
C     Purpose:
C     PATCH generates and modifies patch geometry data.
C     Entry SUBPH divides a patch at a wire connection.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION T1X(1), T1Y(1), T1Z(1)
      EQUIVALENCE (T1X,SI), (T1Y,ALP), (T1Z,BET)
C     NEW PATCHES.  FOR NX=0, NY=1,2,3,4 PATCH IS (RESPECTIVELY)
C     ARBITRARY, RECTAGULAR, TRIANGULAR, OR QUADRILATERAL.
C     FOR NX AND NY .GT. 0 A RECTANGULAR SURFACE IS PRODUCED WITH
C     NX BY NY RECTANGULAR PATCHES.
      M=M+1
      MI=LD+1-M
      NTP=NY
      IF (NX.GT.0) NTP=2
      IF (NTP.GT.1) GO TO 2
      X(MI)=X1
      Y(MI)=Y1
      Z(MI)=Z1
      BI(MI)=Z2
      ZNV=COS(X2)
      XNV=ZNV*COS(Y2)
      YNV=ZNV*SIN(Y2)
      ZNV=SIN(X2)
      XA=SQRT(XNV*XNV+YNV*YNV)
      IF (XA.LT.1.E-6) GO TO 1
      T1X(MI)=-YNV/XA
      T1Y(MI)=XNV/XA
      T1Z(MI)=0.
      GO TO 6
1     T1X(MI)=1.
      T1Y(MI)=0.
      T1Z(MI)=0.
      GO TO 6
2     S1X=X2-X1
      S1Y=Y2-Y1
      S1Z=Z2-Z1
      S2X=X3-X2
      S2Y=Y3-Y2
      S2Z=Z3-Z2
      IF (NX.EQ.0) GO TO 3
      S1X=S1X/NX
      S1Y=S1Y/NX
      S1Z=S1Z/NX
      S2X=S2X/NY
      S2Y=S2Y/NY
      S2Z=S2Z/NY
3     XNV=S1Y*S2Z-S1Z*S2Y
      YNV=S1Z*S2X-S1X*S2Z
      ZNV=S1X*S2Y-S1Y*S2X
      XA=SQRT(XNV*XNV+YNV*YNV+ZNV*ZNV)
      XNV=XNV/XA
      YNV=YNV/XA
      ZNV=ZNV/XA
      XST=SQRT(S1X*S1X+S1Y*S1Y+S1Z*S1Z)
      T1X(MI)=S1X/XST
      T1Y(MI)=S1Y/XST
      T1Z(MI)=S1Z/XST
      IF (NTP.GT.2) GO TO 4
      X(MI)=X1+.5*(S1X+S2X)
      Y(MI)=Y1+.5*(S1Y+S2Y)
      Z(MI)=Z1+.5*(S1Z+S2Z)
      BI(MI)=XA
      GO TO 6
4     IF (NTP.EQ.4) GO TO 5
      X(MI)=(X1+X2+X3)/3.
      Y(MI)=(Y1+Y2+Y3)/3.
      Z(MI)=(Z1+Z2+Z3)/3.
      BI(MI)=.5*XA
      GO TO 6
5     S1X=X3-X1
      S1Y=Y3-Y1
      S1Z=Z3-Z1
      S2X=X4-X1
      S2Y=Y4-Y1
      S2Z=Z4-Z1
      XN2=S1Y*S2Z-S1Z*S2Y
      YN2=S1Z*S2X-S1X*S2Z
      ZN2=S1X*S2Y-S1Y*S2X
      XST=SQRT(XN2*XN2+YN2*YN2+ZN2*ZN2)
      SALPN=1./(3.*(XA+XST))
      X(MI)=(XA*(X1+X2+X3)+XST*(X1+X3+X4))*SALPN
      Y(MI)=(XA*(Y1+Y2+Y3)+XST*(Y1+Y3+Y4))*SALPN
      Z(MI)=(XA*(Z1+Z2+Z3)+XST*(Z1+Z3+Z4))*SALPN
      BI(MI)=.5*(XA+XST)
      S1X=(XNV*XN2+YNV*YN2+ZNV*ZN2)/XST
      IF (S1X.GT.0.9998) GO TO 6
      WRITE(*,14)
      STOP
6     T2X(MI)=YNV*T1Z(MI)-ZNV*T1Y(MI)
      T2Y(MI)=ZNV*T1X(MI)-XNV*T1Z(MI)
      T2Z(MI)=XNV*T1Y(MI)-YNV*T1X(MI)
      SALP(MI)=1.
      IF (NX.EQ.0) GO TO 8
      M=M+NX*NY-1
      XN2=X(MI)-S1X-S2X
      YN2=Y(MI)-S1Y-S2Y
      ZN2=Z(MI)-S1Z-S2Z
      XS=T1X(MI)
      YS=T1Y(MI)
      ZS=T1Z(MI)
      XT=T2X(MI)
      YT=T2Y(MI)
      ZT=T2Z(MI)
      MI=MI+1
      DO 7 IY=1,NY
      XN2=XN2+S2X
      YN2=YN2+S2Y
      ZN2=ZN2+S2Z
      DO 7 IX=1,NX
      XST=IX
      MI=MI-1
      X(MI)=XN2+XST*S1X
      Y(MI)=YN2+XST*S1Y
      Z(MI)=ZN2+XST*S1Z
      BI(MI)=XA
      SALP(MI)=1.
      T1X(MI)=XS
      T1Y(MI)=YS
      T1Z(MI)=ZS
      T2X(MI)=XT
      T2Y(MI)=YT
7     T2Z(MI)=ZT
8     IPSYM=0
      NP=N
      MP=M
      RETURN
C     DIVIDE PATCH FOR WIRE CONNECTION
      ENTRY SUBPH (NX,NY,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4)
      IF (NY.GT.0) GO TO 10
      IF (NX.EQ.M) GO TO 10
      NXP=NX+1
      IX=LD-M
      DO 9 IY=NXP,M
      IX=IX+1
      NYP=IX-3
      X(NYP)=X(IX)
      Y(NYP)=Y(IX)
      Z(NYP)=Z(IX)
      BI(NYP)=BI(IX)
      SALP(NYP)=SALP(IX)
      T1X(NYP)=T1X(IX)
      T1Y(NYP)=T1Y(IX)
      T1Z(NYP)=T1Z(IX)
      T2X(NYP)=T2X(IX)
      T2Y(NYP)=T2Y(IX)
9     T2Z(NYP)=T2Z(IX)
10    MI=LD+1-NX
      XS=X(MI)
      YS=Y(MI)
      ZS=Z(MI)
      XA=BI(MI)*.25
      XST=SQRT(XA)*.5
      S1X=T1X(MI)
      S1Y=T1Y(MI)
      S1Z=T1Z(MI)
      S2X=T2X(MI)
      S2Y=T2Y(MI)
      S2Z=T2Z(MI)
      SALN=SALP(MI)
      XT=XST
      YT=XST
      IF (NY.GT.0) GO TO 11
      MIA=MI
      GO TO 12
11    M=M+1
      MP=MP+1
      MIA=LD+1-M
12    DO 13 IX=1,4
      X(MIA)=XS+XT*S1X+YT*S2X
      Y(MIA)=YS+XT*S1Y+YT*S2Y
      Z(MIA)=ZS+XT*S1Z+YT*S2Z
      BI(MIA)=XA
      T1X(MIA)=S1X
      T1Y(MIA)=S1Y
      T1Z(MIA)=S1Z
      T2X(MIA)=S2X
      T2Y(MIA)=S2Y
      T2Z(MIA)=S2Z
      SALP(MIA)=SALN
      IF (IX.EQ.2) YT=-YT
      IF (IX.EQ.1.OR.IX.EQ.3) XT=-XT
      MIA=MIA-1
13    CONTINUE
      M=M+3
      IF (NX.LE.MP) MP=MP+3
      IF (NY.GT.0) Z(MI)=10000.
      RETURN
C
14    FORMAT (' PATCH: ERROR - CORNERS OF QUADRILATERAL PATCH DO NOT',
     &' LIE IN A PLANE')
      END
      SUBROUTINE READGM(INUNIT,CODE,I1,I2,R1,R2,R3,R4,R5,R6,R7,R8,R9,
     &R10,FNAME)
C
C     Purpose:
C     READGM calls PARSIT to read input commands in the format for
C     structure geometry data.
C
C     OUTPUT:
C     CODE        two letter mnemonic code
C     I1 - I2     integer values from record
C     R1 - R10    real values from record
C
      CHARACTER CODE*(*),FNAME*(*),RECDAT*78
      DIMENSION INTVAL(2),REAVAL(10)
      ICMBLK=0
C
C     Call the routine to read the record and parse it.
C
1     CALL PARSIT(INUNIT,2,10,CODE,RECDAT,INTVAL,REAVAL,FNAME,IEOF)
      IF(IEOF.LT.0)CODE='GE'
C
C     Process text lines.  Then read next input line.
C
      IF(CODE.EQ.'CM')THEN
         CALL COMOUT(RECDAT,ICMBLK)
         GO TO 1
      END IF
      IF(ICMBLK.EQ.1)THEN
         ICMBLK=2
         CALL COMOUT(RECDAT,ICMBLK)
      END IF
C
C     Set the return variables to the buffer array elements.
C
      I1=INTVAL(1)
      I2=INTVAL(2)
      R1=REAVAL(1)
      R2=REAVAL(2)
      R3=REAVAL(3)
      R4=REAVAL(4)
      R5=REAVAL(5)
      R6=REAVAL(6)
      R7=REAVAL(7)
      R8=REAVAL(8)
      R9=REAVAL(9)
      R10=REAVAL(10)
      RETURN
      END
      SUBROUTINE PARSIT(INLUN,MAXINT,MAXRE,CMND,RECDAT,INTFLD,REFLD,
     &FNAME,IEOF)
C
C     PARSIT reads an input record and parses it.
C
C     OUTPUT:
C     MAXINT     total number of integers in record
C     MAXRE      total number of real values in record
C     CMND       two letter mnemonic code
C     INTFLD     integer values from record
C     REFLD      real values from record
C     FNAME      text returned.  Can be used for a file name.
C
C  *****  Internal Variables
C     BGNFLD     list of starting indices
C     BUFFER     text buffer
C     ENDFLD     list of ending indices
C     FLDTRM     flag to indicate that pointer is in field position
C     REC        input line as read
C     TOTCOL     total number of columns in REC
C     TOTFLD     number of numeric fields
      CHARACTER  CMND*2, BUFFER*40, REC*80, RECDAT*78, FNAME*(*)
      INTEGER    INTFLD(*)
      INTEGER    BGNFLD(17), ENDFLD(17), TOTCOL, TOTFLD
      REAL       REFLD(*)
      LOGICAL    FLDTRM
C
      READ(INLUN, 8000, IOSTAT=IEOF) REC
      RECDAT=REC(3:80)
      CALL UPCASE( REC, REC, TOTCOL )
C
C     Store opcode and clear field arrays.
C
      CMND= REC(1:2)
      FNAME=' '
      DO 3000 I=1,MAXINT
         INTFLD(I)= 0
3000  CONTINUE
      DO 3010 I=1,MAXRE
         REFLD(I)= 0.0
3010  CONTINUE
      IF(IEOF.LT.0)RETURN
      IF(CMND.EQ.'CM'.OR.CMND.EQ.'CE')THEN
         CMND='CM'
         RETURN
      END IF
      DO 3020 I=1,17
         BGNFLD(I)= 0
         ENDFLD(I)= 0
3020  CONTINUE
C
C     Find the beginning and ending of each field as well as the total
C     number of fields.
C
      TOTFLD= 0
      NAMFLD= 0
      FLDTRM= .FALSE.
      LAST= MAXRE + MAXINT
      DO 4000 J=3,TOTCOL
         K= ICHAR( REC(J:J) )
C
C     Check for end of line comment (`!').  This is a new modification
C     to allow VAX-like comments at the end of data records, i.e.
C       GW 1 7 0 0 0 0 0 .5 .0001 ! DIPOLE WIRE
C       GE ! END OF GEOMETRY
C
      IF (K .EQ. 33) THEN
         IF (FLDTRM) ENDFLD(TOTFLD)= J - 1
         GO TO 5000
C
C     Set the ending index when the character is a comma or space and
C     the pointer is in a field position (FLDTRM = .TRUE.).
C
      ELSE IF (K .EQ. 32  .OR.  K .EQ. 44) THEN
         IF (FLDTRM) THEN
            ENDFLD(TOTFLD)= J - 1
            FLDTRM= .FALSE.
         ENDIF
C
C     Set beginning index when the character is not a comma or space and
C     the pointer is not currently in a field position (FLDTRM= .FALSE.)
C
      ELSE IF (.NOT. FLDTRM) THEN
         TOTFLD= TOTFLD + 1
         FLDTRM= .TRUE.
         BGNFLD(TOTFLD)= J
         IF(K.GT.57)NAMFLD=TOTFLD
      ENDIF
4000  CONTINUE
      IF (FLDTRM) ENDFLD(TOTFLD)= TOTCOL
C
C     Check to see if the total number of value fields is within the
C     precribed limits.
C
5000  IF (NAMFLD .GT. 0) THEN
         TOTFLD=TOTFLD-1
         IF(NAMFLD.NE.TOTFLD+1)THEN
            WRITE(*,8005)
            GO TO 9010
         END IF
         FNAME=REC(BGNFLD(NAMFLD):ENDFLD(NAMFLD))
      END IF
      IF (TOTFLD .EQ. 0) RETURN
      IF (TOTFLD .GT. LAST) THEN
         WRITE(*, 8001 )
         GO TO 9010
      END IF
      J= MIN( TOTFLD, MAXINT )
C
C     Parse out integer values and store into integer buffer array.
C
      DO 5090 I=1,J
         LENGTH= ENDFLD(I) - BGNFLD(I) + 1
         BUFFER= REC(BGNFLD(I):ENDFLD(I))
         IND= INDEX( BUFFER(1:LENGTH), '.' )
         IF (IND .GT. 0  .AND.  IND .LT. LENGTH) GO TO 9000
         IF (IND .EQ. LENGTH) LENGTH= LENGTH - 1
         READ( BUFFER(1:LENGTH), '(I15)', ERR=9000 ) INTFLD(I)
5090  CONTINUE
C
C     Parse out real values and store into real buffer array.
C
      IF (TOTFLD .GT. MAXINT) THEN
         J= MAXINT + 1
         DO 6000 I=J,TOTFLD
            LENGTH= ENDFLD(I) - BGNFLD(I) + 1
            BUFFER= REC(BGNFLD(I):ENDFLD(I))
            IND= INDEX( BUFFER(1:LENGTH), '.' )
            IF (IND .EQ. 0) THEN
               INDE= INDEX( BUFFER(1:LENGTH), 'E' )
               LENGTH= LENGTH + 1
               IF (INDE .EQ. 0) THEN
                  BUFFER(LENGTH:LENGTH)= '.'
               ELSE
                  BUFFER= BUFFER(1:INDE-1)//'.'//BUFFER(INDE:LENGTH-1)
               ENDIF
            ENDIF
            READ(BUFFER(1:LENGTH),'(E15.5)',ERR=9000)REFLD(I-MAXINT)
6000  CONTINUE
      ENDIF
      RETURN
C
C     Print out text of record line when error occurs.
C
9000  IF (I .LE. MAXINT) THEN
         WRITE(*, 8002 ) I
      ELSE
         I= I - MAXINT
         WRITE(*, 8003 ) I
      END IF
9010  WRITE(*, 8004 ) REC
      IEOF=777
      RETURN
C
C     Input formats and output messages.
C
8000  FORMAT (A80)
8001  FORMAT (//,' PARSIT: INPUT ERROR - TOO MANY FIELDS IN RECORD')
8002  FORMAT (//,' PARSIT: INPUT ERROR - INVALID NUMBER AT INTEGER',
     &' POSITION ',I1)
8003  FORMAT (//,' PARSIT: INPUT ERROR - INVALID NUMBER AT REAL',
     &' POSITION ',I1)
8004  FORMAT (' ***** TEXT -->  ',A80)
8005  FORMAT (' PARSIT: INVALID ENTRY OF NON-NUMERIC DATA')
      END
      SUBROUTINE UPCASE( INTEXT, OUTTXT, LENGTH )
C
C     UPCASE finds the length of INTEXT and converts it to upper case.
C
      CHARACTER *(*) INTEXT, OUTTXT
C
C
      LENGTH=LEN( INTEXT )
      DO 3000 I=1,LENGTH
         J=ICHAR( INTEXT(I:I) )
         IF (J .GE. 96) J=J - 32
         OUTTXT(I:I)=CHAR( J )
3000  CONTINUE
      RETURN
      END
      SUBROUTINE REFLC (IX,IY,IZ,ITX,NOP)
C
C     Purpose:
C     REFLC reflects a partial structure along X,Y, or Z axes or rotates
C     the structure to complete a symmetric structure.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION T1X(1),T1Y(1),T1Z(1),X2(1),Y2(1),Z2(1)
      EQUIVALENCE (T1X,SI),(T1Y,ALP),(T1Z,BET),(X2,SI),(Y2,ALP),(Z2,BET)
      NP=N
      MP=M
      IPSYM=0
      ITI=ITX
      IF (IX.LT.0) GO TO 19
      IF (NOP.EQ.0) RETURN
      IPSYM=1
      IF (IZ.EQ.0) GO TO 6
C
C     REFLECT ALONG Z AXIS
C
      IPSYM=2
      IF (N.LT.N2) GO TO 3
      DO 2 I=N2,N
      NX=I+N-N1
      E1=Z(I)
      E2=Z2(I)
      IF (ABS(E1)+ABS(E2).GT.1.E-5.AND.E1*E2.GE.-1.E-6) GO TO 1
      WRITE(*,24) I
      STOP
1     X(NX)=X(I)
      Y(NX)=Y(I)
      Z(NX)=-E1
      X2(NX)=X2(I)
      Y2(NX)=Y2(I)
      Z2(NX)=-E2
      ITAGI=ITAG(I)
      IF (ITAGI.EQ.0) ITAG(NX)=0
      IF (ITAGI.NE.0) ITAG(NX)=ITAGI+ITI
2     BI(NX)=BI(I)
      N=N*2-N1
      ITI=ITI*2
3     IF (M.LT.M2) GO TO 6
      NXX=LD+1-M1
      DO 5 I=M2,M
      NXX=NXX-1
      NX=NXX-M+M1
      IF (ABS(Z(NXX)).GT.1.E-10) GO TO 4
      WRITE(*,25) I
      STOP
4     X(NX)=X(NXX)
      Y(NX)=Y(NXX)
      Z(NX)=-Z(NXX)
      T1X(NX)=T1X(NXX)
      T1Y(NX)=T1Y(NXX)
      T1Z(NX)=-T1Z(NXX)
      T2X(NX)=T2X(NXX)
      T2Y(NX)=T2Y(NXX)
      T2Z(NX)=-T2Z(NXX)
      SALP(NX)=-SALP(NXX)
5     BI(NX)=BI(NXX)
      M=M*2-M1
6     IF (IY.EQ.0) GO TO 12
C
C     REFLECT ALONG Y AXIS
C
      IF (N.LT.N2) GO TO 9
      DO 8 I=N2,N
      NX=I+N-N1
      E1=Y(I)
      E2=Y2(I)
      IF (ABS(E1)+ABS(E2).GT.1.E-5.AND.E1*E2.GE.-1.E-6) GO TO 7
      WRITE(*,24) I
      STOP
7     X(NX)=X(I)
      Y(NX)=-E1
      Z(NX)=Z(I)
      X2(NX)=X2(I)
      Y2(NX)=-E2
      Z2(NX)=Z2(I)
      ITAGI=ITAG(I)
      IF (ITAGI.EQ.0) ITAG(NX)=0
      IF (ITAGI.NE.0) ITAG(NX)=ITAGI+ITI
8     BI(NX)=BI(I)
      N=N*2-N1
      ITI=ITI*2
9     IF (M.LT.M2) GO TO 12
      NXX=LD+1-M1
      DO 11 I=M2,M
      NXX=NXX-1
      NX=NXX-M+M1
      IF (ABS(Y(NXX)).GT.1.E-10) GO TO 10
      WRITE(*,25) I
      STOP
10    X(NX)=X(NXX)
      Y(NX)=-Y(NXX)
      Z(NX)=Z(NXX)
      T1X(NX)=T1X(NXX)
      T1Y(NX)=-T1Y(NXX)
      T1Z(NX)=T1Z(NXX)
      T2X(NX)=T2X(NXX)
      T2Y(NX)=-T2Y(NXX)
      T2Z(NX)=T2Z(NXX)
      SALP(NX)=-SALP(NXX)
11    BI(NX)=BI(NXX)
      M=M*2-M1
12    IF (IX.EQ.0) GO TO 18
C
C     REFLECT ALONG X AXIS
C
      IF (N.LT.N2) GO TO 15
      DO 14 I=N2,N
      NX=I+N-N1
      E1=X(I)
      E2=X2(I)
      IF (ABS(E1)+ABS(E2).GT.1.E-5.AND.E1*E2.GE.-1.E-6) GO TO 13
      WRITE(*,24) I
      STOP
13    X(NX)=-E1
      Y(NX)=Y(I)
      Z(NX)=Z(I)
      X2(NX)=-E2
      Y2(NX)=Y2(I)
      Z2(NX)=Z2(I)
      ITAGI=ITAG(I)
      IF (ITAGI.EQ.0) ITAG(NX)=0
      IF (ITAGI.NE.0) ITAG(NX)=ITAGI+ITI
14    BI(NX)=BI(I)
      N=N*2-N1
15    IF (M.LT.M2) GO TO 18
      NXX=LD+1-M1
      DO 17 I=M2,M
      NXX=NXX-1
      NX=NXX-M+M1
      IF (ABS(X(NXX)).GT.1.E-10) GO TO 16
      WRITE(*,25) I
      STOP
16    X(NX)=-X(NXX)
      Y(NX)=Y(NXX)
      Z(NX)=Z(NXX)
      T1X(NX)=-T1X(NXX)
      T1Y(NX)=T1Y(NXX)
      T1Z(NX)=T1Z(NXX)
      T2X(NX)=-T2X(NXX)
      T2Y(NX)=T2Y(NXX)
      T2Z(NX)=T2Z(NXX)
      SALP(NX)=-SALP(NXX)
17    BI(NX)=BI(NXX)
      M=M*2-M1
18    RETURN
C
C     REPRODUCE STRUCTURE WITH ROTATION TO FORM CYLINDRICAL STRUCTURE
C
19    FNOP=NOP
      IPSYM=-1
      SAM=6.283185308/FNOP
      CS=COS(SAM)
      SS=SIN(SAM)
      IF (N.LT.N2) GO TO 21
      N=N1+(N-N1)*NOP
      NX=NP+1
      DO 20 I=NX,N
      K=I-NP+N1
      XK=X(K)
      YK=Y(K)
      X(I)=XK*CS-YK*SS
      Y(I)=XK*SS+YK*CS
      Z(I)=Z(K)
      XK=X2(K)
      YK=Y2(K)
      X2(I)=XK*CS-YK*SS
      Y2(I)=XK*SS+YK*CS
      Z2(I)=Z2(K)
      ITAGI=ITAG(K)
      IF (ITAGI.EQ.0) ITAG(I)=0
      IF (ITAGI.NE.0) ITAG(I)=ITAGI+ITI
20    BI(I)=BI(K)
21    IF (M.LT.M2) GO TO 23
      M=M1+(M-M1)*NOP
      NX=MP+1
      K=LD+1-M1
      DO 22 I=NX,M
      K=K-1
      J=K-MP+M1
      XK=X(K)
      YK=Y(K)
      X(J)=XK*CS-YK*SS
      Y(J)=XK*SS+YK*CS
      Z(J)=Z(K)
      XK=T1X(K)
      YK=T1Y(K)
      T1X(J)=XK*CS-YK*SS
      T1Y(J)=XK*SS+YK*CS
      T1Z(J)=T1Z(K)
      XK=T2X(K)
      YK=T2Y(K)
      T2X(J)=XK*CS-YK*SS
      T2Y(J)=XK*SS+YK*CS
      T2Z(J)=T2Z(K)
      SALP(J)=SALP(K)
22    BI(J)=BI(K)
23    RETURN
C
24    FORMAT (' REFLEC: GEOMETRY DATA ERROR - SEGMENT',I5,' LIES IN',
     &' PLANE OF SYMMETRY')
25    FORMAT (' REFLEC: GEOMETRY DATA ERROR - PATCH',I4,' LIES IN PLANE'
     &,' OF SYMMETRY')
      END
      SUBROUTINE WIRE (XW1,YW1,ZW1,XW2,YW2,ZW2,RAD,RDEL,RRAD,NS,ITG)
C
C     Purpose:
C     WIRE generates segment geometry data for a straight wire of NS 
C     segments.
C
      INCLUDE 'NECPAR.INC'
      COMMON /DATA/ LD,N1,N2,N,NP,M1,M2,M,MP,X(MAXSEG),Y(MAXSEG),
     &Z(MAXSEG),SI(MAXSEG),BI(MAXSEG),ALP(MAXSEG),BET(MAXSEG),
     &SALP(MAXSEG),T2X(MAXSEG),T2Y(MAXSEG),T2Z(MAXSEG),ICON1(MAXSEG),
     &ICON2(MAXSEG),ITAG(MAXSEG),ICONX(MAXSEG),IPSYM
      DIMENSION X2(1), Y2(1), Z2(1)
      EQUIVALENCE (X2(1),SI(1)), (Y2(1),ALP(1)), (Z2(1),BET(1))
      IST=N+1
      N=N+NS
      NP=N
      MP=M
      IPSYM=0
      IF (NS.LT.1) RETURN
      XD=XW2-XW1
      YD=YW2-YW1
      ZD=ZW2-ZW1
      IF (ABS(RDEL-1.).LT.1.E-6) GO TO 1
      DELZ=SQRT(XD*XD+YD*YD+ZD*ZD)
      XD=XD/DELZ
      YD=YD/DELZ
      ZD=ZD/DELZ
      DELZ=DELZ*(1.-RDEL)/(1.-RDEL**NS)
      RD=RDEL
      GO TO 2
1     FNS=NS
      XD=XD/FNS
      YD=YD/FNS
      ZD=ZD/FNS
      DELZ=1.
      RD=1.
2     RADZ=RAD
      XS1=XW1
      YS1=YW1
      ZS1=ZW1
      DO 3 I=IST,N
      ITAG(I)=ITG
      XS2=XS1+XD*DELZ
      YS2=YS1+YD*DELZ
      ZS2=ZS1+ZD*DELZ
      X(I)=XS1
      Y(I)=YS1
      Z(I)=ZS1
      X2(I)=XS2
      Y2(I)=YS2
      Z2(I)=ZS2
      BI(I)=RADZ
      DELZ=DELZ*RD
      RADZ=RADZ*RRAD
      XS1=XS2
      YS1=YS2
3     ZS1=ZS2
      X2(N)=XW2
      Y2(N)=YW2
      Z2(N)=ZW2
      RETURN
      END
