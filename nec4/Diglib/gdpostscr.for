	SUBROUTINE GDPOSTSCR_TALL(IFXN,XA,YA)
	DIMENSION XA(8), YA(3)
C
C	POST SCRIPT DRIVER - HARD COPY DEVICE HAS 300 DOTS/INCH
	PARAMETER (DOTS_PER_INCH = 300.0)
C
C-----------------------------------------------------------------------
C
C	DECLARE VARS NEED FOR DRIVER OPERATION
C
	LOGICAL*1 L_NOTHING_PLOTTED, L_WIDE
	BYTE COORD(20)
	CHARACTER*8 CTIME
	CHARACTER*80 FILENAME
	CHARACTER*120 COMMAND
C
	DIMENSION DCHAR(8)
C
C	MAKE NICE NAMES FOR THE DEVICES RESOLUTION IN X AND Y
C	 ("XGUPCM" IS X GRAPHICS UNITS PER CENTIMETER)
C
	EQUIVALENCE (DCHAR(4),XGUPCM), (DCHAR(5),YGUPCM)
C
C	PAPER DEFINITIONS (INCHES)
C
	PARAMETER (PSRES = 72.0)
	REAL*4 LEFT_MARGIN
	PARAMETER (LEFT_MARGIN = 0.5)
	PARAMETER (RIGHT_MARGIN = 0.25)
	PARAMETER (TOP_MARGIN = 0.5)
	PARAMETER (BOTTOM_MARGIN = 0.25)
	PARAMETER (PAPER_HEIGHT = 11.0)
	PARAMETER (PAPER_WIDTH = 8.5)
C		DERIVED PARAMETERS
	PARAMETER (USEABLE_WIDTH = PAPER_WIDTH-LEFT_MARGIN-RIGHT_MARGIN)
	PARAMETER (USEABLE_HEIGHT = PAPER_HEIGHT-TOP_MARGIN-BOTTOM_MARGIN)
	PARAMETER (WIDTH_CM = 2.54*USEABLE_WIDTH)
	PARAMETER (HEIGHT_CM = 2.54*USEABLE_HEIGHT)
	PARAMETER (RESOLUTION = DOTS_PER_INCH/2.54)
	PARAMETER (PSRESCM = PSRES/2.54)
	PARAMETER (XOFF = PSRES*LEFT_MARGIN)
	PARAMETER (YOFF = PSRES*BOTTOM_MARGIN)
C
	PARAMETER (MAX_POINTS_PER_PATH = 900)
C
C	DIGLIB DEVICE CHARACTERISTICS WORDS
C
	DATA DCHAR /910.0, WIDTH_CM, HEIGHT_CM, RESOLUTION,
	1   RESOLUTION, 1.0, 27.0, 4.0/
C
	BYTE EOF(2)
	DATA EOF /4,0/
C
	L_WIDE = .FALSE.
10	CONTINUE
C
C*****************
C
C	FIRST VERIFY WE GOT A GRAPHICS FUNCTION WE CAN HANDLE
C
	IF (IFXN .LE. 0 .OR. IFXN .GT. 7) RETURN
C
C	NOW DISPATCH TO THE PROPER CODE TO HANDLE THAT FUNCTION
C
	GO TO (100,200,300,400,500,600,700) IFXN
C
C	*********************
C	INITIALIZE THE DEVICE
C	*********************
C
100	CONTINUE
	LUN = XA(1)
	CALL IDATE(IM,ID,IY)
	CALL TIME(CTIME)
	FILENAME = 'SYS$SCRATCH:POSTSCRIPT.DIG'//CHAR(IM+64)//CHAR(ID+64)
	1   //CTIME(1:2)//CTIME(4:5)//CTIME(7:8)
	OPEN (UNIT=LUN,NAME=FILENAME,TYPE='NEW',
	1   FORM='UNFORMATTED',CARRIAGECONTROL='NONE',RECORDTYPE='VARIABLE',
	2   INITIALSIZE = 50, EXTENDSIZE = 50, ERR=9000)
C
C	SHOW INITIALIZATION WORKED, I.E. WE OPENED THE FILE.
C
	YA(1) = 0.0
	CALL GDLSR_OPEN_BUFR(LUN)
	CALL GDLSR_INSERT(EOF)
	CALL GDLSR_INSERT('erasepage initgraphics 1 setlinecap 1 setlinejoin ')
	CALL GDLSR_INSERT('/m {moveto} def /l {lineto} def ')
	CALL GDLSR_DUMP_BUFR
190	CONTINUE
	L_NOTHING_PLOTTED = .TRUE.
	N_POINTS_IN_PATH = 0
	RETURN
C
C	**************************
C	GET FRESH PLOTTING SURFACE
C	**************************
C
200	CONTINUE
	IF (.NOT. L_NOTHING_PLOTTED) THEN
		CALL GDLSR_INSERT('stroke showpage ')
	ENDIF
	CALL GDLSR_INSERT('newpath ')
	GO TO 190
C
C	****
C	MOVE
C	****
C
300	CONTINUE
C
C	****
C	DRAW
C	****
C
400	CONTINUE
	N_POINTS_IN_PATH = N_POINTS_IN_PATH + 1
	IF (N_POINTS_IN_PATH .GT. MAX_POINTS_PER_PATH) THEN
		CALL GDLSR_INSERT('stroke newpath ')
		IF (IFXN .EQ. 4) THEN
			CALL GDLSR_INSERT(COORD)
			CALL GDLSR_INSERT('m ')
		ENDIF
		N_POINTS_IN_PATH = 1
	ENDIF
	IF (L_WIDE) THEN
		X = PSRESCM*YA(1)+XOFF
		Y = PSRESCM*(HEIGHT_CM-XA(1))+YOFF
	    ELSE
		X = PSRESCM*XA(1)+XOFF
		Y = PSRESCM*YA(1)+YOFF
	ENDIF
	ENCODE (14,451,COORD) X,Y
451	FORMAT(F6.1,1X,F6.1,1X)
	COORD(15) = 0
	CALL GDLSR_INSERT(COORD)
	IF (IFXN .EQ. 3) THEN
		CALL GDLSR_INSERT('m ')
	    ELSE
		CALL GDLSR_INSERT('l ')
	ENDIF
	L_NOTHING_PLOTTED = .FALSE.
	RETURN
C
C	*****************************
C	FLUSH GRAPHICS COMMAND BUFFER
C	*****************************
C
500	CONTINUE
	RETURN		!DONE BY BGNPLT WHEN NECESSARY.
C
C	******************
C	RELEASE THE DEVICE
C	******************
C
600	CONTINUE
	IF (.NOT. L_NOTHING_PLOTTED) THEN
		CALL GDLSR_INSERT('stroke showpage ')
		CALL GDLSR_INSERT(EOF)
		CALL GDLSR_DUMP_BUFR
	ENDIF
	CLOSE (UNIT=LUN)
	COMMAND = '$ PROCESSPS '//FILENAME
	ISTATUS = LIB$SPAWN(COMMAND, , ,1)
	RETURN
C
C	*****************************
C	RETURN DEVICE CHARACTERISTICS
C	*****************************
C
700	CONTINUE
	DO 720 I=1,8
	XA(I) = DCHAR(I)
720	CONTINUE
	IF (L_WIDE) THEN
		XA(2) = DCHAR(3)
		XA(3) = DCHAR(2)
	ENDIF
	RETURN
C
C	HANDLE FILE OPEN ERROR
C
9000	CONTINUE
	YA(1) = 3.0
	RETURN
C
C	***********************************************************
C
	ENTRY GDPOSTSCR_WIDE(IFXN,XA,YA)
	L_WIDE = .TRUE.
	GO TO 10
	END


	SUBROUTINE GDLSR_OPEN_BUFR(LUN)
C
	PARAMETER (IBUFR_SIZE = 80)
	BYTE BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	LUNOUT = LUN
	NXTCHR = 1
	RETURN
	END


	SUBROUTINE GDLSR_INIT_BUFR
C
	PARAMETER (IBUFR_SIZE = 80)
	BYTE BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	NXTCHR = 1
	RETURN
	END


	SUBROUTINE GDLSR_INSERT(STRING)
	BYTE STRING(2)
C
	PARAMETER (IBUFR_SIZE = 80)
	BYTE BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	EXTERNAL LEN
C
	L = LEN(STRING)
	IF ((NXTCHR+L) .GT. IBUFR_SIZE) CALL GDLSR_DUMP_BUFR
		DO 100 I = 1, L
		BUFFER(NXTCHR) = STRING(I)
		NXTCHR = NXTCHR + 1
100		CONTINUE
	RETURN
	END

	SUBROUTINE GDLSR_DUMP_BUFR
C
	PARAMETER (IBUFR_SIZE = 80)
	BYTE CR
	PARAMETER (CR = 13)
	BYTE BUFFER
	COMMON /GDLSR/ NXTCHR, LUNOUT, BUFFER(IBUFR_SIZE)
C
	IF (NXTCHR .EQ. 1) RETURN
	WRITE (LUNOUT) (BUFFER(I), I=1,NXTCHR-1), CR
	NXTCHR = 1
	RETURN
	END
