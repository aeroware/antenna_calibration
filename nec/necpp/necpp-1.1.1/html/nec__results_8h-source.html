<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>nec++: nec_results.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>nec_results.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">        Copyright (C) 2004  Timothy C.A. Molteno</span>
00003 <span class="comment">        </span>
00004 <span class="comment">        This program is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">        it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">        the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">        (at your option) any later version.</span>
00008 <span class="comment">        </span>
00009 <span class="comment">        This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">        but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">        GNU General Public License for more details.</span>
00013 <span class="comment">        </span>
00014 <span class="comment">        You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">        along with this program; if not, write to the Free Software</span>
00016 <span class="comment">        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">*/</span>
00018 <span class="preprocessor">#ifndef __nec_results__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define __nec_results__</span>
00020 <span class="preprocessor"></span><span class="comment">/*</span>
00021 <span class="comment">        This class contains the results of the NEC analysis. Set methods</span>
00022 <span class="comment">        will store the results in this class, but will NOT print the results</span>
00023 <span class="comment">        to a file</span>
00024 <span class="comment">*/</span>
00025 <span class="preprocessor">#include &lt;vector&gt;</span>
00026 <span class="preprocessor">#include &lt;ostream&gt;</span>
00027 <span class="preprocessor">#include &lt;iostream&gt;</span>
00028 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00029 <span class="preprocessor">#include &lt;string&gt;</span>
00030 
00031 <span class="preprocessor">#include "math_util.h"</span>
00032 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00033 
00034 
00035 <span class="keyword">class </span>nec_base_result
00036 {
00037 <span class="keyword">private</span>:
00038         <span class="keywordtype">bool</span> _write_file;
00039 
00040 <span class="keyword">public</span>:
00041         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write_to_file(ostream&amp; os) = 0;
00042         
00043         nec_base_result()
00044                 : _write_file(true)
00045         {
00046         }
00047         
00048         <span class="keyword">virtual</span> ~nec_base_result()
00049         {
00050         }
00051 
00052         <span class="keyword">inline</span> <span class="keywordtype">void</span> section_start(ostream&amp; os)
00053         {
00054                 os &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
00055         }
00056         
00057         <span class="keyword">inline</span> <span class="keywordtype">void</span> int_out(ostream&amp; os, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> i)
00058         {
00059                 os &lt;&lt; setw(w) &lt;&lt; i &lt;&lt; <span class="stringliteral">" "</span>;
00060         }
00061         
00062         <span class="keyword">inline</span> <span class="keywordtype">void</span> string_out(ostream&amp; os, <span class="keywordtype">int</span> w, <span class="keywordtype">char</span>* s)
00063         {
00064                 os &lt;&lt; right &lt;&lt;setw(w) &lt;&lt; s &lt;&lt; <span class="stringliteral">" "</span>;
00065         }
00066         
00067         <span class="keyword">inline</span> <span class="keywordtype">void</span> real_out(ostream&amp; os, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> p, nec_float f, <span class="keywordtype">bool</span> sci = <span class="keyword">true</span>)
00068         {
00069                 ios::fmtflags flags = ios::showpoint | ios::uppercase | ios::right;
00070                 <span class="keywordflow">if</span> (sci)
00071                         flags |= ios::scientific;
00072                 <span class="keywordflow">else</span>
00073                         flags |= ios::fixed;
00074                 
00075                 os.unsetf(ios::adjustfield | ios::basefield | ios::floatfield);
00076                 os.setf(flags);
00077                 os.precision(p);
00078                 os.width(w);
00079                 os &lt;&lt; f &lt;&lt; <span class="stringliteral">" "</span>;
00080         }
00081         
00082         <span class="keyword">inline</span> <span class="keywordtype">void</span> complex_out(ostream&amp; os, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> p, nec_complex c, <span class="keywordtype">bool</span> sci = <span class="keyword">true</span>)
00083         {
00084                 real_out(os,w,p,real(c),sci);
00085                 real_out(os,w,p,imag(c),sci);
00086         }
00087 
00088         <span class="keyword">inline</span> <span class="keywordtype">void</span> polar_out(ostream&amp; os, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> p, nec_complex c, <span class="keywordtype">bool</span> sci = <span class="keyword">true</span>)
00089         {
00090                 real_out(os,w,p,abs(c),sci);
00091                 real_out(os,w,p,arg_degrees(c),sci);
00092         }
00093         
00094         <span class="keyword">inline</span> <span class="keywordtype">bool</span> write_file()<span class="keyword"> const</span>
00095 <span class="keyword">        </span>{
00096                 <span class="keywordflow">return</span> _write_file;
00097         }
00098         
00099         <span class="keyword">inline</span> <span class="keywordtype">void</span> set_write_file(<span class="keywordtype">bool</span> f)
00100         {
00101                 _write_file = f;
00102         }
00103 };
00104 
00105 
00106 
00107 <span class="keyword">class </span>nec_rx_pattern : <span class="keyword">public</span> nec_base_result
00108 {
00109         <span class="comment">// Receiving Pattern</span>
00110         nec_float _norm_factor;
00111         nec_float _eta, _axial_ratio;
00112         <span class="keywordtype">int</span> _segment_number;
00113         string _type;
00114         
00115         <span class="keywordtype">long</span> n_theta;
00116         <span class="keywordtype">long</span> n_phi;
00117         nec_float _theta0, _theta_step;
00118         nec_float _phi0, _phi_step;
00119         
00120         <a class="code" href="classsafe__array.html">real_array</a> _mag;
00121         
00122 <span class="keyword">public</span>:
00123         nec_rx_pattern(
00124                 <span class="keywordtype">int</span> in_n_theta, <span class="keywordtype">int</span> in_n_phi,
00125                 <a class="code" href="classsafe__array.html">real_array</a>&amp; in_mag,
00126                 nec_float theta0, nec_float theta_step,
00127                 nec_float phi0, nec_float phi_step,
00128                 nec_float in_eta, 
00129                 nec_float in_axial_ratio, 
00130                 <span class="keywordtype">int</span> in_segment_number, 
00131                 string in_type)
00132         {
00133                 n_theta = in_n_theta;
00134                 n_phi = in_n_phi;
00135                 
00136                 _mag.copy(in_mag);
00137                 _mag.resize(n_theta, n_phi);
00138                 
00139                 _theta0 = theta0;
00140                 _theta_step = theta_step;
00141                 
00142                 _phi0 = phi0;
00143                 _phi_step = phi_step;
00144                 
00145                 _eta = in_eta;
00146                 _axial_ratio = in_axial_ratio;
00147                 _segment_number = in_segment_number;
00148                 _type = in_type;
00149                 
00150                 _mag.resize(n_theta, n_phi);
00151         }
00152 
00153         <span class="keyword">virtual</span> ~nec_rx_pattern()
00154         {
00155         }
00156         
00157         <span class="keywordtype">void</span> set_input(<span class="keywordtype">int</span> theta_index, <span class="keywordtype">int</span> phi_index, nec_float mag)
00158         {
00159                 _mag.set(theta_index,phi_index,mag);
00160         }
00161         
00162         nec_float get_norm_factor()
00163         {
00164                 <span class="keywordflow">return</span> _mag.max();
00165         }
00166         
00167         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write_to_file(ostream&amp; os)
00168         {
00169                 <span class="keywordflow">if</span> (n_theta == 0)
00170                         <span class="keywordflow">return</span>;
00171                 <span class="keywordflow">if</span> (n_phi == 0)
00172                         <span class="keywordflow">return</span>;
00173                         
00174                 nec_float norm_factor = get_norm_factor();
00175                 
00176                 section_start(os);
00177                 os &lt;&lt; <span class="stringliteral">"                      ---- NORMALIZED RECEIVING PATTERN ----"</span> &lt;&lt; endl;
00178                 os &lt;&lt; <span class="stringliteral">"                      NORMALIZATION FACTOR: "</span>;real_out(os,11,4,norm_factor);os &lt;&lt; endl;
00179                 os &lt;&lt; <span class="stringliteral">"                      ETA: "</span>;real_out(os,7,2,_eta,<span class="keyword">false</span>); os &lt;&lt; <span class="stringliteral">"DEGREES"</span> &lt;&lt; endl;
00180                 os &lt;&lt; <span class="stringliteral">"                      TYPE: "</span> &lt;&lt; _type &lt;&lt; endl;
00181                 os &lt;&lt; <span class="stringliteral">"                      AXIAL RATIO: "</span>; real_out(os,6,3,_axial_ratio,<span class="keyword">false</span>); os &lt;&lt; endl;
00182                 os &lt;&lt; <span class="stringliteral">"                      SEGMENT No: "</span>; int_out(os, 5, _segment_number); os &lt;&lt; endl &lt;&lt; endl;
00183                 os &lt;&lt; <span class="stringliteral">"                      THETA     PHI       ---- PATTERN ----"</span> &lt;&lt; endl;
00184                 os &lt;&lt; <span class="stringliteral">"                      (DEG)    (DEG)       DB     MAGNITUDE"</span> &lt;&lt; endl;
00185                 
00186                 nec_float theta = _theta0;
00187                 
00188                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=0; t&lt;n_theta; t++)
00189                 {
00190                         nec_float phi = _phi0;
00191                         
00192                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0; p&lt;n_phi;p++)
00193                         {
00194                                 nec_float magnitude = _mag.get(t,p) / norm_factor;
00195                                 nec_float gain = db20(magnitude);
00196                                 
00197                                 os &lt;&lt; <span class="stringliteral">"                    "</span>;
00198                                 real_out(os,7,2, theta, <span class="keyword">false</span>);
00199                                 real_out(os,7,2, phi, <span class="keyword">false</span>);
00200                                 os &lt;&lt; <span class="stringliteral">"  "</span>;
00201                                 real_out(os,7,2, gain, <span class="keyword">false</span>);
00202                                 os &lt;&lt; <span class="stringliteral">" "</span>;
00203                                 real_out(os,11,4, magnitude);
00204                                 os &lt;&lt; endl;
00205                                 
00206                                 phi += _phi_step;
00207                         }
00208                         theta += _theta_step;
00209                 }
00210         }
00211 };
00212 
00213 <span class="keyword">class </span>nec_antenna_input : <span class="keyword">public</span> nec_base_result
00214 {
00215         <span class="comment">// Antenna Input Parameters</span>
00216         vector&lt;int&gt; _tag, _segment;
00217         vector&lt;nec_float&gt; _power;
00218         vector&lt;nec_complex&gt; _voltage, _current, _impedance, _admittance;
00219         <span class="keywordtype">long</span> n_items;
00220         
00221 <span class="keyword">public</span>:
00222         nec_antenna_input()
00223         {
00224                 n_items = 0;
00225         }
00226 
00227         <span class="keyword">virtual</span> ~nec_antenna_input()
00228         {
00229         }
00230         
00231         <span class="keywordtype">void</span> set_input(<span class="keywordtype">int</span> tag, <span class="keywordtype">int</span> segment, nec_complex voltage, nec_complex current, nec_complex impedance, nec_complex admittance, nec_float power)
00232         {
00233                 n_items++;
00234                 _tag.push_back(tag);
00235                 _segment.push_back(segment);
00236                 _voltage.push_back(voltage);
00237                 _current.push_back(current);
00238                 _impedance.push_back(impedance);
00239                 _admittance.push_back(admittance);
00240                 _power.push_back(power);
00241         }
00242         
00243         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write_to_file(ostream&amp; os)
00244         {
00245                 <span class="keywordflow">if</span> (n_items == 0)
00246                         <span class="keywordflow">return</span>;
00247                         
00248                 section_start(os);
00249                 os &lt;&lt; <span class="stringliteral">"                        --------- ANTENNA INPUT PARAMETERS ---------"</span> &lt;&lt; endl;   
00250                 os &lt;&lt; <span class="stringliteral">"  TAG   SEG       VOLTAGE (VOLTS)         CURRENT (AMPS)         IMPEDANCE (OHMS)        ADMITTANCE (MHOS)     POWER"</span> &lt;&lt; endl;
00251                 os &lt;&lt; <span class="stringliteral">"  NO.   NO.     REAL      IMAGINARY     REAL      IMAGINARY     REAL      IMAGINARY    REAL       IMAGINARY   (WATTS)"</span> &lt;&lt; endl;
00252                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n_items; i++)
00253                 {
00254                         int_out(os,4, _tag[i]);
00255                         int_out(os,5, _segment[i]);
00256                         complex_out(os,11,4, _voltage[i]);
00257                         complex_out(os,11,4, _current[i]);
00258                         complex_out(os,11,4, _impedance[i]);
00259                         complex_out(os,11,4, _admittance[i]);
00260                         real_out(os,11,4, _power[i]);
00261                         os &lt;&lt; endl;
00262                 }
00263         }
00264 };
00265 
00266 <span class="comment">/*</span>
00267 <span class="comment">        Stores a nec_result </span>
00268 <span class="comment"></span>
00269 <span class="comment">        Usage</span>
00270 <span class="comment">        </span>
00271 <span class="comment">                nec_antenna_input* ai = new nec_antenna_input();</span>
00272 <span class="comment">                s_results.add(ai);</span>
00273 <span class="comment">                ai-&gt;set_intput(tag, segment, voltage, current, impedance, admittance, power);</span>
00274 <span class="comment">                ai-&gt;set_intput(tag, segment, voltage, current, impedance, admittance, power);</span>
00275 <span class="comment">                ai-&gt;set_intput(tag, segment, voltage, current, impedance, admittance, power);</span>
00276 <span class="comment">        </span>
00277 <span class="comment">*/</span>
00278 <span class="keyword">class </span>nec_results
00279 {
00280         vector&lt;nec_base_result*&gt; _results;
00281         <span class="keywordtype">int</span> _n;
00282         <span class="keywordtype">bool</span> _file_out;
00283         
00284 <span class="keyword">public</span>:
00285         
00286         nec_results()
00287         {
00288                 _n = 0;
00289                 _file_out = <span class="keyword">false</span>;
00290         }
00291 
00292         <span class="comment">// On destruction we write to a file.</span>
00293         ~nec_results()
00294         {
00295                 <span class="comment">// write_to_file();</span>
00296                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;_n;i++)
00297                 {
00298                         <span class="keyword">delete</span> _results[i];
00299                         _results[i] = NULL;
00300                 }
00301         }
00302         
00303         <span class="keywordtype">void</span> add(nec_base_result* br)
00304         {
00305                 _results.push_back(br);
00306                 _n++;
00307         }
00308         
00309         <span class="keywordtype">void</span> write_to_file()
00310         {
00311                 <span class="keywordflow">if</span> (<span class="keyword">false</span> == _file_out)
00312                         <span class="keywordflow">return</span>;
00313                         
00314                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;_n;i++)
00315                 {
00316                         <span class="keywordflow">if</span> (_results[i]-&gt;write_file())
00317                         {
00318                                 _results[i]-&gt;write_to_file(cout);
00319                                 _results[i]-&gt;set_write_file(<span class="keyword">false</span>);
00320                         }
00321                 }
00322         }
00323         
00324         <span class="keywordtype">void</span> set_stdout(<span class="keywordtype">bool</span> f)
00325         {
00326                 _file_out = f;
00327         }
00328 };
00329 
00330 <span class="preprocessor">#endif </span><span class="comment">/* __nec_results__ */</span>
00331 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Nov 23 11:15:17 2004 for nec++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
