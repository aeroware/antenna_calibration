
function [AA,EE,HH,SS]=FieldFarConcept(ant,Op,er,m,opt,num)

% [AA,EE,HH,SS]=FieldFarConcept(ant,Op,er,m,Opt,Num) calculates far field 
% generated by the currents Op.Curr and Op.ConceptCurr excited on the given
% antenna system. 
%
% %   Input parameters :
%
%       ant...          antenna structure
%       Op...           structure describing the antenna operation
%       er...           vector of unit vectors pointing to the direction 
%                       where the fields are calculated.
%       m...            number of feed  
%       opt...          if set to 'SS'. the function returns the magnitude
%                       of the poynting flux.
%       num...          Method of integration Num==1: numerically 
%                                             Num==0: analytically 
%
%   Output parameters:
%
%       AA...   vector potential far field without factor exp(-jkr)/r
%       EE...   electric far field without factor exp(-jkr)/r
%       HH...   magnetic far field without factor exp(-jkr)/r
%       SS...   poynting vector field without factor exp(-jkr)/r
%
% The returned field vectors AA, EE and HH do not take into account the 
% spherical wave factor exp(-j*k*r)/r, which is a function of the distance
% r from the origin. So the following vectors are actually returned:
%   
%   AA = mu/(4*pi) Int I(r') exp(j*k*er.r') ds'
%          
%   EE = - k/(w*eps) * er x HH
%
%   HH = - j*k/mu * er x AA
%
%   SS = 1/2 EE x HH* = k/(2*w*eps) * |HH|^2 * er
%
% The quantities are calculated for the radiation directions defined in er 
% by rows. er is n x 3, where n is the number of directions requested. AA, 
% EE and HH are arrays the same size as er, containing the vectors as 
% defined above in the corresponding rows. SS actually not returns vectors 
% but amplitudes, i.e. the components er.SS=k/(2*w*eps)*|HH|^2 for each 
% given direction, so SS is n x 1.
% 
% For reasons mentioned above the proper complex field vectors can
% be determined from the corresponding returned quantities by:
%
%   A = exp(-j*k*r)/r * AA
%   E = exp(-j*k*r)/r * EE
%   H = exp(-j*k*r)/r * HH
%   S = exp(2*Im(k)*r)/r^2 * SS  
%
% The time-average power flow P through the unit solid angle is then 
% easily calculated by (Im(k)<0 represents attenuation):
%  
%   P = real(r^2 * S) = real(exp(2*Im(k)*r) * SS)
%
% opt offers the possibility to compute only the magnitude of the
% Poynting flux:
%
%   SS=FieldFar(Ant,Op,er,m,'SS') returns only SS.
%   
% This function currently only works with wiregrids. It does not support
% patches.
%
% Written by Thomas Oswald, 2006
%
% Nov 2010 including plasma

Nint=300; % number of integration steps

w=2*pi*Op.Freq; % omega

[k,eps,mu]=Kepsmu(Op);

er=er./repmat(Mag(er,2),[1,3]);  % ensure unit vectors

% plasma effect:

epsilon_r=Op.Exte(2);

eps=eps*epsilon_r;
k=k*sqrt(epsilon_r);

Ner=size(er,1);  % number of directions

%AA=zeros(Ner,3);
AA=0;

Nsegs=size(ant.Desc,1);
l=SegLength(ant);

if (nargin<6)
  num=2;    % analytical
end % if

[relbase,basecoord]=CGetBasePosition(ant);

% vector potential

% integal
if(num==1)
    for s=1:Nsegs  % for all segments   
        r1=ant.Geom(ant.Desc(s,1),:);
        r5=ant.Geom(ant.Desc(s,2),:);
        
        % Length of segment.
        
        L=l(s);        
        
        % Unit vector in segment direction.
        
        ez=(r5-r1)./L;            
        
        I1=Op.Curr(m,s,1);   % I(z1)
        I2=Op.ConceptCurr(m,s,1);
        I3=Op.ConceptCurr(m,s,2);
        I4=Op.ConceptCurr(m,s,3);
        I5=Op.Curr(m,s,2);   % I(z2)
        
        AA=AA+ez*L*(I1/2)*exp(j*k*dot(er,r1))/Nint;
        AA=AA+ez*L*(I5/2)*exp(j*k*dot(er,r5))/Nint;
        
        for(n=2:Nint)    % Nint integration steps
            rel=(n-1)/Nint;
            
            if(rel<=relbase(s,1))
                I=I1+(I2-I1)*rel/(relbase(s,1));
                
                else if(rel<=relbase(s,2))
                    I=I2+(I3-I2)*(rel-relbase(s,1))/(relbase(s,2)-relbase(s,1)); 
                    
                    else if(rel<=relbase(s,3))
                        I=I3+(I4-I3)*(rel-relbase(s,2))/(relbase(s,3)-relbase(s,2)); 
                        else 
                            I=I4+(I5-I4)*(rel-relbase(s,3))/(1-relbase(s,3)); 
                        end %else
                    end %else if
                end % else if    
                
                r=r1+ez*L*rel;
            
                AA=AA+ez*L*I*exp(j*k*dot(er,r))/Nint;
            end% for all steps         
         end %for all segments
else    % analytical
    for ed=1:Nsegs  % for all edges   
        r(1,:)=ant.Geom(ant.Desc(ed,1),:);
        r(2,:)=basecoord(ed,1,:);
        r(3,:)=basecoord(ed,2,:);
        r(4,:)=basecoord(ed,3,:);
        r(5,:)=ant.Geom(ant.Desc(ed,2),:);
        
        I(1,:)=Op.Curr(m,ed,1);   % I(z1)
        I(2,:)=Op.ConceptCurr(m,ed,1);
        I(3,:)=Op.ConceptCurr(m,ed,2);
        I(4,:)=Op.ConceptCurr(m,ed,3);
        I(5,:)=Op.Curr(m,ed,2);   % I(z2)
        
        % unit vector in edge direction
        
        ez=(r(5,:)-r(1,:))./l(ed); % unit vector 
        
        for s=1:4   % sor all segments
        % Length of segment.
        
            L=norm(r(s+1,:)-r(s,:),'fro');        
        
        
            %x=er*ez.';
            x=dot(er,ez);
            expo=exp(0.5*i*k*x*L);
            
            Integral1=I(s)*expo*Sinq(0.5*k*x*L);
            
            
            Integral2=0.5*i*(I(s+1)-I(s))*expo*sinqe(0.5*k*x*L);  %(k*x*L)^2*(expo*(i*k*x*L-1)+1);
            
                
            AA=AA+ez*L*exp(i*k*dot(er,r(s,:)))*(Integral1+Integral2);
         end% for all segments         
     end %for all segments

end % analytical 

AA=AA*(mu/4/pi);

if 0==1,   % check different ways of calculating SS:
  HH=(-j*k/mu).*cross(er,AA,2);
  EE=(-k/w/eps).*cross(er,HH,2);
  SS=(k/2/w/eps)*Mag(HH,2).^2;
  SS2=(k/2/w/mu)*Mag(EE,2).^2;
  SS3=(w*conj(k)/2/mu)*Mag(cross(er,AA,2),2).^2; 
  max(abs(1-SS(:)./SS2(:)))
  max(abs(1-SS(:)./SS3(:)))
end % if

if nargout>1,
  
  HH=(-j*k/mu).*cross(er,AA,2);
  EE=(-k/w/eps).*cross(er,HH,2);
  if nargout>3,
    SS=(k/2/w/eps)*Mag(HH,2).^2;
  end

elseif nargin>4,
  
  if ischar(opt),
    AA=(w*conj(k)/2/mu)*Mag(cross(er,AA,2),2).^2;  % return SS in AA
  end
  
end

