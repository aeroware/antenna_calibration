============================================================

function Ant=AbsorbNodes(Ant0,Nodes)

% Ant=AbsorbNodes(Ant0) adds the nodes which are on edges of patches
% to the respective patches. 
%
% Ant=AbsorbNodes(Ant0,Nodes) restricts the function to the node 
% numbers given in Nodes.

Ant=Ant0;

if ~exist('Nodes','var'),
  Nodes='all';
end
if ischar(Nodes),
  Nodes=1:size(Ant.Geom,1);
end
Nodes=intersect(Nodes(:),1:size(Ant.Geom,1));
if isempty(Nodes),
  return
end

nn=length(Nodes);

r=Ant.Geom(Nodes,:);

d=max(Mag(Ant.Geom,2))/1e5;

for p=1:numel(Ant.Desc2d),
 pat=Ant.Desc2d{p}(:);
 newpat=cell(2,numels(pat));
 for n=1:length(pat),
   r1=Ant.Geom(pat(n),:);
   r2=Ant.Geom(pat(mod(n,length(pat))+1),:);
   e=r2-r1;
   L=(e*e');
   e=e./L;
   tau=e*(r-repmat(r1,nn,1)).';
   dist=Mag(cross(repmat(e,nn,1),r-repmat(r1,nn,1)),2).';
   newpat{1,n}=pat(n);
   newpat{2,n}=Nodes((tau<L-d)&(tau>d)&(dist<d));
 end
 Ant.Desc2d{p}=[newpat{:}];
end


   
============================================================
  
function varargout=FindGridObj(Ant,varargin)

% [Points,Wires,Surfs]=FindGridObj(Ant) returns the grid objects
% in the antenna grid Ant. The objects are defined in the field
% Ant.Obj, which itself is a structure array having these fields:
%   Ant.Obj().Type  string determining the type of object:
%                   'Point', 'Wire' or 'Surf'
%   Ant.Obj().Name  string, name of object
%   Ant.Obj().Elem  vector of elements building up the object,
%                   giving nodes, segments or patches, respectively.
%   Ant.Obj().Graf structure of graphical (line or patch) properties.
% Points, Wires and Surfs return the indices of objects wich are composed
% of points, wires and surfaces, respectively. For instance, the wire
% objects can be accessed by Ant.Obj(Wires), etc.
%
% Objs=FindGridObj(Ant,varargin)
% finds the grid objects in Ant which have the properties given by
% varargin, which is any list of property specifications:
% {property name (string), property value, ...}.
% Objs returns for the found objects the indices into Ant.Obj.

% Rev. Feb. 2008
% Original name GridFindObj changed to FindGridObj to prevent 
% confusion with old version which worked differently.

varargout={[],[],[]};

if ~isfield(Ant,'Obj'),
  return
end

if nargin>1, % Objs=FindGridObj(Ant,varargin)
  
  f=varargin(1:2:end);
  v=varargin(2:2:end);
    
  Objs=ones(length(Ant.Obj),1);
  
  for n=1:length(Ant.Obj),
    Objn=Ant.Obj(n);
    for m=1:length(f),
      try 
        ofi=Objn.(f{m});
      catch
        ofi=[];
        Objs(n)=0;
      end
      if ~isequal(v{m},ofi),
        Objs(n)=0;
        break
      end
    end
  end
  
  varargout={find(Objs)};
  
else % [Points,Wires,Surfs]=FindGridObj(Ant)
  
  if isempty(Ant.Obj), return, end
  
  t=cellfun(@(x)(lower(char(x))),{Ant.Obj.Type},'UniformOutput',false);
  Points=find(ismember(t,{'point',char(0)}));
  Wires=find(ismember(t,{'wire',char(1)}));
  Surfs=find(ismember(t,{'surf',char(2)}));
  
  varargout={Points(:),Wires(:),Surfs(:)};
    
end
  
============================================================

function [LNodes,LSegs,LLen]=FindLines(Desc,Nodes,MaxEndSegs)

% [LNodes,LSegs,LLen]=FindLines(Desc,Nodes,MaxEndSegs) 
% find segment-lines starting at the given Nodes and ending in a node 
% connecting at most MaxEndSegs segments. 
% Nodes may contain a vector of nodes.
% For each node the found lines are returned in the cell arrays
% LNodes, LSegs and LLen.  LNodes is a cell array which
% contains the nodes of the lines, LSegs contains the corresponding 
% segments and LLen the number of segments of the respective lines; 
% e.g. LNodes{n}{m}(q) is the q-th node of the m-th line originating 
% from the node Nodes(n), LSegs{n}{m}(q) is the q-th segment of the 
% m-th line originating from the node Nodes(n), and LLen{n}(m) is the
% number of segments the m-th line originating from Nodes(n) 
% consists of. 
% Single-segment lines are also taken into account (these are segments 
% between a single-segment node and an n-segment node with 
% n~=2 and 1<=n<=MaxEndSegs).
% Line-segments the directions of which are opposite to the 
% direction of the line get negative sign. 
% Default for MaxEndSegs is 2, which amounts to returning all  
% lines connected to Nodes which have open ends. 
%
% [LNodes,LSegs,LLen]=FindLines(Desc,[],MaxEndSegs)
% If Nodes=[] is passed, the function finds all 
% lines in the grid description Desc. The lines are the segment 
% strings of maximum length which are connected at nodes where 
% only two segments meet. The optional parameter MaxEndSegs 
% gives the maximum number of segments which may meet at the 
% start- and endnodes of lines. Lines ending at nodes where  
% more than MaxEndSegs meet are omitted. E.g. for MaxEndSegs=1, 
% 'stand-alone' lines are found which are not closed. 
% Default is MaxEndSegs=2, which amounts to returning all stand-alone 
% lines (open and closed). 
% LNodes is a cell array of node strings (vectors of node 
% numbers), which represent the found lines. LSegs is a cell 
% array of the corresponding segment strings (vectors of 
% segment numbers). The number of segments per line is 
% returned in the vector LLen. So the k-th line is composed of 
% LLen(k)=length(LSegs{k}) segments, the segment numbers being 
% the components of the vector LSegs{k}. The corresponding 
% LLen(k)+1=length(LNodes{k}) nodes build the vector LNodes{k}. 
% If the line is closed, the first and the last node numbers 
% are equal: LNodes{k}(1)=LNodes{k}(end).

% Rev. Feb. 2008:
% Now also lines are found which start at Nodes connecting more
% than MaxEndSegs segments. 
% With Nodes=[] the function does what the former function GridLines
% (now subfunction FindAllLines) has done in earlier toolbox versions. 

if (nargin<3)||isempty(MaxEndSegs),
  MaxEndSegs=2;
end
MaxEndSegs=max(1,floor(MaxEndSegs));

if (nargin<2)||isempty(Nodes),
  [LNodes,LSegs,LLen]=FindGridLines(Desc,MaxEndSegs);
  return
end

[Ln,Ls,Ll]=FindAllLines(Desc,inf);

[Segs,NoS]=FindSegs(Desc);
  
Nodes=Nodes(:);
nn=length(Nodes);

LNodes=cell(nn,1);
LSegs=cell(nn,1);
LLen=cell(nn,1);

for n=1:nn,
  no={};
  se={};
  le=[];
  for k=1:length(Ln),
    q=find(Ln{k}==Nodes(n));
    if ~isempty(q),
      if q==1,
        no{end+1,1}=Ln{k};
        se{end+1,1}=Ls{k};
        le(end+1,1)=Ll(k);
      elseif q==length(Ln{k}),
        no{end+1,1}=Ln{k}(end:-1:1);
        se{end+1,1}=-Ls{k}(end:-1:1);
        le(end+1,1)=Ll(k);
      elseif Ln{k}(1)==Ln{k}(end), % 1 closed line
        no{end+1,1}=[Ln{k}(q:end),Ln{k}(2:q)];
        se{end+1,1}=[Ls{k}(q:end),Ls{k}(1:q-1)];
        le(end+1,1)=Ll(k);
      else  % 2 open lines
        no=[no;{Ln{k}(q:end);Ln{k}(q:-1:1)}];
        se=[se;{Ls{k}(q:end);-Ls{k}(q-1:-1:1)}];
        le(end+1:end+2,1)=[Ll(k)-q+1;q-1];
      end
    end
  end
  endn=zeros(length(no),1);
  for k=1:length(endn),
    endn(k)=no{k}(end);
  end
  endn=find(NoS(endn)<=MaxEndSegs);
  LNodes{n}=no(endn);
  LSegs{n}=se(endn);
  LLen{n}=le(endn);
end

end


function [LNodes,LSegs,LLen]=FindAllLines(Desc,MaxEndSegs)

% [LNodes,LSegs,LLen]=FindAllLines(Desc,MaxEndSegs) 
% is called when Nodes=[] is passed in FindLines. 

Nodes=1:max(max(Desc));

[AdSegs,NAd,AdNodes]=FindSegs(Desc,Nodes);

N2=find((NAd==2)|(NAd==1));

NoL=0;  % number of lines found
LNodes={};
LSegs={};
LLen=[];

n=zeros(1,length(N2)+2);
s=zeros(1,length(N2)+1);

while ~isempty(N2),
  f=N2(1);
  if NAd(f)==1,
    n(1:2)=[f,AdNodes{f}];
    s(1)=AdSegs{f};
    L=2;
  else  
    n(1:3)=[AdNodes{f}(1),f,AdNodes{f}(2)];
    s(1:2)=[-AdSegs{f}(1),AdSegs{f}(2)];
    L=3;
  end
  while (NAd(n(L))==2)&&(n(L)~=n(1)),
    n(L+1)=setdiff(AdNodes{n(L)},n(L-1));
    s(L)=setdiff(AdSegs{n(L)},-s(L-1));
    L=L+1;
  end
  n(1:L)=fliplr(n(1:L));
  s(1:L-1)=-fliplr(s(1:L-1));
  while (NAd(n(L))==2)&&(n(L)~=n(1)), 
    n(L+1)=setdiff(AdNodes{n(L)},n(L-1));
    s(L)=setdiff(AdSegs{n(L)},-s(L-1));
    L=L+1;
  end 
  if (NAd(n(1))<=MaxEndSegs)&&(NAd(n(L))<=MaxEndSegs),
    NoL=NoL+1;
    LNodes{NoL,1}=n(1:L);
    LSegs{NoL,1}=s(1:L-1);
    LLen(NoL,1)=L-1;
  end
  N2=setdiff(N2,n(1:L));
end

% set line direction so that positive segments prevail:

for L=1:NoL,
  if length(find(LSegs{L}>0))<LLen(L)/2,
    LNodes{L}=LNodes{L}(end:-1:1);
    LSegs{L}=-LSegs{L}(end:-1:1);
  end
end

end % FindAllLines

============================================================

function [Mnodes,Msegs,Mlen]=FindMonopoles(Desc,Feeds)

% [Mnodes,Msegs,Mlen]=FindMonopoles(Desc,Feeds)
% finds the monopoles which are driven at the given Feeds.
% Mnodes{n}{q} returns the nodes of the q-th monopole originating from 
% Feeds(n), the repective first nodes being Feeds(n). 
% Msegs{n}{q} returns the corresponding monopole segments,
% starting with the segments at the feed, ending with the
% monopole tips. Mlen{n}(q) returns the monopole 'lengths', which 
% is the number of segments of the respective monopoles.

% Rev. Feb. 2008:
% simplified code on the basis of the Revision Feb. 2008 of FindLines.

Feeds=Feeds(:);
if any(real(Feeds)==0),
  Feeds=real(CheckTerminal(Desc,Feeds));
  if any(Feeds==0),
    error('Nonvalid feed definition passed.');
  end
end
Feeds=real(Feeds);

[Mnodes,Msegs,Mlen]=FindLines(Desc,Feeds,1);

============================================================

function EdgeDesc=FindPatchEdges(Ant,Objs,Pats)

% EdgeDesc=FindPatchEdges(Ant,Objs,Pats) finds edges of the patches Pats and 
% the patches in the objects Objs, returning a corresponding description 
% matrix EdgeDesc which contains the start nodes of the edges in the 
% first column and the end nodes in the second column.
% The orientation of the edges in EdgeDesc is the same as in the 
% respective patch definition (positive circulation sense around patch). 
% Pass Pats='all' or Objs='all' to find all patches or all patches in 
% objects, respectively. 
%
% EdgeDesc=FindPatchEdges(Ant) finds all patch edges.

if ~exist('Objs','var'),
  Objs=[];
  Pats='all';
end
if ischar(Objs),
  Objs=1:numel(Ant.Obj);
end

if ~exist('Pats','var'),
  Pats=[];
end
if ischar(Pats),
  Pats=1:numel(Ant.Desc2d);
elseif ~isempty(Objs),
  [Pos,Wis,Sus]=FindGridObj(Ant);
  Sus=intersect(Sus,Objs);
  for n=1:length(Sus),
    Pats=[Pats(:);Ant.Obj(Sus(n)).Elem(:)];
  end
end

Pats=unique(Pats(:));

le=cellfun(@length,Ant.Desc2d(:),'UniformOutput',true);
EdgeDesc=zeros(sum(le(Pats)),2);
lastp=0;

for p=Pats(:).',

  d=Ant.Desc2d{p}(:);
  EdgeDesc(lastp+1:lastp+le(p),1)=d;
  EdgeDesc(lastp+1:lastp+le(p),2)=[d(2:end);d(1)];
  
  lastp=lastp+le(p);
  
end

EdgeDesc=unique(sort(EdgeDesc,2),'rows');




============================================================

function [Pats,NoP,Corners]=FindPats(Desc2d,Nodes,MaxNoP)

% [Pats,NoP,Corners]=FindPats(Desc,Nodes,MaxNoP) returns 
% the patches which meet at the given Nodes. NoP(k) is 
% the number of patches which are based on the k-th given node 
% Nodes(k). The corresponding patch numbers are returned 
% in Pats{k}, whereby Pats is a cell array of the same length
% as Nodes(:). Corners is of the same variable type as Pats, 
% giving to each patch the corner number where the respective
% node is situated within the patch definition.
%
% If MaxNoP is passed, it defines the maximum number of 
% patches returned per node. In this case Pats is a matrix(!) 
% of size length(Nodes(:)) times MaxNoP, and the k-th row 
% contains the respective patch numbers, with Pats(k,m)=0 
% for m>NoP(k). Pass MaxNoP=inf to get a matrix Pats 
% containing all found patches: in this case the row-length 
% agrees with the maximum number of patches meeting at any 
% node of Nodes.
%
% If Nodes is not given or any string, the search is performed 
% for all nodes from 1 to the highest node number in Desc2d.

if iscell(Desc2d),
  Desc2d=GatherMat(Desc2d);
end

if (nargin<2)||ischar(Nodes),
  Nodes=1:max(Desc2d(:));
end
Nodes=Nodes(:);
nn=length(Nodes);

Pats=cell(nn,1);
Corners=cell(nn,1);
NoP=zeros(nn,1);

for k=1:nn,
  [Pats{k},Corners{k}]=find(Desc2d==Nodes(k));
  NoP(k)=length(Pats{k});
end

if nargin>2,

  if isempty(MaxNoP),
    return
  end

  Pats=GatherMat(Pats,MaxNoP);
  Corners=GatherMat(Corners,MaxNoP);
  
end

============================================================

function [Segs,NoS,AdNodes]=FindSegs(Desc,Nodes,MaxNoS)

% [Segs,NoS,AdNodes]=FindSegs(Desc,Nodes,MaxNoS) returns 
% the segments which meet at the given Nodes. NoS(k) is 
% the number of segments connected to the k-th given node 
% Nodes(k). The corresponding segment numbers are returned 
% in Segs{k}, whereby Segs is a cell array of the same length
% as Nodes(:). 
%
% If MaxNoS is passed, it defines the maximum number of 
% segments returned per node. In this case Segs is a matrix(!) 
% of size length(Nodes(:)) times MaxNoS, and the k-th row 
% contains the respective segment numbers, with Segs(k,m)=0 
% for m>NoS(k). Pass MaxNoS=inf to get a matrix Segs containing 
% all found segments: the row-length agrees with the maximum 
% number of segments meeting at any node in Nodes.
%
% Negative segment numbers are returned if the respective node 
% represents the endpoint of the segment. 
%
% AdNodes returns the adjacent nodes, which are connected to Nodes 
% via Segs. The variable type of AdNodes goes with that of Segs,
% so AdNodes{k} (cell-version) or AdNodes(k,1:min(NoS(k),MaxNoS)) 
% (matrix-version) are the nodes connected to the node Nodes(k).
%
% If Nodes is not given or any string, the search is performed 
% for all nodes from 1 to the highest node number in Desc.

if (nargin<2)||ischar(Nodes),
  Nodes=1:max(Desc(:));
end
Nodes=Nodes(:);
nn=length(Nodes);

Segs=cell(nn,1);
AdNodes=cell(nn,1);
NoS=zeros(nn,1);
n=length(Desc);

for k=1:nn,
  [e,d]=find(Desc==Nodes(k));
  if ~isempty(e),
    Segs{k}=-(e.*(-1).^d)';
    AdNodes{k}=Desc(e+n*((d-1)==0))';
    NoS(k)=length(e);
  end
end

if nargin>2,

  if isempty(MaxNoS),
    return
  end

  Segs=GatherMat(Segs,MaxNoS);
  AdNodes=GatherMat(AdNodes,MaxNoS);
  
end


============================================================

function Ant=Grid1dObj(Ant,Type)

% Ant=Grid1dObj(Ant,Type) defines the whole grid as 1d-object. 
% It removes all existing objects and defines new objects of 
% given Type, or the default objects type 'Wire' if Type is 
% 'default' or omitted. 
% The elements (Desc or Desc2d) not needed in these objects are deleted. 
% Furthermore, the physical object dimension 1 is stored in the 
% field Ant.Obj.Phys.Dimension.
% The function is called by the 1d-grid generation functions.

% Written Feb. 2008

if nargin<2,
  Type='Wire';
elseif isempty(Type),
  Type={};
elseif ischar(Type)&&~isempty(findstr(lower(Type),'default')),
  Type='Wire';
end

Ant.Obj(1:end)=[];

Ant=GridObj(Ant,Type,'all');

for n=1:numel(Ant.Obj),
  Ant.Obj(n).Phys.Dimension=1;
end

[po,wi,su]=FindGridObj(Ant);

if isempty(wi),
  Ant.Desc(1:end,:)=[];
end
if isempty(su),
  Ant.Desc2d(1:end,:)=[];
end

============================================================

function Ant=Grid2dObj(Ant,Type)

% Ant=Grid2dObj(Ant,Type) defines grid as 2d-object. 
% It removes all existing objects and defines new objects of 
% given Type, or the default objects Default2dObjType if Type is empty. 
% The elements not needed in these objects are deleted if OnlyObj2dElem. 
% Furthermore, the physical object dimension 2 is stored in the 
% field Ant.Obj.Phys.Dimension.
% The function is called by the 2d-grid generation functions.

% Written Feb. 2008

global Default2dObjType OnlyObj2dElem

if nargin<2,
  Type=Default2dObjType;
elseif isempty(Type),
  Type={};
elseif ischar(Type)&&~isempty(findstr(lower(Type),'default')),
  Type=Default2dObjType;
end

Ant.Obj(1:end)=[];

Ant=GridObj(Ant,Type,'all');

for n=1:numel(Ant.Obj),
  Ant.Obj(n).Phys.Dimension=2;
end

[po,wi,su]=FindGridObj(Ant);

if OnlyObj2dElem,
  if isempty(wi),
    Ant.Desc(1:end,:)=[];
  end
  if isempty(su),
    Ant.Desc2d(1:end,:)=[];
  end
end

============================================================

function Ant1=GridAnalyse(Ant,Freq)


[Points,Wires,Surfs]=FindGridObj(Ant);

% check segments:
% ----------------

Isactive=zeros(size(Desc,1),1);

Tag=nan(size(Desc,1),1);

try
  Cond=Ant.Phys.Wire.Cond;
  if isempty(Cond),
    Cond=nan;
  end
catch
  Cond=nan;
end
Cond=repmat(Cond,size(Desc,1),1);

try
  Radius=Ant.Phys.Wire.Radius;
  if isempty(Radius),
    Radius=nan;
  end
catch
  Radius=nan;
end
Radius=repmat(Radius,size(Desc,1),1);

Objnum=cell(size(Desc,1),1);

for w=numel(Wires),
  s=abs(Obj(Wires(w)).Elem);
  Isactive(s)=1;
  for sn=1:length(s),
    Objnum{s(sn)}=unique([Objnum{s(sn)}(:).',w]);
  end
  try 
    t=Ant.Obj(Wires(w)).Phys.Tag;
    if isempty(t),
      t=nan;
    end
  catch
    t=nan;
  end
  ss=s(isnan(Tag(s)));
  Tag(ss)=t;
  
  
    
end





  
============================================================

function Ant=GridCircle(varargin)

% Ant=GridCircle(Type,r,phi,n) draws a circular arc 
% with radius r and opening angle |phi| in the xy-plane. 
% The arc is drawn counterclockwise or clockwise around 
% the z-axis, depending on wether phi>0 or phi<0. 
% The arc is represented by a polygon of n segments, 
% starting at point (r,0,0). The function returns a 
% closed polygon when phi is omitted or an integer 
% multiple of 2*pi is passed. 
%
% Type specifies the object type(s) to be defined and is optional
% (for more details on Type see GridRevol.m). Here only 
% 'Point' and 'Wire' types are reasonable, for generating disks
% use GridCone.

% Rev. Feb. 2008:
% Implementation of Type


[Type,r,phi,n]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

Ant=GridInit;

pi2=2*pi;

if isempty(phi),
  ClosedCircle=1;
  phi=pi2;
else
  phi=phi-fix(phi/pi2)*pi2;
  ClosedCircle=abs((abs(phi)-pi2)*phi)<1e-10;
  if ClosedCircle,
    phi=pi2;
  end
end

if isempty(n),
  n=max(1,round(abs(phi)/pi*10));  
end;

nn=n+1-ClosedCircle;     % number of nodes

phi=phi/n*(0:nn-1)';  

Ant.Geom=abs(r)*[cos(phi),sin(phi),zeros(nn,1)];

Ant.Desc=zeros(n,2);

if ClosedCircle,
  Ant.Desc=[1:n;2:n,1]';
else
  Ant.Desc=[1:n;2:n+1]';
end

% define objects:

Ant=Grid1dObj(Ant,Type);

============================================================

function Ant=GridCone(varargin)

% Ant=GridCone(Type,t,r1,r2,nr,p,np,npmin) draws a 
% section of a cone with tip (0,0,0) and half-opening 
% angle t. The section extends from azimuth 0 and 
% distance r=r1 from the axis to azimuth p and r=r2. 
% t must be in the interval 0<t<=pi/2. Pass negative 
% r-values to draw in the lower hemisphere. The whole 
% surface grid is composed of nr horizontal polygons 
% (representing circular arcs) around the z-axis and 
% segments connecting the corners of successive polygons.
% np defines the number of segments to be used to represent 
% the horizontal polygons. A negative np sets the number 
% of segments of the first(!) polygon (at radius r1), a 
% positive np only estimates by its magnitude the number 
% of segments to be used for the widest horizontal polygon. 
% The actual number of segments is suitably adjusted so 
% that segment lengths do not vary too much. By npmin the 
% minimum number of segments to be used for horizontal 
% polygons can be defined. If the number of segments
% shall not be automatically adjusted, pass npmin=0.
% Optional parameters are nr,p,np,npmin with the following
% default values: p=2*pi; if one of the parameters np or 
% nr is not given, it is adjusted in such a way that 
% horizontal and meridian segments have similar length. 
% If both are omitted (or empty), np is calculated to
% yield segments which extend about 18 degrees in azimuth
% and nr is adapted accordingly.
%
% Type specifies the object type(s) to be defined and is optional
% (for more details on Type see GridRevol.m).

% Rev. Feb. 2008:
% Implementation of Type
%
% Revision June 2007:
% - Adaptation for change of meaning of sign(np) in GridRevol;
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)

[Type,t,r1,r2,nr,p,np,npmin]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

if isempty(t)||isempty(r1)||isempty(r2)||(r1==r2),
  error('Invalid input arguments.');
end

t=Bound(t,0,pi/2);

if isempty(p),
  p=2*pi;
else
  p=p/2/pi;
  p=p-floor(p);
  if abs((p-1)*p)<1e-10,
    p=1;
  end
  p=p*2*pi;
end

if abs(p*t)<1e-10, 
  error('Requested angular section too small to generate grid cone.');
end

if isempty(npmin)||(npmin==1)||(npmin<0),
  npmin=2;
end

% analyse and adapt nr and np:

Lr=abs(r2-r1)/sin(t);
if isempty(nr),
  if isempty(np),
    np=10/pi*p;
  end
  np=max(npmin,abs(round(np)))*sign(np);
  if np>0, 
    Lp=max(abs([r1,r2]*p));
  elseif r1==0,
    Lp=abs(r2*p);
  else
    Lp=abs(r1*p);
  end
  nr=max(1,ceil(abs(Lr*np/Lp)));
else
  nr=max(1,abs(nr));
  if isempty(np),
    Lp=max(abs([r1,r2]*p));
    np=max(npmin,round(Lp*nr/Lr));    
  end
end

if (np<0)&&(npmin==0),
  np=repmat(np,nr+1,1);
end

% calculate z- and r-vector of first meridian:

r=r1+(r2-r1)/nr*(0:nr)';
z=r*cot(t);
r=abs(r);

% generate grid:

Ant=GridRevol(Type,z,r,np,p,0,npmin);



============================================================

function Ant=GridCuboid(varargin)

% Ant=GridCuboid(Type,a,b,c,ma,mb,mc,Omit) draws a cuboid
% extending into the first quadrant, with one corner at the origin.
% a, b and c define the edges meeting at the origin: scalars 
% determine the lengths of the edges, the respective directions 
% being assumed parallel to the principal axes; vectors define 
% vectorial edges, so that in general a parallelepiped can be
% drawn. ma, mb and mc determine the number of segments to 
% be used per edge, respectively (optional, default=1); they
% can also be vectors giving multiples of a, b and c, 
% respectively, thereby determining the lengths of successive
% segments on the 3 principal edges, starting from the origin.
% The optional parameter Omit defines faces of the cuboid which 
% are not drawn: 3, 1 or 2 for the face oriented towards a x b, 
% b x c or c x a, respectively. Negative values for the 
% corresponding opposite faces.
%
% Type specifies the object type(s) to be defined and is optional
% (for more details on Type see GridRevol).

% Rev. Feb. 2008:
% Implementation of Type
%
% Revision June 2007:
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)

global Default2dObjType OnlyObj2dElem

[Type,a,b,c,ma,mb,mc,Omit]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

% initializing global variables:
Ant=GridInit;           
Default2dObjTypeSave=Default2dObjType;
OnlyObj2dElemSave=OnlyObj2dElem;
Default2dObjType={};
OnlyObj2dElem=0;

if isempty(ma),
  ma=1;
end
if length(ma)==1,
  ma=0:ma;
elseif ma(1)~=0,
  ma(2:end+1)=ma;
  ma(1)=0;
end
if length(a)==1,
  a=[a,0,0];
end
a=ma(:)*a(:)'; % nodes on 1. principal edge

if isempty(mb),
  mb=1;
end
if length(mb)==1,
  mb=0:mb;
elseif mb(1)~=0,
  mb(2:end+1)=mb;
  mb(1)=0;
end
if length(b)==1,
  b=[0,b,0];
end
b=mb(:)*b(:)'; % nodes on 2. principal edge

if isempty(mc),
  mc=1;
end
if length(mc)==1,
  mc=0:mc;
elseif mc(1)~=0,
  mc(2:end+1)=mc;
  mc(1)=0;
end
if length(c)==1,
  c=[0,0,c];
end
c=mc(:)*c(:)'; % nodes on 3. principal edge

% determine the union of the (at most) 6 parallelograms 
% which are the faces of the parallelepiped:

if isempty(Omit),
  Omit=[];
end

[A1,A2]=GridCuboidPlanes(a,b,c(end,:));
if ~ismember(-3,Omit),
  Ant=GridJoin(Ant,A1);
end
if ~ismember(3,Omit),
  Ant=GridJoin(Ant,A2);
end

[A1,A2]=GridCuboidPlanes(b,c,a(end,:));
if ~ismember(-1,Omit),
  Ant=GridJoin(Ant,A1);
end
if ~ismember(1,Omit),
  Ant=GridJoin(Ant,A2);
end

[A1,A2]=GridCuboidPlanes(c,a,b(end,:));
if ~ismember(-2,Omit),
  Ant=GridJoin(Ant,A1);
end
if ~ismember(2,Omit),
  Ant=GridJoin(Ant,A2);
end

% remove multiple nodes and segments:

Ant=GridPack(Ant,0,'',[1,0]);

if Ant.Init>1,
  Ant.Init=Ant.Init-1;
end

% define objects:

Default2dObjType=Default2dObjTypeSave;
OnlyObj2dElem=OnlyObj2dElemSave;

Ant=Grid2dObj(Ant,Type);

end % GridCuboid


% ------- subfunctions ---------

function [A1,A2]=GridCuboidPlanes(r1,r2,d)

% Generate two parallelograms by using edges r1 and r2 as 
% explained in GridParallelogram.  The second par.
% is simply the first offset by the vector d and changed
% in its patch orientation.

[x,y,z]=GridParallelogram(r1,r2);
A1=GridMatrix(x,y,z);
A2=A1;
A2.Geom=A2.Geom+repmat(d(:)',[size(A2.Geom,1),1]);
for n=1:length(A2.Desc2d),
  A2.Desc2d{n}=A2.Desc2d{n}(end:-1:1);
end

end


function [x,y,z]=GridParallelogram(r1,r2)

% Generate plane grid of parallelogram form, r1 and r2
% being nodes along 2 outer edges which meet in the origin.
% x, y and z are matrices representing the plane surface.

n1=size(r1,1);
n2=size(r2,1);

x=repmat(r1(:,1),[1,n2])+repmat(r2(:,1).',[n1,1]);
y=repmat(r1(:,2),[1,n2])+repmat(r2(:,2).',[n1,1]);
z=repmat(r1(:,3),[1,n2])+repmat(r2(:,3).',[n1,1]);

end

============================================================

function Ant=GridCylinder(varargin)

% Ant=GridCylinder(Type,r,z1,z2,nz,p,np,base,ceiling) 
% draws a section of a circular cylinder with radius r
% and opening angle p, the mantle extending from z1 to z2. 
% The whole surface grid is composed of nz horizontal polygons 
% (representing circular arcs) around the z-axis and 
% segments connecting the corners of successive polygons.
% np defines the number of segments to be used to represent 
% the horizontal polygons. 
% Optional parameters are nz,p,np,base,ceiling with the 
% following default values: p=2*pi; if one of the parameters 
% nz or np is not given, it is adjusted in such a way that 
% horizontal and meridian segments have similar length. 
% If both are omitted (or empty), np is calculated to
% yield segments which extend about 18 degrees in azimuth
% and nz is adapted accordingly.
% In order to draw a cylinder base (floor), the corresponding
% variable base is used, which can be a scalar or vector of
% up to 5 components: 
%   [xtype,nr,npmin,rmin,height].
% xtype .. shape of the base (1=cone or disk, 2=sphere),
% nr .. number of horizontal circular arcs, default=automatic
% npmin .. minimum number of segments per arc (0=no variation)
% rmin .. minimum radius, default=0
% height .. height of the whole tip (for rmin=0), 
%           negative values cause drawing into the cylinder
% If not all components are given (only xtype is needed), canonic
% default values are used. The same holds for the ceiling.
%
% Type specifies the object-type(s) to be defined and is optional
% (for more details on Type see GridRevol).

% Rev. Feb. 2008:
% Implementation of Type (object-type).
%
% Revision June 2007:
% - Adaptation for change of meaning of sign(np) in GridRevol;
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)
%
% Revision 22.7.2003:
% correct removal of multiple occurrances at 
% base- and ceiling-contact with mantle

global Default2dObjType OnlyObj2dElem

% initializing global variables:
Ant=GridInit;           
Default2dObjTypeSave=Default2dObjType;
OnlyObj2dElemSave=OnlyObj2dElem;
Default2dObjType={};
OnlyObj2dElem=0;

[Type,r,z1,z2,nz,p,np,base,ceiling]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

if isempty(r)||isempty(z1)||isempty(z2)||(z1==z2),
  error('Invalid input parameters.');
end

r=abs(r);

[z1,z2]=deal(min(z1,z2),max(z1,z2));

if isempty(p),
  p=2*pi;
else
  p=p/2/pi;
  p=p-floor(p);
  if abs((p-1)*p)<1e-10,
    p=1;
  end
  p=p*2*pi;
end

if abs(p)<1e-10, 
  error('Too small cylindrical azimuth-extension requested.');
end

if abs(z2-z1)/(abs(z1)+abs(z2))<1e-10, 
  error('Requested cylinder length too small.');
end

% analyse and adapt nz and np:

npmin=3;

if isempty(nz),
  if isempty(np),
    np=10/pi*p;
  end
  np=max(npmin,abs(round(np)));
  nz=max(1,round(abs((z2-z1)*np/r/p)));
else
  nz=max(1,abs(nz));
  if isempty(np),
    np=r*p*nz/(z2-z1);    
  end
  np=max(npmin,abs(round(np)));
end

np=repmat(np,nz+1,1);

% calculate z- and r-vector of first meridian:

z=z1+(z2-z1)/nz*(0:nz)';
r=repmat(r,nz+1,1);

% generate grid of mantle:

Ant=GridRevol(z,r,np,p,0,[]);

nm=size(Ant.Geom,1); % number of nodes in mantle

nh=sum(Ant.Geom(:,3)==Ant.Geom(1,3)); % number of nodes at same height

% generate base:

if isempty(base), 
  base=[]; 
end
if ~isempty(base),
  if isequal(base(1),0),
    base=[];
  end
end
nb=0;
if ~isempty(base),
  A=GridCylinderTip(r(1),p,np(1),base);
  if ~isempty(A),
    A.Geom(:,3)=-A.Geom(:,3)+min(z1,z2);
    for n=1:length(A.Desc2d),           
      A.Desc2d{n}=flipud(A.Desc2d{n}(:))'; % change patch orientation 
    end
    nb=size(A.Geom,1);
    Ant=GridJoin(Ant,A);
  end
end  

% generate ceiling:

if isempty(ceiling), 
  ceiling=[]; 
end
if ~isempty(ceiling),
  if isequal(ceiling(1),0),
    ceiling=[];
  end
end
nc=0;
if ~isempty(ceiling),
  A=GridCylinderTip(r(1),p,np(1),ceiling);
  if ~isempty(A),
    A.Geom(:,3)=A.Geom(:,3)+max(z1,z2);
    nc=size(A.Geom,1);
    Ant=GridJoin(Ant,A);
  end
end  

% remove multiple occurrances of nodes and segments
% (joints of base and ceiling with mantle):

if isempty(base), 
  NewNodesBase=[];
else
  NewNodesBase=[1:nh,nm+(1:nb-nh)];
end

if isempty(ceiling), 
  NewNodesCeiling=[];
else
  NewNodesCeiling=[nm-nh+1:nm,nm+max(nb-nh,0)+(1:nc-nh)];
end
NewNodes=[1:nm,NewNodesBase,NewNodesCeiling];

Ant.Geom=Ant.Geom([1:nm,nm+1+nh:nm+nb,nm+nb+1+nh:nm+nb+nc],:);

Ant=GridUpdate(Ant,'Nodes',NewNodes,[1,0]);

% define objects:

Default2dObjType=Default2dObjTypeSave;
OnlyObj2dElem=OnlyObj2dElemSave;

Ant=Grid2dObj(Ant,Type);

end % GridCylinder


% --------- subfunction -----------

function T=GridCylinderTip(r,p,np,x)

% This function is used by the function GridCylinder.
% Create tip for cylinder, with basis at z=0 and
% extending into the upper hemisphere for positive
% height x(5), and in the negative hemisphere otherwise.
% r is the radius and p the azimuth angle of the 
% cylinder section, which is devided into np segments. 
% x represents the variable base or ceiling, 
% respectively: x=(xtype,nr,npmin,rmin,height).

x=x(:);
xtype=max(0,x(1));
if length(x)>1,
  nr=x(2);
  if nr<=0, nr=[]; end
else
  nr=[];
end
if length(x)>2,
  npmin=x(3);
  if npmin<0, npmin=2; end
else
  npmin=2;
end
if length(x)>3,
  rmin=max(0,x(4));
else
  rmin=0;
end
if length(x)>4,
  height=abs(x(5));
else
  if xtype==2,
    height=r;
  else
    height=0;
  end
end

if height<1e-5*r(1),
  xtype=1;
end

switch xtype,
  
case 1, % cone
  
  if height==0,
    t=pi/2;
  else
    t=atan(r/height);
  end
  
  T=GridCone(t,-r,-rmin,nr,p,-np,npmin);
  T.Geom(:,3)=T.Geom(:,3)+height;
  
case 2, % sphere
  
  a=(r^2+height^2)/2/height;
  t1=acos((a-height)/a);
  t2=asin(rmin/a);
  T=GridSphere(a,t1,t2,nr,p,-np,npmin);
  T.Geom(:,3)=T.Geom(:,3)-a+height;
  
%case 3, % paraboloid
  
  
otherwise
  
  T=[];
  return
  
end

if length(x)>4,
  if x(5)<0,
    T.Geom(:,3)=-T.Geom(:,3);
  end
end

end % GridCylinderTip

============================================================

function [e,d]=GridEqual(Ant1,Ant2,Perm)

% [e,d]=GridEqual(Ant1,Ant2) checks if the given antenna grid
% structure-variables Ant1 and Ant2 contain the same antenna 
% grid topography, i.e. if they have the same Geom, Desc and
% Desc2d fields, apart from permutations of nodes, segments 
% or patches. d returns the non-coincidences in a vector, 
% where 1, 2 and 3 denote nodes, segments and patches, 
% respectively.
%
% [e,d]=GridEqual(Ant1,Ant2,Perm) with Perm=0 does not accept 
% permutations as equal representations. Perm may be a 3-element 
% vector, the coordinates referring to resp. permutation restriction 
% of [nodes,segments,patches]. Use Perm~=0 to recognize permutations 
% which is equal to the default behaviour of GridEqual(Ant1,Ant2).
% There is one additional feature: Perm(1)=2 also accepts the
% presence of multiple nodes, which amounts to packing nodes before
% the equality test.

if (nargin<3)||isempty(Perm),
  Perm=1;
end
Perm(end+1:3)=Perm(1);

n1=1:size(Ant1.Geom,1);
q1=Ant1.Geom;
if isempty(q1),
  q1=[];
elseif Perm(1),
  if Perm(1)==2,
    [q1,m,n1]=unique(Ant1.Geom);
  else
    [q1,n1]=sortrows(Ant1.Geom);
    n1(n1)=1:size(Ant1.Geom,1);
  end
  n1=n1(:)';
end

n2=1:size(Ant2.Geom,1);
q2=Ant2.Geom;
if isempty(q2),
  q2=[];
elseif Perm(1),
  if Perm(1)==2,
    [q2,m,n2]=unique(Ant2.Geom);
  else
    [q2,n2]=sortrows(Ant2.Geom);
    n2(n2)=1:size(Ant2.Geom,1);
  end
  n2=n2(:)';
end

d=~isequal(q1,q2);

q1=n1(Ant1.Desc);
if isempty(q1),
  q1=[];
elseif Perm(2),
  q1=sortrows(q1);
end

q2=n2(Ant2.Desc);
if isempty(q2),
  q2=[];
elseif Perm(2),
  q2=sortrows(q2);
end

d(2)=~isequal(q1,q2);

q1=GatherMat(Ant1.Desc2d);
q1(:)=MapComp(q1(:),n1);
if isempty(Ant1.Desc2d),
  q1=[];
elseif Perm(3),
  q1=sortrows(q1);
end

q2=GatherMat(Ant2.Desc2d);
q2(:)=MapComp(q2(:),n2);
if isempty(Ant2.Desc2d),
  q2=[];
elseif Perm(3),
  q2=sortrows(q2);
end

d(3)=~isequal(q1,q2);

d=find(d);

e=isempty(d);

============================================================

function [Ant,NewO,NewN,NewS,NewP]=GridExtract(Ant0,Objs,Nodes,Segs,Pats)

% [Ant,NewO,NewN,NewS,NewP]=GridExtract(Ant0,Objs,Nodes,Segs,Pats)
% extracts part of the antenna grid Ant0. The objects, nodes, 
% segments and patches which are to be taken are defined by Obj, Nodes, 
% Segs and Pats. The nodes which are needed to define the extracted 
% segments and patches are added to the extracted nodes, they need 
% not be given explicitly. If only certain segments or patches and 
% their end nodes shall be extracted, set Nodes=[]; similarly, all 
% elements building the objects Objs are automatically extracted.
% Pass 'all' (or any string) to extract all objects or elements of the 
% respective type. Pass only Ant0 to extract all objects, segments and 
% patches, which amounts to removing 'unused' nodes. 
%
% NewO, NewN, NewS and NewP are index vectors which give the new 
% object-, node-, segment- and patch-numbers as a function of the old 
% ones, respectively. Indices of removed elements are set to 0.

Objs0=length(Ant0.Obj);
Nodes0=size(Ant0.Geom,1);
Segs0=size(Ant0.Desc,1);
Pats0=length(Ant0.Desc2d);

if nargin<2,
  Objs=1:Objs0;
  Nodes=[];
  Segs=1:Segs0;
  Pats=1:Pats0;
end

if ischar(Objs),
  Objs=1:Objs0;
end

if ~exist('Nodes','var'),
  Nodes=[];
end
if ischar(Nodes),
  Nodes=1:Nodes0;
end

if ~exist('Segs','var'),
  Segs=[];
end
if ischar(Segs),
  Segs=1:Segs0;
end

if ~exist('Pats','var'),
  Pats=[];
end
if ischar(Pats),
  Pats=1:Pats0;
end

% copy antenna grid:

Ant=Ant0;  

% extract objects and add object-composing elements:

Objs=intersect(abs(Objs),1:Objs0);

Ant.Obj=Ant0.Obj(Objs);          

for n=1:length(Ant.Obj),
  switch Ant.Obj(n).Type,
  case 'Point',
    Nodes=[Nodes(:);Ant.Obj(n).Elem(:)];
  case 'Wire',
    Segs=[Segs(:);Ant.Obj(n).Elem(:)];
  case 'Surf',
    Pats=[Pats(:);Ant.Obj(n).Elem(:)];
  end
end

NewO=zeros(Objs0,1);
NewO(Objs)=(1:length(Objs))';

% extract segments and add segment-defining nodes:

Segs=intersect(abs(Segs),1:Segs0);

Ant.Desc=Ant0.Desc(Segs,:);      

Nodes=[Nodes(:);Ant.Desc(:)];

NewS=zeros(Segs0,1);
NewS(Segs)=(1:length(Segs))';

Ant=GridUpdate(Ant,'Segs',NewS);

% extract patches and add patch-defining nodes:

Pats=intersect(abs(Pats),1:Pats0);

Ant.Desc2d=Ant0.Desc2d(Pats);    

for n=1:length(Ant.Desc2d),
  Nodes=[Nodes(:);Ant.Desc2d{n}(:)];
end

NewP=zeros(Pats0,1);
NewP(Pats)=(1:length(Pats))';

Ant=GridUpdate(Ant,'Pats',NewP);

% extract nodes:

Nodes=intersect(abs(Nodes),1:Nodes0);

Ant.Geom=Ant0.Geom(Nodes,:);     

NewN=zeros(Nodes0,1);
NewN(Nodes)=(1:length(Nodes))';

Ant=GridUpdate(Ant,'Nodes',NewN);

============================================================

function Ant=GridFlip(Ant0,Segs,Pats,AdaptObjs)

% Ant=GridFlip(Ant0,Segs,Pats) reverses the order of nodes in the 
% definition of the segments Segs and the patches Pats. So the 
% orientations of the given segments and patches are changed.
%
% Ant=GridFlip(Ant0,Segs,Pats,AdaptObjs) additionaly adapts the
% objects AdaptObjs so that their elements keep the same orientation.
% This is achieved by changing the sign of those elements of 
% Ant.Obj(AdaptObj).Elem which are identified by Segs or Pats.
% All other object elements do not change sign, so they 
% change their orientation if in Segs/Pats because the respective
% segments or patches are flipped.

% Added to grid toolbox 15.4.2003
%
% Rev. Feb. 2008:
% Object adaptation for AdaptObjs implemented.

if nargin<2,
  Segs=[];
elseif ischar(Segs),
  Segs=1:size(Ant0.Desc,1);
end
Segs=intersect(1:size(Ant0.Desc,1),abs(Segs));

if nargin<3,
  Pats=[];
elseif ischar(Pats),
  Pats=1:length(Ant0.Desc2d);
end
Pats=intersect(1:length(Ant0.Desc2d),abs(Pats));

Ant=Ant0;

Ant.Desc(Segs,:)=fliplr(Ant0.Desc(Segs,:));  

for n=Pats(:).',
  Ant.Desc2d{n}=Ant0.Desc2d{n}(end:-1:1);
end

if nargin<4,
  AdaptObjs=[];
elseif ischar(AdaptObjs),
  AdaptObjs=1:length(Ant0.Obj);
end
AdaptObjs=unique(intersect(1:length(Ant0.Obj),abs(AdaptObjs)));

if isempty(AdaptObjs),
  return
end

[Points,Wires,Surfs]=FindGridObj(Ant);

if ~isempty(Segs),
  for n=intersect(AdaptObjs(:),Wires(:)).'
    m=ismember(abs(Ant.Obj(n).Elem),Segs);
    Ant.Obj(n).Elem(m)=-Ant.Obj(n).Elem(m);
  end
end

if ~isempty(Pats),
  for n=intersect(AdaptObjs(:),Surfs(:)).'
    m=ismember(abs(Ant.Obj(n).Elem),Pats);
    Ant.Obj(n).Elem(m)=-Ant.Obj(n).Elem(m);
  end
end

    
    
============================================================

function Ant=GridInit(Ant0,ResetFields)

% Ant=GridInit(Ant0,ResetFields) initializes antenna structure: 
% The 'grid fields' 
%   Geom, Desc, Desc2d, Obj, Default 
% are initialized if not yet present. The field Init is created after 
% initialization and in future calls of GridInit the field Init will
% not be changed if it still exists. 
% When the optional parameter ResetFields=1 is passed, initialization of
% the 'grid field' is forced. If ResetFields is a cell array 
% of strings, only the fields with the given names are reset to their 
% respective initial value. All other present fields 
% (i.e. non-'grid fields') remain unchanged.
%
% Ant=GridInit creates a new initialized antenna structure with
% the above mentioned fields.

% Rev. Mar. 2009:
% The global variable Atta_CumulativeGridFields added and
% implemented in GridJoin. Atta_CumulativeGridFields declares which 
% fields of an antenna struct are cumulative, i.e.
% which fields are appended instead of overwritten when joining two
% grids; e.g. all element fields (.Geom, .Desc and .Desc2d) and
% the objects field (.Obj) are cumulative, whereas the 
% .Default field must be non-cumulative (here appending 
% would generate an array of tantamount default values and so 
% unresolvable ambiguities).
%
% Rev. Jan. 2009:
% Fields for default values introduced:
%   Default.CONCEPT.Wire.NBases, Default.CONCEPT.Feeds.Posi,
%   Default.CONCEPT.Loads.Posi,
%   Default.ASAP.Inte
%
% Rev. Nov. 2008:
% Fields for default values introduced:
%   Default.Wire.Diam, Default.Wire.Cond, 
%   Default.Surf.Thick, Default.Surf.Cond.
% Ant.Init is set to 0 (or reset to 0 if empty or not yet present).
%
% Revision Feb. 2008:
% Obj-field 'GraphProp' replaced with 'Graf',
% new Obj-field 'Phys' added;
% Introduction of global variables Default2dObjType and OnlyObj2dElem,
% and corresponding funcionality (see also GridInit).
%
% Revision June 2007:
% Implementation of GlobalMaxPatchCorners, which defines the 
% maximum number of Corners a patch may have. This affects the
% generation of patches in the grid routines GridRevol, GridSphere, 
% GridMatrix, etc.

% define global variables characterizing grid creation behaviour:
% ---------------------------------------------------------------

global GlobalMaxPatchCorners Default2dObjType OnlyObj2dElem

% Default2dObjType prescribes the default objects which are to 
% be defined when 2d grid structures are created which may be 
% composed of segments ('Wire' object) or of patches ('Surf' object).  
% Behavior of previous toolbox versions can be forced 
% by defining Default2dObjType={}.
% Default2dObjType={'Wire','Surf'} forces the generation of both,
% a Wire as well as a Surf object.
% OnlyObj2dElem=1: only 2d-elements which are used in the
% objects defined by Default2dObjType are generated in the
% grid creation routines (GridSphere, etc.).
% OnlyObj2dElem=0: all segments and patches of 2d grids are 
% generated, no matter if objects are defined.

if ~iscell(Default2dObjType)&&isempty(Default2dObjType),
  Default2dObjType={'Wire','Surf'};
end
if isempty(OnlyObj2dElem),
  OnlyObj2dElem=1;
end

% Maximum number of corners allowed in the generation of patches:

if isempty(GlobalMaxPatchCorners),
  GlobalMaxPatchCorners=4;
end

% Declare cumulative grid fields:

global Atta_CumulativeGridFields

if isempty(Atta_CumulativeGridFields),
  Atta_CumulativeGridFields={'Geom','Desc','Desc2d','Obj','Bodies'};
end


% Initialize Ant structure:
%---------------------------

% Fields to be created in Ant:
GridFields={'Geom','Desc','Desc2d','Obj','Default'};

if nargin>0,
  Ant=Ant0;
else 
  Ant=struct('Geom',zeros(0,3));
end

if ~exist('ResetFields','var')||isempty(ResetFields),
  ResetFields={};
elseif ~iscell(ResetFields),
  ResetFields=GridFields;
end
ResetFields=ResetFields(:);

PresentFields=fieldnames(Ant);
insefi=intersect(PresentFields,GridFields);
for f=insefi(:).',
  if isempty(Ant.(f{1})),
    ResetFields=union(ResetFields,f);
  end
end

ResetFields=union(setdiff(GridFields,PresentFields),ResetFields);

% sort according to order in GridFields:
[q,loc]=ismember(GridFields,ResetFields);
if ~isempty(loc),
  loc=loc(loc~=0);
  loc=loc(:);
  ResetFields=ResetFields([loc;setdiff(1:length(ResetFields),loc)]);
end

for f=ResetFields(:).',
  switch f{1},
    case 'Geom',
      Ant.Geom=zeros(0,3);
    case 'Desc',
      Ant.Desc=zeros(0,2);
    case 'Desc2d',
      Ant.Desc2d=cell(0,1);
    case 'Obj',
      Ant.Obj=struct('Type','','Name','','Elem',[],'Graf',[],'Phys',[]);
      Ant.Obj(1)=[];
    case 'Default',
      Ant.Default.Wire.Diam=1e-2;
      Ant.Default.Wire.Cond=50e6;
      Ant.Default.Surf.Thick=1e-2;
      Ant.Default.Surf.Cond=50e6;
      Ant.Default.CONCEPT.Wire.NBases=3;
      Ant.Default.CONCEPT.Feeds.Posi='m';
      Ant.Default.CONCEPT.Loads.Posi='m';
      Ant.Default.ASAP.Inte=200;
      Ant.Exterior.epsr=1;
    otherwise
      Ant.(f{1})=[];
  end
end
  
if ~isfield(Ant,'Init')||isempty(Ant.Init),
  Ant.Init=0;
end

============================================================

function Ant=GridJoin(Ant1,Ant2,Con1,Con2,Opt,ConName)

% Ant=GridJoin(Ant1,Ant2,Con1,Con2,Opt,ConName)
% puts together the two antenna grids Ant1 and Ant2. Additionally,
% the nodes Con1 of grid 1 are connected to the nodes Con2
% of grid 2. Con1 and Con2 are optional: If both are omitted 
% or empty, no connections are added. In case Con1 and Con2 are
% non-empty and length(Con1)>length(Con2), Ant2.Geom(Con2,:) are 
% connected to the respectively closest nodes of Ant1.Geom(Con1,:);
% vice versa for length(Con1)<length(Con2); in these cases
% a warning message is printed when the optional parameter Opt 
% is not given, so set Opt=0 to omit the warning message.
% By passing Opt=1 a connection of Con2-nodes to closest nodes 
% of Con1 is forced; vice versa by setting Opt=2. 
% If Con1 is a string all nodes of Ant1 are used, similarly for Con2.
% If a string ConName is passed, the added connections are collected 
% in one new object of type 'Wire' with the name ConName. This object 
% is generated as the last object in the resulting structure: 
% Ant.Obj(end). If a Wire object with name ConName already exists,
% the connections are added to the elements of this object.
%
% Ant.Init is set to Ant1.Init+Ant2.Init, so successive GridJoin
% calls count the number of joined grids in the field Init.

% Rev. Mar. 2009:
% The global variable Atta_CumulativeGridFields added and
% declared in GridInit (see there for explanation).


global Atta_CumulativeGridFields

if ~isfield(Ant1,'Init'),
  Ant1=GridInit(Ant1);
end

if ~isfield(Ant2,'Init'),
  Ant2=GridInit(Ant2);
end

if nargin<3,
  Con1=zeros(0,1);
elseif ischar(Con1),
  Con1=1:size(Ant1.Geom,1);
end
Con1=Con1(:);
Con1=Con1(Con1<=size(Ant1.Geom,1));

if nargin<4,
  Con2=zeros(0,1);
elseif ischar(Con2),
  Con2=1:size(Ant2.Geom,1);
end
Con2=Con2(:);
Con2=Con2(Con2<=size(Ant2.Geom,1));

if isempty(Con1)||isempty(Con2),
  Con1=zeros(0,1);
  Con2=zeros(0,1);
end

if nargin<5,
  Opt=[];
end

if (length(Con1)~=length(Con2)) && ~(isequal(Opt,1)||isequal(Opt,2)),
  Warn=~isequal(Opt,0);
  if length(Con2)<length(Con1),
    Opt=1;
  else
    Opt=2;
  end
  if Warn,
    warning(['GridJoin option set to ',num2str(Opt),'.']);
  end
end

if isequal(Opt,1),
  C=GridNearest(Ant1.Geom(Con1,:),Ant2.Geom(Con2,:));
  Con1=Con1(C,1);
elseif isequal(Opt,2),
  C=GridNearest(Ant2.Geom(Con2,:),Ant1.Geom(Con1,:));
  Con2=Con2(C,1);
end

f1=fieldnames(Ant1);
f2=fieldnames(Ant2);
fc=intersect(f1,f2); 
fc=setdiff(fc,{'Init'});

Ant=SetStruct(Ant1,Ant2);

Ant.Init=Ant1.Init+Ant2.Init;

% append fields of Ant2 to the corresponding fields of Ant1:

for m=1:length(fc),
  f=fc{m};
  s=Ant1.(f);
  if ~ismember(f,Atta_CumulativeGridFields),
    if isstruct(s),
      Ant.(f)=SetStruct(s,Ant2.(f));
    else
      Ant.(f)=Ant2.(f);
    end
  else
    if isstruct(s),
      Ant.(f)=AppStruct(s,Ant2.(f));
    elseif isequal(f,'Desc2d'),
      Ant.(f)=[s(:);Ant2.Desc2d(:)];
    else
      Ant.(f)=[s;Ant2.(f)];
    end
  end
end

% Update Desc, Desc2d and Obj:

n1=size(Ant1.Geom,1);
s1=size(Ant1.Desc,1);
p1=length(Ant1.Desc2d);
o1=length(Ant1.Obj);

Ant.Desc(s1+1:end,:)=Ant.Desc(s1+1:end,:)+n1;  

ConSegs=size(Ant.Desc,1)+(1:length(Con1));     % added connections
Ant.Desc(ConSegs,:)=[Con1,Con2+n1];

for p=(p1+1):(p1+length(Ant2.Desc2d)),
  Ant.Desc2d{p}=Ant.Desc2d{p}+n1;
end

[Points,Wires,Surfs]=FindGridObj(Ant2);

for n=Points(:)'+o1,
  Ant.Obj(n).Elem=(abs(Ant.Obj(n).Elem)+n1).*sign(Ant.Obj(n).Elem);
end

for n=Wires(:)'+o1,
  Ant.Obj(n).Elem=(abs(Ant.Obj(n).Elem)+s1).*sign(Ant.Obj(n).Elem);
end

for n=Surfs(:)'+o1,
  Ant.Obj(n).Elem=(abs(Ant.Obj(n).Elem)+p1).*sign(Ant.Obj(n).Elem);
end

% generate connection object:

if nargin<6,
  ConName=[];
end
if ~ischar(ConName),
  return
end

o=FindGridObj(Ant,'Type','Wire','Name',ConName);

if isempty(o),
  Ant=GridObj(Ant,'Wire',ConName,ConSegs);
else
  for n=o(:)',
    Ant.Obj(n).Elem=union(Ant.Obj(n).Elem,ConSegs);
  end
end

============================================================

function Ant=GridLine(varargin)

% Ant=GridLine(Type,r,n)
% draws a line from the r(1,:) to r(2,:) to r(3,:) etc., i.e.
% a string of straight lines connecting the points r(1,:), r(2,:), etc.
% r is a matrix the rows of which define the points which are 
% to be connected (so r must have 3 colums and at least two rows).
% n is the number of segments to be used for each straight line; 
% a vector n may be passed to define the segmentation of each 
% straight line (in such a case length(n)=size(r,1)-1).
% n is optional, default=1, i.e. each straight line is 1 segment.
% Type signifies which object type has to be created, if not passed
% the default is as defined by Default2dObjType and OnlyObj2dElem.

% Written 28. Feb. 2008

[Type,r,n]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

Ant=GridInit;

if isempty(n),
  n=1;
end
if numel(n)==1,
  n=repmat(n,size(r,1)-1,1);
else
  n=n(:);
end
if length(n)~=size(r,1)-1,
  error('Inconsistent input parameters r and n.');
end

nsegs=sum(n);
Ant.Geom=zeros(nsegs+1,3);
Ant.Desc=[1:nsegs;2:nsegs+1].';

k=0;
for m=1:length(n),
  for q=0:n(m)-1, 
    k=k+1;
    Ant.Geom(k,:)=r(m,:)+(r(m+1,:)-r(m,:))*q/n(m);
  end
end
Ant.Geom(end,:)=r(end,:);

% define objects:

Ant=Grid1dObj(Ant,Type);


============================================================

function [Ant,NewPats,SubDiv]=GridMatrix(varargin)

% Ant=GridMatrix(Type,x,y,z,Close,EndCap) generates a surface grid 
% from the matrices x, y and z, which give the coordinates 
% of points lying on the surface. The indices of the matrices
% serve as parameters for the surface description.
% The optional argument Close determines if the surface 
% should be closed in the first (Close=1) or second (Close=2)
% parameter (matrix dimension). EndCap defines optional
% end caps: -1 for a cap enclosed by the first coordinate line
% of the first parameter (index), i.e. lowest second parameter;
% -2 for the first coordinate line of the second parameter 
% (index), i.e. lowest first parameter; positive values 
% indicate the respective last coordinate lines (highest 
% index value of fixed parameter). Define several end caps 
% by a vector of values.
% All returned patches have the same orientation, namely
% expressed in matrix indices: (1,1) (1,2) (2,2) (2,1).
%
% Type specifies the object type(s) to be defined and is optional
% (for more details on Type see GridRevol.m).

% Rev. Feb. 2008:
% Implementation of Type
%
% Revision June 2007:
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)


global GlobalMaxPatchCorners;

[Type,x,y,z,Close,EndCap]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

Ant=GridInit;

if isempty(Close),
  Close=0;
end

% matrix of node numbers for patch corners:

p=size(x);
if any(p<1),
  return
end
nn=reshape(1:prod(p),p);
if isequal(Close,1)&&~isequal(p(1),1),
  nn=[nn;nn(1,:)];
elseif isequal(Close,2)&&~isequal(p(2),1),
  nn=[nn,nn(:,1)];
else 
  Close=0;
end

% generate nodes:

Ant.Geom=[x(:),y(:),z(:)];

% generate segments:

if isequal(Close,1),
  f1=nn(1:end-1,:);
  t1=nn(2:end,:);
  f2=nn(1:end-1,1:end-1);
  t2=nn(1:end-1,2:end);
elseif isequal(Close,2),
  f1=nn(1:end-1,1:end-1);
  t1=nn(2:end,1:end-1);
  f2=nn(:,1:end-1);
  t2=nn(:,2:end);
else
  f1=nn(1:end-1,:);
  t1=nn(2:end,:);
  f2=nn(:,1:end-1);
  t2=nn(:,2:end);
end

Ant.Desc=[f1(:),t1(:);f2(:),t2(:)];

% generate patches:

f1=nn(1:end-1,1:end-1);
f2=nn(2:end,1:end-1);
t2=nn(2:end,2:end);
t1=nn(1:end-1,2:end);

D=num2cell([t1(:),t2(:),f2(:),f1(:)],2);

% generate end caps:

if isempty(EndCap),
  EndCap='';
end

if isnumeric(EndCap),
  
  EndCap=unique(EndCap);
  s=size(x);

  for c=EndCap(:)',
    switch c,
      case -1,
        D{end+1,1}=nn(1:s(1),1)';
      case -2,
        D{end+1,1}=nn(1,s(2):-1:1);
      case 1,
        D{end+1,1}=nn(s(1):-1:1,s(2))';
      case 2,
        D{end+1,1}=nn(s(1),1:s(2));
    end
    if length(D{end})<3,
      D=D(1:end-1);
    end
  end

end

Ant.Desc2d=D;

% subdivide patches with more than GlobalMaxPatchCorners nodes:

if isequal(GlobalMaxPatchCorners,3)&&~isempty(Ant.Desc2d),
  [Ant,NewPats,SubDiv]=GridSubPatches(Ant,'all',GlobalMaxPatchCorners);
end

% define objects:

Ant=Grid2dObj(Ant,Type);

============================================================

function Geom=GridMove(Geom0,R,t,dir)

% Ant=GridMove(Ant0,R,t,dir) or Geom=GridMove(Geom0,R,t,dir) 
% moves the grid given by the antenna structure Ant0  or
% by the geometry matrix Geom0 into a new position. 
% The motion is defined by the rotation matrix R and 
% the translation vector t, so rnew=R*rold+t. Instead 
% of the rotation matrix a revolution vector can be 
% passed, which is parallel to the revolution axis and 
% the magnitude of which gives the revolution angle.
% Another alternative is to define 3 initial points
% in the columns of R and the corresponding 3 final 
% points (after motion) in the columns of t. R or t
% can be omitted or left empty to assume no rotation
% or no translation, respectively. The moved grid 
% geometry is returned in the antenna structure Ant or 
% in the geometry field Geom, respectively (depending 
% on the first input argument).  If the optional 
% parameter dir is set to 1, the first column of R and 
% t are not interpreted as points but as initial and 
% final directions, respectively. For dir=2 two colums
% (the first and the second) of R and t are treated 
% in this way.

if (nargin<2)||isempty(R),
  R=eye(3);
end

if (nargin<3)||isempty(t),
  t=[0;0;0];
end

if nargin<4,
  dir=[];
end

% if necessary calculate rotation matrix and 
% translation vector :

if isequal(size(t),[3,3]),  % given 3 initial and 3 final points 

  [R,t]=Motion(R,t,dir);
  
elseif ~isequal(size(R,1),size(R,2)),  % given revolution vector
  
  R=Motion(R);
  
end

% calculate motion (rotation and successive translation):

if isstruct(Geom0),
  Geom=Geom0;
  Geom.Geom=Geom0.Geom*R'+repmat(t(:)',size(Geom0.Geom,1),1);
else
  Geom=Geom0*R'+repmat(t(:)',size(Geom0,1),1);
end

============================================================

function [varargout]=GridNearest(varargin) 
 
% Nodes=GridNearest(Geom,Geom1) finds to each point of Geom1
% the respective nearest node of Geom, so Geom(Nodes(k),:)
% is nearest to Geom1(k,:) among all nodes in Geom.
%
% [Segms,F]=GridNearest(Geom,Desc,Geom1) finds to each 
% point of Geom1 the nearest segment of the grid (Geom,Desc).
% F returns the fraction of the segment from start to end point 
% where the nearest point is found, so the segment which is 
% closest to Geom1(k,:) is Segms(k) and the nearest point on it is 
% Geom(Desc(Segms(k),1),:)*(1-F(k))+Geom(Desc(Segms(k),2),:)*F(k).
%
% [Nodes,F1]=GridNearest(Geom,Geom1,Desc1) finds to each 
% segment of the grid (Geom1,Desc1) the nearest node of Geom.
% F1 returns the fraction of the segment from start to end point 
% where the nearest point is found, so the node which is 
% closest to the segment Desc1(k,:) is Geom(Nodes(k),:) and 
% the nearest point of the segment itself is 
% Geom1(Desc1(k,1),:)*(1-F1(k))+Geom1(Desc1(k,2),:)*F1(k).
%
% Not implemented yet:
% [Segms,F,F1]=GridNearest(Geom,Desc,Geom1,Desc1) finds to each 
% segment of the grid (Geom1,Desc1) the nearest segment of the 
% grid (Geom,Desc). As defined above, F and F1 are the fractions 
% of the segments from start to end point where the respective 
% nearest points are found. F refers to grid (Geom,Desc) and F1
% to the grid (Geom1,Desc1). Segms(k) is the number of the 
% segment of (Geom,Desc) which is closest to the k-th segment 
% of grid (Geom1,Desc1).

if nargin==2, 
  
  % Nodes=GridNearest(Geom,Geom1) 
  
  n=size(varargin{1},1);
  n1=size(varargin{2},1);

  if n*n1==0,
    varargout={};
    return
  end

  varargout={zeros(n1,1)};

  for k=1:n1,
    [m,j]=min(Mag(varargin{1}-repmat(varargin{2}(k,:),n,1),2));
    varargout{1}(k)=j(1);
  end

elseif nargin==4,  % not implemented yet!
  
  % [Segms,F,F1]=GridNearest(Geom,Desc,Geom1,Desc1) 
  
  n=size(varargin{2},1);
  n1=size(varargin{4},1);

  if n*n1==0,
    varargout={};
    return
  end

  varargout={zeros(n1,1),zeros(n1,1)};

  for k=1:n1,
    
    
  end

elseif size(varargin{2},2)==2,
    
  % [Segms,F]=GridNearest(Geom,Desc,Geom1) 
  
  n=size(varargin{2},1);
  n1=size(varargin{3},1);

  if n*n1==0,
    varargout={};
    return
  end

  varargout={zeros(n1,1),zeros(n1,1)};

  ss=varargin{1}(varargin{2}(:,1),:);  % segment start point
  sv=varargin{1}(varargin{2}(:,2),:)-ss;  % segment vector
  
  for k=1:n1,
    G=repmat(varargin{3}(k,:),n,1);
    F=Bound(sum(sv.*(G-ss),2)./sum(sv.*sv,2),0,1);
    [m,j]=min(sum((ss+sv.*[F,F,F]-G).^2,2));
    varargout{1}(k)=j(1);
    varargout{2}(k)=F(j(1));
  end

else
  
  % [Nodes,F1]=GridNearest(Geom,Geom1,Desc1)
  
  n=size(varargin{1},1);
  n1=size(varargin{3},1);

  if n*n1==0,
    varargout={};
    return
  end

  varargout={zeros(n1,1),zeros(n1,1)};
  
  G=varargin{1};
  
  for k=1:n1,
    ss=repmat(varargin{2}(varargin{3}(k,1),:),n,1); 
    sv=repmat(varargin{2}(varargin{3}(k,2),:)-ss(1,:),n,1); 
    F=Bound(sum(sv.*(G-ss),2)./sum(sv.*sv,2),0,1);
    [m,j]=min(sum((ss+sv.*[F,F,F]-G).^2,2));
    varargout{1}(k)=j(1);
    varargout{2}(k)=F(j(1));
  end
   
end





============================================================

function Ant1=GridObj(Ant,Type,Elem,varargin)

% Ant1=GridObj(Ant,Type,Elem,varargin)
% generates (adds) a new grid object with the given specifications. 
% varargin can take any list of property specifications:
% property name (string), property value, ...;
% e.g. 'Name','Sphere1','Graf',struct('Color','r').
% The new object is appended to present ones (Ant.Obj).
% 
% If no object is defined yet (Ant.Obj empty) and Elem is empty, 
% this call defines the whole grid as object of given Type.
% Type may also be a list (cell vector) of types, e.g.
% {'Wire','Surf'}; in this case Elem must be a list of corresponding 
% element sets or 'all':
% Elem='all' causes all elements of given Type to be used in the 
% new object(s).

% Rev. Jan. 2009:
% The field Phys.Dimension of the generated object gets the 
% dimension of the object (1, 2 and 3 for point, wire and surf objects, resp.) 
% The input parameters have been changed:
% Passing the object-fields 'Name' and 'GrafProp' is not obligate any 
% longer, but they can be passed as (property,value) pairs from the 
% 4th input parameter onwards.
% Now 'all' has to be passed to get all Type(s) or Elem(ents). 

if ~isfield(Ant,'Init'),
  Ant1=GridInit(Ant);
  return
else
  Ant1=Ant;
end

if ~exist('Elem','var')||ischar(Elem),
  Elem='all';
end

% check Type:

if ~exist('Type','var'),
  error('No object type defined.');
end

if isempty(Type),
  return
end

if iscell(Type),
  if ~iscell(Elem),
    Elem={Elem};
  end
  if numel(Elem)==1,
    Elem=repmat(Elem,size(Type));
  end
  [Type,ii]=unique(Type);
  Elem=Elem(ii);
  for ty=1:numel(Type),
     Ant1=GridObj(Ant1,Type{ty},Elem{ty},varargin{:});
  end
  return
end

Type=strtrim(Type);

if ~(isequal(Type,'Point')||isequal(Type,'Wire')||isequal(Type,'Surf')),
  error('Invalid Type specification.');
end

% check Elem:

if ischar(Elem),
  if isequal(Type,'Point')||isequal(Type,0),
    Elem=1:size(Ant1.Geom,1);
  end
  if isequal(Type,'Wire')||isequal(Type,1),
    Elem=1:size(Ant1.Desc,1);
  end
  if isequal(Type,'Surf')||isequal(Type,2),
    Elem=1:length(Ant1.Desc2d);
  end
end

% check default dimension:

if isequal(Type,'Point')||isequal(Type,0),
  DefaultDim=0;
end
if isequal(Type,'Wire')||isequal(Type,1),
  DefaultDim=1;
end
if isequal(Type,'Surf')||isequal(Type,2),
  DefaultDim=2;
end


% add object:

AddObj=struct('Type',Type,'Elem',Elem);

AddObj.Phys.Dimension=DefaultDim;

for n=1:floor(length(varargin)/2),
  eval(['AddObj.',varargin{n*2-1},'=varargin{n*2};']);
end

Ant1.Obj=AppStruct(Ant1.Obj,AddObj);

============================================================

function [Ant,NewNodes,NewSegs,NewPats,NewObjs]=...
           GridPack(Ant0,Dist,FreeNodes,Pack)

% [Ant,NewNodes,NewSegs,NewPats,NewObjs]=GridPack(Ant0,Dist,FreeNodes,Pack)
% identifies nodes which are closer to each other than the given 
% distance limit Dist. The nodes which may be removed can be confined 
% by the optional parameter FreeNodes. If omitted or any string, all 
% nodes are "free". If Dist is omitted, Dist=0 is assumed, i.e. only 
% multiple node definitions are reduced.
% Pack works as explained in GridUpdate.
% NewNodes associates to each node in Ant0.Geom the new node number in 
% Ant.Geom, NewSegs is the same for segments (negative values indicate 
% a change in orientation), NewPats for patches (negative for change 
% of circulation direction). NewSegs and NewPats get zero values for
% removed segments and patches, respectively.
% Multiple Point-, Wire- and Surf-objects are not removed
% so that different properties can be set to the same wire or 
% segment by including it into several objects. Nevertheless,
% objects containing removed nodes, segments or patches, 
% respectively, are deleted. The relation between old and new 
% arrangement is represented by NewObjs. 

% To be implemented in the future:
% Recognition of nearly-intersecting segments and patches.

if ~isfield(Ant0,'Init'),
  Ant=GridInit(Ant0);
else
  Ant=Ant0;
end

n0=size(Ant.Geom,1);
if n0==0,
  return
end

if nargin<2,
  Dist=0;
end

if nargin<3,
  FreeNodes=1:n0;
elseif ischar(FreeNodes),
  FreeNodes=1:n0;
else
  FreeNodes=intersect(1:n0,FreeNodes);
end

if nargin<4,
  Pack=[0,0];
end

if ~isempty(FreeNodes),

  % group nodes which are to be identified (equivalent):
  
  k=ones(1,n0);   % nodes to keep
  nk=1;           % number of nodes to keep
  NewNodes=k;     % new node numbers 
  for n=2:n0,
    m=[];
    if ismember(n,FreeNodes),
      m=find(Mag(repmat(Ant.Geom(n,:),nk,1)-...
        Ant.Geom(k(1:nk),:),2)<=Dist, 1);
    end
    if isempty(m),
      nk=nk+1;
      k(nk)=n;
      NewNodes(n)=nk;
    else
      NewNodes(n)=m;
    end
  end

  % select one node per group:
  
  Ant.Geom=Ant.Geom(k(1:nk),:);

else
  
  NewNodes=1:size(Ant.Geom,1);

end

% Update antenna grid:

[Ant,NewObjs,NewSegs,NewPats]=GridUpdate(Ant,'Nodes',NewNodes,Pack);

============================================================

function [Ant,NewO,NewN,NewS,NewP,AddS]=...
  GridRemove(Ant0,Objs,Nodes,Segs,Pats,Lin,FreeObjs)

% [Ant,NewO,NewN,NewS,NewP,AddS]=...
%   GridRemove(Ant0,Objs,Nodes,Segs,Pats,Lin,FreeObjs)
% removes given objects and elements from antenna grid Ant0, returning the
% result in Ant. With the given Nodes all segments and patches based on 
% them are removed, similarly all objects based on any removed elements 
% are removed. Negative values of Objs force removal of those elements of 
% removed objects which are not needed in any remaining object definition; 
% negative values of Segs and Pats force removal of those nodes of the 
% removed segments and patches which are not needed in any remaining 
% segment or patch definition.
%
% NewO, NewN, NewS and NewP are index maps from old to new index numbers,
% where 0 indicates that the corresponding object or element is removed. 
%
% If Lin is set to a positive integer, all grid-lines having end nodes 
% where a maximum of Lin segments meet are maintained, more precisely:
% whenever at least 2 nodes of such a grid-line remain, the line is 
% maintained by substituting the old segment string by a new one 
% connecting the remaining nodes. AddS returns the additional segments  
% which had to be added to render the lines.
%
% All input parameters after Ant0 are optional.
% Ant=GridRemove(Ant0) sets Ant=Ant0, but removes all grid contents
% (i.e. resets fields Geom, Desc, Desc2d and Obj).
%
% The optional argument FreeObjs causes removal of the given objects if
% any elements of the respective object are removed. Objects not contained
% in FreeObjs remain, but reduced by removed elements. FreeObjs='all' sets 
% all objects free. Default: FreeObjs=[].

Objs0=length(Ant0.Obj);
Nodes0=size(Ant0.Geom,1);
Segs0=size(Ant0.Desc,1);
Pats0=length(Ant0.Desc2d);

NewO=zeros(Objs0,1);
NewN=zeros(Nodes0,1);
NewS=zeros(Segs0,1);
NewP=zeros(Pats0,1);
AddS=[];

Ant=Ant0;

if nargin<2,
  Ant1=GridInit;
  Ant.Geom=Ant1.Geom;
  Ant.Desc=Ant1.Desc;
  Ant.Desc2d=Ant1.Desc2d;
  Ant.Obj=Ant1.Obj;
  return
end

if ischar(Objs),
  Objs=1:Objs0;
end

if ~exist('Nodes','var'),
  Nodes=[];
end
if ischar(Nodes),
  Nodes=1:Nodes0;
end

if ~exist('Segs','var'),
  Segs=[];
end
if ischar(Segs),
  Segs=1:Segs0;
end

if ~exist('Pats','var'),
  Pats=[];
end
if ischar(Pats),
  Pats=1:Pats0;
end

if (nargin<6)||isempty(Lin),
  Lin=0;
end
Lin=abs(Lin);

if nargin<7,
  FreeObjs=[];
end
if ischar(FreeObjs),
  FreeObjs=1:length(Ant0.Obj);
end
FreeObjs=intersect(FreeObjs,1:length(Ant0.Obj));

% -----------------
% remove objects
% -----------------

eObjs=abs(intersect(Objs,-(1:Objs0)));  % objects to remove with elements

Objs=intersect(abs(Objs),1:Objs0);      % objects to remove

kObjs=setdiff(1:Objs0,Objs);            % objects to keep

Ant.Obj=Ant0.Obj(kObjs);

NewO(kObjs)=1:length(kObjs);

FreeObjs=NewO(FreeObjs);
FreeObjs=FreeObjs(FreeObjs~=0);

[Points,Wires,Surfs]=FindGridObj(Ant0);

% add object-segments to be deleted:

rs=abs(Gather({Ant0.Obj(intersect(Wires,eObjs)).Elem}));
ks=abs(Gather({Ant0.Obj(intersect(Wires,kObjs)).Elem}));
rs=setdiff(rs,ks);
Segs=[Segs(:);rs]; 

% add object-patches to be deleted:

rp=abs(Gather({Ant0.Obj(intersect(Surfs,eObjs)).Elem}));
kp=abs(Gather({Ant0.Obj(intersect(Surfs,kObjs)).Elem}));
rp=setdiff(rp,kp);
Pats=[Pats(:);rp]; 

% add object-nodes to be deleted:

rn=abs(Gather({Ant0.Obj(intersect(Points,eObjs)).Elem}));
rn=[rn;Gather(Ant0.Desc2d(rp));Gather(Ant0.Desc(rs,:))]; 

kn=abs(Gather({Ant0.Obj(intersect(Points,kObjs)).Elem}));
kn=[kn;Gather(Ant0.Desc2d(kp));Gather(Ant0.Desc(ks,:))]; 

Nodes=[Nodes(:);setdiff(rn,kn)]; 

% ----------------
% remove patches
% ----------------

nPats=abs(intersect(Pats,-(1:Pats0)));  % patches to remove with nodes

Pats=intersect(abs(Pats),1:Pats0);      % patches to remove

kPats=setdiff(1:Pats0,Pats);            % patches to keep

Ant.Desc2d=Ant0.Desc2d(kPats);

NewP(kPats)=1:length(kPats);

[Ant,NewObjs]=GridUpdate(Ant,'Patches',NewP,[],FreeObjs);

FreeObjs=NewObjs(FreeObjs);
FreeObjs=FreeObjs(FreeObjs~=0);

NewO=MapComp(NewO,NewObjs);

r=Gather(Ant0.Desc2d(nPats));           % removable patch-nodes
k=Gather(Ant.Desc2d);                   % patch-nodes to keep

% ----------------
% remove segments
% ----------------

nSegs=abs(intersect(Segs,-(1:Segs0)));  % segments to remove with nodes

Segs=intersect(abs(Segs),1:Segs0);      % segments to remove

kSegs=setdiff(1:Segs0,Segs);            % segments to keep

Ant.Desc=Ant0.Desc(kSegs,:);

NewS(kSegs)=1:length(kSegs);

[Ant,NewObjs]=GridUpdate(Ant,'Segments',NewS,[],FreeObjs);

FreeObjs=NewObjs(FreeObjs);
FreeObjs=FreeObjs(FreeObjs~=0);

NewO=MapComp(NewO,NewObjs);

r=[r;Gather(Ant0.Desc(nSegs,:))];       % add removable segment-nodes 
k=[k;Ant.Desc(:)];                      % add segment-nodes to keep

% --------------
% remove nodes
% --------------

if Lin,
  [LNodes,LSegs,LLen]=GridLines(Ant.Desc,Lin); 
end

% add segment- and patch-nodes to be removed:

Nodes=[Nodes(:);setdiff(r,k)]; 

% nodes to keep:

kNodes=setdiff(1:Nodes0,abs(Nodes));    

Ant.Geom=Ant.Geom(kNodes,:);

NewN(kNodes)=1:length(kNodes);

[Ant,NewObjs,NewSegs,NewPats]=GridUpdate(Ant,'Nodes',NewN,[],FreeObjs);

NewO=MapComp(NewO,NewObjs);
NewS=MapComp(NewS,NewSegs);
NewP=MapComp(NewP,NewPats);

if Lin,
  
  AddD=[];
    
  D=[Ant.Desc;fliplr(Ant.Desc)];
  
  for L=1:length(LLen);
    n=LNodes{L}(1:LLen(L));
    [s,i]=intersect(n,kNodes);
    if length(s)>1,
      s=NewN(n(sort(i)));
      s=s(:);
      if (length(LNodes{L})~=LLen(L))&&(length(s)>2), 
        s=[s;s(1)];                                   % close line
      end
      s=[s(1:end-1),s(2:end)];
      AddD=[AddD;setdiff(s,D,'rows')];
    end
  end
  
  AddS=size(Ant.Desc,1)+(1:size(AddD,1));

  Ant.Desc=[Ant.Desc;AddD];
  
end

============================================================

function [Ant,NewPats,SubDiv]=GridRevol(varargin)

% Ant=GridRevol(Type,z,r,n,phi,AutoReduce,nmin) creates a 
% surface of revolution about the z-axis. Actually, only an 
% azimuth-section extending from 0 to phi is drawn. This 
% amounts to an entire rotatory figure for phi=2*pi. If phi 
% is omitted, left empty or equal to an integer multiple of 
% 2*pi, phi=2*pi is assumed. The figure is composed of 
% m=length(z)=length(r)=length(n) polygons (representing 
% horizontal cross-sections) drawn counterclockwise about the 
% z-axis, starting at zero azimuth. The corners of the n(k)
% segments of the k-th polygon lie the radius r(k) away from 
% the z-axis at height z(k). When n is a negative scalar, 
% it defines the number of segments of the first polygon at
% (z(1),r(1)); in this case the number of horizontal segments 
% of the other polygons are determined automatically. When n 
% is positive, abs(n) defines the minimum number of segments 
% that should be used for the widest polygon. When n is not passed
% it is adapted in such a way that each latitudinal segment extends
% approximately 18 degrees.
% The corners of successive polygons are connected in such 
% a way that the connecting segments have minimum length and 
% no multiple connections occur. When 1 is passed for the 
% optional parameter AutoReduce, the number of intermediate 
% polygons is automatically reduced so that distances between 
% successive polygons are not "much" smaller than the 
% horizontal segments of the polygons. The optional parameter 
% nmin defines the minimum number of segments that are used 
% to represent a horizontal polygon.
% Optional: phi,AutoReduce,nmin
%
% Type defines the object of the given type ('Point', 'Wire' or 
% 'Surf'). Type may be a list (cell vector) of types, e.g.
% Type={'Wire','Surf'} defines a wire and a surface object.
% If Type is empty or omitted, no objects are defined, but all nodes, 
% segments and patches needed for the definition of the respective 
% objects are kept. Type='all' causes all kinds of objects to be defined.
% If Type='Wire', no segments are generated (Desc empty), 
% vice versa for Type='Surf' (Desc2d empty); Geom is always created.

% Rev. Feb. 2008:
% implementation of Type
%
% Revision June 2007:
% - Change of meaning of sign(np);
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)
%   [Ant,NewPats,SubDiv]=GridRevol(...) returns the new and subdivided
%   patches in NewPats and SubDiv, resp.
% - changed handling of nmin at axis (see (*)) 

global GlobalMaxPatchCorners 

[Type,z,r,n,phi,AutoReduce,nmin]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

% ensure column vectors:

z=z(:); 
r=abs(r(:));
n=n(:);

% no automatic reduction by default:

if isempty(AutoReduce),
  AutoReduce=0;
end

% check phi, determine if complete revolution:

if isempty(phi),
  phi=0;
end
pi2=2*pi;
phi=phi-fix(phi/pi2)*pi2;
ClosedFigure=(abs((abs(phi)-pi2)*phi)<1e-10);
if ClosedFigure,
  phi=pi2;
end

% set default n corresponding to 18 degrees steps in phi:

if isempty(n),
  n=ones(length(z),1)*max(round(phi/pi*10),1);
end
n=round(n);

% nmin must be greater than 2, default=3
% (to ensure that a maximum of 4 segments may meet 
% on the symmetry axis set nmin<5):

if isempty(nmin)||(nmin<3),
  nminfixed=0;
  nmin=3; 
else
  nminfixed=1;
end

% check number m of polygons to be drawn; 
% if less than 2, return empty grid:

Ant=GridInit;

m=length(z); 
if m<2, return, end

% tolerance factor for segment length:

LTol=sqrt(2);

% calculate maximum radius and ensure that points on the axis 
% are properly connected to adjacent polygons (see end of file):

rmax=max(r); 
if rmax==0, return, end

rzaxis=rmax*1e-10;  % virtual radius of z-axis

r=max(r,rzaxis); 

% check if automatic calculation of n required: 

if length(n)~=m, 
  Auton=1;  % automatic n
  n1=max(abs(n(1)),nmin)*sign(n(1));
  n=abs(n1);
  if n1>0,  % n(1) free
    rref=rmax;
  else      % n(1) fixed
    rref=r(1);
    if rref<2*rzaxis,  
      warning(['Inconsistent input parameters, ',...
        'radius of first polygon too small.']);
      rref=rmax;
      n1=-n1;
    end
  end
  L=rref*2*pi/n*ones(m,1);  % nom. seglen. for AutoReduce
else
  Auton=0;  % fixed n-vector 
  n=max(abs(n),nmin);
  L=(2*pi)*r./n;  % nominal segment length for AutoReduce
end

% find polygon-cross-sections to be drawn:

if AutoReduce,
  md=ones(1,m);
  zold=z(1);
  rold=r(1);
  for k=2:(m-1),  
    if Mag([z(k)-zold;r(k)-rold],1)<L(k)/LTol,
      md(k)=0;
    else
      zold=z(k);
      rold=r(k);
    end
  end
  md=find(md);
  if length(md)>2,
    k=md(end-1);
    if Mag([z(k)-z(m);r(k)-r(m)],1)<L(k)/LTol/2,
      md=md([1:end-2,end]);
    end
  end
else
  md=1:m;
end
z=z(md);
r=r(md);
if Auton==0,
  n=n(md);
end
m=length(md);

% calculate vector of nominal-n for automatic n-determination:

if Auton,
  n=max(r/rref*n,nmin);   % ideal n
  if m==2,
    n=max(n)*[1;1];
  else
    n=[max(n(1),n(2)/LTol);...
       max(max(n(1:end-2)/LTol,n(2:end-1)),n(3:end)/LTol);...
       max(n(end-1)/LTol,n(end))];
  end
  if nmin<4,   % (*) changed from 5 to 4, 14. June 2007
    na=find(r<2*rzaxis);
    n(na)=min(n(na),3);
  end
  n=round(n); 
  % prepare nold for main loop:
  if n1>0, % n(1) free
    nold=min(n);  
    if nminfixed==0,
      maxn=max(n);
      nnew=nmin+1;
      if abs(nold*2^ceil(log2(maxn/nold)-1/4)-maxn)>...
         abs(nnew*2^ceil(log2(maxn/nnew)-1/4)-maxn),
        nold=nnew;
      end
    end
  else  % n(1) fix
    nold=abs(n1);
    n(1)=nold;
  end
end

% main loop:

for k=1:m,  
    
  if Auton,
    nnew=nold*2^ceil(log2(n(k)/nold)-1/4);
    if nnew~=round(nnew),
      nnew=min(n);
      nnew=nnew*2^ceil(log2(n(k)/nnew)-1/4);
    end
    if k==m,
      nnew=min(nnew,nold);
    elseif (k==1)&&(n1>0),
      if ceil(log2(n(2)/nnew)-1/4)<=-1,
        nnew=nnew/2;
      end
    end
  else
    nnew=n(k);
  end
  
  A=GridCircle(r(k),phi,nnew);
  A.Geom(:,3)=A.Geom(:,3)+z(k);
  
  if k==1,
    Ant.Geom=A.Geom;
    Ant.Desc=A.Desc;
  else
    dn=min(nold,nnew);
    do=max(nold,nnew);
    t=0:(dn-ClosedFigure);
    do=1+round(t*do/dn);
    dn=1+t;    
    if nnew>nold,
      [do,dn]=deal(dn,do);
    end
    x=size(Ant.Geom,1);
    do=do+x-nold-1+ClosedFigure;
    dn=dn+x;
    Ant.Geom=[Ant.Geom;A.Geom];
    Ant.Desc=[Ant.Desc;[do',dn'];A.Desc+x];
    for q=1:(length(dn)-1),
      Ant.Desc2d{end+1,1}=...
        fliplr([do(q),dn(q):dn(q+1),do(q+1):-1:do(q)+1]);
    end
    if ClosedFigure,
      Ant.Desc2d{end+1,1}=...
        fliplr([do(end),dn(end):size(Ant.Geom,1),dn(1),do(1),x:-1:do(end)+1]);
    end     
  end

  nold=nnew; 
  
end  % main loop

% identify nodes on z-axis which have been radially 
% offset for proper connections:

NewNodes=zeros(size(Ant.Geom,1),1);

n=find(sqrt(Ant.Geom(:,1).^2+Ant.Geom(:,2).^2)<2*rzaxis); % nodes on z-axis

[z,m,k]=unique(Ant.Geom(n,3));
rep=n(m(k));                        % representatives of z-axis nodes
Ant.Geom(rep,1:2)=0;

d=setdiff(n,rep);                   % nodes on z-axis to be deleted
Ant.Geom(d,:)=[];

m=setdiff(1:length(NewNodes),d);    % nodes kept 
NewNodes(m)=1:length(m);
NewNodes(n)=NewNodes(rep);

Ant=GridUpdate(Ant,'Nodes',NewNodes,[1,0]);

for n=1:length(Ant.Desc2d),         % remove zero-length edges present
  d=Ant.Desc2d{n};                  % from z-axis node handling.
  [dd,k]=unique(d);
  Ant.Desc2d{n}=d(sort(k));
end

% subdivide patches with more than GlobalMaxPatchCorners nodes:

if ~isempty(GlobalMaxPatchCorners)&&~isempty(Ant.Desc2d),
  [Ant,NewPats,SubDiv]=GridSubPatches(Ant,'all',4,{[0,0,0],[0,0,1]});
end

% define objects:

Ant=Grid2dObj(Ant,Type);

============================================================

function Ant=GridSphere(varargin)

% Ant=GridSphere(Type,r,t1,t2,nt,p,np,npmin) draws a 
% section of a sphere with center (0,0,0), radius r and 
% angular extent abs(t2-t1) and p in colatitude and azimuth, 
% respectively. The section extends from azimuth 0 and 
% colatitude t1 to azimuth p  and colatitude t2. The whole 
% surface grid is composed of nt horizontal polygons 
% (representing circular arcs) around the z-axis and 
% segments connecting the corners of successive polygons.
% np defines the number of segments to be used to represent 
% the horizontal polygons. A negative np sets the number 
% of segments of the first polygon (at latitude t1), 
% a positive np only estimates by its magnitude the number 
% of segments to be used for the widest horizontal polygon. 
% The actual number of segments is suitably adjusted so 
% that segment lengths do not vary too much. By npmin the 
% minimum number of segments to be used for horizontal 
% polygons can be defined. If the number of segments
% shall not be automatically adjusted, pass npmin=0.
% All parameters except r are optional, default values: 
% t1=0; t2=pi; p=2*pi; if one of the parameters np or 
% nt is not given, it is adjusted in such a way that 
% horizontal and meridian segments have similar length. 
% If both are omitted (or empty), nt is calculated to
% yield segments which extend about 18 degrees in latitude
% and np is adapted accordingly.
% Generally the following assumptions must hold: 
% 0<=t1,t2<=pi; t1~=t2.
%
% Type specifies the object type(s) to be defined and is optional
% (for more details on Type see GridRevol.m).

% Rev. Feb. 2008:
% Implementation of Type
%
% Revision June 2007:
% - Adaptation for change of meaning of sign(np) in GridRevol;
% - Subdivision of patches according to the global variable 
%   GlobalMaxPatchCorners (which is set to its default in GridInit)

[Type,r,t1,t2,nt,p,np,npmin]=...
  FirstArgin(@(x)(ischar(x)||iscell(x)),'default',[],varargin{:});

r=abs(r);

if isempty(t1),
  t1=0;
else
  t1=Bound(t1,0,pi);
end
if isempty(t2),
  t2=pi;
else
  t2=Bound(t2,0,pi);
end

if t1>t2,
  [t1,t2]=deal(t2,t1);
end

if isempty(p),
  p=2*pi;
else
  p=p/2/pi;
  p=p-floor(p);
  if abs((p-1)*p)<1e-10,
    p=1;
  end
  p=p*2*pi;
end

if abs((t2-t1)*p)<1e-10, 
  error('Solid angle too small to generate spherical grid.');
end

if isempty(npmin)||(npmin==1)||(npmin<0),
  npmin=2;
end

% analyse and adapt nr and np:

Lt=abs(t2-t1);
if (t1-pi/2)*(t2-pi/2)<0,
  Lp=p;
else
  Lp=p*max(sin([t1,t2]));
end

nadj=0.9;  % exp. adjustment factor for Lp

if isempty(np),
  if isempty(nt),
    nt=10/pi*(t2-t1);
  end
  nt=max(1,ceil(abs(nt)));
  np=max(npmin,round(nadj*Lp*nt/Lt));    
else
  np=max(npmin,abs(np))*sign(np);
  if isempty(nt),
    if (np<0)||(npmin~=0),
      if sin(t1)>1e-5,
        Lp=p*sin(t1);
      elseif sin(t2)>1e-5,
        Lp=p*sin(t2);
      end
    end
    nt=max(1,ceil(abs(Lt*np/(nadj*Lp))));
  end
end 

if (np<0)&&(npmin==0),
  np=repmat(np,nt+1,1);
end

% calculate z- and r-vector of first meridian:

z=r*cos(t1+(t2-t1)/nt*(nt:-1:0)');
r=sqrt(r^2-z.^2);

% generate grid:

Ant=GridRevol(Type,z,r,np,p,0,npmin);


============================================================

function [Ant,AddN,AddS]=...
  GridSplitSegs(Ant0,Segs,Frac,AddN2Obj,AddS2Obj,AdaptPats)

% [Ant,AddN,AddS]=GridSplitSegs(Ant0,Segs,Frac,AddN2Obj,AddS2Obj,AdaptPats)
% inserts new points in the segments Segs. The new node 
% inserted in the k-th segment is the fraction Frac(k) 
% of the respective segment length away from the  
% start node of the segment. If Frac is a scalar, it 
% is applied to all segments. If Frac is not passed,
% a default value of 0.5 is assumed. AddN are the node 
% numbers of the inserted nodes, AddS the segment numbers 
% of the additional inserted segments.
%
% If AddN2Obj=1 is passed, each inserted node is also
% added to the respective Point objects where both end nodes of 
% the respective splitted segment are contained.
% If AddS2Obj=1 is passed, the inserted segments are also
% added to the respective Wire objects where the splitted segments 
% are contained. AdaptPats=1 causes all patches which have an edge 
% common with a splitted segment to be adapted by adding the 
% corresponding inserted nodes as new corners.

% REVISIONS
% 15.4.2003: 
% - additional feature AdaptPats implemented.
% - changed the line 
%     [s,m,k]=intersect(Ant.Obj(n).Elem,Segs);
%   into (see #1)
%     [s,m,k]=intersect(abs(Ant.Obj(n).Elem),Segs);
%   to respect potential negative segment elements in object definitions.

Ant=Ant0;

if (nargin<2)||ischar(Segs),
  Segs=1:size(Ant.Desc,1);
end
Segs=Segs(:);

if (nargin<3)||isempty(Frac),
  Frac=1/2;
end
Frac=Frac(:);
if length(Frac)~=length(Segs),
  Frac=repmat(Frac(1),[length(Segs),1]);
end
if any((Frac<=0)|(Frac>=1));
  warning('There are fraction(s) not pointing inside segment(s).');
end

Frac=[Frac,Frac,Frac];

% new geometry matrix:

Geomi=Ant0.Geom(Ant0.Desc(Segs,1),:).*(1-Frac)+...
      Ant0.Geom(Ant0.Desc(Segs,2),:).*Frac;

Ant.Geom=[Ant0.Geom;Geomi];

AddN=size(Ant0.Geom,1)+(1:size(Geomi,1))';

% new description matrix:

Desci=[AddN,Ant0.Desc(Segs,2)];

Ant.Desc=[Ant0.Desc;Desci];
Ant.Desc(Segs,2)=AddN;

AddS=size(Ant0.Desc,1)+(1:size(Desci,1))';

[P,W]=FindGridObj(Ant);

% add new segments to objects:

if (nargin<5)||isempty(AddS2Obj),
  AddS2Obj=0;
end

if AddS2Obj&&~isempty(W),
  for n=W(:)',
    [s,m,k]=intersect(abs(Ant.Obj(n).Elem),Segs);  %#1
    if ~isempty(k),
      Ant.Obj(n).Elem=union(Ant.Obj(n).Elem,AddS(k));
    end
  end
end

% add new nodes to objects:

if (nargin<4)||isempty(AddN2Obj),
  AddN2Obj=0;
end

if AddN2Obj&&~isempty(P),
  for n=P(:)',
    [s,m,k]=intersect(Ant.Obj(n).Elem,Ant0.Desc(Segs,1));
    [s,m,q]=intersect(Ant.Obj(n).Elem,Ant0.Desc(Segs,2));
    k=intersect(k,q);
    if ~isempty(k),
      Ant.Obj(n).Elem=union(Ant.Obj(n).Elem,AddN(k));
    end
  end
end

% adapt patches:

if (nargin<6)||isempty(AdaptPats),
  AdaptPats=0;
end

if AdaptPats&&~isempty(Ant.Desc2d),
  [s,n,AdNodes]=FindSegs(Ant.Desc,AddN,2);
  k=size(AdNodes,1);
  for p=1:length(Ant.Desc2d),
    d=Ant.Desc2d{p}(:)';
    m=length(d);
    a=cell(m,1);
    for n=1:m,
      e=repmat([d(n),d(mod(n,m)+1)],k,1);
      q=AddN(prod(double(e==AdNodes),2)|prod(double(e==fliplr(AdNodes)),2));
      [du,s]=sort(Mag(Ant.Geom(q,:)-repmat(Ant.Geom(d(n),:),length(q),1),2));
      q=q(s);
      a{n}=[d(n),q(:)'];
    end
    Ant.Desc2d{p}=[a{:}];
  end
end

============================================================

function [Desc2d,NewPats,SubDiv]=GridSubPatches(Geom,Desc2d0,c,SymAxis)

% Desc2d=GridSubPatches(Geom,Desc2d0,c)
% subdivides patches whith more than c corners into 
% patches with a maximum of c corners. 
%
% Desc2d=GridSubPatches(Geom,Desc2d0,c,SymAxis)
% tries to respect/preserve symmetry with regard to axis SymAxis. 
% The variable SymAxis is a cell array of two vectors, the 
% first giving a point on the axis, the second 
% defining its direction.
%
% [Desc2d,NewPats,SubDiv]=GridSubPatches(...)
% SubDiv gives the number of subdivisions into which the
% patches are split, and NewPats returns a vector of indices 
% defining the first of the new patch numbers.
% E.g. NewPats(5)=10, SubDiv(5)=4 means that 
% patch 5 (namely Ant0.Desc2d{5}) has been split 
% into 4 patches which have now the numbers 10,11,12,13
% (namely Ant.Desc2d{10:13}). 
%
% Ant=GridSubPatches(Ant0,Pats,c) and
% Ant=GridSubPatches(Ant0,Pats,c,SymAxis) 
% do the same, using the Geom and Desc2d fields of the Ant0 
% and Ant structure. Only the patches given in Pats are split. 
% The new patch subdivisions are added to the Objects 
% containing the respective original patches.

% Written June 2007.
%
% Rev. Feb. 2008:
% Original function name SubdivPatches changed to GridSubPatches

if nargin<4,
  SymAxis={};
end

if (nargin<3)||isempty(c),
  c=3;
end
c=max(3,round(c));

% Ant=GridSubPatches(Ant0,Pats,...)
% ------------------------------------

if isstruct(Geom),
  
  Pats=Desc2d0;
  if ischar(Pats),
    Pats=1:length(Geom.Desc2d);
  end
  Pats=unique(Pats);
  N0=length(Geom.Desc2d);
  NewPats=(1:N0).';
  SubDiv=ones(N0,1);
  Desc2d=Geom;
  
  if isempty(Pats),
    return
  end
  
  [d,np,sd]=GridSubPatches(Geom.Geom,Geom.Desc2d(Pats(:)),c,SymAxis);
  shp=[0;cumsum(sd-1)];  % shift in patch-numbering
  NewPats=zeros(length(Geom.Desc2d),1);
  SubDiv=NewPats;
  Desc2d.Desc2d=cell(N0+shp(end),1);
  q=0;  
  k=0;
  for p=1:length(Pats),
    NewPats(k+1:Pats(p))=(q+1:q+Pats(p)-k).';
    SubDiv(k+1:Pats(p)-1)=1;
    SubDiv(Pats(p))=sd(p);
    Desc2d.Desc2d(NewPats(k+1:Pats(p)-1))=Geom.Desc2d(k+1:Pats(p)-1);
    Desc2d.Desc2d(NewPats(Pats(p))+(0:sd(p)-1))=...
      d(p+shp(p)+(0:sd(p)-1));
    k=Pats(p);
    q=k+shp(p)+sd(p)-1;    
  end
  NewPats(k+1:end)=(q+1:length(Desc2d.Desc2d)).';
  Desc2d.Desc2d(NewPats(k+1:end))=Geom.Desc2d(k+1:end);
  SubDiv(k+1:end)=1;

  % update objects:
  
  [Points,Wires,Surfs]=FindGridObj(Desc2d);
  for s=1:length(Surfs),
    eo=Desc2d.Obj(s);
    en=[];
    for e=eo(:).';
      en=[en,NewPats(e)+(0:SubDiv(e)-1)];
    end
    Desc2d.Obj(s)=en;
  end
  
  return
  
end

% Desc2d=GridSubPatches(Geom,Desc2d0,..)
% -----------------------------------------

Desc2d=Desc2d0;
NewPats=zeros(size(Desc2d0,1),1);
SubDiv=NewPats;

Sym=~isempty(SymAxis);
if Sym,
  ez=SymAxis{2}(:)'./Mag(SymAxis{2});
  g=Geom-repmat(SymAxis{1}(:).',size(Geom,1),1);
  z=g*ez';
  g=g-z*ez;
  rho=Mag(g,2);
  [m,n]=max(rho);
  ex=g(n,:)/Mag(g(n,:));
  ey=cross(ez,ex,2);
  phi=atan2(g*ey',g*ex');
  Zyl=[rho,phi,z]; 
else
  Zyl=zeros(size(Geom));
end

k=0;
for p=1:length(Desc2d0),
  d=Desc2d0{p};
  dd=HalfPatchRecurs(Geom(d,:),d,c,Zyl(d,:),Sym);
  Desc2d(k+1:k+length(dd))=dd;
  NewPats(p)=k+1;
  SubDiv(p)=length(dd);
  k=k+length(dd);
end

return


function dd=HalfPatchRecurs(g,d,c,Zyl,Sym)

% divides single patch d with node geometry g into a list dd of 
% patches so that no patch has more than c corners

if length(d)<=c,
  if isempty(d),
    dd={};
  else
    dd={d(:).'};
  end
  return
end

[num1,num2,num3]=HalfPatchNum(g,Zyl,Sym);
d1=HalfPatchRecurs(g(num1,:),d(num1),c,Zyl(num1,:),Sym);
d2=HalfPatchRecurs(g(num2,:),d(num2),c,Zyl(num1,:),Sym);
d3=HalfPatchRecurs(g(num3,:),d(num3),c,Zyl(num1,:),Sym);
dd=[d1;d2;d3];


function [num1,num2,num3]=HalfPatchNum(g,Zyl,Sym)

nc=size(g,1);

if Sym&&~isequal(nc,4),
  
  if std(Zyl(:,1))>std(Zyl(:,3)),
    q=Zyl(:,1);
  else
    q=Zyl(:,3);
  end
  mq=mean(q);
  if q(1)<mq,
    m=1;
    while (m<nc)&&(q(m+1)<mq),
      m=m+1;
    end
    n=nc+1;
    while (n>1)&&(q(n-1)<mq),
      n=n-1;
    end
  else
    m=1;
    while (m<nc)&&(q(m+1)>=mq),
      m=m+1;
    end
    n=nc+1;
    while (n>1)&&(q(n-1)>=mq),
      n=n-1;
    end
  end
  if n>1, 
    n=n-nc; 
  end
  n1=(n+m)/2;
  n2=(m+n+nc)/2;
  min1=floor(n1);
  max1=ceil(n1);
  min2=floor(n2);
  max2=ceil(n2);
  num1=mod([n:min1,max2:n+nc-1]-1,nc)+1;
  num2=mod([min1:max1,min2:max2]-1,nc)+1;
  if length(num2)<3, 
    num2=[]; 
  end
  num3=mod((max1:min2)-1,nc)+1;
  
else

  co=PatchCosines(g);

  n1=1:ceil(nc/2);
  n2=ceil((nc+1)/2):nc;

  [du,m]=max(co(n1).^2+co(n2).^2);  % split at node m

  num1=n1(m):n2(m);
  num2=[n2(m):nc,1:n1(m)];
  num3=[];

end


function cosi=PatchCosines(g)

e=g([2:end,1],:)-g;
e=e./repmat(sqrt(sum(abs(e).^2,2)),1,3);
cosi=-dot(e,e([end,1:end-1],:),2);


============================================================

function [Ant,NewObjs,NewSegs,NewPats]=GridUpdate(Ant0,...
  Type,NewInd,Pack,FreeObjs)

% [Ant,NewObjs,NewSegs,NewPats]=GridUpdate(Ant0,Type,NewInd,Pack,FreeObjs)
% updates the Ant0 grid as defined by NewInd, which is an index 
% map for the elements of the given Type: 'Nodes', 'Segments', 
% or 'Patches'. Optional values for Type are 0,1 and 2 which 
% correspond to 'Nodes', 'Segments' and 'Patches', respectively.
% For Type='Nodes' the Ant0-fields  Desc, Desc2d and Obj are
% updated, for Type='Segments' or 'Patches' only Obj is
% updated. Ant returns the updated grid, NewObjs an index map 
% which represents the update of objects. NewSegs and NewPats are 
% only returned for Type='Nodes' and represent the change of
% segments and patches, respectively.
% Note that the type of elements (Type) the index map of which
% is given remains unchanged. You can force this transformation 
% by adding a plus sign at the end of the Type string, e.g. 
% Type='Nodes+'. But careful use is recommended as the 
% transformation is not unique if NewInd represents a 
% non-injective map.
% Pack is a 2-element vector used to cause reduction of multiple segments 
% and patches (and zero-length segments and patches with less than 3 nodes). 
% Pack(1)=1 reduces segments, Pack(2)=1 patches. For instance, Pack=[0,1]
% reduces patches, but not segments, etc.
% The optional argument FreeObjs causes removal of the given objects if
% any elements of the respective object are removed. Objects not contained
% in FreeObjs remain, but reduced by removed elements. FreeObjs='all' sets 
% all objects free. Default: FreeObjs=[].

if nargin<3,
  error('Not enough input arguments.');
end

if (nargin<4)||isempty(Pack),
  Pack=[0,0];
elseif length(Pack)==1,
  Pack=[Pack,Pack];
end

if nargin<5,
  FreeObjs=[];
end
if ischar(FreeObjs),
  FreeObjs=1:length(Ant0.Obj);
end
FreeObjs=intersect(FreeObjs,1:length(Ant0.Obj));

Ant=Ant0;

[Points,Wires,Surfs]=FindGridObj(Ant);

if isequal(upper(Type(1)),'N')||isequal(Type,0), % Type='Nodes'

  NewNodes=NewInd(:)';
  
  % update Desc:

  NewSegs=zeros(1,size(Ant.Desc,1));
  Ant.Desc=NewNodes(Ant.Desc);
  n=find(all(Ant.Desc,2));
  Ant.Desc=Ant.Desc(n,:);
  NewSegs(n)=1:length(n);
  
  % segment-packing: remove multiple segment definitions and
  % connections of zero length (from nodes to themselves):

  if Pack(1),
    
    % remove multiple segment definitions 
    Desc=flipud(Ant.Desc); % flipud is used to choose as representative  
                           % the first of equal values, not the last
    [D,k,NSegs]=unique(sort(Desc,2),'rows');
    [k,D]=sort(k);
    Desc=flipud(Desc(k,:));
    [k,D]=sort(D);           % inversion of D
    NSegs=size(Desc,1)+1-flipud(D(NSegs));
    k=find(Desc(NSegs,2)==Ant.Desc(:,1)); % reverted segments
    NSegs(k)=-NSegs(k);                   % are set negative
    NewSegs=MapComp(NewSegs,NSegs);

    % remove connections from nodes to themselves
    k=find(Desc(:,1)~=Desc(:,2));
    Ant.Desc=Desc(k,:);
    NSegs=zeros(1,size(Desc,1));
    NSegs(k)=1:length(k);
    NewSegs=MapComp(NewSegs,NSegs);
    
  end % segment-packing 

  % update Desc2d:
  
  NewPats=zeros(1,length(Ant.Desc2d));
  for n=1:length(NewPats),
    Ant.Desc2d{n}=NewNodes(Ant.Desc2d{n});
    NewPats(n)=all(Ant.Desc2d{n});
  end
  n=find(NewPats);
  Ant.Desc2d=Ant.Desc2d(n);
  NewPats(n)=1:length(n);
  
  % patch-packing: remove multiple patch definitions
  % and patches with less than 3 nodes:

  if Pack(2),
    
    p0=length(Ant.Desc2d);
    k=zeros(1,p0);          % patches to keep
    nk=0;                   % number of patches to keep
    NPats=k;                % new patch numbers 
    
    for n=1:p0,
      dn=Ant.Desc2d{n}(:)';
      if length(unique(dn))>=3, % exclude patches with less than 3 nodes
        m=0;
        while (m<nk)&&(NPats(n)==0),
          m=m+1;
          dm=Ant.Desc2d{k(m)}(:)';
          if isequal(sort(dn),sort(dm)),
            for s=1:length(dn),
              if isequal(dn,dm),
                NPats(n)=m;
                break
              elseif isequal(dn,fliplr(dm)), % if reverse orientation 
                NPats(n)=-m;                 % set patch number negative
                break            
              end
              dm=[dm(2:end),dm(1)];
            end
          end
        end
        if NPats(n)==0,
          nk=nk+1;
          k(nk)=n;
          NPats(n)=nk;
        end
      end
    end
    
    Ant.Desc2d=Ant.Desc2d(k(1:nk));
    
    NewPats=MapComp(NewPats,NPats);
    
  end % patch-packing
  
elseif isequal(upper(Type(1)),'S')||isequal(Type,1), % Type='Segments'
  
  NewSegs=NewInd(:)';
  NewPats=[];
  NewNodes=[];
  
elseif isequal(upper(Type(1)),'P')||isequal(Type,2), % Type='Patches'
  
  NewPats=NewInd(:)';
  NewSegs=[];
  NewNodes=[];
  
else 
  
  error('Invalid Type parameter.');
  
end

% update point-, wire- and surface-objects in Ant.Obj:

NewObjs=ones(1,length(Ant.Obj));

if ~isempty(NewNodes),
  for n=Points(:)',
    e=MapComp(Ant.Obj(n).Elem,NewNodes);
    NewObjs(n)=all(e(:));
    Ant.Obj(n).Elem=e(e~=0);
  end
end

if ~isempty(NewSegs),
  for n=Wires(:)',
    e=MapComp(Ant.Obj(n).Elem,NewSegs);
    NewObjs(n)=all(e(:));
    Ant.Obj(n).Elem=e(e~=0);
  end
end

if ~isempty(NewPats),
  for n=Surfs(:)',
    e=MapComp(Ant.Obj(n).Elem,NewPats);
    NewObjs(n)=all(e(:));
    Ant.Obj(n).Elem=e(e~=0);
  end
end

n=union(find(NewObjs),setdiff(1:length(Ant.Obj),FreeObjs));
Ant.Obj=Ant.Obj(n);
NewObjs(n)=1:length(n);

% optional transformation of the given Type of elements:

if ~isequal(Type(end),'+'),
  return
end
  
if ~isempty(NewNodes),
  
  if length(NewNodes)~=size(Ant0.Geom,1),
    error('Incorrect lenght of NewNodes index map.');
  end
  n=find(NewNodes);
  Ant.Geom=zeros(max(NewNodes),3);
  Ant.Geom(NewNodes(n),:)=Ant0.Geom(n,:);
  
elseif ~isempty(NewSegs),
  
  if length(NewSegs)~=size(Ant0.Desc,1),
    error('Incorrect lenght of NewSegs index map.');
  end
  n=find(NewSegs);
  Ant.Desc=zeros(max(NewSegs),2);
  Ant.Desc(NewSegs(n),:)=Ant0.Desc(n,:);
  
elseif ~isempty(NewPats),
  
  if length(NewPats)~=length(Ant0.Desc2d),
    error('Incorrect lenght of NewPats index map.');
  end
  n=find(NewPats);
  Ant.Desc2d=cell(max(NewSegs),1);
  Ant.Desc2d(NewPats(n))=Ant0.Desc2d(n);
  
end

  
============================================================

function [x,y]=LineBend(L,b,n)

% [x,y]=LineBend(L,b,n) calculates bend function y(x) for wire antenna
% of length L and tip deviation b. n segments are used to represent 
% the antenna wire. If n is a vector, it defines the relative lengths of
% the subdivisions.
%
% The assumed bend is of square form, y=k*x^2.

% Rev. Feb. 2008:
% Original function name AntBend changed to LineBend;
% Implementation of n as rel.-lengths vector.

if numel(n)==1,
  n=ones(n,1)/n;
else
  n=n(:)/sum(n(:));
end

% x/L as a function of (y/L)^2 on the curve y=k*x^2 
% (L=length of curve, y<<L assumed):

XOL=inline(...
  'polyval([-44588/467775,346/14175,-92/945,-2/45,-2/3,1],yol2)',...
  'yol2');

% calculate x and y:

xend=XOL((b/L)^2)*L;
k=b/xend^2;

x=cumsum(n)*xend;
if x(1)~=0,
  x=[0;x(:)];
end

y=k*x.^2;

============================================================

function [R,t]=Motion(r1,r2,dir)

% [R,t]=Motion(..) analyzes rigid body motion.
% The function depends on the number of given parameters.
%
% [R,t]=Motion(r1,r2,dir), where dir is optional:
% r1 and r2 must have size 3x3, each representing the 
% position of 3 points, which are stored as columns. 
% r1 represents the positions of the 3 points before, 
% r2 the position after the motion. 
% Each triple of points must not lie on a straight line
% but the triples must span triangles of same size. 
% The transformation is decomposed into a rotation R 
% (an orthogonal matrix with unit determinant) and a 
% translation t, so any point r is transformed by the 
% matrix expression R*r+t. If the optional parameter dir 
% is set to 1, the first columns of r1 and r2 are not 
% interpreted as points but as initial and final directions, 
% respectively. For dir=2 two colums (the first and the 
% second, resp.) of r1 and r2 are treated in this way.
%
% R=Motion(r1), with two possibilities: 
% if r1 is a vector, it is assumed to represent a revolution 
% vector, which means that it defines a revolution by the 
% angle |r1| around the axis through the origin parallel 
% to r1; the pertaining rotation matrix R is returned. 
% Vice versa, if r1 is a 3x3 array, it is supposed to 
% represent a rotation, and the corresponding revolution 
% vector is calculated and returned in R.  

% Revision Feb 2008:
% changed (nargin<2) in line (*) to (nargin<3).

if nargin<2,
  
  t=[0;0;0];
  
  if size(r1,1)==size(r1,2),  
    
    % given rotation matrix -> revolution vector:
    % (for |phi| < 60 deg the revolution vector is calculated from 
    % the asymmetric part of the rotation matrix to improve accuracy, 
    % otherwise an eigenvector decomposition is used)
    
    if (trace(r1)-1)/2<0.5,
      [v,w]=eig(r1);
      [m,n]=sort(abs(diag(w)-1));
      R=real(v(:,n(1)));
      if R'*cross(real(v(:,n(3))),imag(v(:,n(3))))<0,
        R=-R;  
      end
      R=-angle(w(n(3),n(3)))*R;
      return
    else   
      A=(r1-r1')/2;
      R=[-A(2,3);A(1,3);-A(1,2)];
      s=norm(R);
      if s==0,
        R=[0;0;0];
      else
        R=asin(s)/s*R;
      end
    end
    
  else  
    
    % given revolution vector -> rotation matrix:
    
    if size(r1,1)<size(r1,2),
      r1=r1';
    end    
    A=norm(r1);
    if A==0,
      R=eye(3);
      return
    end
    s=sin(A);
    c=cos(A);
    A=r1/A;
    R=A*A'*(1-c)+eye(3)*c+s*[0,-A(3),A(2);A(3),0,-A(1);-A(2),A(1),0];
    
  end
  
else  
  
  % given r1, r2 -> rotation matrix and translation vector:
  
  if (nargin<3)||isempty(dir),  % (*)
    dir=0; 
  end
  if dir,
    s=max(Mag(r1(:,3),1),Mag(r2(:,3),1));
    if s==0, s=1; end
    if dir==2,
      r1(:,2)=r1(:,3)+r1(:,2)/Mag(r1(:,2),1)*s;
      r2(:,2)=r2(:,3)+r2(:,2)/Mag(r2(:,2),1)*s;
    end
    if (dir==1)||(dir==2),
      r1(:,1)=r1(:,3)+r1(:,1)/Mag(r1(:,1),1)*s;
      r2(:,1)=r2(:,3)+r2(:,1)/Mag(r2(:,1),1)*s;
    end
  end
  
  A=[r1(:,1)-r1(:,2),r1(:,2)-r1(:,3),r1(:,3)-r1(:,1)];
  B=[r2(:,1)-r2(:,2),r2(:,2)-r2(:,3),r2(:,3)-r2(:,1)];
  
  [s,c]=sort(Mag(A,1));
  A(:,c(3))=cross(A(:,c(1)),A(:,c(2)));
  A=A*diag(1./Mag(A,1));
  B(:,c(3))=cross(B(:,c(1)),B(:,c(2)));
  B=B*diag(1./Mag(B,1));
  
  R=B/A;
  t=mean(r2-R*r1,2);
  
end

============================================================

function [Nodes,Segs,Pats,NH,SH,PH]=PlotGrid(Ant,PObjs,PNodes,PSegs,PPats)

% [Nodes,Segs,Pats,NH,SH,PH]=PlotGrid(Ant,PObjs,PNodes,PSegs,PPats)
% plots objects PObjs, nodes PNodes, segments PSegs and patches PPats 
% of the antenna grid Ant. The graphical properties of nodes, segments 
% and patches not occurring in any object (Ant.Obj) are set according 
% to the defaults defined in the global variable PlotGridProp.
% PObjs may be a cell array of strings specifying object names of the 
% field Ant.Obj().Name. Pass an empty matrix (the string 'all') for PObjs, 
% PNodes, PSegs or PPats to plot no (all) elements of the respective 
% kind.
%
% [Nodes,Segs,Pats,NH,SH,PH]=PlotGrid(Ant) plots 'everything': 
% all nodes, segments, patches, points, wires and surfaces.
%
% In any case: If hold is on, all nodes, segments and patches yet present 
% in the plot are removed before the corresponding new ones are plotted. 
% In this respect the functions PlotNodes and PlotSegs behave different
% (they plot over existing elements).
% The output parameters (as defined in PlotRecog) return the graphical 
% representation of the antenna grid in the current axis after the 
% function call.

[Nodes,Segs,Pats]=deal([]);
[NH,SH,PH]=deal({});

if ~isfield(Ant,'Init'),
  Ant=GridInit(Ant);
end

if (nargin<1)||isempty(Ant.Geom),
  if ~ishold, cla('reset'); end
  if nargout==0,
    clear Nodes;
  end
  return
end

% determine nodes, segments and patches to plot:

if nargin<2,
  [PObjs,PNodes,PSegs,PPats]=deal('all');
end

% objects:

if ischar(PObjs),
  PObjs=1:length(Ant.Obj);
elseif iscell(PObjs),
  for n=1:length(PObjs),
    PObjs{n}=FindGridObj(Ant,'Name',PObjs{n});
  end
  PObjs=cat(1,PObjs{:});
end
PObjs=PObjs(:);

[PPoints,PWires,PSurfs]=FindGridObj(Ant);

PPoints=intersect(PPoints,PObjs);
PWires=intersect(PWires,PObjs);
PSurfs=intersect(PSurfs,PObjs);

% nodes:

if ~exist('PNodes','var'),
  PNodes=[];
elseif ischar(PNodes),
  PNodes=1:size(Ant.Geom,1);
end

for n=PPoints(:)',
  PNodes=[PNodes(:);Ant.Obj(n).Elem(:)];
end

PNodes=intersect((1:size(Ant.Geom,1))',abs(PNodes(:)));

% segments:

if ~exist('PSegs','var'),
  PSegs=[];
elseif ischar(PSegs),
  PSegs=1:size(Ant.Desc,1);
end

for n=PWires(:)',
  PSegs=[PSegs(:);Ant.Obj(n).Elem(:)];
end

PSegs=intersect((1:size(Ant.Desc,1))',abs(PSegs(:)));

% patches:

if ~exist('PPats','var'),
  PPats=[];
elseif ischar(PPats),
  PPats=1:length(Ant.Desc2d);
end

for n=PSurfs(:)',
  PPats=[PPats(:);Ant.Obj(n).Elem(:)];
end

PPats=intersect((1:length(Ant.Desc2d))',abs(PPats(:)));

% -------
% PLOT:
% -------

h=ishold;
if ~h, cla('reset'); hold on; end

% analyse and clean current plot according to PNodes,PSegs,PPats:

[Nodes,Segs,Pats,NH,SH,PH]=PlotRemove(Ant,PNodes,PSegs,PPats);

% plot patches:

PH(PPats)=num2cell(PlotPats(Ant.Geom,Ant.Desc2d,PPats));
Pats=union(Pats,PPats);

for n=PSurfs(:)',
  if ~isempty(Ant.Obj(n).Graf),
    set(cat(1,PH{abs(Ant.Obj(n).Elem)}),Ant.Obj(n).Graf);
  end
end

% plot segments:

SH(PSegs)=num2cell(PlotSegs(Ant.Geom,Ant.Desc,PSegs));
Segs=union(Segs,PSegs);

for n=PWires(:)',
  if ~isempty(Ant.Obj(n).Graf),
    set(cat(1,SH{abs(Ant.Obj(n).Elem)}),Ant.Obj(n).Graf);
  end
end

% plot nodes:

NH(PNodes)=num2cell(PlotNodes(Ant.Geom,PNodes));
Nodes=union(Nodes,PNodes);

for n=PPoints(:)',
  if ~isempty(Ant.Obj(n).Graf),
    set(cat(1,NH{abs(Ant.Obj(n).Elem)}),Ant.Obj(n).Graf);
  end
end

if ~h, hold off; end

if nargout==0,
  clear Nodes;
end

============================================================

function PlotGridProperty(Reset)

% PlotGridProperty(Reset) initializes the structure PlotGridProp. 
% It contains the default plot properties of nodes and segments 
% as fields Node, NodeAnno, Seg, SegAnno.
% Node and Seg are structures of Line properties, 
% NodeAnno and SegAnno structures of Text properties.
% For instance PlotGridProp.Node.Marker defines the default
% Markers used to plot nodes.
% Reset~=0 forces the properties to be reset to default values
% (even if already initialized); Reset=0 (default) only 
% resets if PlotGridProp is empty (i.e. not yet initialized).

% Revision June 2007:
% Changed PlotGridProp.Patch.EdgeColor from 'none' to
% a color so that edges which are not represented by segments 
% can be seen.

global PlotGridProp;

if nargin<1,
  Reset=0;
end

if ~(Reset||isempty(PlotGridProp)),
  return
end

PlotGridProp.Node.Tag='Node';
PlotGridProp.Node.LineStyle='none';
PlotGridProp.Node.Marker='o';
PlotGridProp.Node.MarkerSize=3;
PlotGridProp.Node.MarkerEdgeColor=[0 0.2 1];
PlotGridProp.Node.MarkerFaceColor=[0 0.2 1];

PlotGridProp.NodeAnno.Tag='NodeAnno';
PlotGridProp.NodeAnno.Color=[0 0.2 1]*0.4;
PlotGridProp.NodeAnno.VerticalAlignment='bottom';
PlotGridProp.NodeAnno.HorizontalAlignment='left';
PlotGridProp.NodeAnno.EraseMode='xor';

PlotGridProp.Seg.Tag='Seg';
PlotGridProp.Seg.LineStyle='-';
PlotGridProp.Seg.Marker='none';
PlotGridProp.Seg.Color=[0 0.6 0];
PlotGridProp.Seg.LineWidth=1.5;

PlotGridProp.SegAnno.Tag='SegAnno';
PlotGridProp.SegAnno.Color=[0 0.5 0]*0.4;
PlotGridProp.SegAnno.VerticalAlignment='bottom';
PlotGridProp.SegAnno.HorizontalAlignment='left';
PlotGridProp.SegAnno.EraseMode='xor';

PlotGridProp.Patch.Tag='Patch';
PlotGridProp.Patch.FaceColor=[0.80,0.68,0.38]*1.15;
PlotGridProp.Patch.EdgeColor=[0.9,0.7,0.5]*0.7;
PlotGridProp.Patch.FaceAlpha=1;
PlotGridProp.Patch.Marker='none';

PlotGridProp.PatchAnno.Tag='PatchAnno';
PlotGridProp.PatchAnno.Color=[0.9,0.8,0.5]*0.4;
PlotGridProp.PatchAnno.VerticalAlignment='middle';
PlotGridProp.PatchAnno.HorizontalAlignment='center';
PlotGridProp.PatchAnno.EraseMode='xor';

============================================================

function PlotNodeAnno(Ant,Nodes,Action,Anno)

% PlotNodeAnno(Ant,Nodes,Action,Anno) sets or changes the annotation 
% of the given Nodes, according to the passed Action parameter (default=1):
%   Action=0 ... remove present annotations
%   Action=1 ... set new annotations and reset present ones
%   Action=2 ... set annotations only if not yet present
%   Action=3 ... only reset annotations that are present
% The Anno parameter defines the annotation strings. It can be a single 
% string or a cell array of strings of the same length as Nodes. 
% It can also be a numeric array, then it is transformed into strings 
% using num2str. Anno is optional, if omitted or empty the node numbers 
% are used for annotation.

global PlotGridProp;

if nargin<2,
  return
elseif ischar(Nodes),
  Nodes=1:size(Ant.Geom,1);
end
if isempty(Nodes), return, end
Nodes=Nodes(:);

if (nargin<4)||isempty(Anno),
  Anno=Nodes;
end

if (nargin<3)||isempty(Action),
  Action=1;
end

[Nodes,m,N]=unique(Nodes);

q=length(Nodes);
[Nodes,m]=intersect(Nodes,1:size(Ant.Geom,1));
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

[PNodes,PSegs,PPats,NH]=PlotRecog(Ant,'N');

q=length(Nodes);
[Nodes,m]=intersect(Nodes,PNodes);
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

if Action~=0,
  Anno=ToCellstr(Anno,length(N));
  [q,m]=unique(N);
  Anno=Anno(m);
end

switch Action,
  
case 0,
  
  hn=Gather(NH(Nodes));
  ha=Gather(get(hn,'UserData'));
  delete(ha);
  set(hn,'UserData',[]);
  
case 1,
  
  r=Ant.Geom(Nodes,:);
  for k=1:length(Nodes),
    hn=NH{Nodes(k)};
    ha=get(hn,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
    end
    ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.NodeAnno);
    set(hn,'UserData',ha);
  end
  
case 2,
  
  r=Ant.Geom(Nodes,:);
  for k=1:length(Nodes),
    hn=NH{Nodes(k)};
    ha=get(hn,'UserData');
    if isempty(ha)||isequal(ha,0),
      ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.NodeAnno);
      set(hn,'UserData',ha);
    end
  end
  
case 3,
  
  r=Ant.Geom(Nodes,:);
  for k=1:length(Nodes),
    hn=NH{Nodes(k)};
    ha=get(hn,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
      ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.NodeAnno);
      set(hn,'UserData',ha);
    end
  end

end

============================================================

function H=PlotNodes(Geom,Nodes,MarkerEdgeCol,MarkerFaceCol,AnnoCol)

% H=PlotNodes(Geom,Nodes,MarkerEdgeCol,MarkerFaceCol,AnnoCol) 
% plots the nodes given in the vector Nodes using given marker face-
% and edge-colors. AnnoCol defines the colors of annotation numbers.
% The colors may be given in the usual color specifications, where
% several colors can be defined by rows of matrices. If only Geom 
% is given or Nodes='all' is passed, all nodes in 
% Geom are drawn. H returns handles to the line objects, the handles
% of the annotations being saved as UserData property of the respective 
% lines. Default properties for nodes and annotation from
% PlotGridProp.Node and PlotGridProp.NodeAnno, respectively.

global PlotGridProp;

PlotGridProperty;

if nargin<2, 
  Nodes=1:size(Geom,1); 
end
if ischar(Nodes), 
  Nodes=1:size(Geom,1); 
end
if isempty(Nodes),
  if nargout>0,
    H=[];
  end
  return
end
NN=length(Nodes);

if (nargin<3)||isempty(MarkerEdgeCol),
  MarkerEdgeCol=PlotGridProp.Node.MarkerEdgeColor;
end
MarkerEdgeCol=RGBColor(MarkerEdgeCol,PlotGridProp.Node.MarkerEdgeColor);
n=mod((0:NN-1),size(MarkerEdgeCol,1))+1;
MarkerEdgeCol=MarkerEdgeCol(n,:);

if (nargin<4)||isempty(MarkerFaceCol),
  MarkerFaceCol=PlotGridProp.Node.MarkerFaceColor;
end
MarkerFaceCol=RGBColor(MarkerFaceCol,PlotGridProp.Node.MarkerFaceColor);
n=mod((0:NN-1),size(MarkerFaceCol,1))+1;
MarkerFaceCol=MarkerFaceCol(n,:);

if nargin<5,
  AnnoCol=[];
end
Annotation=~isempty(AnnoCol);
if Annotation,
  AnnoCol=RGBColor(AnnoCol,PlotGridProp.NodeAnno.Color);
  n=mod((0:NN-1),size(AnnoCol,1))+1;
  AnnoCol=AnnoCol(n,:);
end 
   
% Plot:

h=ishold;
if ~h, cla('reset'); hold on; end

H=zeros(NN,1);

MFC=PlotGridProp.Node.MarkerFaceColor;
MEC=PlotGridProp.Node.MarkerEdgeColor;
AC=PlotGridProp.NodeAnno.Color;

r=Geom(Nodes,:);

for n=1:NN,
  PlotGridProp.Node.MarkerEdgeColor=MarkerEdgeCol(n,:);
  PlotGridProp.Node.MarkerFaceColor=MarkerFaceCol(n,:);
  H(n)=line(r(n,1),r(n,2),r(n,3),PlotGridProp.Node);
  if Annotation,
    PlotGridProp.NodeAnno.Color=AnnoCol(n,:);
    HA=text(r(n,1),r(n,2),r(n,3),num2str(Nodes(n)),PlotGridProp.NodeAnno);
    set(H(n),'UserData',HA);
  end
end

PlotGridProp.Node.MarkerFaceColor=MFC;
PlotGridProp.Node.MarkerEdgeColor=MEC;
PlotGridProp.NodeAnno.Color=AC;

if ~h, hold off; end

if nargout==0,
  clear H;
end

============================================================

function PlotPatchAnno(Ant,Pats,Action,Anno)

% PlotPatchAnno(Ant,Pats,Action,Anno) sets or changes the annotation of the 
% given patches Pats, according to the passed Action parameter (default=1):
%   Action=0 ... remove present annotations
%   Action=1 ... set new annotations and reset present ones
%   Action=2 ... set annotations only if not yet present
%   Action=3 ... only reset annotations that are present
% The Anno parameter defines the annotation strings. It can be a single 
% string or a cell array of strings of the same length as Pats. 
% It can also be a numeric array, then it is transformed into strings 
% using num2str. Anno is optional, if omitted or empty the patch numbers 
% are used for annotation.

global PlotGridProp;

if nargin<2,
  return
elseif ischar(Pats),
  Pats=1:length(Ant.Desc2d);
end
if isempty(Pats), return, end
Pats=Pats(:);

if (nargin<4)||isempty(Anno),
  Anno=Pats;
end

if (nargin<3)||isempty(Action),
  Action=1;
end

[Pats,m,N]=unique(Pats);

q=length(Pats);
[Pats,m]=intersect(Pats,1:length(Ant.Desc2d));
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

[PNodes,PSegs,PPats,NH,SH,PH]=PlotRecog(Ant,'P');

q=length(Pats);
[Pats,m]=intersect(Pats,PPats);
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

if Action~=0,
  Anno=ToCellstr(Anno,length(N));
  [q,m]=unique(N);
  Anno=Anno(m);
end

switch Action,
  
case 0,
  
  hp=Gather(PH(Pats));
  ha=Gather(get(hp,'UserData'));
  delete(ha);
  set(hp,'UserData',[]);
  
case 1,
  
  for k=1:length(Pats),
    r=mean(Ant.Geom(Ant.Desc2d{Pats(k)},:),1);
    hp=PH{Pats(k)};
    ha=get(hp,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
    end
    ha=text(r(1),r(2),r(3),Anno{k},PlotGridProp.PatchAnno);
    set(hp,'UserData',ha);
  end
  
case 2,
  
  for k=1:length(Pats),
    r=mean(Ant.Geom(Ant.Desc2d{Pats(k)},:),1);
    hp=PH{Pats(k)};
    ha=get(hp,'UserData');
    if isempty(ha)||isequal(ha,0),
      ha=text(r(1),r(2),r(3),Anno{k},PlotGridProp.PatchAnno);
      set(hp,'UserData',ha);
    end
  end
  
case 3,
  
  for k=1:length(Pats),
    r=mean(Ant.Geom(Ant.Desc2d{Pats(k)},:),1);
    hp=PH{Pats(k)};
    ha=get(hp,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
      ha=text(r(1),r(2),r(3),Anno{k},PlotGridProp.PatchAnno);
      set(hp,'UserData',ha);
    end
  end

end

============================================================

function H=PlotPats(Geom,Desc2d,Pats,FaceCol,AnnoCol)

% H=PlotPats(Geom,Desc2d,Pats,FaceCol,AnnoCol)
% plots the patches given in the vector Pats using the color given
% in FaceCol. AnnoCol defines the color of the respective annotation 
% numbers. The colors may be given by the usual color specifications, 
% where several colors can be defined by rows of a matrix. 
% If only Geom and Desc is given or Pats='all', all 
% patches are drawn. H returns handles to the patch objects, the
% handles of the annotation texts being saved as UserData property
% of the respective patch objects.
% Default properties for patches and annotations are defined in
% the global variables PlotGridProp.Patch and PlotGridProp.PatchAnno.

global PlotGridProp;

PlotGridProperty;

if nargin<3, 
  Pats=1:length(Desc2d); 
end
if ischar(Pats), 
  Pats=1:length(Desc2d); 
end
if isempty(Pats),
  if nargout>0,
    H=[];
  end
  return
end
PN=length(Pats);

if nargin<4,
  FaceCol=[];
end
if ~isempty(FaceCol),
  FaceCol=RGBColor(FaceCol,PlotGridProp.Patch.FaceColor);
  n=mod((0:PN-1),size(FaceCol,1))+1;
  FaceCol=FaceCol(n,:);
end

if nargin<5,
  AnnoCol=[];
end
Annotation=~isempty(AnnoCol);
if Annotation,
  AnnoCol=RGBColor(AnnoCol,PlotGridProp.PatchAnno.Color);
  n=mod((0:PN-1),size(AnnoCol,1))+1;
  AnnoCol=AnnoCol(n,:);
end 
   
% Plot Patches:

h=ishold;
if ~h, cla('reset'); hold on; end

c=zeros(PN,3);  % centers of patches
H=zeros(PN,1);

for p=1:PN,
  n=Desc2d{Pats(p)};
  g=Geom(n,:);
  c(p,:)=mean(g,1);
  H(p)=patch('Vertices',g,'Faces',1:length(n),PlotGridProp.Patch);
end

if ~isempty(FaceCol),
  set(H,{'FaceColor'},num2cell(FaceCol,2));
end

% Plot annotation numbers:

if Annotation,
  s=deblank(cellstr(strjust(num2str(Pats(:)),'left')));
  HA=text(c(:,1),c(:,2),c(:,3),s,PlotGridProp.PatchAnno);
  set(HA,{'Color'},num2cell(AnnoCol,2));
  set(H,{'UserData'},num2cell(HA(:),2));  
end

if ~h, hold off; end

if nargout==0,
  clear H;
end

============================================================

function [Nodes,Segs,Pats,NH,SH,PH]=PlotRecog(Ant,Recog)

% [Nodes,Segs,Pats,NH,SH,PH]=PlotRecog(Ant,Recog) finds the segments,
% nodes and patches in the current axis. Nodes, Segs and Pats return 
% vectors of found node-, segment- and patch-numbers, respectively. 
% NH, SH and PH return 1-dim cell arrays. NH is of length size(Ant.Geom,1), 
% NH(m) containing a vector of found handles for the m-th node; SH is 
% of length size(Ant.Desc,1), SH(m) containing a vector of found handles 
% for the m-th segment; PH is of length length(Ant.Desc2d), PH{m} being 
% a vector of found handles for the m-th patch of the given antenna Ant.
% Empty cells in NH, SH and PH represent non-drawn nodes, segments and
% patches, respectively. The search is restricted to the objects with
% the tags defined in the fields Node.Tag, Seg.Tag and Patch.Tag of 
% the global variable PlotGridProp (if Node.Tag, etc., is empty the 
% search is not restricted). The UserData property of the 
% found objects contain eventual handles to annotation numbers (which 
% are text objects, the tags of which are determined by NodeAnno.Tag, 
% SegAnno.Tag and PatchAnno.Tag of PlotGridProp).
% The search can be restricted to certain kinds of objects given by the 
% optional character parameter Recog, where the characters 'N', 'S' and
% 'P' represent nodes, segments and patches, respectively. For example
% PlotRecog(Ant,'pN') will find nodes and patches but no segments, so
% Segs=[] and SH={} are returned.

global PlotGridProp;

if nargout==0, return, end

PlotGridProperty;

[Nodes,Segs,Pats]=deal([]);
[NH,SH,PH]=deal({});

if nargin<2,
  Recog='nsp';
end
Recog=upper(Recog);

% Find nodes:

if any(Recog=='N'),
  
  if ischar(PlotGridProp.Node.Tag),
    L=findobj(gca,'Type','line','Tag',PlotGridProp.Node.Tag);
  else
    L=findobj(gca,'Type','line');
  end
  
  n=size(Ant.Geom,1);
  Nodes=zeros(n,1);
  NH=cell(n,1);
  
  if ~isempty(L),
    for m=1:n,
      NH{m}=findobj(L,'XData',Ant.Geom(m,1),...
        'YData',Ant.Geom(m,2),'ZData',Ant.Geom(m,3));
      Nodes(m)=~isempty(NH{m});
    end
  end
  
  Nodes=find(Nodes);
  
end

% Find segments:

if any(Recog=='S'),
  
  if ischar(PlotGridProp.Seg.Tag),
    L=findobj(gca,'Type','line','Tag',PlotGridProp.Seg.Tag);
  else
    L=findobj(gca,'Type','line');
  end
  
  n=size(Ant.Desc,1);
  Segs=zeros(n,1);
  SH=cell(n,1);
  
  if ~isempty(L),
    for m=1:n,
      g=Ant.Geom(Ant.Desc(m,:),:)';
      SH{m}=findobj(L,'XData',g(1,:),'YData',g(2,:),'ZData',g(3,:));
      Segs(m)=~isempty(SH{m});
    end
  end
  
  Segs=find(Segs);
  
end

% Find patches:

if any(Recog=='P'),
  
  if ischar(PlotGridProp.Patch.Tag),
    L=findobj(gca,'Type','patch','Tag',PlotGridProp.Patch.Tag);
  else
    L=findobj(gca,'Type','patch');
  end
  
  n=length(Ant.Desc2d);
  Pats=zeros(n,1);
  PH=cell(n,1);
  
  if ~isempty(L),
    for m=1:n,
      d=Ant.Desc2d{m};
      g=Ant.Geom(d,:);
      PH{m}=findobj(L,'Vertices',g,'Faces',1:length(d));
      Pats(m)=~isempty(PH{m});
    end
  end
  
  Pats=find(Pats);
  
end

============================================================

function [Nodes,Segs,Pats,NH,SH,PH]=PlotRemove(Ant,RNodes,RSegs,RPats,Anno)

% [Nodes,Segs,Pats,NH,SH,PH]=PlotRemove(Ant,RNodes,RSegs,RPats,Anno)
% removes nodes RNodes, segments RSegs and patches RPats of given antenna
% Ant from the current axis. Nodes, Segs and Pats return the remaining 
% nodes, segments and patches, the corresponding handles are returned 
% in NH, SH and PH, respectively (see also PlotRecog).
% PlotRemove(Ant) removes all segments, nodes and patches of Ant.
% If Anno~=0 is passed, only the annotation numbers of the corresponding 
% elements are removed (default Anno=0). 

global PlotGridProp;

if nargout==0, return, end

PlotGridProperty;

if (nargin<2)||ischar(RNodes),
  RNodes=1:size(Ant.Geom,1);
end

if (nargin<3)||ischar(RSegs),
  RSegs=1:size(Ant.Desc,1);
end

if (nargin<4)||ischar(RPats),
  RPats=1:length(Ant.Desc2d);
end

if nargin<5,
  Anno=0;
end

[Nodes,Segs,Pats,NH,SH,PH]=PlotRecog(Ant);

% Remove nodes:

RNodes=intersect(Nodes(:),RNodes(:));

r=cat(1,NH{RNodes}); % node handles to be removed

a=get(r,'UserData'); % annotation handles to be removed
if iscell(a), 
  a=cat(1,a{:});
end

if Anno,
  if ischar(PlotGridProp.NodeAnno.Tag),
    a=findobj(a,'Tag',PlotGridProp.NodeAnno.Tag);
    if ~isempty(a),
      r=findobj(r,{'UserData'},num2cell(a(:),2));  
    else
      r=[];
    end
  end
  delete(a);
  set(r,'UserData',[]);
else
  delete(a);
  delete(r);
  NH(RNodes)=cell(length(RNodes),1);
  Nodes=setdiff(Nodes,RNodes);
end

% Remove segments:

RSegs=intersect(Segs(:),RSegs(:));

r=cat(1,SH{RSegs}); % segment handles to be removed

a=get(r,'UserData'); % annotation handles to be removed
if iscell(a), 
  a=cat(1,a{:});
end

if Anno,
  if ischar(PlotGridProp.SegAnno.Tag),
    a=findobj(a,'Tag',PlotGridProp.SegAnno.Tag);
    if ~isempty(a),
      r=findobj(r,{'UserData'},num2cell(a(:),2));  
    else
      r=[];
    end
  end
  delete(a);
  set(r,'UserData',[]);
else
  delete(a);
  delete(r);
  SH(RSegs)=cell(length(RSegs),1);
  Segs=setdiff(Segs,RSegs);
end

% Remove patches:

RPats=intersect(Pats(:),RPats(:));

r=cat(1,PH{RPats}); % patches handles to be removed

a=get(r,'UserData'); % annotation handles to be removed
if iscell(a), 
  a=cat(1,a{:});
end

if Anno,
  if ischar(PlotGridProp.PatchAnno.Tag),
    a=findobj(a,'Tag',PlotGridProp.PatchAnno.Tag);
    if ~isempty(a),
      r=findobj(r,{'UserData'},num2cell(a(:),2));  
    else
      r=[];
    end
  end
  delete(a);
  set(r,'UserData',[]);
else
  delete(a);
  delete(r);
  PH(RPats)=cell(length(RPats),1);
  Pats=setdiff(Pats,RPats);
end

============================================================

function PlotSegAnno(Ant,Segs,Action,Anno)

% PlotSegAnno(Ant,Segs,Action,Anno) sets or changes the annotation of the 
% given segments Segs, according to the passed Action parameter (default=1):
%   Action=0 ... remove present annotations
%   Action=1 ... set new annotations and reset present ones
%   Action=2 ... set annotations only if not yet present
%   Action=3 ... only reset annotations that are present
% The Anno parameter defines the annotation strings. It can be a single 
% string or a cell array of strings of the same length as Segs. 
% It can also be a numeric array, then it is transformed into strings 
% using num2str. Anno is optional, if omitted or empty the segment 
% numbers are used for annotation.

global PlotGridProp;

if nargin<2,
  return
elseif ischar(Segs),
  Segs=1:size(Ant.Desc,1);
end
if isempty(Segs), return, end
Segs=Segs(:);

if (nargin<4)||isempty(Anno),
  Anno=Segs;
end

if (nargin<3)||isempty(Action),
  Action=1;
end

[Segs,m,N]=unique(Segs);

q=length(Segs);
[Segs,m]=intersect(Segs,1:size(Ant.Desc,1));
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

[PNodes,PSegs,PPats,NH,SH]=PlotRecog(Ant,'S');

q=length(Segs);
[Segs,m]=intersect(Segs,PSegs);
q=zeros(q,1);
q(m)=1:length(m);
N=MapComp(N,q);

if Action~=0,
  Anno=ToCellstr(Anno,length(N));
  [q,m]=unique(N);
  Anno=Anno(m);
end

switch Action,
  
case 0,
  
  hs=Gather(SH(Segs));
  ha=Gather(get(hs,'UserData'));
  delete(ha);
  set(hs,'UserData',[]);
  
case 1,
  
  r=(Ant.Geom(Ant.Desc(Segs,1),:)+Ant.Geom(Ant.Desc(Segs,2),:))/2;
  for k=1:length(Segs),
    hs=SH{Segs(k)};
    ha=get(hs,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
    end
    ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.SegAnno);
    set(hs,'UserData',ha);
  end
  
case 2,
  
  r=(Ant.Geom(Ant.Desc(Segs,1),:)+Ant.Geom(Ant.Desc(Segs,2),:))/2;
  for k=1:length(Segs),
    hs=SH{Segs(k)};
    ha=get(hs,'UserData');
    if isempty(ha)||isequal(ha,0),
      ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.SegAnno);
      set(hs,'UserData',ha);
    end
  end
  
case 3,
  
  r=(Ant.Geom(Ant.Desc(Segs,1),:)+Ant.Geom(Ant.Desc(Segs,2),:))/2;
  for k=1:length(Segs),
    hs=SH{Segs(k)};
    ha=get(hs,'UserData');
    if ~isempty(ha)&&~isequal(ha,0),
      delete(ha);
      ha=text(r(k,1),r(k,2),r(k,3),Anno{k},PlotGridProp.SegAnno);
      set(hs,'UserData',ha);
    end
  end

end

============================================================

function H=PlotSegs(Geom,Desc,Segs,LineCol,AnnoCol)

% H=PlotSegs(Geom,Desc,Segs,LineCol,AnnoCol) 
% plots the segments given in the vector Segs using the color given
% in LineCol. AnnoCol defines the color of the respective annotation 
% numbers. The colors may be given by the usual color specifications, 
% where several colors can be defined by rows of matrices. 
% If only Geom and Desc is given or Segs='all', all 
% segments are drawn. H returns handles to the line objects, the
% handles of the annotation texts being saved as UserData property
% of the respective line objects.
% Default properties for segments and annotations are defined in
% the global variables PlotGridProp.Seg and PlotGridProp.SegAnno.

global PlotGridProp;

PlotGridProperty;

if nargin<3, 
  Segs=1:size(Desc,1); 
end
if ischar(Segs), 
  Segs=1:size(Desc,1); 
end
if isempty(Segs),
  if nargout>0,
    H=[];
  end
  return
end
SN=length(Segs);

if nargin<4,
  LineCol=[];
end
if ~isempty(LineCol),
  LineCol=RGBColor(LineCol,PlotGridProp.Seg.Color);
  n=mod((0:SN-1),size(LineCol,1))+1;
  LineCol=LineCol(n,:);
end

if nargin<5,
  AnnoCol=[];
end
Annotation=~isempty(AnnoCol);
if Annotation,
  AnnoCol=RGBColor(AnnoCol,PlotGridProp.SegAnno.Color);
  n=mod((0:SN-1),size(AnnoCol,1))+1;
  AnnoCol=AnnoCol(n,:);
end 
   
% Plot segments:

h=ishold;
if ~h, cla('reset'); hold on; end

H=line([Geom(Desc(Segs,1),1),Geom(Desc(Segs,2),1)]',...
       [Geom(Desc(Segs,1),2),Geom(Desc(Segs,2),2)]',...
       [Geom(Desc(Segs,1),3),Geom(Desc(Segs,2),3)]',...
       PlotGridProp.Seg);

if ~isempty(LineCol),
  set(H,{'Color'},num2cell(LineCol,2));
end

% Plot annotation numbers:

if Annotation,
  r=(Geom(Desc(Segs,1),:)+Geom(Desc(Segs,2),:))/2;
  c=deblank(cellstr(strjust(num2str(Segs(:)),'left')));
  HA=text(r(:,1),r(:,2),r(:,3),c,PlotGridProp.SegAnno);
  set(HA,{'Color'},num2cell(AnnoCol,2));
  set(H,{'UserData'},num2cell(HA(:),2));  
end

if ~h, hold off; end

if nargout==0,
  clear H;
end

============================================================

function ViewGrid(Ant,BkObjs,BkNodes,BkSegs,BkPats)

% ViewGrid(Ant) visualizes the nodes, segments and patches
% of the given antenna grid Ant. The whole antenna grid is 
% plotted. In an interactive session an arbitrary subset of
% nodes, segments or patches can be selected, being
% plotted red for emphasis. An initial control character is
% used to indicate if objects, nodes, segments or patches 
% are to be emphasized, followed by the subset specification, 
% e.g.: 'n 10:20' the nodes 10 through 20; 's7' segment 7; 
% 'p[8,11,15]' the patches 8, 11 and 15; 'o3' object 3; and so on.
% The control character '!' can be used to execute a MATLAB 
% command without leaving the interactive visualization.
% The control character 'a' changes the state of annotation 
% (if annotation numbers should be displayed or not).
% Use 'q'  to quit the session.
%
% ViewGrid(Ant,BkObjs,BkNodes,BkSegs,BkPats) is the same, 
% but confines the shown part of the antenna grid to BkObjs,
% BkNodes, BkSegs and BkPats, which define the 'background'-items
% (objects, nodes, segments and patches) which are displayed
% during the whole interactive session. Use BkNodes='all' to 
% display all nodes, similarly for the other types. Objects are
% dispayed as their Graf fields determine. Elements which 
% are not in objects are displayed in a default style defined
% by the local variables NodeProp, NodeAnnoProp, SegProp, 
% SegAnnoProp and PatchProp, PatchAnnoProp, respectively.

% control characters (must be uppercase here):

QuitChar='Q';
ObjChar='O';
NodeChar='N';
SegChar='S';
PatchChar='P';
AnnoChar='A';
ExeChar='!';

Blank=' ';
Prompt='->';

UseAnno=1;  % use annotation by default

NodeProp=struct('Marker','o','MarkerSize',4,...
  'MarkerFaceColor',[1,0,0],'MarkerEdgeColor',[1,0,0]);
NodeAnnoProp=struct('Color',[1,0,0],'EraseMode','xor');


SegProp=struct('LineWidth',2,'Color',[0.7,0,0]);
SegAnnoProp=struct('Color',[0.7,0,0],'EraseMode','xor');

PatchProp=struct('FaceLighting','none','FaceAlpha',1,...
  'FaceColor',[0.8,0.3,0],'EdgeColor','k');
PatchAnnoProp=struct('Color',[0.8,0.3,0],'EraseMode','xor');

% view preparation, plot grid:

h=ishold;
if ~h, cla('reset'); hold on; end

if (nargin<2),
  BkObjs='all';
  BkNodes='all';
  BkSegs='all';
  BkPats='all';
end

if ischar(BkObjs),
  BkObj=1:length(Ant.Obj);
end
BkObj=intersect(BkObj,1:length(Ant.Obj));

if ~exist('BkNodes','var'),
  BkNodes=[];
elseif ischar(BkNodes),
  BkNodes=1:size(Ant.Geom,1);
end
BkNodes=intersect(BkNodes,1:size(Ant.Geom,1));

if ~exist('BkSegs','var'),
  BkSegs=[];
elseif ischar(BkSegs),
  BkSegs=1:size(Ant.Desc,1);
end
BkSegs=intersect(BkSegs,1:size(Ant.Desc,1));

if ~exist('BkPats','var'),
  BkPats=[];
elseif ischar(BkPats),
  BkPats=1:length(Ant.Desc2d);
end
BkPats=intersect(BkPats,1:length(Ant.Desc2d));

[Nodes,Segs,Pats,NH,SH,PH]=PlotGrid(Ant,BkObj,BkNodes,BkSegs,BkPats);

axis equal
xlabel('x');
ylabel('y');
zlabel('z');

set(gcf,'Renderer','zbuffer');

% visualized elements, element-, annotation- and hidden handles
[E,OldE,EH,AH,HH]=deal([]); 

% input strings
Inp=Blank;  
OldInp=Blank;

% visualization loop:

while ~isequal(Inp,QuitChar),

  if isequal(Inp,Blank),  % increment E by default
    if ~isempty(E),
      E=OldE+1+OldE(end)-OldE(1);
    end
    Inp=OldInp(1);
  elseif isequal(Inp(1),ExeChar);  % execute input-line as command
    try
      eval(Inp(2:end));
    catch
      display(lasterr);
      Inp=Blank;
    end
  elseif isequal(Inp(1),AnnoChar)&&isempty(deblank(Inp(2:end))),
    UseAnno=~UseAnno;
    Inp=Blank;
  else
    if ~ismember(Inp(1),[ObjChar,NodeChar,SegChar,PatchChar]),
      Inp=[OldInp(1),Inp];  % use recent control character
    end
    try
      E=eval(Inp(2:end));  % determine elements to plot  
      if ~isnumeric(E),
        Inp=Blank;
      end
    catch
      display(lasterr);
      Inp=Blank;
    end
  end
  
  switch Inp(1),
  case NodeChar,

    if isempty(Ant.Geom),
      E=[];
    end
    E=mod(E-1,size(Ant.Geom,1))+1;
    [d,k]=unique(E);
    E=E(sort(k));
    delete(AH);
    delete(EH);
    set(HH,'Visible','on');
    HH=[NH{E}]';
    set(HH,'Visible','off');
    EH=PlotNodes(Ant.Geom,E,[],[],'r');
    set(EH,NodeProp);
    AH=get(EH,'UserData');
    if iscell(AH),
      AH=cat(1,AH{:});
    end
    set(AH,NodeAnnoProp);
    
  case SegChar,
  
    if isempty(Ant.Desc),
      E=[];
    end
    E=mod(E-1,size(Ant.Desc,1))+1;
    [d,k]=unique(E);
    E=E(sort(k));
    delete(AH);
    delete(EH);
    set(HH,'Visible','on');
    HH=[SH{E}]';
    set(HH,'Visible','off');
    EH=PlotSegs(Ant.Geom,Ant.Desc,E,[],'r');
    set(EH,SegProp);
    AH=get(EH,'UserData');
    if iscell(AH),
      AH=cat(1,AH{:});
    end
    set(AH,SegAnnoProp);
    
  case PatchChar,
    
    if isempty(Ant.Desc2d),
      E=[];
    end
    E=mod(E-1,length(Ant.Desc2d))+1;
    [d,k]=unique(E);
    E=E(sort(k));
    delete(AH);
    delete(EH);
    set(HH,'Visible','on');
    HH=[PH{E}]';
    set(HH,'Visible','off');
    EH=PlotPats(Ant.Geom,Ant.Desc2d,E,[],'r');
    set(EH,PatchProp);
    AH=get(EH,'UserData');
    if iscell(AH),
      AH=cat(1,AH{:});
    end
    set(AH,PatchAnnoProp);
    
  case ObjChar,
  
    if isempty(Ant.Obj),
      E=[];
    end
    E=mod(E-1,length(Ant.Obj))+1;
    [d,k]=unique(E);
    E=E(sort(k));
    delete(AH);
    delete(EH);
    set(HH,'Visible','on');
    
    [Points,Wires,Surfs]=FindGridObj(Ant);
    EN=Gather({Ant.Obj(intersect(Points,E)).Elem});
    ES=Gather({Ant.Obj(intersect(Wires,E)).Elem});
    EP=Gather({Ant.Obj(intersect(Surfs,E)).Elem});
    HH=[NH{EN},SH{ES},PH{EP}]';
    set(HH,'Visible','off');
    
    ENH=PlotNodes(Ant.Geom,EN,[],[],'r');
    set(ENH,NodeProp);
    ANH=get(ENH,'UserData');
    if iscell(ANH),
      ANH=cat(1,ANH{:});
    end
    set(ANH,PatchAnnoProp);

    ESH=PlotSegs(Ant.Geom,Ant.Desc,ES,[],'r');
    set(ESH,SegProp);
    ASH=get(ESH,'UserData');
    if iscell(ASH),
      ASH=cat(1,ASH{:});
    end
    set(ASH,PatchAnnoProp);

    EPH=PlotPats(Ant.Geom,Ant.Desc2d,EP,[],'r');
    set(EPH,PatchProp);
    APH=get(EPH,'UserData');
    if iscell(APH),
      APH=cat(1,APH{:});
    end
    set(APH,PatchAnnoProp);
    
    EH=[ENH;ESH;EPH];
    AH=[ANH;ASH;APH];

  end % of switch
  
  if ismember(Inp(1),[NodeChar,SegChar,PatchChar,ObjChar]),
    OldInp=Inp;
    OldE=E;
  end
  
  if UseAnno,
    set(AH,'Visible','on');
  else
    set(AH,'Visible','off');
  end
  
  Inp=deblank(input(Prompt,'s'));
  if isempty(Inp),
    Inp=Blank;
  else
    Inp(1)=upper(Inp(1));
  end
  
end  

set(HH,'Visible','on');
delete(AH);
delete(EH);

if ~h, hold off; end
