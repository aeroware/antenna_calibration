============================================================

function AttaInit

% AttaInit initialized ATTA (Antenna Toolbox for Transfer Matrix
% Applications). It has to be called before working with the toolbox
% routines.


% ASAP parameters:
% ----------------

global Atta_Asap_Exe Atta_Asap_Inexe Atta_Asap_Outexe 
global Atta_Asap_In Atta_Asap_Out 

% Asap executable:

Atta_Asap_Exe='asap3g.exe';

% Asap input and output files used by Asap executable:

Atta_Asap_Inexe='asapin.dat';
Atta_Asap_Outexe='asapout.dat';

% Asap input and output files used by toolbox:

Atta_Asap_In='asap.in';
Atta_Asap_Out='asap.out';


% CONCEPT parameters:
% ----------------

global Atta_Concept_FE Atta_Concept_BG Atta_Concept_BE
global Atta_Concept_In Atta_Concept_Out Atta_Concept_Ili Atta_Concept_Ifl
global Atta_Concept_Surf0 Atta_Concept_Wire1 Atta_Concept_Surf1 
global Atta_Concept_EHIn Atta_Concept_EHOut Atta_Concept_EHExe
global Atta_Concept_EOutasc Atta_Concept_HOutasc Atta_Concept_EHOutasc
global Atta_Concept_DelEHFiles 

% Concept executables:

Atta_Concept_FE='concept.fe.exe';   % concept front end
Atta_Concept_BG='buildgeo.exe';     % concept geometry builder
Atta_Concept_BE='concept.be.exe';   % concept back end

% Concept input and output files:

Atta_Concept_In='concept.in';
Atta_Concept_Wire1='wire.1';
Atta_Concept_Surf1='surf.1';
Atta_Concept_Out='concept.out';
Atta_Concept_Ili='co_ili.bin';
Atta_Concept_Ifl='co_ifl.bin';
Atta_Concept_EHIn='eh1d.in';
Atta_Concept_EHOut='eh1d.out';
Atta_Concept_EHExe='eh1d.exe';
Atta_Concept_Surf0='surf.0';
Atta_Concept_EOutasc='co_edat.asc';
Atta_Concept_HOutasc='co_hdat.asc';

% etc.

Atta_Concept_EHOutasc=1; 
% if co_?dat.asc file shall be read instead of eh1d.out to get E or H

Atta_Concept_DelEHFiles=1; 
% if EH files shall be deleted after field calculations


% Directory, file and variable names, etc.:
% -----------------------------------------

global Atta_SolverDirFormat Atta_FreqDirFormat Atta_FeedDirFormat
global Atta_FeedDirAlldriven Atta_PhysGridFile Atta_TransferFile
global Atta_PhysGridName Atta_TsFileName Atta_ToFileName
global Atta_CalcAnt_Recalc

Atta_SolverDirFormat='%s';
Atta_FreqDirFormat='kHz_%06.0f';
Atta_FeedDirFormat='Feed_%d';
Atta_FeedDirAlldriven='Feed_alldriven';

Atta_PhysGridFile='PhysGrid';
Atta_TransferFile='Transfer';

Atta_PhysGridName='PhysGrid';

% set the following variables =[] to prevent auto-saving at calculation:
Atta_TsFileName=''; % save Ts and Y in this file when calculated by CalcTs
Atta_ToFileName='To'; % save To and Z in this file when calculated by CalcTo

Atta_CalcAnt_Recalc={'Curr','To'}; 
% Signify if 'Curr' or 'To' shall be recalculated by CalcAnt even if already 
% present, e.g. Atta_CalcAnt_Recalc={'To'} does calculate only those currents 
% only which were not yet calculates, but always calculates To anew; 
% Atta_CalcAnt_Recalc={} recalculates only what is not yet present.


% Solver names (must be different, the solver-id is simply the index number):
% -------------------------------------------------------------------------

global Atta_Solver_Names 

Atta_Solver_Names={'Asap','Concept'};

============================================================

function [Z,To,Op,PhysGrid]=CalcAnt(AntGrid,DataRootDir,Solver,Freq,...
  er,Titel,WireOption,FarFieldOption)

% [Z,To,Op,PhysGrid]=CalcAnt(AntGrid,DataRootDir,Solver,Freq,...
%   er,Titel,WireOption,FarFieldOption)
% calculates antenna currents (returned in Op), impedance matrices Z, 
% and transfer maztrices (To) for open ports. The physical antenna grid
% for the given Solver is returned in PhysGrid. The antenna parameters
% (Z,To,Op) are calculated for all given frequencies (in vector Freq).
%
% The transfer matrices are calculated for all directions er.
% er contains unit vectors as rows showing in the respective direction from 
% which the wave comes in (antiparallel to wave vector of incident wave).
% If er=[] is passed, no tranfer matrices are calculated and To=[] returned.
%
% Titel is an optional title or short comment for the antenna system.
%
% WireOption may be {}, {'ForceWires'} or {'OnlyWires'}, for explanation
% see the function PhysGrid.
% 
% FarFieldOption may be 'Matlab' or 'Solver' and defines how the far field
% for the determination of To is calculated (by Matlab toolbox routines or
% by the programs implemented in the respective solver).
%
% Default values: er=[]; Titel=''; WireOption={}; FarFieldOption='Matlab'

global Atta_ToFileName Atta_CalcAnt_Recalc

if ~exist('er','var')||isempty(er),
  er=[];
end

if ~exist('Titel','var')||isempty(Titel),
  Titel='';
end

if ~exist('WireOption','var')||isempty(WireOption),
  WireOption={};
end

if ~exist('FarFieldOption','var')||isempty(FarFieldOption),
  FarFieldOption='Matlab';
end

if isfield(AntGrid,'Solver')&&isfield(AntGrid,'Geom_'),
  PhysGrid=AntGrid;
else
  PhysGrid=GetPhysGrid(AntGrid,Solver,WireOption,DataRootDir);
end

Recalc=ismember(upper({'Curr','To'}),upper(Atta_CalcAnt_Recalc));
  
FeedNum='sys';
  
Z=[];
To=[];
Op=struct('Freq',{});

NFreqs=numel(Freq);

for n=1:NFreqs,
  
  RecalcCurr=Recalc(1);
  if ~RecalcCurr,
    try
      Op=LoadCurr(DataRootDir,PhysGrid,Freq(n),FeedNum);
    catch
      RecalcCurr=1;
    end
  end
  if RecalcCurr,
    Op=CalcCurr(PhysGrid,Freq(n),FeedNum,Titel,DataRootDir);
  end
  
  if isempty(er),
    Z(:,:,n)=CalcZ(Op,FeedNum);
    To=[];
  else
    RecalcTo=Recalc(2);
    if ~RecalcTo,
      try
        [To,ex,Z(:,:,n)]=LoadT(DataRootDir,Solver,Freq(n),Atta_ToFileName);
        if ~isequal(ex,er),
          RecalcTo=1;
        end
      catch
        RecalcTo=1;
      end
    end
    if RecalcTo,
      [To,Z(:,:,n)]=CalcTo(er,PhysGrid,Op,DataRootDir,FarFieldOption);
    end
  end

end

if NFreqs>1,

  if nargout>2,
    Op=LoadCurr(DataRootDir,PhysGrid,Freq(:),FeedNum);
  end
  
  if ~isempty(er)&&(nargout>1),
    To=LoadT(DataRootDir,Solver,Freq(:),Atta_ToFileName);
  end
  
end


============================================================

function Op=CalcCurr(PhysGrid,Freq,FeedNum,Titel,DataRootDir)

% Op=CalcCurr(PhysGrid,Freq,FeedNum,Titel)
% solves the boundary value problem for the currents on the given antenna
% structure PhysGrid, where the feeding is defined in FeedNum:
% FeedNum='all' causes simultaneous driving of all feeds as declared in
%   PhysGrid.Geom_.Feeds.Elem and/or PhysGrid.Desc_.Feeds.Elem, 
%   driven by the respective voltages 
%   PhysGrid.Geom_.Feeds.V and/or PhysGrid.Desc_.Feeds.V.
% If FeedNum passes a number, unit voltage at the feed with number FeedNum 
%   is applied, the other feeds being short-circuited, where
%   the counting is according to the order in the concatenation
%   [PhysGrid.Geom_.Feeds.Elem,PhysGrid.Desc_.Feeds.Elem]. 
%   The fields PhysGrid.Geom_.Feeds.V and PhysGrid.Desc_.Feeds.V
%   are ignored in this case.
% FeedNum='sys' solves consecutively for FeedNum=1,2,...;
%   this gives a whole current system which fully defines the behaviour of
%   the antenna system as part of an electronic circuit and the possible
%   reception and transmission states (from the resulting current system 
%   the antenna impedance matrix and the transfer matrices can be calculated).
% 
% The returned struct Op contains the calculated antenna currents
% (.Curr1 on wires and .Curr2 on surfaces; .Curr1b and .Curr2b wire and 
% surface bases definition), E-field normal to surface (.Ensurf), 
% exterior properties (.Exterior) and input parameters reread from 
% the output file (.Reread.Freq, .Reread.Exterior, etc.). 
% The array size of Op depends on the number of frequencies, ie.
% length(Freq), and the number of driving states to be observed: 
% the first dimension of Op counts the driving states (feeds), 
% the second the frequencies.
% For FeedNum='all' or numeric FeedNum (must be scalar) only one driving
% state is analysed, for FeedNum='sys' the number of driving states agrees
% with the number of feeds (as explained above).
%
% The string Titel is placed as a title at the beginning of the input files.
% 
% Op=CalcCurr(PhysGrid,Freq,FeedNum,Titel,DataRootDir) 
% defines also the directory DataRootDir which is the root of certain
% subdirectories where the calculations have to be performed, 
% i.e. where the input and output files are stored
% (default is the current directory).
% Actually a directory structure of the form
%   DataRootDir/solver/frequency/feed 
% is created for each frequency and driving type.
% For further info see the function GetDataSubdirs.
% 
% Note that all present files of the type DeleteFiles (defined in the
% beginning of the this function) are deleted before new input files are 
% generated for the following calculations.


% Old files to be deleted from the directory of output files 
% before calling Solver:

DeleteFiles={'*.bin','*.o','*.out'};


if ~exist('DataRootDir','var')||isempty(DataRootDir),
  DataRootDir='';
end

if ~exist('Titel','var')||isempty(Titel),
  Titel='';
end

Op=struct('Freq',{});

% check FeedNum and applied voltages:

if ~exist('FeedNum','var')||isempty(FeedNum),
  FeedNum='sys';
end
if ischar(FeedNum),
  FeedNum=lower(FeedNum);
end
if ~isnumeric(FeedNum)&&~isequal(FeedNum,'sys')&&~isequal(FeedNum,'all'),
  error('Unknown FeedNum parameter encountered.');
end

if isequal(FeedNum,'sys'), 
  
  % determine the whole current system
  
  try
    q0=PhysGrid.Geom_.Feeds.Elem;
  catch
    q0=[];
  end
  try
    q1=PhysGrid.Desc_.Feeds.Elem;
  catch
    q1=[];
  end
  MaxFeedNum=length(q0)+length(q1);
  if MaxFeedNum<1,
    error('No feeds found.');
  end
  for nf=1:length(Freq),
    for FeedNum=1:MaxFeedNum,
      Opx=CalcCurr(PhysGrid,Freq(nf),FeedNum,Titel,DataRootDir);
      Op=SetStruct(Op,Opx,{FeedNum,nf},{1,1});
    end  
  end
  return

elseif isequal(FeedNum,'all'),

  % perform some checks if all feeds are to be driven:
  
  try
    SegmFeeds=PhysGrid.Desc_.Feeds.Elem(:);
    NodeFeeds=PhysGrid.Geom_.Feeds.Elem(:);
    SegmV=PhysGrid.Desc_.Feeds.V(:);
    NodeV=PhysGrid.Geom_.Feeds.V(:);
  catch
    error('Incorrect feed definition in antenna grid.');
  end
  if isequal(CheckSolver(PhysGrid.Solver),CheckSolver('CONCEPT')),
    if ~isempty(NodeFeeds)||~isempty(NodeV),
      error('Node feeds are not allowed for Concept calculation.');
    end
  end
  if length(SegmFeeds)~=length(SegmV),
    error('The number of segment voltages does not agree with feeds.');
  end
  if length(NodeFeeds)~=length(NodeV),
    error('The number of node voltages does not agree with feeds.');
  end

end


% Frequency loop:
% ---------------

for nf=1:length(Freq),
  
  % subdirectories of DataRootDir dependent on solver, frequency and FeedNum

  [SolverDir,FreqDir,FeedDir]=...
    GetDataSubdirs(DataRootDir,PhysGrid.Solver,Freq(nf),FeedNum,1);  

  % delete old files:
  
  try
    for n=1:length(DeleteFiles),
      Filn=fullfile(FeedDir,DeleteFiles{n});
      d=dir(Filn);
      if ~isempty(d),
        delete(Filn);
      end
    end
  catch
    error(['Error occured while trying to delete "',Filn,'".']);
  end

  % display solver, frequency and feed on screen
  
  if ~isempty(lastwarn),
    fprintf('\n');
    lastwarn('');
  end

  if isnumeric(FeedNum),
    Message=sprintf('Solver=%s, f = %g kHz, driven feed = %d \n',...
      CheckSolver(PhysGrid.Solver),Freq(nf)/1e3,FeedNum);
  else
    Message=sprintf('Solver=%s, f = %g kHz, all feeds driven \n',...
      CheckSolver(PhysGrid.Solver),Freq(nf)/1e3);
  end
  
  fprintf(Message);
  
  % generate input files, call solver and read output (result) files

  if isequal(CheckSolver(PhysGrid.Solver),CheckSolver('CONCEPT')),

    Op=Concept_Curr(PhysGrid,Freq(nf),FeedNum,FeedDir,Titel);
    
  elseif isequal(CheckSolver(PhysGrid.Solver),CheckSolver('ASAP')),

    Op=Asap_Curr(PhysGrid,Freq(nf),FeedNum,FeedDir,Titel);
    
  else
    
    error('Unknown Solver declaration in grid-struct.')
    
  end
  
  Op(1,nf).Freq=Freq(nf);
  
  Op(1,nf).Exterior.epsr=EvaluateFun(PhysGrid.Exterior.epsr,Freq(nf));

  Op(1,nf).Vfeed=GetFeedVolt(PhysGrid,FeedNum);
  Op(1,nf).Ifeed=GetFeedCurr(PhysGrid,Op(1,nf));
  
end


============================================================

function [To,Z]=CalcTo(er,PhysGrid,Op,DataRootDir,Method)

% To=CalcTo(er,PhysGrid,Op,DataRootDir) and
% To=CalcTo(er,Solver,Freq,DataRootDir)
% work like CalcTs (see there), except that the open-port transfer
% matrix To is returned instead of the short-circuit one (Ts).
%
% [To,Z]=CalcTo(...) additionally returns the antenna impedance matrix Z,
% which is also needed for the determination of the transfer matrix of
% the loaded antenna system (by means of To2T).

global Atta_ToFileName

if ~exist('DataRootDir','var')||isempty(DataRootDir),
  DataRootDir='';
end

if ~exist('Method','var')||isempty(Method),
  Method='';
end

% determine Ts and Y, and store it into To and Z, resp.:

[To,Z]=CalcTs(er,PhysGrid,Op,DataRootDir,Method);

% determine Z=inv(Y) and use it to calculate To=Z*Ts:

NDirs=size(To,3);
NFreqs=size(To,4);

if isstruct(Op),
  Freqs=[Op(1,:).Freq];
else
  Freqs=Op;
end
if length(Freqs)~=NFreqs,
  error('Inconsistent number of frequencies.');
end

if isstruct(PhysGrid),
  Solver=PhysGrid.Solver;
else
  Solver=PhysGrid;
end

for n=1:NFreqs,  
    
  Z(:,:,n)=inv(Z(:,:,n));
  for m=1:NDirs,
    To(:,:,m,n)=Z(:,:,n)*To(:,:,m,n);
  end
  
  [SolverDir,FreqDir]=GetDataSubdirs(DataRootDir,Solver,Freqs(n));
    
  if ~isempty(Atta_ToFileName),
    VarSave(fullfile(FreqDir,Atta_ToFileName),To(:,:,:,n),[],'To');
    VarSave(fullfile(FreqDir,Atta_ToFileName),er,[],'er');
    VarSave(fullfile(FreqDir,Atta_ToFileName),Z(:,:,n),[],'Z');
  end
  
end

============================================================

function [Ts,Y]=CalcTs(er,PhysGrid,Op,DataRootDir,Method)

% Ts=CalcTs(er,PhysGrid,Op,DataRootDir)
% calculates the short-circuit transfer matrix Ts of the 
% antenna system PhysGrid for all frequencies for which
% currents are stored in the operation struct Op and for all directions
% given in er (where each row is a unit vector in the respective direction). 
% The results are returned in Ts and stored in the frequency-specific 
% directories inside the data root directory DataRootDir.
% Ts has size NFeeds x 3 x Ndirs x NFreqs, with NFeeds=number of
% frequencies (=size(Op,2)), Ndirs=number of directions (=size(er,1)),
% NFeeds=number of feeds (=size(Op,1)).
%
% Ts=CalcTs(er,Solver,Freq,DataRootDir)
% does the same but reads PhysGrid and Op from the subdirectories
% of DataRootDir determined by Solver and Freq. Freq may be a vector
% of frequencies.
%
% [Ts,Y]=CalcTs(...) also returns the antenna admittance matrix Y.
%
% [Ts,Y]=CalcTs(er,PhysGrid,Op,DataRootDir,Method,TFileName)
% gives a calculation Method to be used, either Method='Matlab' 
% or Method='Solver', which means that Matlab routines of the toolbox or 
% the programs provided by the respective solver are to be used.


global Atta_PhysGridFile Atta_PhysGridName Atta_TsFileName

if ~exist('DataRootDir','var')||isempty(DataRootDir),
  DataRootDir='';
end

if ~exist('Method','var')||isempty(Method),
  Method='Matlab';
end


if ~isstruct(PhysGrid),
  
  Solver=PhysGrid;
  Freq=Op;
  
  SolverDir=GetDataSubdirs(DataRootDir,Solver);
  
  PhysGrid=VarLoad(fullfile(SolverDir,Atta_PhysGridFile),[],Atta_PhysGridName);
  
  Op=LoadCurr(DataRootDir,PhysGrid,Freq,'sys');
  
end

Ndirs=size(er,1);
NFeeds=size(Op,1);
NFreqs=numel(Op)/NFeeds;

Ts=zeros([NFeeds,3,Ndirs,NFreqs]);

if (nargout>1)||~isempty(Atta_TsFileName),
  Y=CalcY(Op,'sys');
end

fprintf('\n')

for n=1:NFreqs,
  
  Message=sprintf('Transfer matrix for %d. of %d frequencies (%fkHz).  ',...
    n,NFreqs,Op(1,n).Freq/1e3);
  fprintf(Message);
  
  for m=1:NFeeds, 
    
    [SolverDir,FreqDir,FeedDir]=...
      GetDataSubdirs(DataRootDir,PhysGrid.Solver,Op(m,n).Freq,m);
      
    AA=FarField('A',PhysGrid,Op(m,n),er,FeedDir,Method);

    [k,epsi,mu]=Kepsmu(Op(m,n).Freq,PhysGrid) ;

    Ts(m,:,:,n)=permute(AA,[3,2,1])*(4*pi)/mu/Op(m,n).Vfeed(m);
  
  end

  if ~isempty(Atta_TsFileName),
    VarSave(fullfile(FreqDir,Atta_TsFileName),Ts(:,:,:,n),[],'Ts');
    VarSave(fullfile(FreqDir,Atta_TsFileName),er,[],'er');
    VarSave(fullfile(FreqDir,Atta_TsFileName),Y(:,:,n),[],'Y');
  end
  
  fprintf(repmat('\b',1,length(Message)))
  
end


if numel(Ts(1,1,:))==1,
  m='matrix';
else
  m='matrices';
end
fprintf('%d-port transfer %s successfully calculated; frequ [kHz]: ',NFeeds,m);
f=unique([Op.Freq]/1e3);
if length(f)==1,
  fprintf('%7g\n',f);
else
  fprintf('\n');
  fprintf('%7g %7g %7g %7g %7g %7g %7g %7g %7g %7g\n',f);
  if mod(length(f),10)~=0,
    fprintf('\n')
  end
end
fprintf('\n')

============================================================

function Y=CalcY(Op,FeedNum)

% Y=CalcY(Op) determines the antenna admittances for 
% the currents given in Op, which means:
%   Y(m,n,q) = Op(n,q).Ifeed(m)/Op(n,q).Vfeed(m)
% in case FeedNum='all', i.e. if Op was obtained by driving all feeds 
% simultaneously using the option FeedNum='all' in CalcCurr; otherwise
%   Y(m,n,q) = Op(n,q).Ifeed(m)/Op(n,q).Vfeed(n),
% which returns proper admittance matrices when current systems
% were obtained by passing FeedNum='sys' to CalcCurr.
% If FeedNum is not given, the second method is the default one
% in case max(n)=max(m), otherwise the first.
%
% Here q may also stand for a list of indices q1,q2,q3,...

Y=[];
if isempty(Op),
  return
end

% number of observed feeds:
mm=numel(Op(1).Ifeed);

% number of driven feeds:
nn=size(Op,1);

% number of driving situations (apart from feed variation), usually frequencies:
qq=numel(Op)/nn;        

s=[size(Op),1];

Y=zeros([mm,nn,s(3:end)]);

if ~exist('FeedNum','var')||isempty(FeedNum),
  if nn==mm,
    FeedNum='sys';
  else
    FeedNum='all';
  end
end
if ischar(FeedNum),
  FeedNum=lower(FeedNum(~isspace(FeedNum)));
end

if isequal(FeedNum,'all'),

  for n=1:nn,
    for q=1:qq,
      Y(:,n,q)=Op(n,q).Ifeed(:)./Op(n,q).Vfeed(:);
    end
  end

else

  for n=1:nn,
    for q=1:qq,
      Y(:,n,q)=Op(n,q).Ifeed(:)./Op(n,q).Vfeed(n);
    end
  end

end

============================================================

function Z=CalcZ(Op,FeedNum)

% Z=CalcZ(Op,FeedNum) determines the antenna impedances for 
% the currents given in Op, which means:
%   Z(m,n,q) = Op(n,q).Vfeed(m) / Op(n,q).Ifeed(m)
% in case FeedNum='all', i.e. if Op was obtained by driving all feeds 
% simultaneously using the option FeedNum='all' in CalcCurr; otherwise
%   Z(:,:,q) = inv(Y(:,:,q)), with
%   Y(m,n,q) = Op(n,q).Ifeed(m)/Op(n,q).Vfeed(n),
% which returns proper impedance matrices when current systems
% were obtained by passing FeedNum='sys' to CalcCurr.
% If FeedNum is not given, the second method is the default one
% in case max(n)=max(m), otherwise the first.
%
% Here q may also stand for a list of indices q1,q2,q3,...

Z=[];
if isempty(Op),
  return
end

if ~exist('FeedNum','var'),
  FeedNum=[];
end

Z=CalcY(Op,FeedNum);

if isequal(FeedNum,'all'),
  
  for n=1:size(Z(:,:,:),3),
    Z(:,:,n)=1./Z(:,:,n);
  end
  
else
  
  for n=1:size(Z(:,:,:),3),
    Z(:,:,n)=inv(Z(:,:,n));
  end
  
end

============================================================

function [SolverName,SolverId]=CheckSolver(Solver)

% [SolverName,SolverId]=CheckSolver(Solver)
% returns the exact name of the given Solver. Solver may
% be an abbreviation of the Solver name or the solver id. The latter is
% simply the index number under which the solver appears in the global
% variable Atta_Solver_Names. This variable declares the exact names of all
% implemented solvers. If the Solver is not recognized, SolverName='' and
% SolverId=0 is returned. 

global Atta_Solver_Names

n=length(Atta_Solver_Names);

if ischar(Solver),  % string passed
  
  e=zeros(n,1);

  Solver=Solver(~isspace(Solver));
  for m=1:n,
    so=upper(char({Solver,Atta_Solver_Names{m}}));
    e(m)=sum(so(1,:)==so(2,:));
  end
  
  [eii,ii]=sort(e,1,'descend');
  
  if eii(1)<1,
    SolverName='';
    SolverId=0;
  else
    if eii(1)==eii(2),
      warning('Solver not uniquely identified.');
    end
    SolverId=ii(1);
    SolverName=Atta_Solver_Names{SolverId};    
  end
  
else  % solver-id passed
  
  if (Solver<1)||(Solver>n),
    SolverName='';
    SolverId=0;
  else
    SolverId=round(Solver);
    SolverName=Atta_Solver_Names{SolverId};    
  end
  
end    
  

============================================================

function Zcorr=DiamCorr(Z,AntLen,AntDiam,AntDiamCorr,Freq,epsilon)

% Zcorr=DiamCorr(Z,AntLen,AntDiam,AntDiamCorr,Freq,epsilon)
% performs a correction of the impedance matrix Z of a multi-port
% antenna system consisting of monopoles (i.e. each port is at a 
% monopole, but any number of other parasitic bodies may be present), 
% in order to adapt the antenna diameters. 
% AntLen is the antenna length, AntDiam the original diameter of the 
% antennas for which Z has been determined, and AntDiamCorr is the 
% correct diameter of the antennas for which Zcorr is to be calculated. 
% Freq is the operation frequency and epsilon the dielectric constant 
% (default is vacuum). Freq and epsilon must be scalars,
% AntLen, AntDiam and AntDiamCorr may be scalar or vectors having one 
% element for each monopole. If scalar, it means that the respective value
% holds for all monopoles.

NFeeds=length(Z);

if ~exist('epsilon','var')||isempty(epsilon),
  c=2.99792458e8;
  mu=4e-7*pi;
  epsilon=1/c^2/mu;
end

if isequal(size(AntLen),[1,1]),
  AntLen=repmat(AntLen,NFeeds,1);
end
if isequal(size(AntDiam),[1,1]),
  AntDiam=repmat(AntDiam,NFeeds,1);
end
if isequal(size(AntDiamCorr),[1,1]),
  AntDiamCorr=repmat(AntDiamCorr,NFeeds,1);
end

Zcorr=Z-diag(log(AntDiamCorr./AntDiam)./(j*4*pi^2*Freq*epsilon*AntLen));

============================================================

function [FF,AA]=FarField(Field,AntGrid,Op,er,WorkingDir,Method)

% FF=FarField(Field,AntGrid,Op,er,WorkingDir)
% calculates the far field for the driving situation given by the 
% operation struct array Op (may only be a 1x1 struct).
% er must be a matrix of size (d x 3), d being the number of 
% directions for which the field is to be calculated.
% The directory WorkingDir is that where the input and output files
% for the calculations are stored (at present only used for
% Concept solver calculations). 
% The returned field FF is determined by the string Field, which may
% be 'A','E','H' or 'S'. FF then returns the vector potential AA, 
% the electric (EE) or magnetic (HH) field strength apart from the 
% factor exp(-jkr)/r:
%
%   AA = mu/(4*pi) Int I(r') exp(j*k*er.r') ds'
%   EE = - k/(w*epsilon) * er x HH
%   HH = - j*k/mu * er x AA
%
% or it returns the Poynting flux amplitude (SS) apart from the factor 
% exp(2Im(k)r)/r^2:
%
%   SS = 1/2 EE x HH* = k/(2*w*epsilon) * |HH|^2 * er
%
% Therefore the proper complex field vectors can be determined from 
% the corresponding returned quantities as follows:
%
%   A = exp(-j*k*r)/r * AA
%   E = exp(-j*k*r)/r * EE
%   H = exp(-j*k*r)/r * HH
%   S = exp(2*Im(k)*r)/r^2 * SS
%
% The time-average power flow P through the unit solid angle is then
% easily calculated by (Im(k)<0 represents attenuation):
%
%   P = real(r^2 * S) = real(exp(2*Im(k)*r) * SS)
%
% [FF,AA]=FarField(...) additionally returns the vector potential AA.
% 
% [FF,AA]=FarField(Field,AntGrid,Op,er,WorkingDir,Method)
% determines the Method to be used:
%   Method='Matlab' uses Matlab funcions to calculate AA, EE, etc.
%          'Solver' calls the respective solver to determine EE and 
%                   therefrom other fields.
% The following methods are implemented at present:
%   'Matlab' for Asap wire grid,
%   'Solver' for Concept wire and patch grids.

if ~exist('Method','var')||isempty(Method),
  Method='Matlab';
end
Method=upper(Method);
if isequal(Method(1),'M'),
  Method='Matlab';
else
  Method='Solver';
end

if ~exist('Field','var')||isempty(Field)||~ischar(Field),
  error('No Field name given.');
end
Field=deblank(Field);
Field=upper(Field(1));
if ~ismember(Field,{'A','E','H','S'}),
  error('Unknown field specification.');
end

er=er./repmat(Mag(er,2),[1,3]);  % ensure unit vectors

[k,epsilon,mu]=Kepsmu(Op.Freq,AntGrid);

w=2*pi*Op.Freq;


if isequal(CheckSolver(AntGrid.Solver),CheckSolver('ASAP')),
  
  AA=Asap_FarA(AntGrid,Op,er);
  
  switch Field,
    case 'A',
      FF=AA;
    case 'E',
      FF=(j*w)*cross(er,cross(er,AA,2),2);
    case 'H',
      FF=(-j*k/mu).*cross(er,AA,2);
    case 'S',
      FF=(w*conj(k/mu)/2)*Mag(cross(er,AA,2),2).^2;
  end
  
elseif isequal(CheckSolver(AntGrid.Solver),CheckSolver('CONCEPT')),
  
  if 1==0, % isempty(AntGrid.Desc2d)&&isequal(Method,'Matlab'),
    
    AA=Concept_FarA(AntGrid,Op,er);
    
    switch Field,
      case 'A',
        FF=AA;
      case 'E',
        FF=(j*w)*cross(er,cross(er,AA,2),2);
      case 'H',
        FF=(-j*k/mu).*cross(er,AA,2);
      case 'S',
        FF=(w*conj(k/mu)/2)*Mag(cross(er,AA,2),2).^2;
    end

  else % use Solver to calculate E first
    
    if 1==1,
      EE=Concept_Far(Op.Freq,AntGrid,er,WorkingDir,'E');
    else
      % The following is an alternative, but worse since Concept seems
      % to calculate Hp less accurate than Ep in the far zone
      % (where Hp and Ep are projections normal to er),
      % although there are large E-components parallel to er(!?).
      HH=Concept_Far(Op.Freq,AntGrid,er,WorkingDir,'H');
      EE=(-k/w/epsilon).*cross(er,HH,2);
    end
    
    switch Field,
      case 'A',
        FF=Vproj2V(er,EE/(-j*w));
      case 'E',
        FF=EE;
      case 'H',
        FF=(k/w/mu).*cross(er,EE,2);
      case 'S',
        FF=conj(k/2/w/mu)*Mag(EE,2).^2;
    end
    
    if (nargout>1)&&~exist('AA','var'),
      AA=Vproj2V(er,EE/(-j*w));
    end
    
  end % Concept-Solver  
  
else
  
  error('Solver not recognized.');
  
end 


% if 0==1,   % check different ways of calculating fields and SS:
%   HH1=(-j*k/mu).*cross(er,AA,2); % =(k/w/mu).*cross(er,EE);
%   EE1=(-k/w/epsilon).*cross(er,HH1,2); % =(j*w)*cross(er,cross(er,AA,2),2);
%   SS1=(k/2/w/epsilon)*Mag(HH1,2).^2;
%   SS2=conj(k/2/w/mu)*Mag(EE1,2).^2;
%   SS3=(w*conj(k/mu)/2)*Mag(cross(er,AA,2),2).^2;
%   max(abs(1-SS(:)./SS1(:)))
%   max(abs(1-SS(:)./SS2(:)))
%   max(abs(1-SS(:)./SS3(:)))
% end

============================================================

function [RFar,RFresnel,d,c]=FieldZones(Freq,AntGrid)

% [RFar,RFresnel,d,c]=FieldZones(Freq,AntGrid) calculates the boundaries of
% radiation zones: The far zone extends from RFar to infinity 
% and the Fresnel zone from RFresnel to RFar. In the far zone the
% exponent kR in the radiation field integral can be calculated 
% by first-order expansion, in the Fresnel zone second-order 
% terms must be included. The returned zone boundaries are determined
% very optimistic, i.e. it may be that the expansion for kR gets 
% very poor when approaching the respective boundaries from outside.
% d returns the antenna dimension and c its center as radius vector 
% from the origin.

% calculate abs(k):

k=Kepsmu(Freq,AntGrid);

ak=abs(k);

% antenna dimension d and center c:

g=AntGrid.Geom(AntGrid.Desc(:),:);
ma=max(g,[],1);
mi=min(g,[],1);
d=Mag(ma-mi);
c=(ma+mi)/2;

% radiation zone boundaries:

RFresnel=max(sqrt(d^3*ak/2/pi), 5*d);

RFar=max([RFresnel, ak*d^2/pi, 10/ak]);

============================================================

function [SolverDir,FreqDir,FeedDir]=...
  GetDataSubdirs(DataRootDir,Solver,Freq,FeedNum,GenerateDirs)

% [SolverDir,FreqDir,FeedDir]=...
%   GetDataSubdirs(DataRootDir,Solver,Freq,FeedNum)
% determines the subdirectories for data of given Solver, 
% frequency Freq and feed number FeedNum.
% In the subdirectory FreqDir all data which are specific for a certain 
% frequency are stored, where in the subsubdirectory FeedDir the data 
% specific to a certain driven feed  are stored. FeedNum may be 'all' or a
% scalar. Usually FeedDir is a subdirectory of FreqDir, and FreqDir a 
% subdirectory of SolverDir.
%
% The formats for the names of the (sub)directories are declared 
% in the global variables Atta_SolverDirFormat, Atta_FreqDirFormat,
% Atta_FeedDirFormat and Atta_FeedDirAlldrivenand.
%
% [...]=GetDataSubdirs(DataRootDir,Solver,Freq,FeedNum,1)
% also creates the directories down to the FeedDir if not yet present.

global Atta_SolverDirFormat Atta_FreqDirFormat
global Atta_FeedDirFormat Atta_FeedDirAlldriven

SolverName=CheckSolver(Solver);

SolverDir=fullfile(DataRootDir,sprintf(Atta_SolverDirFormat,SolverName));
CreateDir=SolverDir;

if nargout>1,

  FreqDir=fullfile(SolverDir,sprintf(Atta_FreqDirFormat,Freq/1e3));
  CreateDir=FreqDir;
  
  if nargout>2,
    
    if isnumeric(FeedNum),
      FeedDir=fullfile(FreqDir,sprintf(Atta_FeedDirFormat,FeedNum));
    else
      FeedDir=fullfile(FreqDir,Atta_FeedDirAlldriven);
    end
    CreateDir=FeedDir;
    
  end
  
end

if exist('GenerateDirs','var')&&~isempty(GenerateDirs),
  
  if ~exist(CreateDir,'dir'),
    Success=mkdir(CreateDir);
    if ~Success,
      error(['Could not create directory "',CreateDir,'".']);
    end
  end
  
end

============================================================

function [IA,Feeds0,Feeds1,Pos]=GetFeedCurr(PhysGrid,Op)

% IA=GetFeedCurr(PhysGrid,Op) determines the currents at the antenna feeds.
% Op must be a struct of size 1x1.
%
% [IA,Feeds0,Feeds1,Pos]=GetFeedCurr(...) returns also the feed nodes
% Feeds0 and the feed segments Feeds1, with their positions Pos.

% determine feeds:

try
  Feeds0=PhysGrid.Geom_.Feeds.Elem;
catch
  Feeds0=[];
end

try
  Feeds1=PhysGrid.Desc_.Feeds.Elem;
catch
  Feeds1=[];
end

if isempty(Feeds1)&&isempty(Feeds0),
  error('No feeds defined.');
end


IA=zeros(length(Feeds0)+length(Feeds1),1);


if isequal(CheckSolver(PhysGrid.Solver),CheckSolver('ASAP')),
  
  if length(Feeds0)>0,
    [Segs,NoS]=FindSegs(PhysGrid.Desc,Feeds0,2);
    if any(NoS~=2)||any(Segs(:,1).*Segs(:,2)>=0),
      error('Incorrect feed node definition encountered.');
    end
    Segs=max(Segs,[],2);
  else
    Segs=[];
  end
  
  if length(Feeds1)>0,
    Segs=[Segs;Feeds1(:)];  
  end
  
  IA=Op.Curr1(Segs,1);
  
  if nargout>3,
    Pos=repmat('n',1,length(IA));
  end
  
elseif isequal(CheckSolver(PhysGrid.Solver),CheckSolver('CONCEPT')),
  
  if length(Feeds0)>0,
    error('Feed nodes encountered, not possible for CONCEPT.');
  end
  
  try
    Pos=PhysGrid.Desc_.Feeds.Posi;
  catch
    Pos=[];
  end
  
  if ~ischar(Pos)||(length(Pos)~=length(Feeds1))||...
      any(~ismember(Pos(:),{'a','e','m'})),
    error('Error in position definitions of feeds.');
  end
  
  for n=1:length(Feeds1),
    
    c=Op.Curr1{Feeds1(n)};
    
    switch Pos(n),
      case 'a',
        m=1;
      case 'e',
        m=length(c);
      otherwise
        m=(length(c)+1)/2;
    end
    
    IA(n)=c(m);
    
  end
  
else  % wrong Solver-id
  
  error('Unknown Solver defined in grid.')
  
end


============================================================

function [VA,Feeds0,Feeds1,Pos]=GetFeedVolt(PhysGrid,FeedNum)

% VA=GetFeedVolt(PhysGrid,FeedNum) determines the voltages applied to
% at the antenna feeds. FeedNum may be 'all' or a scalar. In the former 
% case voltages are as defined in PhysGrid.Geom_.Feeds and/or
% PhysGrid.Desc_.Feeds; in the latter case unit voltage is applied at feed 
% FeedNum, the others being short-circuited.
%
% [VA,Feeds0,Feeds1,Pos]=GetFeedVolt(...) returns also the feed nodes
% Feeds0 and the feed segments Feeds1, with their feed positions Pos.

% determine feeds:

try
  Feeds0=PhysGrid.Geom_.Feeds.Elem;
catch
  Feeds0=[];
end

try
  Feeds1=PhysGrid.Desc_.Feeds.Elem;
catch
  Feeds1=[];
end

if isempty(Feeds1)&&isempty(Feeds0),
  error('No feeds defined.');
end

if ~exist('FeedNum','var')||isempty(FeedNum),
  error('No feed number specification (must be a scalar or ''all'').');
end
if ischar(FeedNum),
  FeedNum=lower(FeedNum(~isspace(FeedNum)));
  if ~isequal(FeedNum,'all'),
    error('Wrong feed number specification (must be a scalar or ''all'').');
  end
end

if isnumeric(FeedNum),
  VA=zeros(length(Feeds0)+length(Feeds1),1);
  VA(FeedNum)=1;
else
  try
    V0=PhysGrid.Geom_.Feeds.V;
  catch
    V0=[];
  end
  try
    V1=PhysGrid.Desc_.Feeds.V;
  catch
    V1=[];
  end
  if (length(Feeds0)~=length(V0))||(length(Feeds1)~=length(V1)),
    error('Incorrect number of defined feed voltages.');
  end
  VA=[V0(:);V1(:)];
end

if nargout<4,
  return
end

% determine feed positions:

if isempty(Feeds0),
  Pos0='';
else
  try
    Pos0=PhysGrid.Geom_.Feeds.Posi;
  catch
    Pos0='';
  end
  if isempty(Pos0),
    Pos0=repmat('n',size(Feeds0));
  end
end

if isempty(Feeds1),
  Pos1='';
else
  try
    Pos1=PhysGrid.Desc_.Feeds.Posi;
  catch
    Pos1='';
  end
  if isempty(Pos1),
    if isequal(CheckSolver(PhysGrid.Solver),CheckSolver('CONCEPT')),
      d=PhysGrid.Default.CONCEPT.Feeds.Posi;
    else
      d='n';
    end
    Pos1=repmat(d,size(Feeds1));
  end
  if (length(Pos1)~=length(Feeds1))||...
    isequal(CheckSolver(PhysGrid.Solver),CheckSolver('CONCEPT'))&&...
    ~all(ismember(Pos1(:),{'a','e','m'})),
    error('Error in position definitions of feed segments.');
  end
end

Pos=[Pos0(:);Pos1(:)].';

============================================================

function [PhysGrid,NewO,NewN,NewS,NewP]=...
  GetPhysGrid(AntGrid,Solver,Option,DataRootDir)

% [PhysGrid,Op,NewO,NewN,NewS,NewP]=GetPhysGrid(AntGrid,Solver,Option) 
% extracts the physically effective objects from AntGrid (objects for which
% AntGrid.Obj.Phys.Act=1) and returns it in PhysGrid. Only the elements 
% occuring in these objects are maintained.
%
% Wires containing segments which are patch edges are not extracted
% unless Option={'OnlyWires'} is passed or the Solver is ASAP. 
% In the latter case Surf objects and patches are removed.
% Default is Option={}, i.e. wires which are patch edges are omitted.
% If Option={'ForceWires'} is passed, the edges of patches are used as
% segments. All such segments are taken in one Wire object with 
% Name='SurfEdges'.
%
% The index maps NewO, NewN, NewS and NewP describe the mapping from 
% the old to the new object, node, segment and patch indices, respectively.
%
% Solver defines the program to be used for the determination of 
% antenna the currents. The implemented solvers are declared in the
% global variable Atta_Solver_Names.
%
% [...]=GetPhysGrid(AntGrid,Solver,Option,DataRootDir)
% also passes the directory DataRootDir in which all data concerning
% the antenna configuration AntGrid are to be stored. If this parameter is 
% given, PhysGrid is stored into the file defined in the global variable
% Atta_PhysGridFile in the respective solver-directory (For directory
% structure see also GetDataSubdirs).

if ~exist('Solver','var')||isempty(Solver),
  error('No solver defined.');
end
Solver=CheckSolver(Solver);
if isempty(Solver),
  error('Unknown solver requested.');
end

EdgeObjName4Surfs='SurfEdges';

if ~exist('Option','var')||isempty(Option),
  Option={};
end
if ~iscell(Option),
  Option={Option};
end

OnlyWires=false;
if ismember(upper('OnlyWires'),cellfun(@upper,Option,'UniformOutput',false))...
    || isequal(Solver,CheckSolver('ASAP')),
  OnlyWires=true;
end
  
ForceWires=false;
if ismember(upper('ForceWires'),cellfun(@upper,Option,'UniformOutput',false)),
  ForceWires=true;
end


% pack grid:
% ------------

[AntGrid,NewN,NewS,NewP,NewO]=GridPack(AntGrid,0,'all',[1,1]);


% extract physical grid:
% ------------------------

PhysObjs=[];
for n=1:numel(AntGrid.Obj),
  try
    m=AntGrid.Obj(n).Phys.Act;
  catch
    m=[];
  end
  if isempty(m),
    m=0;
  end
  if m~=0,
    PhysObjs=[PhysObjs,n];
  end
end

[Pos,Wis,Sus]=FindGridObj(AntGrid);

% add edges of patch objects as segments and collect them in a wire object:

if ForceWires, 
  
  Nsegold=size(AntGrid.Desc,1);
  
  % detect edges that are not yet present as segments in wire objects:
  
  Edges=FindPatchEdges(AntGrid,Sus);
  nn={AntGrid.Obj(Wis).Elem};
  for n=1:length(nn),
    nn{n}=nn{n}(:).';
  end
  nn=unique([nn{:}]);
  n=~ismember(sort(Edges,2),sort(AntGrid.Desc(nn,:),2),'rows');
  Edges=Edges(n,:); 
  
  if ~isempty(Edges),

    AntGrid.Desc=[AntGrid.Desc;Edges];

    % determine unique name for new object containing edge segments:

    q=EdgeObjName4Surfs;
    x=FindGridObj(AntGrid,'Name',q);
    n=0;
    while ~isempty(x),
      n=n+1;
      q=[EdgeObjName4Surfs,num2str(n)];
      x=FindGridObj(AntGrid,'Name',q);
    end

    % add new wire object:
    
    AntGrid=GridObj(AntGrid,'Wire',(Nsegold+1):size(AntGrid.Desc,1),...
      'Name',q,'Phys.Dimension',2);
    
    PhysObjs=[PhysObjs,length(AntGrid.Obj)];
  
  end
  
end

% remove patches if only wire grid:

if OnlyWires||ForceWires,
  PhysObjs=setdiff(PhysObjs,Sus);
end

% finally extract:

[PhysGrid,NewO2,NewN2,NewS2,NewP2]=GridExtract(AntGrid,PhysObjs);

NewO=MapComp(NewO,NewO2);
NewN=MapComp(NewN,NewN2);
NewS=MapComp(NewS,NewS2);
NewP=MapComp(NewP,NewP2);

PhysGrid.Solver=Solver;


% check if there are segments along patches and delete 
% the corresponding wire-objects:
% ---------------------------------------------------------

if ~isempty(PhysGrid.Desc2d),
  
  Edges=FindPatchEdges(PhysGrid);

  n=find(ismember(sort(PhysGrid.Desc,2),sort(Edges,2),'rows'));

  if ~isempty(n),
    
    [PhysGrid,NewO2,NewN2,NewS2,NewP2]=...
      GridRemove(PhysGrid,[],[],-n,[],[],'all');
    NewO=MapComp(NewO,NewO2);
    NewN=MapComp(NewN,NewN2);
    NewS=MapComp(NewS,NewS2);
    NewP=MapComp(NewP,NewP2);
    
    [PhysGrid,NewO2,NewN2,NewS2,NewP2]=GridExtract(PhysGrid,'all');
    NewO=MapComp(NewO,NewO2);
    NewN=MapComp(NewN,NewN2);
    NewS=MapComp(NewS,NewS2);
    NewP=MapComp(NewP,NewP2);
    
  end

end


% sort elements according to their appearance in the 
% physical objects (PhysGrid.Obj):
% ---------------------------------------------------

[Pos,Wis,Sus]=FindGridObj(PhysGrid);

% segments:

Nseg=size(PhysGrid.Desc,1);      % number of segments

PhysGrid.Desc_.ObjNum=zeros(Nseg,1);

NewS2=zeros(Nseg,1);

count=0;
for n=1:length(Wis),
  nn=length(PhysGrid.Obj(Wis(n)).Elem);
  PhysGrid.Desc_.ObjNum(count+1:count+nn)=Wis(n);
  NewS2(count+1:count+nn)=abs(PhysGrid.Obj(Wis(n)).Elem);
  count=count+nn;
end

if count<Nseg,
  error('Not all segments in Wire-objects.');
elseif any(NewS2==0),
  error('Zero segment number not allowed.'); 
end

SegObjs=cell(Nseg,1);
for q=1:Nseg,
  SegObjs{q}=PhysGrid.Desc_.ObjNum(NewS2==q);
end

[xx,ii]=unique(NewS2,'last');
ii=sort(ii);
PhysGrid.Desc_.ObjNum=PhysGrid.Desc_.ObjNum(ii);
NewS2=NewS2(ii);

SegObjs=SegObjs(NewS2);
PhysGrid.Desc=PhysGrid.Desc(NewS2,:);

NewS2(NewS2)=(1:length(NewS2)).';
NewS=MapComp(NewS,NewS2);

if count>Nseg,
  display('Overlapping Wire-objects.');
  fprintf(' Seg   Objects\n');
  for q=1:Nseg,
    if length(SegObjs{q})>1,
      fprintf('%4d: ',q);
      fprintf(' %3d',SegObjs{q});
      fprintf('\n')
    end
  end
  fprintf('\n');      
end

PhysGrid=GridUpdate(PhysGrid,'Segments',NewS2);

if ~isequal(PhysGrid.Desc_.ObjNum,sort(PhysGrid.Desc_.ObjNum))
  error('Wire ObjNums must be sorted.');
end

% patches:

Npat=numel(PhysGrid.Desc2d);   % number of patches

PhysGrid.Desc2d_.ObjNum=zeros(Npat,1);

NewP2=zeros(Npat,1);

count=0;
for n=1:length(Sus),
  nn=length(PhysGrid.Obj(Sus(n)).Elem);
  PhysGrid.Desc2d_.ObjNum(count+1:count+nn)=Sus(n);
  NewP2(count+1:count+nn)=abs(PhysGrid.Obj(Sus(n)).Elem);
  count=count+nn;
end

if count<Npat,
  error('Not all patches in Surf-objects.');
elseif any(NewP2==0),
  error('Zero patch number not allowed.'); 
end

PatObjs=cell(Npat,1);
for q=1:Npat,
  PatObjs{q}=PhysGrid.Desc2d_.ObjNum(NewP2==q);
end

[xx,ii]=unique(NewP2,'last');
ii=sort(ii);
PhysGrid.Desc2d_.ObjNum=PhysGrid.Desc2d_.ObjNum(ii);
NewP2=NewP2(ii);

PatObjs=PatObjs(NewP2); 
PhysGrid.Desc2d=PhysGrid.Desc2d(NewP2);

NewP2(NewP2)=(1:length(NewP2)).';
NewP=MapComp(NewP,NewP2);

if count>Npat,
  display('Overlapping Patch-objects.');
  fprintf(' Pat   Objects\n');
  for q=1:Npat,
    if length(PatObjs{q})>1,
      fprintf('%4d: ',q);
      fprintf(' %3d',PatObjs{q});
      fprintf('\n')
    end
  end
  fprintf('\n');      
end

PhysGrid=GridUpdate(PhysGrid,'Patches',NewP2);

if ~isequal(PhysGrid.Desc2d_.ObjNum,sort(PhysGrid.Desc2d_.ObjNum))
  error('Surface ObjNums must be sorted.');
end


% Collect Wire properties:
% ----------------------------

PhysGrid.Desc_.Diam=nan(Nseg,1);
PhysGrid.Desc_.Cond=nan(Nseg,1);

if isequal(Solver,CheckSolver('CONCEPT')),
  PhysGrid.Desc_.NBases=nan(Nseg,1);
end

for n=1:length(Wis),
  
  e=PhysGrid.Obj(Wis(n)).Elem;

  try 
    q=PhysGrid.Obj(Wis(n)).Phys.Diam;
  catch
    q=[];
  end
  if ~isempty(q),
    PhysGrid.Desc_.Diam(e)=q;
  end
  
  try
    q=PhysGrid.Obj(Wis(n)).Phys.Cond;
  catch
    q=[];
  end
  if ~isempty(q),
    PhysGrid.Desc_.Cond(e)=q;
  end
  
  try
    q=PhysGrid.Obj(Wis(n)).Phys.NBases;
  catch
    q=[];
  end
  if ~isempty(q),
    PhysGrid.Desc_.NBases(e)=q;
  end
  
end

PhysGrid.Desc_.Diam(isnan(PhysGrid.Desc_.Diam))=PhysGrid.Default.Wire.Diam;
PhysGrid.Desc_.Cond(isnan(PhysGrid.Desc_.Cond))=PhysGrid.Default.Wire.Cond;

if isequal(Solver,CheckSolver('CONCEPT')),
  PhysGrid.Desc_.NBases(isnan(PhysGrid.Desc_.NBases))=PhysGrid.Default.CONCEPT.Wire.NBases;
end


% Collect Surf properties:
% ----------------------------

PhysGrid.Desc2d_.Thick=zeros(Npat,1);
PhysGrid.Desc2d_.Cond=zeros(Npat,1);

for n=1:length(Sus),
  
  e=PhysGrid.Obj(Sus(n)).Elem;
  
  try 
    q=PhysGrid.Obj(Sus(n)).Phys.Thick;
  catch
    q=[];
  end
  if ~isempty(q),
    PhysGrid.Desc2d_.Thick(e)=q;
  end
  
  try
    q=PhysGrid.Obj(Sus(n)).Phys.Cond;
  catch
    q=[];
  end
  if ~isempty(q),
    PhysGrid.Desc2d_.Cond(e)=q;
  end
  
end

PhysGrid.Desc2d_.Thick(isnan(PhysGrid.Desc2d_.Thick))=PhysGrid.Default.Surf.Thick;
PhysGrid.Desc2d_.Cond(isnan(PhysGrid.Desc2d_.Cond))=PhysGrid.Default.Surf.Cond;


% Find Feeds and Loads:
% ---------------------

% node feeds:

NodeFeedObjs=FindGridObj(PhysGrid,'Name','Feeds','Type','Point');
q=[];
V=[];
obnu=[];
for n=1:length(NodeFeedObjs),
  el=PhysGrid.Obj(NodeFeedObjs(n)).Elem(:);
  q=[q;el];
  obnu=[obnu;repmat(NodeFeedObjs(n),size(el))];
  try
    Vn=PhysGrid.Obj(NodeFeedObjs(n)).Phys.V(:);
  catch
    Vn=[];
  end
  if isempty(Vn),
    Vn=repmat(nan,size(el)); 
  elseif length(Vn)~=length(el),
    error(['Voltage definition inconsistent with number of elements in object ',...
      num2str(NodeFeedObjs(n))]);
  end
  V=[V;Vn];
end
[qq,ii]=unique(q);
ii=sort(ii);
if length(ii)<length(q),
  warning('Multiple (overlapping) feed definitions in point objects.');
end
PhysGrid.Geom_.Feeds.ObjNum=obnu(ii);
PhysGrid.Geom_.Feeds.Elem=q(ii);
V=V(ii);
if any(isnan(V)),
  if ~all(isnan(V)),
    warning('Some but not all feed voltages are defined (missining ones are set 0).');
    V(isnan(V))=0;
  else
    V=[];  % [] indicate that no voltages are defined
  end
end
PhysGrid.Geom_.Feeds.V=V;

% segment feeds:

SegFeedObjs=FindGridObj(PhysGrid,'Name','Feeds','Type','Wire');
q=[];
p='';
V=[];
for n=1:length(SegFeedObjs),
  el=PhysGrid.Obj(SegFeedObjs(n)).Elem(:);
  q=[q;el];
  obnu=[obnu;repmat(SegFeedObjs(n),size(el))];
  try
    Vn=PhysGrid.Obj(SegFeedObjs(n)).Phys.V(:);
  catch
    Vn=[];
  end
  if isempty(Vn),
    Vn=repmat(nan,size(el)); 
  elseif length(Vn)~=length(el),
    error(['V(oltage) definition inconsistent with number of elements in object ',...
      num2str(SegFeedObjs(n))]);
  end
  V=[V;Vn];
  try
    po=PhysGrid.Obj(SegFeedObjs(n)).Phys.Posi(:);
  catch
    po='';
  end
  if isempty(po),
    po=repmat('n',size(el));
    % 'n' identifies missing position definition
  elseif length(po)~=length(el),
    error(['Posi(tion) definition inconsistent with number of elements in object ',...
      num2str(SegFeedObjs(n))]);
  end
  p=[p;po];
end
[qq,ii]=unique(q);
ii=sort(ii);
if length(ii)<length(q),
  warning('Multiple (overlapping) feed definitions in wire objects.');
end
PhysGrid.Desc_.Feeds.ObjNum=obnu(ii);
PhysGrid.Desc_.Feeds.Elem=q(ii);
V=V(ii);
if any(isnan(V)),
  if ~all(isnan(V)),
    warning('Some but not all feed voltages are defined (missining ones are set 0).');
    V(isnan(V))=0;
  else
    V=[];
  end
end
PhysGrid.Desc_.Feeds.V=V;
p=p(ii);
if any(p=='n')&&isequal(Solver,CheckSolver('CONCEPT')),
  fprintf('Non-defined feed positions are set to default.\n\n');
  p(p=='n')=PhysGrid.Default.CONCEPT.Feeds.Posi;
end
if isequal(Solver,CheckSolver('CONCEPT')),
  p=CheckCONCEPTPosiChars(p);  
end
PhysGrid.Desc_.Feeds.Posi=p;

% node loads:

NodeLoadObjs=FindGridObj(PhysGrid,'Name','Loads','Type','Point');
q=[];
Z=[];
for n=1:length(NodeLoadObjs),
  el=PhysGrid.Obj(NodeLoadObjs(n)).Elem(:);
  q=[q;el];
  obnu=[obnu;repmat(NodeLoadObjs(n),size(el))];
  ZZ=PhysGrid.Obj(NodeLoadObjs(n)).Phys.Z(:);
  if length(ZZ)~=length(el),
    error(['Number of impedances not correct in Loads of object ,',...
      NodeLoadObjs(n)]);
  end
  Z=[Z;ZZ];
end
[qq,ii]=unique(q);
ii=sort(ii);
if length(ii)<length(q),
  warning('Multiple (overlapping) load definitions in point objects.');
end
PhysGrid.Geom_.Loads.ObjNum=obnu(ii);
PhysGrid.Geom_.Loads.Elem=q(ii);
PhysGrid.Geom_.Loads.Z=Z(ii);

% segments loads:

SegLoadObjs=FindGridObj(PhysGrid,'Name','Loads','Type','Wire');
q=[];
p='';
Z=[];
for n=1:length(SegLoadObjs),
  el=PhysGrid.Obj(SegLoadObjs(n)).Elem(:);
  q=[q;el];
  obnu=[obnu;repmat(SegLoadObjs(n),size(el))];
  ZZ=PhysGrid.Obj(SegLoadObjs(n)).Phys.Z(:);
  if length(ZZ)~=length(el),
    error(['Number of impedances not correct in Loads of object ,',...
      SegLoadObjs(n)]);
  end
  Z=[Z;ZZ];
  try
    po=PhysGrid.Obj(SegLoadObjs(n)).Phys.Posi(:);
  catch
    po='';
  end
  if isempty(po),
    po=repmat('n',size(el));
    % 'n' identifies missing position definition
  elseif length(po)~=length(el),
    error(['Posi(tion) definition inconsistent with number of elements in object ',...
      num2str(SegLoadObjs(n))]);
  end
  p=[p;po];  
end
[qq,ii]=unique(q);
ii=sort(ii);
if length(ii)<length(q),
  warning('Multiple (overlapping) load definitions in wire objects.');
end
PhysGrid.Desc_.Loads.ObjNum=obnu(ii);
PhysGrid.Desc_.Loads.Elem=q(ii);
PhysGrid.Desc_.Loads.Z=Z(ii);
p=p(ii);
if any(p=='n')&&isequal(Solver,CheckSolver('CONCEPT')),
  fprintf('Not defined load positions are set to default.');
  p(p=='n')=PhysGrid.Default.CONCEPT.Loads.Posi;
end
if isequal(Solver,CheckSolver('CONCEPT')),
  p=CheckCONCEPTPosiChars(p);  
end
PhysGrid.Desc_.Loads.Posi=p;


% save PhysGrid if DataRootDir is passed:
% ---------------------------------------

global Atta_PhysGridFile Atta_PhysGridName

if exist('DataRootDir','var'),
  
  if isempty(DataRootDir),
    DataRootDir='';
  end
  SolverDir=GetDataSubdirs(DataRootDir,Solver,[],[],1);
  VarSave(fullfile(SolverDir,Atta_PhysGridFile),PhysGrid,[],Atta_PhysGridName);
  
end


end  % GetPhysGrid


% ---------------------------------------

function pp=CheckCONCEPTPosiChars(p)

pp=lower(p);

pp(pp=='b')='a';
pp((pp~='a')&(pp~='e'))='m';

end

============================================================

function [k,epsilon,mu,eps0,mu0]=Kepsmu(Freq,AntGrid,sigma)

% [k,epsilon,mu]=Kepsmu(Freq,AntGrid) returns the propagation constant k,  
% the complex dielectric constant epsilon and the permeability mu of 
% the exterior medium for frequency Freq. 
% (In this version it is still assumed that mu=mu0.)
%
% [k,epsilon]=Kepsmu(Freq,epsrel,sigma) calculates k and epsilon from 
% relative permittivity epsrel and conductivity sigma at frequency Freq.
% All parameters may be arrays of same size or scalars.


c=2.99792458e8;

mu0=4e-7*pi;
eps0=1/c^2/mu0;

% determine mu:

mu=mu0;

% determine epsilon:

if isstruct(AntGrid), % Kepsmu(Freq,AntGrid)

  if nargin>2,
    error('No 3. input argument allowed when 2. argument is a grid struct.');
  end
  
  try
    epsilon=eps0*EvaluateFun(AntGrid.Exterior.epsr,Freq);
    %mu=EvaluateFun(AntGrid.Exterior.mu,Freq);
  catch
    error('No exterior medium derfined in antenna grid struct.');
  end
  
else    % Kepsmu(Freq,epsrel,sigma)
  
  if nargin<3,
    error('No conductivity defined.');
  end
  
  epsilon=eps0*AntGrid+sigma./(j*2*pi*Freq);  
  
end

% determine k:

k=sqrt(epsilon.*mu).*(2*pi*Freq);
m=find(real(k)<0);
k(m)=-k(m);

============================================================

function Op=LoadCurr(DataRootDir,PhysGrid,Freqs,FeedNum)

% Op=LoadCurr(DataRootDir,Solver,Freqs,CalcCurr)
% loads the currents from the directory where they are saved. This
% directory depends on the DataRootDir (data root directory), the Solver,
% the frequencies (Freqs) and the feed numbers FeedNum. 
% DataRootDir is a string containing the name of the data root directory,
% Solver a string or number identifying the solver,
% Freqs a scalar or vector or frequencies, and
% FeedNum a string ('all' or 'sys') or a feed number ('sys' is default if
% the parameter FeedNum is not passed or empty):
% FeedNum='all' means that all feeds are driven by applying the voltages
% defined in the antenna grid structure. 
% FeedNum='sys' regards as many driving (operation) situations as there are
% feeds defined in the antenna grid structure, an individual driving state 
% being realized by applying unit voltage at one feed, the other feeds being
% short-circuited. This yields a whole current system, which is ,e.g., 
% needed to determine the transfer and impedance matrices.
%
% The read currents are stored in Op as explained in CalcCurr.
% Op is a (number of feeds times number of frequencies)-array, each element
% of the array holding the antenna currents induced on the antenna when
% driven according to the feed specification at the respective frequency.
%
% Op=LoadCurr(DataRootDir,PhysGrid,Freqs,FeedNum)
% If the whole PhysGrid antenna struct is passed instead of the Solver, 
% the function returns in Op also the fields .Exterior.epsr, 
% .Vfeed and .Ifeed, which can only be determined on the basis of PhysGrid.

global Atta_Solver_Names

if ~exist('DataRootDir','var')||isempty(DataRootDir),
  DataRootDir='';
end

if isstruct(PhysGrid),
  Solver=PhysGrid.Solver;
else
  Solver=PhysGrid;
  PhysGrid=[];
end
  
Solver=CheckSolver(Solver);
if ~any(ismember(Solver,Atta_Solver_Names)),
  error('Passed Solver not known.');
end

% check FeedNum:

if ~exist('FeedNum','var')||isempty(FeedNum),
  FeedNum='sys';
end
if ischar(FeedNum),
  FeedNum=lower(FeedNum);
end
if ~isnumeric(FeedNum)&&~isequal(FeedNum,'sys')&&~isequal(FeedNum,'all'),
  error('Unknown FeedNum parameter encountered.');
end

% check number of feeds in case whole current system is to be loaded:

if isequal(FeedNum,'sys'), 

  NFeeds=zeros(length(Freqs),1);
  
  for n=1:length(Freqs),
    FeedExists=1;
    while FeedExists,
      [SolverDir,FreqDir,FeedDir]=...
        GetDataSubdirs(DataRootDir,Solver,Freqs(n),NFeeds(n)+1);
      FeedExists=exist(FeedDir,'dir');
      if FeedExists,
        NFeeds(n)=NFeeds(n)+1;
      end
    end    
  end

  if ~all(NFeeds(1)==NFeeds)||any(NFeeds<1),
    error('Inconsistent feed numbers/frequencies, current systems cannot be loaded.');
  end
  
  FeedNum=1:NFeeds(1); 

end

if ischar(FeedNum),
  NFeeds=1;
else
  NFeeds=length(FeedNum);
end


% Frequencies-feeds loop:
% -----------------------

Op=struct('Freq',{});

for n=1:length(Freqs),
  
  for m=1:NFeeds,
    
    if ischar(FeedNum),
      FN=FeedNum;
    else
      FN=FeedNum(m);
    end
    
    [SolverDir,FreqDir,FeedDir]=...
      GetDataSubdirs(DataRootDir,Solver,Freqs(n),FN);
      
    if isequal(Solver,CheckSolver('CONCEPT')),
      Opx=Concept_ReadAll(FeedDir);
    elseif isequal(Solver,CheckSolver('ASAP')),
      Opx=Asap_ReadOut(FeedDir);
    end

    Op=SetStruct(Op,Opx,{m,n},{1,1});

    Op(m,n).Freq=Freqs(n);
      
    if ~isempty(PhysGrid),
      Op(m,n).Exterior.epsr=EvaluateFun(PhysGrid.Exterior.epsr,Freqs(n));
      Op(m,n).Vfeed=GetFeedVolt(PhysGrid,FN);
      Op(m,n).Ifeed=GetFeedCurr(PhysGrid,Op(m,n));
    end

  end % count feeds

end % count frequencies

============================================================

function PhysGrid=LoadPhysGrid(DataRootDir,Solver)

% PhysGrid=LoadPhysGrid(DataRootDir,Solver)
% loads physical grid PhysGrid from the respective directory, which 
% is defined by the data root directory DataRootDir and the Solver.

global Atta_PhysGridFile Atta_PhysGridName

SolverDir=GetDataSubdirs(DataRootDir,Solver);

PhysGrid=VarLoad(fullfile(SolverDir,Atta_PhysGridFile),[],Atta_PhysGridName);

============================================================

function [T,er,YZ]=LoadT(DataRootDir,Solver,Freqs,FileName)

% [T,er,YZ]=LoadT(DataRootDir,Solver,Freqs,FileName)
% loads transfer matrices (T) from files with name FileName in the
% respective frequency directories which are determined by the 
% data root directory DataRootDir, the Solver and the frequencies Freqs.  
% er are the directions for which the T-matrices are loaded. It is assumed
% that er is the same for all frequencies. YZ returns either Y or Z,
% whichever is stored in the file (if both are in the file, Z is returned).

global Atta_Solver_Names

if ~exist('DataRootDir','var')||isempty(DataRootDir),
  DataRootDir='';
end

Solver=CheckSolver(Solver);
if ~any(ismember(Solver,Atta_Solver_Names)),
  error('Passed Solver not known.');
end

if ~exist('FileName','var')||isempty(FileName),
  error('No file name defined.');
end


NFreqs=length(Freqs);

for n=1:NFreqs,
  
   [SolverDir,FreqDir]=GetDataSubdirs(DataRootDir,Solver,Freqs(n));
   FN=fullfile(FreqDir,FileName);
   v=load(FN);
   
   na=fieldnames(v);
   m=strmatch('T',na);
   if length(m)~=1,
     error('No or several T-candidates found for frequency = %fkHz.\n',...
       Freqs(n)/1e3);
   end
   nam=na{m};
   
   if n==1,
     NFeeds=size(v.(nam),1);
     NDirs=size(v.(nam),3);
     T=zeros(NFeeds,3,NDirs,NFreqs);
     YZ=zeros(NFeeds,NFeeds,NFreqs);
     er=v.er;
     isZ=isfield(v,'Z');
   end

   T(:,:,:,n)=v.(nam);
   
   if isZ,
     YZ(:,:,n)=v.Z;
   else
     YZ(:,:,n)=v.Y;
   end
    
end

============================================================

% Concept_Test.m
% ==============

OnlyReadCurr=1;  
% if =1, no current calculations are performed, but data are read from
% files in respective data directories

DataRootDir=...
'..\Datatest';

load('patch-concept-rA33_rB33_fseg2');

deg=pi/180;

% transform to new toolbox format
% -------------------------------

Ant_=GridInit;
Ant_.Geom=ant.Geom;
Ant_.Desc=ant.Desc;
Ant_.Desc2d=ant.Desc2d;
Ant_.Obj=ant.Obj;
Ant_.Init=ant.Init;

for n=1:numel(Ant_.Obj),
  Ant_.Obj(n).Graf=Ant_.Obj(n).GraphProp;
  Ant_.Obj(n).Phys=Ant_.Obj(n).Prop;
  Ant_.Obj(n).Phys.Act=1;
end
Ant_.Obj=rmfield(Ant_.Obj,'GraphProp');
Ant_.Obj=rmfield(Ant_.Obj,'Prop');
Ant_.Obj=rmfield(Ant_.Obj,'forwire');
Ant_.Obj=rmfield(Ant_.Obj,'forpat');

n=FindGridObj(Ant_,'Name','Feeds','Type','Wire');
el=Ant_.Obj(n).Elem;
Ant_.Obj(n).Phys.Posi=repmat('m',size(el));
Ant_.Obj(n).Phys.V=10+(1:length(el));

[P,W,S]=FindGridObj(Ant_);
for n=S(:).',
  Ant_.Obj(n).Graf.EdgeColor=[1,1,1]*0.8;
end
for n=W(:).',
  Ant_.Obj(n).Phys.Posi='';
  Ant_.Obj(n).Phys.Cond=[];
  Ant_.Obj(n).Phys.Radius=[];
  Ant_.Obj(n).Phys.Diam=[];
end

Ant_.Default.CONCEPT.Wire.NBases=3;
Ant_.Default.CONCEPT.Feeds.Posi='b';
Ant_.Default.CONCEPT.Loads.Posi='b';
 
Ant_.Default.Wire.Diam=2e-3;
Ant_.Default.Wire.Cond=inf;
% Ant_.Default.Surf.Thick=1e-2;
% Ant_.Default.Surf.Cond=50e6;
 
 Ant_.Exterior.epsr=1;


% add some loads and specifications for testing
% ---------------------------------------------

% n=FindGridObj(Ant_,'Name','A4','Type','Wire');
% Ant_.Obj(end+1)=Ant_.Obj(n);
% Ant_.Obj(end).Name='Loads';
% el=setdiff(Ant_.Obj(end).Elem,Ant_.Obj(n).Elem); % do not load feed segments
% Ant_.Obj(end).Elem=el;
% Ant_.Obj(end).Phys.Z=100*ones(size(el));
% Ant_.Obj(end).Phys.Posi=repmat('e',size(el));
% 
% n=FindGridObj(Ant_,'Name','A1','Type','Wire');
% Ant_.Obj(n).Phys.NBases=3;
% Ant_.Obj(n).Phys.Cond=1e5;
% 

Ant_.Obj=Ant_.Obj([2,7:end]);


% Solver-Independent parameters
% -----------------------------

Freq=[0.5]*1e6;

Titel='This is a test ';

FeedNum='sys';


% directions for T-calculations:

nth=9;  % intervals in theta
nph=9;  % ..in phi

th=(0:nth)/nth*pi;
ph=(0:nph)/nph*2*pi;
[th,ph]=meshgrid(th,ph);

er=sph2car([ones(numel(th),1),th(:),ph(:)],2);


% Solve with ASAP
% ---------------

if 1==0,
  
tic

Solver='ASAP';

Option={'ForceWires'};

PhysGrid1=GetPhysGrid(Ant_,Solver,Option,DataRootDir);

if OnlyReadCurr,
  Op1=LoadCurr(DataRootDir,PhysGrid1,Freq,FeedNum);
else
  Op1=CalcCurr(PhysGrid1,Freq,FeedNum,Titel,DataRootDir);
end

display(Op1)

% transfer matrices:

if 1==0,
  [To1,Z1]=CalcTo(er,PhysGrid1,Op1,DataRootDir,'Matlab');
else
  [To1,Z1]=CalcTo(er,Solver,Freq,DataRootDir,'Matlab');
end

if 1==1,
  [To1_,er_,Z1_]=LoadT(DataRootDir,Solver,Freq,'To');
  isequal(To1,To1_)
  isequal(er,er_)
  isequal(Z1,Z1_)
end

C1=Z1;
for n=1:size(Z1,3),
  C1(:,:,n)=inv(Z1(:,:,n))/(j*2*pi*Op1(1,n).Freq);
end
fprintf('\nC=\n')
disp(real(C1)*1e12)

fprintf('\nmean(To)=\n')
disp(mean(To1,3))
fprintf('\nstd(To)=\n')
disp(std(To1,[],3))

To1_=car2sph(real(To1),2);
To1_(:,2:3,:)=To1_(:,2:3,:)/deg;
nnn=(To1_(:)<-160);
To1_(nnn)=To1_(nnn)+360;

fprintf('\nmean(To_spherical)=\n')
disp(mean(To1_,3))
fprintf('\nstd(To_spherical)=\n')
disp(std(To1_,[],3))

toc

end


% Solve with CONCEPT
% -------------------

if 1==1,
  
tic

Solver='CONCEPT';

Option={'ForceWires'};

PhysGrid2=GetPhysGrid(Ant_,Solver,Option,DataRootDir);

if OnlyReadCurr,
  Op2=LoadCurr(DataRootDir,PhysGrid2,Freq,FeedNum);
else
  Op2=CalcCurr(PhysGrid2,Freq,FeedNum,Titel,DataRootDir);
end

display(Op2)

% transfer matrices:

if 1==0,
  [To2,Z2]=CalcTo(er,PhysGrid2,Op2,DataRootDir,'Matlab');
else
  [To2,Z2]=CalcTo(er,Solver,Freq,DataRootDir,'Matlab');
end

if 1==1,
  [To2_,er_,Z2_]=LoadT(DataRootDir,Solver,Freq,'To');
  isequal(To2,To2_)
  isequal(er,er_)
  isequal(Z2,Z2_)
end

C2=Z2;
for n=1:size(Z2,3),
  C2(:,:,n)=inv(Z2(:,:,n))/(j*2*pi*Op2(1,n).Freq);
end
fprintf('\nC=\n')
disp(real(C2)*1e12)

fprintf('\nmean(To)=\n')
disp(mean(To2,3))
fprintf('\nstd(To)=\n')
disp(std(To2,[],3))

To2_=car2sph(real(To2),2);
To2_(:,2:3,:)=To2_(:,2:3,:)/deg;
nnn=(To2_(:)<-160);
To2_(nnn)=To2_(nnn)+360;

fprintf('\nmean(To_spherical)=\n')
disp(mean(To2_,3))
fprintf('\nstd(To_spherical)=\n')
disp(std(To2_,[],3))

toc

end

% 

============================================================

function T=To2T(To,ZA,ZL)

% T=To2T(To,ZA,ZL) calculates voltage transfer matrix T for loaded ports 
% from open ports voltage transfer matrix To and antennna impedance 
% matrix ZA. The load network is given by its impedance matrix ZL.   
% The first dimension of To counts ports, the second coordinates, the
% 3rd directions (treated in parallel). T gets the same size as To. 
% The dimensions from the 3rd upwards of ZA and ZL must be all 1 or 
% agree with the dimensions of To from the 4th upwards.
%
% The relations representing antenna and load network are 
%
%   I = YA*V + Ts*E, or V = ZA*I - To,  with ZA=inv(YA) and To=ZA*Ts
%   I = -YL*V
% 
% so one obtains the voltages V at the loaded antenna 
%
%   V = -T*E with T = ZL*inv(ZL+ZA)*To
%
% in particular, for open ports we have ZL=Id*inf, T=To; this is 
% the default if ZL is empty or omitted.

if isempty(To),
  T=[];
  return
end

sT=[size(To),1];
NFeeds=sT(1);  % number of feeds
NDirs=sT(3);   % number of directions

if prod(sT(4:end))==1,
  sT3=@(x)(1);
else
  sT3=@(x)(x);
end

sA=[size(ZA),1];
if prod(sA(3:end))==1,
  sA3=@(x)(1);
else
  sA3=@(x)(x);
end

% check ZL:

if ~exist('ZL','var')||isempty(ZL),
  T=To;
  return
end

ZL(isinf(ZL))=max(1,max(abs(ZA(:))))*1e10;

if size(ZL,1)==1,
  ZL=permute(ZL,[2,1,3:ndims(ZL)]);
end
if size(ZL,1)==1,
  ZL=repmat(ZL,[NFeeds,1]);
end
if size(ZL,2)==1,
  ZL=repmat(ZL,[1,size(ZL,1)]);
  for n=1:numel(ZL(1,1,:)),
    ZL(:,:,n)=diag(ZL(:,1,n));
  end
end

sL=[size(ZL),1];
if prod(sL(3:end))==1,
  sL3=@(x)(1);
else
  sL3=@(x)(x);
end

% check consistency of dimensions of ZA, ZL and T:

if (sT3(2)*sA3(2)>2)&&~isequal(sT(4:end),sA(3:end)) ||...
   (sT3(2)*sL3(2)>2)&&~isequal(sT(4:end),sL(3:end)) ||...
   (sL3(2)*sA3(2)>2)&&~isequal(sL(3:end),sA(3:end)) ||...
   ~isequal(sA(1:2),[NFeeds,NFeeds]) ||...
   ~isequal(sL(1:2),[NFeeds,NFeeds]),...
   error('Inconsistent dimensions of input parameters.');
end

% calculate T:

T=zeros(size(To));

% number of instances (usually frequencies):
nn=max([prod(sT(4:end)),prod(sA(3:end)),prod(sL(3:end))]);

for n=1:nn,
  
  Q=ZL(:,:,sL3(n))*inv(ZA(:,:,sA3(n))+ZL(:,:,sL3(n)));
  
  sT3n=sT3(n);
  
  if 1==0, % slower
    for m=1:NDirs,
      T(:,:,m,sT3n)=Q*To(:,:,m,sT3n);
    end
  else % faster
    T(:,:,:,sT3n)=...
    reshape(Q*reshape(To(:,:,:,sT3n),[NFeeds,3*NDirs]),[NFeeds,3,NDirs]);
  end
  
end

============================================================

function T=Ts2T(Ts,YA,YL)

% T=Ts2T(Ts,YA,YL) calculates voltage transfer matrix T for loaded ports 
% from short-circuit current transfer matrix Ts and antennna admittance 
% matrix YA. The load network is given by its admittance matrix YL.   
% The first dimension of Ts counts ports, the second coordinates, the
% 3rd directions (treated in parallel). T gets the same size as Ts. 
% The dimensions from the 3rd upwards of YA and YL must be all 1 or 
% agree with the dimensions of Ts from the 4th upwards.
%
% The relations representing antenna and load network are 
%
%   I = YA*V + Ts*E, or V = ZA*I - To,  with ZA=inv(YA) and To=ZA*Ts
%   I = -YL*V
% 
% so one obtains the voltages V at the loaded antenna 
%
%   V = -T*E with T = inv(YA+YL)*Ts
%
% in particular, for open ports we have YL=0, T=ZA*Ts=To; this is 
% the default if YL is empty or omitted, returning the open port transfer
% matrix.


if isempty(Ts),
  T=[];
  return
end

sT=[size(Ts),1];
NFeeds=sT(1);  % number of feeds
NDirs=sT(3);   % number of directions

if prod(sT(4:end))==1,
  sT3=@(x)(1);
else
  sT3=@(x)(x);
end

sA=[size(YA),1];
if prod(sA(3:end))==1,
  sA3=@(x)(1);
else
  sA3=@(x)(x);
end

% check YL:

if ~exist('YL','var')||isempty(YL),
  YL=zeros(NFeeds);
end

YL(isinf(YL))=max(1,max(abs(YA(:))))*1e10;

if size(YL,1)==1,
  YL=permute(YL,[2,1,3:ndims(YL)]);
end
if size(YL,1)==1,
  YL=repmat(YL,[NFeeds,1]);
end
if size(YL,2)==1,
  YL=repmat(YL,[1,size(YL,1)]);
  for n=1:numel(YL(1,1,:)),
    YL(:,:,n)=diag(YL(:,1,n));
  end
end

sL=[size(YL),1];
if prod(sL(3:end))==1,
  sL3=@(x)(1);
else
  sL3=@(x)(x);
end

% check consistency of dimensions of YA, YL and T:

if (sT3(2)*sA3(2)>2)&&~isequal(sT(4:end),sA(3:end)) ||...
   (sT3(2)*sL3(2)>2)&&~isequal(sT(4:end),sL(3:end)) ||...
   (sL3(2)*sA3(2)>2)&&~isequal(sL(3:end),sA(3:end)) ||...
   ~isequal(sA(1:2),[NFeeds,NFeeds]) ||...
   ~isequal(sL(1:2),[NFeeds,NFeeds]),...
   error('Inconsistent dimensions of input parameters.');
end

% calculate T:

T=zeros(size(Ts));

% number of instances (usually frequencies):
nn=max([prod(sT(4:end)),prod(sA(3:end)),prod(sL(3:end))]);

for n=1:nn,
  
  Q=inv(YA(:,:,sA3(n))+YL(:,:,sL3(n)));
  
  sT3n=sT3(n);
    
  if 1==0, % slower
    for m=1:NDirs,
      T(:,:,m,sT3n)=Q*Ts(:,:,m,sT3n);
    end
  else % faster
    T(:,:,:,sT3n)=...
      reshape(Q*reshape(Ts(:,:,:,sT3n),[NFeeds,3*NDirs]),[NFeeds,3,NDirs]);
  end


end

============================================================

function T=Ts2T(Ts,YA,YL,AntLen,AntDiam,AntDiamCorrect,Freq,epsilon)

% T=Ts2T(Ts,YA,YL) calculates transfer matrix T for loaded ports 
% from short-circuit transfer matrix Ts and antennna admittance matrix YA. 
% The load network is given by its admittance matrix YL.   
% The first dimension of Ts counts ports, the second coordinates, the
% dimensions from the third upwards are treated in parallel, T getting the
% same size as Ts. 
%
% The relations representing antenna and load network are 
%
%   I = YA*V + Ts*E, or V = ZA*I - To,  with ZA=inv(YA) and To=ZA*Ts
%   I = -YL*V
% 
% so one obtains the voltages V at the loaded antenna 
%
%   V = -T*E with T = inv(YA+YL)*Ts
%
% in particular, for open ports we have YL=0, T=ZA*Ts=To; this is 
% the default for empty of omitted YL, returning the open port transfer
% matrix.
%
% T=Ts2T(Ts,YA,YL,AntLen,AntDiam,AntDiamCorrect,Freq,epsilon)
% allows the correction of YA according to an adaptation of 
% antenna diameters. AntLen is the antenna length, AntDiam the diameter of
% the antennas for which Ts and YA are determined. AntDiamCorrect is the
% correct diameter of the real antennas. Freq is the operation frequency
% and epsilon the dielectric constant (default is vacuum).

f=size(Ts,1);  % number of feeds

if ~exist('YL','var')||isempty(YL),
  YL=zeros(f);
elseif length(YL)==1,
  YL=eye(f)*YL;
elseif size(YL,1)~=size(YL,2),
  YL=diag(YL);
end
YL(isinf(YL))=max(1,max(abs(YA(:))))*1e10;


if ~exist('AntLen','var')||isempty(AntLen),
  
  Q=inv(YA+YL);
  
else  % with correction for antenna radii:
  
  if ~exist('epsilon','var')||isempty(epsilon),
    c=2.99792458e8;
    mu=4e-7*pi;
    epsilon=1/c^2/mu;
  end
  
  if isequal(size(AntLen),[1,1]),
    AntLen=repmat(AntLen,f,1);
  end
  if isequal(size(AntDiam),[1,1]),
    AntDiam=repmat(AntDiam,f,1);
  end
  if isequal(size(AntDiamCorrect),[1,1]),
    AntDiamCorrect=repmat(AntDiamCorrect,f,1);
  end

  ZA=inv(YA);
  
  ZAc=ZA-diag(log(AntDiamCorrect./AntDiam)./(j*4*pi^2*epsilon*Freq*AntLen));
  
  Q=inv(eye(size(YL,1))+ZAc*YL)*ZA;
  
end

T=zeros(size(Ts));
for m=1:numel(Ts(1,1,:)),
  T(:,:,m)=Q*Ts(:,:,m);
end  
  

============================================================

function V=Vproj2V(er,Vp,Method)

% V=Vproj2V(er,Vp)
% calculates vectors V from its provections Vp othogonal to er.
% er, Vp and V are 2-dim arrays, the rows of er giving the directions
% to which the fields Vp (respective rows) are radiated.
% So er, Vp and V are size nx3, n being the number of directions.
% Since V cannot be determined from Vp uniquely, it is done in 
% such a way that the variation of V over the directions is minimal.

if ~exist('Method','var'),
  Method=1;
end

n=size(er,1);   % number of radiation/incidence directions

er=er./repmat(Mag(er,2),[1,3]);

V=cross(cross(er,Vp,2),er,2);

if n<2,
  warning('At least 2 projections are necessary to retrieve er-components.')
  return
end

if Method==1

  sV=sum(V,1);
  
  if 1==0,
    lam=(n*eye(n)-er*er.')\(er*sV.');
  else
    een=er.'*er/n;
    lam=er*(eye(3)+(eye(3)-een)\een)*sV.'/n;
  end
  
else
  
  ediff=zeros(3*(n-1),n);
  for m=1:n-1,
    ediff(3*(m-1)+1:3*m,m:m+1)=[er(m,:).',-er(m+1,:).'];
  end

  Vdiff=reshape(V(2:end,:).'-V(1:end-1,:).',3*(n-1),1);
  lam=ediff\Vdiff;

end

for mm=1:n,
  V(mm,:)=V(mm,:)+lam(mm)*er(mm,:);
end

